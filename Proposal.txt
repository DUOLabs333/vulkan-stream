A client<->server flow looks like this:
	1. The client calls a Vulkan function
	2. The driver sends a command object to the server
	3. The server receives the command object
	4. The server deserializes the command object
	5. The server executes the command with the parsed arguments
	6. The server then serializes the returned object, as well as the arguments into a response object
	7. The server sends the response object back to the driver
	8. The driver deserializes the response object
	9. The driver sets the arguments the client passed in based on the parsed arguments
	10. The function returns
There are some other parts that will be discussed later, but this is the main procedure.

We'll deal with each part separately:

I. Client calls a Vulkan function
There are two types of functions: those that return PFN_vkVoidFunction and those that return something else. We'll deal with both of them separately

Functions that return PFN_vkVoidFunction:
There are exactly 2 functions that return this value: vkGetDeviceProcAddr and vkGetInstanceProcAddr. For these function, the normal behavior below is overwritten to follow the behavior written here: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGet{Device,Instance}ProcAddr.html. Because these functions do not dispatch to the server, there's not much to say here.

Functions that return something else:
For each of these functions, the driver dispatches the command to the server as a command object. The command object is a json object with the following keys: "command", which is the name of the command being dispatched; and "members", which points to a dictionary that map the name of an argument to the json object that is the result of   parsing that argument.

To populate "members", the driver goes through the arguments provided, and for each of them:
1. Parse arg into json object
2. Makes new entry in "members" that maps the name of the arg to the json object. 

To know how the driver parses, we now talk about

PARSING:
The driver only supports parsing pointers with a single level of indirection, ie. *a, not **a.

So, the driver must transform an variable of arbitrary type into a single pointer of arbitrary type.

To do so, the driver uses this algorithm:
Let parse be some function that takes a variable of arbitrary type and returns a json object.
Set up an empty json object with an empty dictionary at "members"
1. If the type is "char *"/"int *"/"void *", return parse_{type}(arg)
2. If the argument is a list, run parse on each of the arguments, adding each one of them to "members" by stringifying the index and mapping the returned json object to that string index
3. If the argument is a pointer that has an indirection greater than 1, return parse on the dereferenced argument
4. If the argument is a pointer that has an indirection less than 1, return parse on the referenced argument
5. If the argument is a pointer to a struct, return parse_{struct}(arg)

parse_{struct} is a function that takes a pointer to that struct that returns a json object
Set up an empty json object with an empty dictionary at "members":
1. For each attribute in struct, run parse on the attribute and add them to "members" by mapping their stringified attribute to the returned json object

parse_{type} is a function that takes a pointer to the type and returns a json object
Set up an empty json object
1. Cast pointer into (char *) and write that the string into the "value" key

Before we can send our command object, there's one more thing to take care of: Synchronization

SYNCHRONIZATION:
vkMapMemory, like the name suggests, maps vkDeviceMemory into a buffer on the process's address space. However, the client and server can't share memory. So, when vkMapMemory is called on the server, a buffer of equal length is created on the client. To keep the contents in sync, the driver and server will at times, send synchronization objects to each other.

WHEN SHOULD THIS HAPPEN:

HOW DOES IT WORK:

Optimization --- on server, don't reserialise argument if const --- not meant to be changed

Syncing of buffers