A client<->server flow looks like this:
	1. The client calls a Vulkan function
	2. The driver sends a command object to the server
	3. The server receives the command object
	4. The server deserializes the command object
	5. The server executes the command with the parsed arguments
	6. The server then serializes the returned object, as well as the arguments into a response object
	7. The server sends the response object back to the driver
	8. The driver deserializes the response object
	9. The driver sets the arguments the client passed in based on the parsed arguments
	10. The function returns
There are some other parts that will be discussed later, but this is the main procedure.

We'll deal with each part separately:

I. Client calls a Vulkan function
There are two types of functions: those that return PFN_vkVoidFunction and those that return something else. We'll deal with both of them separately

Functions that return PFN_vkVoidFunction:
There are exactly 2 functions that return this value: vkGetDeviceProcAddr and vkGetInstanceProcAddr. For these function, the normal behavior below is overwritten to follow the behavior written here: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGet{Device,Instance}ProcAddr.html. Because these functions do not dispatch to the server, there's not much to say here.

Functions that return something else:
For each of these functions, the driver dispatches the command to the server as a command object. The command object is a json object with the following keys: "command", which is the name of the command being dispatched; and "members", which points to a dictionary that map the name of an argument to the json object that is the result of   parsing that argument.

To populate "members", the driver goes through the arguments provided, and for each of them:
1. Parse arg into json object
2. Makes new entry in "members" that maps the name of the arg to the json object. 

To know how the driver parses, we now talk about

PARSING:
The driver only supports parsing pointers with a single level of indirection, ie. *a, not **a.

So, the driver must transform an variable of arbitrary type into a single pointer of arbitrary type.

To do so, the driver uses this algorithm:
Let parse be some function that takes a variable of arbitrary type and outputs a json object.
Set up an empty json object with an empty dictionary at "members"
1. If the type is "char *"/"char"/"int", add key at "value" with value of casting the value to (char *). Return
2. If the argument is a list, run parse on each of the arguments, adding each one of them to "members" by stringifying the index and mapping the returned json object to that string index
3. If the argument is a pointer that has an indirection greater than 1, return parse on the dereferenced argument
4. If the argument is a pointer that has an indirection less than 1, return parse on the referenced argument
5. If the argument is a pointer to a struct, run parse on each of the arguments, adding them to "members" by mapping their stringified key to the returned json object


	
Optimization --- pn server, don't reserialize argument if const --- not meant to be changed

Syncing of buffers