
#include <debug.hpp>

#include <stdexcept>
#include <shared_mutex>
#include <future>
#include "vk_enum_string_helper.h"
#include <set>
#include <vector>
#include <vulkan/vulkan.h>

#include <msgpack.hpp>
#include <Serialization.hpp>
#include <Server.hpp>
#include <Synchronization.hpp>

#ifdef CLIENT
    #include <Surface.hpp>
    
    std::map<uintptr_t, VkDeviceSize> devicememory_to_size;
    void registerDeviceMemory(VkDeviceMemory memory, VkDeviceSize size){
        devicememory_to_size[(uintptr_t)memory]=size;
    }
#endif

typedef std::shared_mutex Lock;

Lock MemoryMapLock;
Lock MemoryOperationLock; //This is not needed (but may be preferred, at the expense of unneccessary locking)

#ifndef CLIENT

auto get_instance_proc_addr=vkGetInstanceProcAddr;
auto get_device_proc_addr=vkGetDeviceProcAddr;


    void handle_vkCreateInstance(json::map& json){
    //Will only be called by the server
    
 VkInstanceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkInstanceCreateInfo*)malloc(1*sizeof(VkInstanceCreateInfo));auto& arr_KMjnDnU=json["pCreateInfo"].as_vector();
        for(int tBToPhv=0; tBToPhv < 1; tBToPhv++){
            [&](){
            deserialize_struct(arr_KMjnDnU[tBToPhv].as_map(),pCreateInfo[tBToPhv]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkInstance* pInstance;
[&](){
            if (json["pInstance"].as_vector().size()==0){
                pInstance=NULL;
            return; }pInstance=(VkInstance*)malloc(1*sizeof(VkInstance));auto& arr_GanofFb=json["pInstance"].as_vector();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();

    PFN_vkCreateInstance call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateInstance)get_instance_proc_addr(parent,"vkCreateInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateInstance)get_device_proc_addr(parent,"vkCreateInstance");
    }  
    
VkResult  result;
{


        VkInstanceCreateInfo* temp_info=pCreateInfo;

        VkInstanceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        #ifdef VK_USE_PLATFORM_METAL_EXT
            extensions_set.erase(std::string("VK_KHR_xcb_surface"));
            extensions_set.erase(std::string("VK_KHR_xlib_surface"));
        #endif
        
        extensions_set.insert(std::string(VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME));
        //extensions_set.insert(std::string(VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;
        pCreateInfo->flags|=VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;            
        
result=call_function(pCreateInfo, pAllocator, pInstance);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_yCteunD=json::vector(1);
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[pSiEPar]);
            arr_yCteunD[pSiEPar]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_yCteunD;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=json::vector();
            return; }auto arr_GanofFb=json::vector(1);
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        json["pInstance"]=arr_GanofFb;}();


        json["stream_type"]=static_cast<int>(VKCREATEINSTANCE);
        writeToConn(json);
    }

    void handle_vkDestroyInstance(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyInstance call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyInstance)get_instance_proc_addr(parent,"vkDestroyInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyInstance)get_device_proc_addr(parent,"vkDestroyInstance");
    }  
    
{
call_function(instance, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYINSTANCE);
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDevices(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceCount;
[&](){
            if (json["pPhysicalDeviceCount"].as_vector().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }pPhysicalDeviceCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].as_vector();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){
            if (arr_ngpFKeB[TRqNryD].is_uint64_t()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_uint64_t());
            }else if (arr_ngpFKeB[TRqNryD].is_int64_t()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_int64_t());
            }else{
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_double());
            }
            }();
        }
        }();
VkPhysicalDevice* pPhysicalDevices;
[&](){
            if (json["pPhysicalDevices"].as_vector().size()==0){
                pPhysicalDevices=NULL;
            return; }pPhysicalDevices=(VkPhysicalDevice*)malloc(*pPhysicalDeviceCount*sizeof(VkPhysicalDevice));auto& arr_ZSQNUNc=json["pPhysicalDevices"].as_vector();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();

    PFN_vkEnumeratePhysicalDevices call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumeratePhysicalDevices)get_instance_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumeratePhysicalDevices)get_device_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }  
    
VkResult  result;
{
result=call_function(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=json::vector();
            return; }auto arr_ngpFKeB=json::vector(1);
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=static_cast<uint>(pPhysicalDeviceCount[TRqNryD]);}();
        }
        json["pPhysicalDeviceCount"]=arr_ngpFKeB;}();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=json::vector();
            return; }auto arr_ZSQNUNc=json::vector(*pPhysicalDeviceCount);
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        json["pPhysicalDevices"]=arr_ZSQNUNc;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICES);
        writeToConn(json);
    }

    void handle_vkGetDeviceProcAddr(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 char* pName;
[&](){
            if (json["pName"].as_vector().size()==0){
                pName=NULL;
            return; }pName=(char*)malloc(json["pName"].as_vector().size()*sizeof(char));auto& arr_OBaQazs=json["pName"].as_vector();
        for(int eoosrrl=0; eoosrrl < json["pName"].as_vector().size(); eoosrrl++){
            [&](){
            if (arr_OBaQazs[eoosrrl].is_uint64_t()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_uint64_t());
            }else if (arr_OBaQazs[eoosrrl].is_int64_t()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_int64_t());
            }else{
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_double());
            }
            }();
        }
        }();

    PFN_vkGetDeviceProcAddr call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceProcAddr)get_instance_proc_addr(parent,"vkGetDeviceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceProcAddr)get_device_proc_addr(parent,"vkGetDeviceProcAddr");
    }  
    
PFN_vkVoidFunction  result;
{
result=call_function(device, pName);
}
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=json::vector();
            return; }auto arr_XCtfitt=json::vector(strlen(pName)+1);
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=static_cast<uint>(pName[EZmXTUp]);}();
        }
        json["pName"]=arr_XCtfitt;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEPROCADDR);
        writeToConn(json);
    }

    void handle_vkGetInstanceProcAddr(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 char* pName;
[&](){
            if (json["pName"].as_vector().size()==0){
                pName=NULL;
            return; }pName=(char*)malloc(json["pName"].as_vector().size()*sizeof(char));auto& arr_OBaQazs=json["pName"].as_vector();
        for(int eoosrrl=0; eoosrrl < json["pName"].as_vector().size(); eoosrrl++){
            [&](){
            if (arr_OBaQazs[eoosrrl].is_uint64_t()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_uint64_t());
            }else if (arr_OBaQazs[eoosrrl].is_int64_t()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_int64_t());
            }else{
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].as_double());
            }
            }();
        }
        }();

    PFN_vkGetInstanceProcAddr call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetInstanceProcAddr)get_instance_proc_addr(parent,"vkGetInstanceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetInstanceProcAddr)get_device_proc_addr(parent,"vkGetInstanceProcAddr");
    }  
    
PFN_vkVoidFunction  result;
{
result=call_function(instance, pName);
}
debug_printf("Getting %s\n",pName);
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=json::vector();
            return; }auto arr_XCtfitt=json::vector(strlen(pName)+1);
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=static_cast<uint>(pName[EZmXTUp]);}();
        }
        json["pName"]=arr_XCtfitt;}();


        json["stream_type"]=static_cast<int>(VKGETINSTANCEPROCADDR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties*)malloc(1*sizeof(VkPhysicalDeviceProperties));auto& arr_rSttUuQ=json["pProperties"].as_vector();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            deserialize_struct(arr_rSttUuQ[RBAofpr].as_map(),pProperties[RBAofpr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_rSttUuQ=json::vector(1);
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[RBAofpr]);
            arr_rSttUuQ[RBAofpr]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_rSttUuQ;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].as_vector().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_vector();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_uint64_t());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_int64_t());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_double());
            }
            }();
        }
        }();
VkQueueFamilyProperties* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].as_vector().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties));auto& arr_ixxluvk=json["pQueueFamilyProperties"].as_vector();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            deserialize_struct(arr_ixxluvk[WYdxXmB].as_map(),pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=json::vector();
            return; }auto arr_tzRlmPf=json::vector(1);
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=static_cast<uint>(pQueueFamilyPropertyCount[cPKCUxv]);}();
        }
        json["pQueueFamilyPropertyCount"]=arr_tzRlmPf;}();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=json::vector();
            return; }auto arr_ixxluvk=json::vector(*pQueueFamilyPropertyCount);
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueFamilyProperties[WYdxXmB]);
            arr_ixxluvk[WYdxXmB]=temp_map;
            return;
            }();
        }
        json["pQueueFamilyProperties"]=arr_ixxluvk;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].as_vector().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties));auto& arr_cVJWqPt=json["pMemoryProperties"].as_vector();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            deserialize_struct(arr_cVJWqPt[iqfYjRc].as_map(),pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=json::vector();
            return; }auto arr_cVJWqPt=json::vector(1);
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryProperties[iqfYjRc]);
            arr_cVJWqPt[iqfYjRc]=temp_map;
            return;
            }();
        }
        json["pMemoryProperties"]=arr_cVJWqPt;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMEMORYPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures* pFeatures;
[&](){
            if (json["pFeatures"].as_vector().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures*)malloc(1*sizeof(VkPhysicalDeviceFeatures));auto& arr_MNJcbZO=json["pFeatures"].as_vector();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            deserialize_struct(arr_MNJcbZO[IqPoadP].as_map(),pFeatures[IqPoadP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=json::vector();
            return; }auto arr_MNJcbZO=json::vector(1);
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFeatures[IqPoadP]);
            arr_MNJcbZO[IqPoadP]=temp_map;
            return;
            }();
        }
        json["pFeatures"]=arr_MNJcbZO;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFEATURES);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties* pFormatProperties;
[&](){
            if (json["pFormatProperties"].as_vector().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties*)malloc(1*sizeof(VkFormatProperties));auto& arr_ktGodop=json["pFormatProperties"].as_vector();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            deserialize_struct(arr_ktGodop[CLkwuSw].as_map(),pFormatProperties[CLkwuSw]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=json::vector();
            return; }auto arr_ktGodop=json::vector(1);
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatProperties[CLkwuSw]);
            arr_ktGodop[CLkwuSw]=temp_map;
            return;
            }();
        }
        json["pFormatProperties"]=arr_ktGodop;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFORMATPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkImageFormatProperties* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties*)malloc(1*sizeof(VkImageFormatProperties));auto& arr_sBgMBXU=json["pImageFormatProperties"].as_vector();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            deserialize_struct(arr_sBgMBXU[hhYjZOs].as_map(),pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_sBgMBXU=json::vector(1);
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[hhYjZOs]);
            arr_sBgMBXU[hhYjZOs]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_sBgMBXU;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES);
        writeToConn(json);
    }

    void handle_vkCreateDevice(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkDeviceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDeviceCreateInfo*)malloc(1*sizeof(VkDeviceCreateInfo));auto& arr_weWBoax=json["pCreateInfo"].as_vector();
        for(int JAVPgPK=0; JAVPgPK < 1; JAVPgPK++){
            [&](){
            deserialize_struct(arr_weWBoax[JAVPgPK].as_map(),pCreateInfo[JAVPgPK]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDevice* pDevice;
[&](){
            if (json["pDevice"].as_vector().size()==0){
                pDevice=NULL;
            return; }pDevice=(VkDevice*)malloc(1*sizeof(VkDevice));auto& arr_WTIobJE=json["pDevice"].as_vector();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();

    PFN_vkCreateDevice call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDevice)get_instance_proc_addr(parent,"vkCreateDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDevice)get_device_proc_addr(parent,"vkCreateDevice");
    }  
    
VkResult  result;
{

        VkDeviceCreateInfo* temp_info=pCreateInfo;

        VkDeviceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        
        extensions_set.insert(std::string(VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;            
        
result=call_function(physicalDevice, pCreateInfo, pAllocator, pDevice);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TuuJAwt=json::vector(1);
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[Ktbkccz]);
            arr_TuuJAwt[Ktbkccz]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TuuJAwt;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=json::vector();
            return; }auto arr_WTIobJE=json::vector(1);
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        json["pDevice"]=arr_WTIobJE;}();


        json["stream_type"]=static_cast<int>(VKCREATEDEVICE);
        writeToConn(json);
    }

    void handle_vkDestroyDevice(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDevice call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDevice)get_instance_proc_addr(parent,"vkDestroyDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDevice)get_device_proc_addr(parent,"vkDestroyDevice");
    }  
    
{
call_function(device, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDEVICE);
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceVersion(json::map& json){
    //Will only be called by the server
    
uint32_t* pApiVersion;
[&](){
            if (json["pApiVersion"].as_vector().size()==0){
                pApiVersion=NULL;
            return; }pApiVersion=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_qBCKjKo=json["pApiVersion"].as_vector();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){
            if (arr_qBCKjKo[KJjQFCs].is_uint64_t()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_uint64_t());
            }else if (arr_qBCKjKo[KJjQFCs].is_int64_t()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_int64_t());
            }else{
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_double());
            }
            }();
        }
        }();

    PFN_vkEnumerateInstanceVersion call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumerateInstanceVersion)get_instance_proc_addr(parent,"vkEnumerateInstanceVersion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumerateInstanceVersion)get_device_proc_addr(parent,"vkEnumerateInstanceVersion");
    }  
    
VkResult  result;
{
result=call_function(pApiVersion);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=json::vector();
            return; }auto arr_qBCKjKo=json::vector(1);
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=static_cast<uint>(pApiVersion[KJjQFCs]);}();
        }
        json["pApiVersion"]=arr_qBCKjKo;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCEVERSION);
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceLayerProperties(json::map& json){
    //Will only be called by the server
    
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));auto& arr_AKGITwD=json["pProperties"].as_vector();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            deserialize_struct(arr_AKGITwD[AVcpYdO].as_map(),pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceLayerProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_device_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }  
    
VkResult  result;
{
result=call_function(pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_AKGITwD=json::vector(*pPropertyCount);
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[AVcpYdO]);
            arr_AKGITwD[AVcpYdO]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_AKGITwD;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCELAYERPROPERTIES);
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceExtensionProperties(json::map& json){
    //Will only be called by the server
    
 char* pLayerName;
[&](){
            if (json["pLayerName"].as_vector().size()==0){
                pLayerName=NULL;
            return; }pLayerName=(char*)malloc(json["pLayerName"].as_vector().size()*sizeof(char));auto& arr_pwIbPmt=json["pLayerName"].as_vector();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].as_vector().size(); ybQeduD++){
            [&](){
            if (arr_pwIbPmt[ybQeduD].is_uint64_t()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_uint64_t());
            }else if (arr_pwIbPmt[ybQeduD].is_int64_t()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_int64_t());
            }else{
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_double());
            }
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));auto& arr_yJzeHZb=json["pProperties"].as_vector();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            deserialize_struct(arr_yJzeHZb[oiKhvHw].as_map(),pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceExtensionProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }  
    
VkResult  result;
{
result=call_function(pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=json::vector();
            return; }auto arr_xWfwWBl=json::vector(strlen(pLayerName)+1);
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=static_cast<uint>(pLayerName[EYxuOlw]);}();
        }
        json["pLayerName"]=arr_xWfwWBl;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_yJzeHZb=json::vector(*pPropertyCount);
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oiKhvHw]);
            arr_yJzeHZb[oiKhvHw]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_yJzeHZb;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCEEXTENSIONPROPERTIES);
        writeToConn(json);
    }

    void handle_vkEnumerateDeviceLayerProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));auto& arr_AKGITwD=json["pProperties"].as_vector();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            deserialize_struct(arr_AKGITwD[AVcpYdO].as_map(),pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceLayerProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_device_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_AKGITwD=json::vector(*pPropertyCount);
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[AVcpYdO]);
            arr_AKGITwD[AVcpYdO]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_AKGITwD;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEDEVICELAYERPROPERTIES);
        writeToConn(json);
    }

    void handle_vkEnumerateDeviceExtensionProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 char* pLayerName;
[&](){
            if (json["pLayerName"].as_vector().size()==0){
                pLayerName=NULL;
            return; }pLayerName=(char*)malloc(json["pLayerName"].as_vector().size()*sizeof(char));auto& arr_pwIbPmt=json["pLayerName"].as_vector();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].as_vector().size(); ybQeduD++){
            [&](){
            if (arr_pwIbPmt[ybQeduD].is_uint64_t()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_uint64_t());
            }else if (arr_pwIbPmt[ybQeduD].is_int64_t()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_int64_t());
            }else{
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].as_double());
            }
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));auto& arr_yJzeHZb=json["pProperties"].as_vector();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            deserialize_struct(arr_yJzeHZb[oiKhvHw].as_map(),pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceExtensionProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=json::vector();
            return; }auto arr_xWfwWBl=json::vector(strlen(pLayerName)+1);
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=static_cast<uint>(pLayerName[EYxuOlw]);}();
        }
        json["pLayerName"]=arr_xWfwWBl;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_yJzeHZb=json::vector(*pPropertyCount);
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oiKhvHw]);
            arr_yJzeHZb[oiKhvHw]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_yJzeHZb;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEDEVICEEXTENSIONPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetDeviceQueue(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
uint32_t queueIndex;
[&](){
            if (json["queueIndex"].is_uint64_t()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_uint64_t());
            }else if (json["queueIndex"].is_int64_t()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_int64_t());
            }else{
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_double());
            }
            }();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].as_vector().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));auto& arr_rYZbcEA=json["pQueue"].as_vector();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceQueue)get_instance_proc_addr(parent,"vkGetDeviceQueue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceQueue)get_device_proc_addr(parent,"vkGetDeviceQueue");
    }  
    
{
call_function(device, queueFamilyIndex, queueIndex, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){json["queueIndex"]=static_cast<uint>(queueIndex);}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=json::vector();
            return; }auto arr_rYZbcEA=json::vector(1);
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        json["pQueue"]=arr_rYZbcEA;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEQUEUE);
        writeToConn(json);
    }

    void handle_vkQueueSubmit(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){
            if (json["submitCount"].is_uint64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_uint64_t());
            }else if (json["submitCount"].is_int64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_int64_t());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].as_double());
            }
            }();
 VkSubmitInfo* pSubmits;
[&](){
            if (json["pSubmits"].as_vector().size()==0){
                pSubmits=NULL;
            return; }pSubmits=(VkSubmitInfo*)malloc(submitCount*sizeof(VkSubmitInfo));auto& arr_TcbTpKH=json["pSubmits"].as_vector();
        for(int XjgvzRX=0; XjgvzRX < submitCount; XjgvzRX++){
            [&](){
            deserialize_struct(arr_TcbTpKH[XjgvzRX].as_map(),pSubmits[XjgvzRX]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueSubmit)get_instance_proc_addr(parent,"vkQueueSubmit");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueSubmit)get_device_proc_addr(parent,"vkQueueSubmit");
    }  
    
VkResult  result;
{
result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=static_cast<uint>(submitCount);}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=json::vector();
            return; }auto arr_kYcwgKD=json::vector(submitCount);
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubmits[FrUhwZA]);
            arr_kYcwgKD[FrUhwZA]=temp_map;
            return;
            }();
        }
        json["pSubmits"]=arr_kYcwgKD;}();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=static_cast<int>(VKQUEUESUBMIT);
        writeToConn(json);
    }

    void handle_vkQueueWaitIdle(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueWaitIdle call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueWaitIdle)get_instance_proc_addr(parent,"vkQueueWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueWaitIdle)get_device_proc_addr(parent,"vkQueueWaitIdle");
    }  
    
VkResult  result;
{
result=call_function(queue);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();


        json["stream_type"]=static_cast<int>(VKQUEUEWAITIDLE);
        writeToConn(json);
    }

    void handle_vkDeviceWaitIdle(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkDeviceWaitIdle call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDeviceWaitIdle)get_instance_proc_addr(parent,"vkDeviceWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDeviceWaitIdle)get_device_proc_addr(parent,"vkDeviceWaitIdle");
    }  
    
VkResult  result;
{
result=call_function(device);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=static_cast<int>(VKDEVICEWAITIDLE);
        writeToConn(json);
    }

    void handle_vkAllocateMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].as_vector().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkMemoryAllocateInfo*)malloc(1*sizeof(VkMemoryAllocateInfo));auto& arr_deRkgom=json["pAllocateInfo"].as_vector();
        for(int ujZsXLJ=0; ujZsXLJ < 1; ujZsXLJ++){
            [&](){
            deserialize_struct(arr_deRkgom[ujZsXLJ].as_map(),pAllocateInfo[ujZsXLJ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDeviceMemory* pMemory;
[&](){
            if (json["pMemory"].as_vector().size()==0){
                pMemory=NULL;
            return; }pMemory=(VkDeviceMemory*)malloc(1*sizeof(VkDeviceMemory));auto& arr_JqUSUSb=json["pMemory"].as_vector();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();

    PFN_vkAllocateMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAllocateMemory)get_instance_proc_addr(parent,"vkAllocateMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAllocateMemory)get_device_proc_addr(parent,"vkAllocateMemory");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pAllocator, pMemory);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_NGCHnPz=json::vector(1);
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[MAXIAGO]);
            arr_NGCHnPz[MAXIAGO]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_NGCHnPz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=json::vector();
            return; }auto arr_JqUSUSb=json::vector(1);
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        json["pMemory"]=arr_JqUSUSb;}();


        json["stream_type"]=static_cast<int>(VKALLOCATEMEMORY);
        writeToConn(json);
    }

    void handle_vkFreeMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkFreeMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkFreeMemory)get_instance_proc_addr(parent,"vkFreeMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkFreeMemory)get_device_proc_addr(parent,"vkFreeMemory");
    }  
    
{
call_function(device, memory, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKFREEMEMORY);
        writeToConn(json);
    }

    void handle_vkMapMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
VkMemoryMapFlags flags;
[&](){[&](){int temp_UEEqVUK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_UEEqVUK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_UEEqVUK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_UEEqVUK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
void** ppData;
[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));auto& arr_syvZTtN=json["ppData"].as_vector();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].as_vector().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].as_vector().size()==0){
                temp_syvZTtN=NULL;
            return; }temp_syvZTtN=(char*)malloc(size*sizeof(char));auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].as_vector();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();

    PFN_vkMapMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkMapMemory)get_instance_proc_addr(parent,"vkMapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkMapMemory)get_device_proc_addr(parent,"vkMapMemory");
    }  
    
VkResult  result;
{
result=call_function(device, memory, offset, size, flags, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_syvZTtN=json::vector(1);
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=json::vector();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(size);
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[weOJAdg]))[jYdchEs]);}();
        }
        arr_syvZTtN[weOJAdg]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_syvZTtN;}();

        json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=server_memory_json.as_uint64_t(); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        json["stream_type"]=static_cast<int>(VKMAPMEMORY);
        writeToConn(json);
    }

    void handle_vkUnmapMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

    PFN_vkUnmapMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUnmapMemory)get_instance_proc_addr(parent,"vkUnmapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUnmapMemory)get_device_proc_addr(parent,"vkUnmapMemory");
    }  
    
{
call_function(device, memory);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();


        json["stream_type"]=static_cast<int>(VKUNMAPMEMORY);
        writeToConn(json);
    }

    void handle_vkFlushMappedMemoryRanges(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){
            if (json["memoryRangeCount"].is_uint64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_uint64_t());
            }else if (json["memoryRangeCount"].is_int64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_int64_t());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_double());
            }
            }();
 VkMappedMemoryRange* pMemoryRanges;
[&](){
            if (json["pMemoryRanges"].as_vector().size()==0){
                pMemoryRanges=NULL;
            return; }pMemoryRanges=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));auto& arr_nFHDtPn=json["pMemoryRanges"].as_vector();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            deserialize_struct(arr_nFHDtPn[oXMPKll].as_map(),pMemoryRanges[oXMPKll]);
            }();
        }
        }();

    PFN_vkFlushMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkFlushMappedMemoryRanges)get_instance_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkFlushMappedMemoryRanges)get_device_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }  
    
VkResult  result;
{
result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=static_cast<uint>(memoryRangeCount);}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=json::vector();
            return; }auto arr_sKDZFVw=json::vector(memoryRangeCount);
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRanges[GdhGpVL]);
            arr_sKDZFVw[GdhGpVL]=temp_map;
            return;
            }();
        }
        json["pMemoryRanges"]=arr_sKDZFVw;}();


        json["stream_type"]=static_cast<int>(VKFLUSHMAPPEDMEMORYRANGES);
        writeToConn(json);
    }

    void handle_vkInvalidateMappedMemoryRanges(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){
            if (json["memoryRangeCount"].is_uint64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_uint64_t());
            }else if (json["memoryRangeCount"].is_int64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_int64_t());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_double());
            }
            }();
 VkMappedMemoryRange* pMemoryRanges;
[&](){
            if (json["pMemoryRanges"].as_vector().size()==0){
                pMemoryRanges=NULL;
            return; }pMemoryRanges=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));auto& arr_nFHDtPn=json["pMemoryRanges"].as_vector();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            deserialize_struct(arr_nFHDtPn[oXMPKll].as_map(),pMemoryRanges[oXMPKll]);
            }();
        }
        }();

    PFN_vkInvalidateMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_instance_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_device_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }  
    
VkResult  result;
{
result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=static_cast<uint>(memoryRangeCount);}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=json::vector();
            return; }auto arr_sKDZFVw=json::vector(memoryRangeCount);
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRanges[GdhGpVL]);
            arr_sKDZFVw[GdhGpVL]=temp_map;
            return;
            }();
        }
        json["pMemoryRanges"]=arr_sKDZFVw;}();


        json["stream_type"]=static_cast<int>(VKINVALIDATEMAPPEDMEMORYRANGES);
        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryCommitment(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize* pCommittedMemoryInBytes;
[&](){
            if (json["pCommittedMemoryInBytes"].as_vector().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }pCommittedMemoryInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].as_vector();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){
            if (arr_BkHcKeY[iEYXrVv].is_uint64_t()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_uint64_t());
            }else if (arr_BkHcKeY[iEYXrVv].is_int64_t()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_int64_t());
            }else{
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_double());
            }
            }();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

    PFN_vkGetDeviceMemoryCommitment call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_instance_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_device_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }  
    
{
call_function(device, memory, pCommittedMemoryInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=json::vector();
            return; }auto arr_BkHcKeY=json::vector(1);
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=static_cast<uint>(pCommittedMemoryInBytes[iEYXrVv]);}();}();
        }
        json["pCommittedMemoryInBytes"]=arr_BkHcKeY;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEMEMORYCOMMITMENT);
        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));auto& arr_qQjUyYD=json["pMemoryRequirements"].as_vector();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            deserialize_struct(arr_qQjUyYD[VeirrNu].as_map(),pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }  
    
{
call_function(device, buffer, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_qQjUyYD=json::vector(1);
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[VeirrNu]);
            arr_qQjUyYD[VeirrNu]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_qQjUyYD;}();


        json["stream_type"]=static_cast<int>(VKGETBUFFERMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkBindBufferMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_uint64_t());
            }else if (json["memoryOffset"].is_int64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_int64_t());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindBufferMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindBufferMemory)get_instance_proc_addr(parent,"vkBindBufferMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindBufferMemory)get_device_proc_addr(parent,"vkBindBufferMemory");
    }  
    
VkResult  result;
{
result=call_function(device, buffer, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=static_cast<uint>(memoryOffset);}();}();


        json["stream_type"]=static_cast<int>(VKBINDBUFFERMEMORY);
        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));auto& arr_qQjUyYD=json["pMemoryRequirements"].as_vector();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            deserialize_struct(arr_qQjUyYD[VeirrNu].as_map(),pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageMemoryRequirements)get_device_proc_addr(parent,"vkGetImageMemoryRequirements");
    }  
    
{
call_function(device, image, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_qQjUyYD=json::vector(1);
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[VeirrNu]);
            arr_qQjUyYD[VeirrNu]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_qQjUyYD;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkBindImageMemory(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_uint64_t());
            }else if (json["memoryOffset"].is_int64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_int64_t());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindImageMemory call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindImageMemory)get_instance_proc_addr(parent,"vkBindImageMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindImageMemory)get_device_proc_addr(parent,"vkBindImageMemory");
    }  
    
VkResult  result;
{
result=call_function(device, image, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=static_cast<uint>(memoryOffset);}();}();


        json["stream_type"]=static_cast<int>(VKBINDIMAGEMEMORY);
        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements));auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].as_vector();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            deserialize_struct(arr_gCgbiZM[HKRWUBR].as_map(),pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }  
    
{
call_function(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_gCgbiZM=json::vector(*pSparseMemoryRequirementCount);
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[HKRWUBR]);
            arr_gCgbiZM[HKRWUBR]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_gCgbiZM;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGESPARSEMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkSparseImageFormatProperties* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties));auto& arr_jINYdYP=json["pProperties"].as_vector();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            deserialize_struct(arr_jINYdYP[BOLcXca].as_map(),pProperties[BOLcXca]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }  
    
{
call_function(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_jINYdYP=json::vector(*pPropertyCount);
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[BOLcXca]);
            arr_jINYdYP[BOLcXca]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_jINYdYP;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES);
        writeToConn(json);
    }

    void handle_vkQueueBindSparse(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();
 VkBindSparseInfo* pBindInfo;
[&](){
            if (json["pBindInfo"].as_vector().size()==0){
                pBindInfo=NULL;
            return; }pBindInfo=(VkBindSparseInfo*)malloc(bindInfoCount*sizeof(VkBindSparseInfo));auto& arr_yoxMwfS=json["pBindInfo"].as_vector();
        for(int dbkPgzh=0; dbkPgzh < bindInfoCount; dbkPgzh++){
            [&](){
            deserialize_struct(arr_yoxMwfS[dbkPgzh].as_map(),pBindInfo[dbkPgzh]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueBindSparse call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueBindSparse)get_instance_proc_addr(parent,"vkQueueBindSparse");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueBindSparse)get_device_proc_addr(parent,"vkQueueBindSparse");
    }  
    
VkResult  result;
{
result=call_function(queue, bindInfoCount, pBindInfo, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=json::vector();
            return; }auto arr_eUGJCxJ=json::vector(bindInfoCount);
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfo[ujBkVap]);
            arr_eUGJCxJ[ujBkVap]=temp_map;
            return;
            }();
        }
        json["pBindInfo"]=arr_eUGJCxJ;}();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=static_cast<int>(VKQUEUEBINDSPARSE);
        writeToConn(json);
    }

    void handle_vkCreateFence(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFenceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkFenceCreateInfo*)malloc(1*sizeof(VkFenceCreateInfo));auto& arr_cSMNytM=json["pCreateInfo"].as_vector();
        for(int JOkcmyM=0; JOkcmyM < 1; JOkcmyM++){
            [&](){
            deserialize_struct(arr_cSMNytM[JOkcmyM].as_map(),pCreateInfo[JOkcmyM]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkCreateFence call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateFence)get_instance_proc_addr(parent,"vkCreateFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateFence)get_device_proc_addr(parent,"vkCreateFence");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_qbBwXza=json::vector(1);
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[kPSKeJY]);
            arr_qbBwXza[kPSKeJY]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_qbBwXza;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();


        json["stream_type"]=static_cast<int>(VKCREATEFENCE);
        writeToConn(json);
    }

    void handle_vkDestroyFence(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyFence call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyFence)get_instance_proc_addr(parent,"vkDestroyFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyFence)get_device_proc_addr(parent,"vkDestroyFence");
    }  
    
{
call_function(device, fence, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYFENCE);
        writeToConn(json);
    }

    void handle_vkResetFences(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){
            if (json["fenceCount"].is_uint64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_uint64_t());
            }else if (json["fenceCount"].is_int64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_int64_t());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_double());
            }
            }();
 VkFence* pFences;
[&](){
            if (json["pFences"].as_vector().size()==0){
                pFences=NULL;
            return; }pFences=(VkFence*)malloc(fenceCount*sizeof(VkFence));auto& arr_nntmqqP=json["pFences"].as_vector();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], pFences[hksYnfK]);}();
        }
        }();

    PFN_vkResetFences call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetFences)get_instance_proc_addr(parent,"vkResetFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetFences)get_device_proc_addr(parent,"vkResetFences");
    }  
    
VkResult  result;
{
result=call_function(device, fenceCount, pFences);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=static_cast<uint>(fenceCount);}();
[&](){
            if (pFences==NULL){
                json["pFences"]=json::vector();
            return; }auto arr_UUllwqV=json::vector(fenceCount);
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        json["pFences"]=arr_UUllwqV;}();


        json["stream_type"]=static_cast<int>(VKRESETFENCES);
        writeToConn(json);
    }

    void handle_vkGetFenceStatus(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkGetFenceStatus call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetFenceStatus)get_instance_proc_addr(parent,"vkGetFenceStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetFenceStatus)get_device_proc_addr(parent,"vkGetFenceStatus");
    }  
    
VkResult  result;
{
result=call_function(device, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=static_cast<int>(VKGETFENCESTATUS);
        writeToConn(json);
    }

    void handle_vkWaitForFences(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){
            if (json["fenceCount"].is_uint64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_uint64_t());
            }else if (json["fenceCount"].is_int64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_int64_t());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_double());
            }
            }();
 VkFence* pFences;
[&](){
            if (json["pFences"].as_vector().size()==0){
                pFences=NULL;
            return; }pFences=(VkFence*)malloc(fenceCount*sizeof(VkFence));auto& arr_nntmqqP=json["pFences"].as_vector();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], pFences[hksYnfK]);}();
        }
        }();
VkBool32 waitAll;
[&](){uint32_t temp_pqKsrTL;[&](){
            if (json["waitAll"].is_uint64_t()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_uint64_t());
            }else if (json["waitAll"].is_int64_t()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_int64_t());
            }else{
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_double());
            }
            }();waitAll=(VkBool32)temp_pqKsrTL;}();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();

    PFN_vkWaitForFences call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkWaitForFences)get_instance_proc_addr(parent,"vkWaitForFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkWaitForFences)get_device_proc_addr(parent,"vkWaitForFences");
    }  
    
VkResult  result;
{
result=call_function(device, fenceCount, pFences, waitAll, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=static_cast<uint>(fenceCount);}();
[&](){
            if (pFences==NULL){
                json["pFences"]=json::vector();
            return; }auto arr_UUllwqV=json::vector(fenceCount);
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        json["pFences"]=arr_UUllwqV;}();
[&](){[&](){json["waitAll"]=static_cast<uint>(waitAll);}();}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();

            if (result!=VK_TIMEOUT){
                SyncAll();
            }
            


        json["stream_type"]=static_cast<int>(VKWAITFORFENCES);
        writeToConn(json);
    }

    void handle_vkCreateSemaphore(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSemaphoreCreateInfo*)malloc(1*sizeof(VkSemaphoreCreateInfo));auto& arr_FJDFSKM=json["pCreateInfo"].as_vector();
        for(int aGXpPVQ=0; aGXpPVQ < 1; aGXpPVQ++){
            [&](){
            deserialize_struct(arr_FJDFSKM[aGXpPVQ].as_map(),pCreateInfo[aGXpPVQ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSemaphore* pSemaphore;
[&](){
            if (json["pSemaphore"].as_vector().size()==0){
                pSemaphore=NULL;
            return; }pSemaphore=(VkSemaphore*)malloc(1*sizeof(VkSemaphore));auto& arr_rvNHvxY=json["pSemaphore"].as_vector();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();

    PFN_vkCreateSemaphore call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateSemaphore)get_instance_proc_addr(parent,"vkCreateSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateSemaphore)get_device_proc_addr(parent,"vkCreateSemaphore");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSemaphore);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_hQVwpIP=json::vector(1);
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TzTYDbe]);
            arr_hQVwpIP[TzTYDbe]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_hQVwpIP;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=json::vector();
            return; }auto arr_rvNHvxY=json::vector(1);
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        json["pSemaphore"]=arr_rvNHvxY;}();


        json["stream_type"]=static_cast<int>(VKCREATESEMAPHORE);
        writeToConn(json);
    }

    void handle_vkDestroySemaphore(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySemaphore call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroySemaphore)get_instance_proc_addr(parent,"vkDestroySemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroySemaphore)get_device_proc_addr(parent,"vkDestroySemaphore");
    }  
    
{
call_function(device, semaphore, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSEMAPHORE);
        writeToConn(json);
    }

    void handle_vkCreateEvent(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkEventCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkEventCreateInfo*)malloc(1*sizeof(VkEventCreateInfo));auto& arr_cHgRyNm=json["pCreateInfo"].as_vector();
        for(int gikyLcY=0; gikyLcY < 1; gikyLcY++){
            [&](){
            deserialize_struct(arr_cHgRyNm[gikyLcY].as_map(),pCreateInfo[gikyLcY]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkEvent* pEvent;
[&](){
            if (json["pEvent"].as_vector().size()==0){
                pEvent=NULL;
            return; }pEvent=(VkEvent*)malloc(1*sizeof(VkEvent));auto& arr_edObbrc=json["pEvent"].as_vector();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();

    PFN_vkCreateEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateEvent)get_instance_proc_addr(parent,"vkCreateEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateEvent)get_device_proc_addr(parent,"vkCreateEvent");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pEvent);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_wqWioqo=json::vector(1);
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[ThfQKZW]);
            arr_wqWioqo[ThfQKZW]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_wqWioqo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=json::vector();
            return; }auto arr_edObbrc=json::vector(1);
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        json["pEvent"]=arr_edObbrc;}();


        json["stream_type"]=static_cast<int>(VKCREATEEVENT);
        writeToConn(json);
    }

    void handle_vkDestroyEvent(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyEvent)get_instance_proc_addr(parent,"vkDestroyEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyEvent)get_device_proc_addr(parent,"vkDestroyEvent");
    }  
    
{
call_function(device, event, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYEVENT);
        writeToConn(json);
    }

    void handle_vkGetEventStatus(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkGetEventStatus call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetEventStatus)get_instance_proc_addr(parent,"vkGetEventStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetEventStatus)get_device_proc_addr(parent,"vkGetEventStatus");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=static_cast<int>(VKGETEVENTSTATUS);
        writeToConn(json);
    }

    void handle_vkSetEvent(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkSetEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetEvent)get_instance_proc_addr(parent,"vkSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetEvent)get_device_proc_addr(parent,"vkSetEvent");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=static_cast<int>(VKSETEVENT);
        writeToConn(json);
    }

    void handle_vkResetEvent(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkResetEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetEvent)get_instance_proc_addr(parent,"vkResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetEvent)get_device_proc_addr(parent,"vkResetEvent");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=static_cast<int>(VKRESETEVENT);
        writeToConn(json);
    }

    void handle_vkCreateQueryPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkQueryPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkQueryPoolCreateInfo*)malloc(1*sizeof(VkQueryPoolCreateInfo));auto& arr_OFyRSSf=json["pCreateInfo"].as_vector();
        for(int HxljsQx=0; HxljsQx < 1; HxljsQx++){
            [&](){
            deserialize_struct(arr_OFyRSSf[HxljsQx].as_map(),pCreateInfo[HxljsQx]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkQueryPool* pQueryPool;
[&](){
            if (json["pQueryPool"].as_vector().size()==0){
                pQueryPool=NULL;
            return; }pQueryPool=(VkQueryPool*)malloc(1*sizeof(VkQueryPool));auto& arr_uEjfPmz=json["pQueryPool"].as_vector();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();

    PFN_vkCreateQueryPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateQueryPool)get_instance_proc_addr(parent,"vkCreateQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateQueryPool)get_device_proc_addr(parent,"vkCreateQueryPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pQueryPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_AOuTZQo=json::vector(1);
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[SvYxRUl]);
            arr_AOuTZQo[SvYxRUl]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_AOuTZQo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=json::vector();
            return; }auto arr_uEjfPmz=json::vector(1);
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        json["pQueryPool"]=arr_uEjfPmz;}();


        json["stream_type"]=static_cast<int>(VKCREATEQUERYPOOL);
        writeToConn(json);
    }

    void handle_vkDestroyQueryPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyQueryPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyQueryPool)get_instance_proc_addr(parent,"vkDestroyQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyQueryPool)get_device_proc_addr(parent,"vkDestroyQueryPool");
    }  
    
{
call_function(device, queryPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYQUERYPOOL);
        writeToConn(json);
    }

    void handle_vkGetQueryPoolResults(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_int64_t());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkGetQueryPoolResults call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetQueryPoolResults)get_instance_proc_addr(parent,"vkGetQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetQueryPoolResults)get_device_proc_addr(parent,"vkGetQueryPoolResults");
    }  
    
VkResult  result;
{
result=call_function(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){[&](){json["stride"]=static_cast<uint>(stride);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKGETQUERYPOOLRESULTS);
        writeToConn(json);
    }

    void handle_vkResetQueryPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();

    PFN_vkResetQueryPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetQueryPool)get_instance_proc_addr(parent,"vkResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetQueryPool)get_device_proc_addr(parent,"vkResetQueryPool");
    }  
    
{
call_function(device, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();


        json["stream_type"]=static_cast<int>(VKRESETQUERYPOOL);
        writeToConn(json);
    }

    void handle_vkCreateBuffer(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkBufferCreateInfo*)malloc(1*sizeof(VkBufferCreateInfo));auto& arr_vAtICCQ=json["pCreateInfo"].as_vector();
        for(int kBYZDCM=0; kBYZDCM < 1; kBYZDCM++){
            [&](){
            deserialize_struct(arr_vAtICCQ[kBYZDCM].as_map(),pCreateInfo[kBYZDCM]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkBuffer* pBuffer;
[&](){
            if (json["pBuffer"].as_vector().size()==0){
                pBuffer=NULL;
            return; }pBuffer=(VkBuffer*)malloc(1*sizeof(VkBuffer));auto& arr_cIWQmjJ=json["pBuffer"].as_vector();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();

    PFN_vkCreateBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateBuffer)get_instance_proc_addr(parent,"vkCreateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateBuffer)get_device_proc_addr(parent,"vkCreateBuffer");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_YapwvbL=json::vector(1);
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XkzMxbI]);
            arr_YapwvbL[XkzMxbI]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_YapwvbL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=json::vector();
            return; }auto arr_cIWQmjJ=json::vector(1);
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        json["pBuffer"]=arr_cIWQmjJ;}();


        json["stream_type"]=static_cast<int>(VKCREATEBUFFER);
        writeToConn(json);
    }

    void handle_vkDestroyBuffer(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyBuffer)get_instance_proc_addr(parent,"vkDestroyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyBuffer)get_device_proc_addr(parent,"vkDestroyBuffer");
    }  
    
{
call_function(device, buffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYBUFFER);
        writeToConn(json);
    }

    void handle_vkCreateBufferView(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferViewCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkBufferViewCreateInfo*)malloc(1*sizeof(VkBufferViewCreateInfo));auto& arr_MSlizKJ=json["pCreateInfo"].as_vector();
        for(int bEIfqcJ=0; bEIfqcJ < 1; bEIfqcJ++){
            [&](){
            deserialize_struct(arr_MSlizKJ[bEIfqcJ].as_map(),pCreateInfo[bEIfqcJ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkBufferView* pView;
[&](){
            if (json["pView"].as_vector().size()==0){
                pView=NULL;
            return; }pView=(VkBufferView*)malloc(1*sizeof(VkBufferView));auto& arr_FoBLnTF=json["pView"].as_vector();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();

    PFN_vkCreateBufferView call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateBufferView)get_instance_proc_addr(parent,"vkCreateBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateBufferView)get_device_proc_addr(parent,"vkCreateBufferView");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_SvrkcZl=json::vector(1);
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[cSdiRJj]);
            arr_SvrkcZl[cSdiRJj]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_SvrkcZl;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pView==NULL){
                json["pView"]=json::vector();
            return; }auto arr_FoBLnTF=json::vector(1);
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        json["pView"]=arr_FoBLnTF;}();


        json["stream_type"]=static_cast<int>(VKCREATEBUFFERVIEW);
        writeToConn(json);
    }

    void handle_vkDestroyBufferView(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferView bufferView;
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyBufferView call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyBufferView)get_instance_proc_addr(parent,"vkDestroyBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyBufferView)get_device_proc_addr(parent,"vkDestroyBufferView");
    }  
    
{
call_function(device, bufferView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYBUFFERVIEW);
        writeToConn(json);
    }

    void handle_vkCreateImage(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));auto& arr_yCiQzQk=json["pCreateInfo"].as_vector();
        for(int QiYISUj=0; QiYISUj < 1; QiYISUj++){
            [&](){
            deserialize_struct(arr_yCiQzQk[QiYISUj].as_map(),pCreateInfo[QiYISUj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkImage* pImage;
[&](){
            if (json["pImage"].as_vector().size()==0){
                pImage=NULL;
            return; }pImage=(VkImage*)malloc(1*sizeof(VkImage));auto& arr_YGmHGGw=json["pImage"].as_vector();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();

    PFN_vkCreateImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateImage)get_instance_proc_addr(parent,"vkCreateImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateImage)get_device_proc_addr(parent,"vkCreateImage");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pImage);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TpPCnAy=json::vector(1);
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[pRwmwcF]);
            arr_TpPCnAy[pRwmwcF]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TpPCnAy;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pImage==NULL){
                json["pImage"]=json::vector();
            return; }auto arr_YGmHGGw=json::vector(1);
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        json["pImage"]=arr_YGmHGGw;}();


        json["stream_type"]=static_cast<int>(VKCREATEIMAGE);
        writeToConn(json);
    }

    void handle_vkDestroyImage(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyImage)get_instance_proc_addr(parent,"vkDestroyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyImage)get_device_proc_addr(parent,"vkDestroyImage");
    }  
    
{
call_function(device, image, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYIMAGE);
        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkImageSubresource* pSubresource;
[&](){
            if (json["pSubresource"].as_vector().size()==0){
                pSubresource=NULL;
            return; }pSubresource=(VkImageSubresource*)malloc(1*sizeof(VkImageSubresource));auto& arr_zbWgqCd=json["pSubresource"].as_vector();
        for(int ioHtFIy=0; ioHtFIy < 1; ioHtFIy++){
            [&](){
            deserialize_struct(arr_zbWgqCd[ioHtFIy].as_map(),pSubresource[ioHtFIy]);
            }();
        }
        }();
VkSubresourceLayout* pLayout;
[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout*)malloc(1*sizeof(VkSubresourceLayout));auto& arr_JAFsVvP=json["pLayout"].as_vector();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            deserialize_struct(arr_JAFsVvP[jGHmbXh].as_map(),pLayout[jGHmbXh]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageSubresourceLayout)get_device_proc_addr(parent,"vkGetImageSubresourceLayout");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=json::vector();
            return; }auto arr_bNRLlpX=json::vector(1);
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubresource[trrMzRH]);
            arr_bNRLlpX[trrMzRH]=temp_map;
            return;
            }();
        }
        json["pSubresource"]=arr_bNRLlpX;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JAFsVvP=json::vector(1);
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jGHmbXh]);
            arr_JAFsVvP[jGHmbXh]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JAFsVvP;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGESUBRESOURCELAYOUT);
        writeToConn(json);
    }

    void handle_vkCreateImageView(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkImageViewCreateInfo*)malloc(1*sizeof(VkImageViewCreateInfo));auto& arr_JenFyWd=json["pCreateInfo"].as_vector();
        for(int RiehwsS=0; RiehwsS < 1; RiehwsS++){
            [&](){
            deserialize_struct(arr_JenFyWd[RiehwsS].as_map(),pCreateInfo[RiehwsS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkImageView* pView;
[&](){
            if (json["pView"].as_vector().size()==0){
                pView=NULL;
            return; }pView=(VkImageView*)malloc(1*sizeof(VkImageView));auto& arr_GCwrdnq=json["pView"].as_vector();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();

    PFN_vkCreateImageView call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateImageView)get_instance_proc_addr(parent,"vkCreateImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateImageView)get_device_proc_addr(parent,"vkCreateImageView");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TYfFrkP=json::vector(1);
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[HNOogbj]);
            arr_TYfFrkP[HNOogbj]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TYfFrkP;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pView==NULL){
                json["pView"]=json::vector();
            return; }auto arr_GCwrdnq=json::vector(1);
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        json["pView"]=arr_GCwrdnq;}();


        json["stream_type"]=static_cast<int>(VKCREATEIMAGEVIEW);
        writeToConn(json);
    }

    void handle_vkDestroyImageView(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyImageView call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyImageView)get_instance_proc_addr(parent,"vkDestroyImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyImageView)get_device_proc_addr(parent,"vkDestroyImageView");
    }  
    
{
call_function(device, imageView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYIMAGEVIEW);
        writeToConn(json);
    }

    void handle_vkCreateShaderModule(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkShaderModuleCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));auto& arr_GtIQgds=json["pCreateInfo"].as_vector();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            deserialize_struct(arr_GtIQgds[PbmosKP].as_map(),pCreateInfo[PbmosKP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkShaderModule* pShaderModule;
[&](){
            if (json["pShaderModule"].as_vector().size()==0){
                pShaderModule=NULL;
            return; }pShaderModule=(VkShaderModule*)malloc(1*sizeof(VkShaderModule));auto& arr_FaKUyxw=json["pShaderModule"].as_vector();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();

    PFN_vkCreateShaderModule call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateShaderModule)get_instance_proc_addr(parent,"vkCreateShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateShaderModule)get_device_proc_addr(parent,"vkCreateShaderModule");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pShaderModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iSZUILM=json::vector(1);
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[dKxemXH]);
            arr_iSZUILM[dKxemXH]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iSZUILM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=json::vector();
            return; }auto arr_FaKUyxw=json::vector(1);
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        json["pShaderModule"]=arr_FaKUyxw;}();


        json["stream_type"]=static_cast<int>(VKCREATESHADERMODULE);
        writeToConn(json);
    }

    void handle_vkDestroyShaderModule(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyShaderModule call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyShaderModule)get_instance_proc_addr(parent,"vkDestroyShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyShaderModule)get_device_proc_addr(parent,"vkDestroyShaderModule");
    }  
    
{
call_function(device, shaderModule, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSHADERMODULE);
        writeToConn(json);
    }

    void handle_vkCreatePipelineCache(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineCacheCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPipelineCacheCreateInfo*)malloc(1*sizeof(VkPipelineCacheCreateInfo));auto& arr_tPFcwyz=json["pCreateInfo"].as_vector();
        for(int ccOebrR=0; ccOebrR < 1; ccOebrR++){
            [&](){
            deserialize_struct(arr_tPFcwyz[ccOebrR].as_map(),pCreateInfo[ccOebrR]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipelineCache* pPipelineCache;
[&](){
            if (json["pPipelineCache"].as_vector().size()==0){
                pPipelineCache=NULL;
            return; }pPipelineCache=(VkPipelineCache*)malloc(1*sizeof(VkPipelineCache));auto& arr_mogHiwV=json["pPipelineCache"].as_vector();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();

    PFN_vkCreatePipelineCache call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreatePipelineCache)get_instance_proc_addr(parent,"vkCreatePipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreatePipelineCache)get_device_proc_addr(parent,"vkCreatePipelineCache");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPipelineCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_wTXOYfz=json::vector(1);
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[iWdFkeP]);
            arr_wTXOYfz[iWdFkeP]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_wTXOYfz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=json::vector();
            return; }auto arr_mogHiwV=json::vector(1);
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        json["pPipelineCache"]=arr_mogHiwV;}();


        json["stream_type"]=static_cast<int>(VKCREATEPIPELINECACHE);
        writeToConn(json);
    }

    void handle_vkDestroyPipelineCache(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipelineCache call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyPipelineCache)get_instance_proc_addr(parent,"vkDestroyPipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyPipelineCache)get_device_proc_addr(parent,"vkDestroyPipelineCache");
    }  
    
{
call_function(device, pipelineCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYPIPELINECACHE);
        writeToConn(json);
    }

    void handle_vkGetPipelineCacheData(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetPipelineCacheData call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineCacheData)get_instance_proc_addr(parent,"vkGetPipelineCacheData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineCacheData)get_device_proc_addr(parent,"vkGetPipelineCacheData");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINECACHEDATA);
        writeToConn(json);
    }

    void handle_vkMergePipelineCaches(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache dstCache;
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){
            if (json["srcCacheCount"].is_uint64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_uint64_t());
            }else if (json["srcCacheCount"].is_int64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_int64_t());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_double());
            }
            }();
 VkPipelineCache* pSrcCaches;
[&](){
            if (json["pSrcCaches"].as_vector().size()==0){
                pSrcCaches=NULL;
            return; }pSrcCaches=(VkPipelineCache*)malloc(srcCacheCount*sizeof(VkPipelineCache));auto& arr_criceHb=json["pSrcCaches"].as_vector();
        for(int TBfRFpH=0; TBfRFpH < srcCacheCount; TBfRFpH++){
            [&](){deserialize_VkPipelineCache(arr_criceHb[TBfRFpH], pSrcCaches[TBfRFpH]);}();
        }
        }();

    PFN_vkMergePipelineCaches call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkMergePipelineCaches)get_instance_proc_addr(parent,"vkMergePipelineCaches");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkMergePipelineCaches)get_device_proc_addr(parent,"vkMergePipelineCaches");
    }  
    
VkResult  result;
{
result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=static_cast<uint>(srcCacheCount);}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=json::vector();
            return; }auto arr_DmqfOOL=json::vector(srcCacheCount);
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        json["pSrcCaches"]=arr_DmqfOOL;}();


        json["stream_type"]=static_cast<int>(VKMERGEPIPELINECACHES);
        writeToConn(json);
    }

    void handle_vkCreateGraphicsPipelines(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();
 VkGraphicsPipelineCreateInfo* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkGraphicsPipelineCreateInfo*)malloc(createInfoCount*sizeof(VkGraphicsPipelineCreateInfo));auto& arr_bKkRMWv=json["pCreateInfos"].as_vector();
        for(int kSHyOYR=0; kSHyOYR < createInfoCount; kSHyOYR++){
            [&](){
            deserialize_struct(arr_bKkRMWv[kSHyOYR].as_map(),pCreateInfos[kSHyOYR]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateGraphicsPipelines call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateGraphicsPipelines)get_instance_proc_addr(parent,"vkCreateGraphicsPipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateGraphicsPipelines)get_device_proc_addr(parent,"vkCreateGraphicsPipelines");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_juQDvLY=json::vector(createInfoCount);
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[wqGiARr]);
            arr_juQDvLY[wqGiARr]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_juQDvLY;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();


        json["stream_type"]=static_cast<int>(VKCREATEGRAPHICSPIPELINES);
        writeToConn(json);
    }

    void handle_vkCreateComputePipelines(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();
 VkComputePipelineCreateInfo* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkComputePipelineCreateInfo*)malloc(createInfoCount*sizeof(VkComputePipelineCreateInfo));auto& arr_THdSKsK=json["pCreateInfos"].as_vector();
        for(int qnUOnCC=0; qnUOnCC < createInfoCount; qnUOnCC++){
            [&](){
            deserialize_struct(arr_THdSKsK[qnUOnCC].as_map(),pCreateInfos[qnUOnCC]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateComputePipelines call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateComputePipelines)get_instance_proc_addr(parent,"vkCreateComputePipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateComputePipelines)get_device_proc_addr(parent,"vkCreateComputePipelines");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_eqiaDas=json::vector(createInfoCount);
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[NsFJrJk]);
            arr_eqiaDas[NsFJrJk]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_eqiaDas;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();


        json["stream_type"]=static_cast<int>(VKCREATECOMPUTEPIPELINES);
        writeToConn(json);
    }

    void handle_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderpass;
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
VkExtent2D* pMaxWorkgroupSize;
[&](){
            if (json["pMaxWorkgroupSize"].as_vector().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }pMaxWorkgroupSize=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].as_vector();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            deserialize_struct(arr_QJRQgTX[WdbibPk].as_map(),pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();

    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_instance_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_device_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }  
    
VkResult  result;
{
result=call_function(device, renderpass, pMaxWorkgroupSize);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=json::vector();
            return; }auto arr_QJRQgTX=json::vector(1);
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMaxWorkgroupSize[WdbibPk]);
            arr_QJRQgTX[WdbibPk]=temp_map;
            return;
            }();
        }
        json["pMaxWorkgroupSize"]=arr_QJRQgTX;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI);
        writeToConn(json);
    }

    void handle_vkDestroyPipeline(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipeline call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyPipeline)get_instance_proc_addr(parent,"vkDestroyPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyPipeline)get_device_proc_addr(parent,"vkDestroyPipeline");
    }  
    
{
call_function(device, pipeline, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYPIPELINE);
        writeToConn(json);
    }

    void handle_vkCreatePipelineLayout(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPipelineLayoutCreateInfo*)malloc(1*sizeof(VkPipelineLayoutCreateInfo));auto& arr_oLPmvyU=json["pCreateInfo"].as_vector();
        for(int wpAzccn=0; wpAzccn < 1; wpAzccn++){
            [&](){
            deserialize_struct(arr_oLPmvyU[wpAzccn].as_map(),pCreateInfo[wpAzccn]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipelineLayout* pPipelineLayout;
[&](){
            if (json["pPipelineLayout"].as_vector().size()==0){
                pPipelineLayout=NULL;
            return; }pPipelineLayout=(VkPipelineLayout*)malloc(1*sizeof(VkPipelineLayout));auto& arr_NheDZho=json["pPipelineLayout"].as_vector();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();

    PFN_vkCreatePipelineLayout call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreatePipelineLayout)get_instance_proc_addr(parent,"vkCreatePipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreatePipelineLayout)get_device_proc_addr(parent,"vkCreatePipelineLayout");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPipelineLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iyZpkhm=json::vector(1);
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[AdWYCmn]);
            arr_iyZpkhm[AdWYCmn]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iyZpkhm;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=json::vector();
            return; }auto arr_NheDZho=json::vector(1);
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        json["pPipelineLayout"]=arr_NheDZho;}();


        json["stream_type"]=static_cast<int>(VKCREATEPIPELINELAYOUT);
        writeToConn(json);
    }

    void handle_vkDestroyPipelineLayout(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineLayout pipelineLayout;
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipelineLayout call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyPipelineLayout)get_instance_proc_addr(parent,"vkDestroyPipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyPipelineLayout)get_device_proc_addr(parent,"vkDestroyPipelineLayout");
    }  
    
{
call_function(device, pipelineLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYPIPELINELAYOUT);
        writeToConn(json);
    }

    void handle_vkCreateSampler(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSamplerCreateInfo*)malloc(1*sizeof(VkSamplerCreateInfo));auto& arr_tMhVauC=json["pCreateInfo"].as_vector();
        for(int yZfhKUj=0; yZfhKUj < 1; yZfhKUj++){
            [&](){
            deserialize_struct(arr_tMhVauC[yZfhKUj].as_map(),pCreateInfo[yZfhKUj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSampler* pSampler;
[&](){
            if (json["pSampler"].as_vector().size()==0){
                pSampler=NULL;
            return; }pSampler=(VkSampler*)malloc(1*sizeof(VkSampler));auto& arr_nEROYrx=json["pSampler"].as_vector();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();

    PFN_vkCreateSampler call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateSampler)get_instance_proc_addr(parent,"vkCreateSampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateSampler)get_device_proc_addr(parent,"vkCreateSampler");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSampler);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_xWlqrLm=json::vector(1);
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[yMsdBPh]);
            arr_xWlqrLm[yMsdBPh]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_xWlqrLm;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=json::vector();
            return; }auto arr_nEROYrx=json::vector(1);
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        json["pSampler"]=arr_nEROYrx;}();


        json["stream_type"]=static_cast<int>(VKCREATESAMPLER);
        writeToConn(json);
    }

    void handle_vkDestroySampler(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSampler sampler;
[&](){deserialize_VkSampler(json["sampler"], sampler);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySampler call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroySampler)get_instance_proc_addr(parent,"vkDestroySampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroySampler)get_device_proc_addr(parent,"vkDestroySampler");
    }  
    
{
call_function(device, sampler, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSAMPLER);
        writeToConn(json);
    }

    void handle_vkCreateDescriptorSetLayout(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));auto& arr_oELBvJU=json["pCreateInfo"].as_vector();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            deserialize_struct(arr_oELBvJU[RmYFXzA].as_map(),pCreateInfo[RmYFXzA]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorSetLayout* pSetLayout;
[&](){
            if (json["pSetLayout"].as_vector().size()==0){
                pSetLayout=NULL;
            return; }pSetLayout=(VkDescriptorSetLayout*)malloc(1*sizeof(VkDescriptorSetLayout));auto& arr_iCAhOCt=json["pSetLayout"].as_vector();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();

    PFN_vkCreateDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDescriptorSetLayout)get_instance_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDescriptorSetLayout)get_device_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSetLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dFRsqIW=json::vector(1);
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tUGauKK]);
            arr_dFRsqIW[tUGauKK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dFRsqIW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=json::vector();
            return; }auto arr_iCAhOCt=json::vector(1);
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        json["pSetLayout"]=arr_iCAhOCt;}();


        json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORSETLAYOUT);
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorSetLayout(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout descriptorSetLayout;
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_instance_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_device_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }  
    
{
call_function(device, descriptorSetLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORSETLAYOUT);
        writeToConn(json);
    }

    void handle_vkCreateDescriptorPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorPoolCreateInfo*)malloc(1*sizeof(VkDescriptorPoolCreateInfo));auto& arr_aaNyAKF=json["pCreateInfo"].as_vector();
        for(int zIfzhBg=0; zIfzhBg < 1; zIfzhBg++){
            [&](){
            deserialize_struct(arr_aaNyAKF[zIfzhBg].as_map(),pCreateInfo[zIfzhBg]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorPool* pDescriptorPool;
[&](){
            if (json["pDescriptorPool"].as_vector().size()==0){
                pDescriptorPool=NULL;
            return; }pDescriptorPool=(VkDescriptorPool*)malloc(1*sizeof(VkDescriptorPool));auto& arr_zvYCksx=json["pDescriptorPool"].as_vector();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();

    PFN_vkCreateDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDescriptorPool)get_instance_proc_addr(parent,"vkCreateDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDescriptorPool)get_device_proc_addr(parent,"vkCreateDescriptorPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pDescriptorPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_fChMCRL=json::vector(1);
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XgrRVVh]);
            arr_fChMCRL[XgrRVVh]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_fChMCRL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=json::vector();
            return; }auto arr_zvYCksx=json::vector(1);
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        json["pDescriptorPool"]=arr_zvYCksx;}();


        json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORPOOL);
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDescriptorPool)get_instance_proc_addr(parent,"vkDestroyDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDescriptorPool)get_device_proc_addr(parent,"vkDestroyDescriptorPool");
    }  
    
{
call_function(device, descriptorPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORPOOL);
        writeToConn(json);
    }

    void handle_vkResetDescriptorPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
VkDescriptorPoolResetFlags flags;
[&](){[&](){int temp_zAsidUJ;[&](){
            if (json["flags"].is_uint64_t()){
                temp_zAsidUJ=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_zAsidUJ=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_zAsidUJ=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();

    PFN_vkResetDescriptorPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetDescriptorPool)get_instance_proc_addr(parent,"vkResetDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetDescriptorPool)get_device_proc_addr(parent,"vkResetDescriptorPool");
    }  
    
VkResult  result;
{
result=call_function(device, descriptorPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKRESETDESCRIPTORPOOL);
        writeToConn(json);
    }

    void handle_vkAllocateDescriptorSets(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].as_vector().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkDescriptorSetAllocateInfo*)malloc(1*sizeof(VkDescriptorSetAllocateInfo));auto& arr_scxnpgA=json["pAllocateInfo"].as_vector();
        for(int LkJrMgh=0; LkJrMgh < 1; LkJrMgh++){
            [&](){
            deserialize_struct(arr_scxnpgA[LkJrMgh].as_map(),pAllocateInfo[LkJrMgh]);
            }();
        }
        }();
VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].as_vector().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(pAllocateInfo->descriptorSetCount*sizeof(VkDescriptorSet));auto& arr_hwQSDBT=json["pDescriptorSets"].as_vector();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();

    PFN_vkAllocateDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAllocateDescriptorSets)get_instance_proc_addr(parent,"vkAllocateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAllocateDescriptorSets)get_device_proc_addr(parent,"vkAllocateDescriptorSets");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_yVqYJHW=json::vector(1);
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[jTINpTr]);
            arr_yVqYJHW[jTINpTr]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_yVqYJHW;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_hwQSDBT=json::vector(pAllocateInfo->descriptorSetCount);
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        json["pDescriptorSets"]=arr_hwQSDBT;}();


        json["stream_type"]=static_cast<int>(VKALLOCATEDESCRIPTORSETS);
        writeToConn(json);
    }

    void handle_vkFreeDescriptorSets(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
uint32_t descriptorSetCount;
[&](){
            if (json["descriptorSetCount"].is_uint64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_uint64_t());
            }else if (json["descriptorSetCount"].is_int64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_int64_t());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_double());
            }
            }();
 VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].as_vector().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));auto& arr_EoTJzqV=json["pDescriptorSets"].as_vector();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], pDescriptorSets[ignhEiw]);}();
        }
        }();

    PFN_vkFreeDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkFreeDescriptorSets)get_instance_proc_addr(parent,"vkFreeDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkFreeDescriptorSets)get_device_proc_addr(parent,"vkFreeDescriptorSets");
    }  
    
VkResult  result;
{
result=call_function(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=static_cast<uint>(descriptorSetCount);}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_JZNsxgK=json::vector(descriptorSetCount);
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        json["pDescriptorSets"]=arr_JZNsxgK;}();


        json["stream_type"]=static_cast<int>(VKFREEDESCRIPTORSETS);
        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSets(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t descriptorWriteCount;
[&](){
            if (json["descriptorWriteCount"].is_uint64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_uint64_t());
            }else if (json["descriptorWriteCount"].is_int64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_int64_t());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_double());
            }
            }();
 VkWriteDescriptorSet* pDescriptorWrites;
[&](){
            if (json["pDescriptorWrites"].as_vector().size()==0){
                pDescriptorWrites=NULL;
            return; }pDescriptorWrites=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));auto& arr_YJcGFpk=json["pDescriptorWrites"].as_vector();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            deserialize_struct(arr_YJcGFpk[PyFuMgH].as_map(),pDescriptorWrites[PyFuMgH]);
            }();
        }
        }();
uint32_t descriptorCopyCount;
[&](){
            if (json["descriptorCopyCount"].is_uint64_t()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_uint64_t());
            }else if (json["descriptorCopyCount"].is_int64_t()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_int64_t());
            }else{
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_double());
            }
            }();
 VkCopyDescriptorSet* pDescriptorCopies;
[&](){
            if (json["pDescriptorCopies"].as_vector().size()==0){
                pDescriptorCopies=NULL;
            return; }pDescriptorCopies=(VkCopyDescriptorSet*)malloc(descriptorCopyCount*sizeof(VkCopyDescriptorSet));auto& arr_kgDeqJO=json["pDescriptorCopies"].as_vector();
        for(int ygJPsJJ=0; ygJPsJJ < descriptorCopyCount; ygJPsJJ++){
            [&](){
            deserialize_struct(arr_kgDeqJO[ygJPsJJ].as_map(),pDescriptorCopies[ygJPsJJ]);
            }();
        }
        }();

    PFN_vkUpdateDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUpdateDescriptorSets)get_instance_proc_addr(parent,"vkUpdateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUpdateDescriptorSets)get_device_proc_addr(parent,"vkUpdateDescriptorSets");
    }  
    
{
call_function(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=static_cast<uint>(descriptorWriteCount);}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=json::vector();
            return; }auto arr_AuOrFWk=json::vector(descriptorWriteCount);
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorWrites[qJACxKx]);
            arr_AuOrFWk[qJACxKx]=temp_map;
            return;
            }();
        }
        json["pDescriptorWrites"]=arr_AuOrFWk;}();
[&](){json["descriptorCopyCount"]=static_cast<uint>(descriptorCopyCount);}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=json::vector();
            return; }auto arr_WWZDhqd=json::vector(descriptorCopyCount);
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorCopies[ryeXdkw]);
            arr_WWZDhqd[ryeXdkw]=temp_map;
            return;
            }();
        }
        json["pDescriptorCopies"]=arr_WWZDhqd;}();


        json["stream_type"]=static_cast<int>(VKUPDATEDESCRIPTORSETS);
        writeToConn(json);
    }

    void handle_vkCreateFramebuffer(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFramebufferCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkFramebufferCreateInfo*)malloc(1*sizeof(VkFramebufferCreateInfo));auto& arr_JrEGPNB=json["pCreateInfo"].as_vector();
        for(int NUUgVax=0; NUUgVax < 1; NUUgVax++){
            [&](){
            deserialize_struct(arr_JrEGPNB[NUUgVax].as_map(),pCreateInfo[NUUgVax]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkFramebuffer* pFramebuffer;
[&](){
            if (json["pFramebuffer"].as_vector().size()==0){
                pFramebuffer=NULL;
            return; }pFramebuffer=(VkFramebuffer*)malloc(1*sizeof(VkFramebuffer));auto& arr_xECXRAK=json["pFramebuffer"].as_vector();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();

    PFN_vkCreateFramebuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateFramebuffer)get_instance_proc_addr(parent,"vkCreateFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateFramebuffer)get_device_proc_addr(parent,"vkCreateFramebuffer");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFramebuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_LBIrWmz=json::vector(1);
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[jMLqpUb]);
            arr_LBIrWmz[jMLqpUb]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_LBIrWmz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=json::vector();
            return; }auto arr_xECXRAK=json::vector(1);
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        json["pFramebuffer"]=arr_xECXRAK;}();


        json["stream_type"]=static_cast<int>(VKCREATEFRAMEBUFFER);
        writeToConn(json);
    }

    void handle_vkDestroyFramebuffer(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyFramebuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyFramebuffer)get_instance_proc_addr(parent,"vkDestroyFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyFramebuffer)get_device_proc_addr(parent,"vkDestroyFramebuffer");
    }  
    
{
call_function(device, framebuffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYFRAMEBUFFER);
        writeToConn(json);
    }

    void handle_vkCreateRenderPass(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderPassCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkRenderPassCreateInfo*)malloc(1*sizeof(VkRenderPassCreateInfo));auto& arr_aQkDqwy=json["pCreateInfo"].as_vector();
        for(int RbeQDgp=0; RbeQDgp < 1; RbeQDgp++){
            [&](){
            deserialize_struct(arr_aQkDqwy[RbeQDgp].as_map(),pCreateInfo[RbeQDgp]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].as_vector().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));auto& arr_ZwdXTfx=json["pRenderPass"].as_vector();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateRenderPass)get_instance_proc_addr(parent,"vkCreateRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateRenderPass)get_device_proc_addr(parent,"vkCreateRenderPass");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_upxhtZe=json::vector(1);
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[oHJSJzU]);
            arr_upxhtZe[oHJSJzU]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_upxhtZe;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=json::vector();
            return; }auto arr_ZwdXTfx=json::vector(1);
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        json["pRenderPass"]=arr_ZwdXTfx;}();


        json["stream_type"]=static_cast<int>(VKCREATERENDERPASS);
        writeToConn(json);
    }

    void handle_vkDestroyRenderPass(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyRenderPass call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyRenderPass)get_instance_proc_addr(parent,"vkDestroyRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyRenderPass)get_device_proc_addr(parent,"vkDestroyRenderPass");
    }  
    
{
call_function(device, renderPass, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYRENDERPASS);
        writeToConn(json);
    }

    void handle_vkGetRenderAreaGranularity(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].as_vector().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));auto& arr_VvmWHYL=json["pGranularity"].as_vector();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            deserialize_struct(arr_VvmWHYL[tgiNLQL].as_map(),pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderAreaGranularity call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRenderAreaGranularity)get_instance_proc_addr(parent,"vkGetRenderAreaGranularity");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRenderAreaGranularity)get_device_proc_addr(parent,"vkGetRenderAreaGranularity");
    }  
    
{
call_function(device, renderPass, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=json::vector();
            return; }auto arr_VvmWHYL=json::vector(1);
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGranularity[tgiNLQL]);
            arr_VvmWHYL[tgiNLQL]=temp_map;
            return;
            }();
        }
        json["pGranularity"]=arr_VvmWHYL;}();


        json["stream_type"]=static_cast<int>(VKGETRENDERAREAGRANULARITY);
        writeToConn(json);
    }

    void handle_vkGetRenderingAreaGranularityKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderingAreaInfoKHR* pRenderingAreaInfo;
[&](){
            if (json["pRenderingAreaInfo"].as_vector().size()==0){
                pRenderingAreaInfo=NULL;
            return; }pRenderingAreaInfo=(VkRenderingAreaInfoKHR*)malloc(1*sizeof(VkRenderingAreaInfoKHR));auto& arr_WDJFhzk=json["pRenderingAreaInfo"].as_vector();
        for(int Eyzmwzy=0; Eyzmwzy < 1; Eyzmwzy++){
            [&](){
            deserialize_struct(arr_WDJFhzk[Eyzmwzy].as_map(),pRenderingAreaInfo[Eyzmwzy]);
            }();
        }
        }();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].as_vector().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));auto& arr_VvmWHYL=json["pGranularity"].as_vector();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            deserialize_struct(arr_VvmWHYL[tgiNLQL].as_map(),pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderingAreaGranularityKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_instance_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_device_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }  
    
{
call_function(device, pRenderingAreaInfo, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=json::vector();
            return; }auto arr_QFvDqfG=json::vector(1);
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingAreaInfo[WRYBJDa]);
            arr_QFvDqfG[WRYBJDa]=temp_map;
            return;
            }();
        }
        json["pRenderingAreaInfo"]=arr_QFvDqfG;}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=json::vector();
            return; }auto arr_VvmWHYL=json::vector(1);
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGranularity[tgiNLQL]);
            arr_VvmWHYL[tgiNLQL]=temp_map;
            return;
            }();
        }
        json["pGranularity"]=arr_VvmWHYL;}();


        json["stream_type"]=static_cast<int>(VKGETRENDERINGAREAGRANULARITYKHR);
        writeToConn(json);
    }

    void handle_vkCreateCommandPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCommandPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCommandPoolCreateInfo*)malloc(1*sizeof(VkCommandPoolCreateInfo));auto& arr_gbWnDrT=json["pCreateInfo"].as_vector();
        for(int kFYaAKf=0; kFYaAKf < 1; kFYaAKf++){
            [&](){
            deserialize_struct(arr_gbWnDrT[kFYaAKf].as_map(),pCreateInfo[kFYaAKf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkCommandPool* pCommandPool;
[&](){
            if (json["pCommandPool"].as_vector().size()==0){
                pCommandPool=NULL;
            return; }pCommandPool=(VkCommandPool*)malloc(1*sizeof(VkCommandPool));auto& arr_ohCGecZ=json["pCommandPool"].as_vector();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();

    PFN_vkCreateCommandPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateCommandPool)get_instance_proc_addr(parent,"vkCreateCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateCommandPool)get_device_proc_addr(parent,"vkCreateCommandPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pCommandPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_ISnaSOj=json::vector(1);
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[ubLLexW]);
            arr_ISnaSOj[ubLLexW]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_ISnaSOj;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=json::vector();
            return; }auto arr_ohCGecZ=json::vector(1);
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        json["pCommandPool"]=arr_ohCGecZ;}();


        json["stream_type"]=static_cast<int>(VKCREATECOMMANDPOOL);
        writeToConn(json);
    }

    void handle_vkDestroyCommandPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCommandPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyCommandPool)get_instance_proc_addr(parent,"vkDestroyCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyCommandPool)get_device_proc_addr(parent,"vkDestroyCommandPool");
    }  
    
{
call_function(device, commandPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYCOMMANDPOOL);
        writeToConn(json);
    }

    void handle_vkResetCommandPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolResetFlags flags;
[&](){[&](){int temp_ZfbLqrp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();

    PFN_vkResetCommandPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetCommandPool)get_instance_proc_addr(parent,"vkResetCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetCommandPool)get_device_proc_addr(parent,"vkResetCommandPool");
    }  
    
VkResult  result;
{
result=call_function(device, commandPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKRESETCOMMANDPOOL);
        writeToConn(json);
    }

    void handle_vkAllocateCommandBuffers(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCommandBufferAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].as_vector().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkCommandBufferAllocateInfo*)malloc(1*sizeof(VkCommandBufferAllocateInfo));auto& arr_IZSSdEC=json["pAllocateInfo"].as_vector();
        for(int VNokfaI=0; VNokfaI < 1; VNokfaI++){
            [&](){
            deserialize_struct(arr_IZSSdEC[VNokfaI].as_map(),pAllocateInfo[VNokfaI]);
            }();
        }
        }();
VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].as_vector().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(pAllocateInfo->commandBufferCount*sizeof(VkCommandBuffer));auto& arr_WZYlBGU=json["pCommandBuffers"].as_vector();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();

    PFN_vkAllocateCommandBuffers call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAllocateCommandBuffers)get_instance_proc_addr(parent,"vkAllocateCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAllocateCommandBuffers)get_device_proc_addr(parent,"vkAllocateCommandBuffers");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pCommandBuffers);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_ZURucFE=json::vector(1);
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[VMrKYrr]);
            arr_ZURucFE[VMrKYrr]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_ZURucFE;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_WZYlBGU=json::vector(pAllocateInfo->commandBufferCount);
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        json["pCommandBuffers"]=arr_WZYlBGU;}();


        json["stream_type"]=static_cast<int>(VKALLOCATECOMMANDBUFFERS);
        writeToConn(json);
    }

    void handle_vkFreeCommandBuffers(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
uint32_t commandBufferCount;
[&](){
            if (json["commandBufferCount"].is_uint64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_uint64_t());
            }else if (json["commandBufferCount"].is_int64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_int64_t());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_double());
            }
            }();
 VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].as_vector().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));auto& arr_aIQpbyi=json["pCommandBuffers"].as_vector();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], pCommandBuffers[Neoyndt]);}();
        }
        }();

    PFN_vkFreeCommandBuffers call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkFreeCommandBuffers)get_instance_proc_addr(parent,"vkFreeCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkFreeCommandBuffers)get_device_proc_addr(parent,"vkFreeCommandBuffers");
    }  
    
{
call_function(device, commandPool, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=static_cast<uint>(commandBufferCount);}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_PdRlpEO=json::vector(commandBufferCount);
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        json["pCommandBuffers"]=arr_PdRlpEO;}();


        json["stream_type"]=static_cast<int>(VKFREECOMMANDBUFFERS);
        writeToConn(json);
    }

    void handle_vkBeginCommandBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCommandBufferBeginInfo* pBeginInfo;
[&](){
            if (json["pBeginInfo"].as_vector().size()==0){
                pBeginInfo=NULL;
            return; }pBeginInfo=(VkCommandBufferBeginInfo*)malloc(1*sizeof(VkCommandBufferBeginInfo));auto& arr_IMPwIrn=json["pBeginInfo"].as_vector();
        for(int yjPwvUw=0; yjPwvUw < 1; yjPwvUw++){
            [&](){
            deserialize_struct(arr_IMPwIrn[yjPwvUw].as_map(),pBeginInfo[yjPwvUw]);
            }();
        }
        }();

    PFN_vkBeginCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBeginCommandBuffer)get_instance_proc_addr(parent,"vkBeginCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBeginCommandBuffer)get_device_proc_addr(parent,"vkBeginCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pBeginInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=json::vector();
            return; }auto arr_cULABHU=json::vector(1);
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBeginInfo[MlslWJM]);
            arr_cULABHU[MlslWJM]=temp_map;
            return;
            }();
        }
        json["pBeginInfo"]=arr_cULABHU;}();


        json["stream_type"]=static_cast<int>(VKBEGINCOMMANDBUFFER);
        writeToConn(json);
    }

    void handle_vkEndCommandBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkEndCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEndCommandBuffer)get_instance_proc_addr(parent,"vkEndCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEndCommandBuffer)get_device_proc_addr(parent,"vkEndCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKENDCOMMANDBUFFER);
        writeToConn(json);
    }

    void handle_vkResetCommandBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCommandBufferResetFlags flags;
[&](){[&](){int temp_lxCkbVG;[&](){
            if (json["flags"].is_uint64_t()){
                temp_lxCkbVG=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_lxCkbVG=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_lxCkbVG=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();

    PFN_vkResetCommandBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkResetCommandBuffer)get_instance_proc_addr(parent,"vkResetCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkResetCommandBuffer)get_device_proc_addr(parent,"vkResetCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKRESETCOMMANDBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdBindPipeline(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdBindPipeline call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindPipeline)get_instance_proc_addr(parent,"vkCmdBindPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindPipeline)get_device_proc_addr(parent,"vkCmdBindPipeline");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        json["stream_type"]=static_cast<int>(VKCMDBINDPIPELINE);
        writeToConn(json);
    }

    void handle_vkCmdSetAttachmentFeedbackLoopEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageAspectFlags aspectMask;
[&](){[&](){int temp_LWxAVsj;[&](){
            if (json["aspectMask"].is_uint64_t()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_uint64_t());
            }else if (json["aspectMask"].is_int64_t()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_int64_t());
            }else{
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_double());
            }
            }();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_device_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }  
    
{
call_function(commandBuffer, aspectMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=static_cast<int>(aspectMask);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetViewport(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();
 VkViewport* pViewports;
[&](){
            if (json["pViewports"].as_vector().size()==0){
                pViewports=NULL;
            return; }pViewports=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));auto& arr_NYoDqxX=json["pViewports"].as_vector();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            deserialize_struct(arr_NYoDqxX[SjlAQpy].as_map(),pViewports[SjlAQpy]);
            }();
        }
        }();

    PFN_vkCmdSetViewport call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewport)get_instance_proc_addr(parent,"vkCmdSetViewport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewport)get_device_proc_addr(parent,"vkCmdSetViewport");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=json::vector();
            return; }auto arr_SyYryUE=json::vector(viewportCount);
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewports[HAuJlzw]);
            arr_SyYryUE[HAuJlzw]=temp_map;
            return;
            }();
        }
        json["pViewports"]=arr_SyYryUE;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORT);
        writeToConn(json);
    }

    void handle_vkCmdSetScissor(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstScissor;
[&](){
            if (json["firstScissor"].is_uint64_t()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_uint64_t());
            }else if (json["firstScissor"].is_int64_t()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_int64_t());
            }else{
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_double());
            }
            }();
uint32_t scissorCount;
[&](){
            if (json["scissorCount"].is_uint64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_uint64_t());
            }else if (json["scissorCount"].is_int64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_int64_t());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_double());
            }
            }();
 VkRect2D* pScissors;
[&](){
            if (json["pScissors"].as_vector().size()==0){
                pScissors=NULL;
            return; }pScissors=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));auto& arr_bIRAuhj=json["pScissors"].as_vector();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            deserialize_struct(arr_bIRAuhj[QukNmCZ].as_map(),pScissors[QukNmCZ]);
            }();
        }
        }();

    PFN_vkCmdSetScissor call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetScissor)get_instance_proc_addr(parent,"vkCmdSetScissor");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetScissor)get_device_proc_addr(parent,"vkCmdSetScissor");
    }  
    
{
call_function(commandBuffer, firstScissor, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=static_cast<uint>(firstScissor);}();
[&](){json["scissorCount"]=static_cast<uint>(scissorCount);}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=json::vector();
            return; }auto arr_RpUaBcS=json::vector(scissorCount);
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pScissors[XBYGvVT]);
            arr_RpUaBcS[XBYGvVT]=temp_map;
            return;
            }();
        }
        json["pScissors"]=arr_RpUaBcS;}();


        json["stream_type"]=static_cast<int>(VKCMDSETSCISSOR);
        writeToConn(json);
    }

    void handle_vkCmdSetLineWidth(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float lineWidth;
[&](){
            if (json["lineWidth"].is_uint64_t()){
                lineWidth=static_cast<float>(json["lineWidth"].as_uint64_t());
            }else if (json["lineWidth"].is_int64_t()){
                lineWidth=static_cast<float>(json["lineWidth"].as_int64_t());
            }else{
                lineWidth=static_cast<float>(json["lineWidth"].as_double());
            }
            }();

    PFN_vkCmdSetLineWidth call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLineWidth)get_instance_proc_addr(parent,"vkCmdSetLineWidth");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLineWidth)get_device_proc_addr(parent,"vkCmdSetLineWidth");
    }  
    
{
call_function(commandBuffer, lineWidth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=static_cast<float>(lineWidth);}();


        json["stream_type"]=static_cast<int>(VKCMDSETLINEWIDTH);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float depthBiasConstantFactor;
[&](){
            if (json["depthBiasConstantFactor"].is_uint64_t()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_uint64_t());
            }else if (json["depthBiasConstantFactor"].is_int64_t()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_int64_t());
            }else{
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_double());
            }
            }();
float depthBiasClamp;
[&](){
            if (json["depthBiasClamp"].is_uint64_t()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_uint64_t());
            }else if (json["depthBiasClamp"].is_int64_t()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_int64_t());
            }else{
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_double());
            }
            }();
float depthBiasSlopeFactor;
[&](){
            if (json["depthBiasSlopeFactor"].is_uint64_t()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_uint64_t());
            }else if (json["depthBiasSlopeFactor"].is_int64_t()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_int64_t());
            }else{
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_double());
            }
            }();

    PFN_vkCmdSetDepthBias call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthBias)get_instance_proc_addr(parent,"vkCmdSetDepthBias");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthBias)get_device_proc_addr(parent,"vkCmdSetDepthBias");
    }  
    
{
call_function(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=static_cast<float>(depthBiasConstantFactor);}();
[&](){json["depthBiasClamp"]=static_cast<float>(depthBiasClamp);}();
[&](){json["depthBiasSlopeFactor"]=static_cast<float>(depthBiasSlopeFactor);}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIAS);
        writeToConn(json);
    }

    void handle_vkCmdSetBlendConstants(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 float blendConstants[4];
[&](){auto& arr_jgecLWF=json["blendConstants"].as_vector();
        for(int JTJKYzw=0; JTJKYzw < 4; JTJKYzw++){
            [&](){
            if (arr_jgecLWF[JTJKYzw].is_uint64_t()){
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].as_uint64_t());
            }else if (arr_jgecLWF[JTJKYzw].is_int64_t()){
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].as_int64_t());
            }else{
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].as_double());
            }
            }();
        }
        }();

    PFN_vkCmdSetBlendConstants call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetBlendConstants)get_instance_proc_addr(parent,"vkCmdSetBlendConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetBlendConstants)get_device_proc_addr(parent,"vkCmdSetBlendConstants");
    }  
    
{
call_function(commandBuffer, blendConstants);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){auto arr_HTjCZtj=json::vector(4);
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_HTjCZtj[lLRJClr]=static_cast<float>(blendConstants[lLRJClr]);}();
        }
        json["blendConstants"]=arr_HTjCZtj;}();


        json["stream_type"]=static_cast<int>(VKCMDSETBLENDCONSTANTS);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBounds(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float minDepthBounds;
[&](){
            if (json["minDepthBounds"].is_uint64_t()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_uint64_t());
            }else if (json["minDepthBounds"].is_int64_t()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_int64_t());
            }else{
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_double());
            }
            }();
float maxDepthBounds;
[&](){
            if (json["maxDepthBounds"].is_uint64_t()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_uint64_t());
            }else if (json["maxDepthBounds"].is_int64_t()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_int64_t());
            }else{
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_double());
            }
            }();

    PFN_vkCmdSetDepthBounds call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthBounds)get_instance_proc_addr(parent,"vkCmdSetDepthBounds");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthBounds)get_device_proc_addr(parent,"vkCmdSetDepthBounds");
    }  
    
{
call_function(commandBuffer, minDepthBounds, maxDepthBounds);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=static_cast<float>(minDepthBounds);}();
[&](){json["maxDepthBounds"]=static_cast<float>(maxDepthBounds);}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBOUNDS);
        writeToConn(json);
    }

    void handle_vkCmdSetStencilCompareMask(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t compareMask;
[&](){
            if (json["compareMask"].is_uint64_t()){
                compareMask=static_cast<uint32_t>(json["compareMask"].as_uint64_t());
            }else if (json["compareMask"].is_int64_t()){
                compareMask=static_cast<uint32_t>(json["compareMask"].as_int64_t());
            }else{
                compareMask=static_cast<uint32_t>(json["compareMask"].as_double());
            }
            }();

    PFN_vkCmdSetStencilCompareMask call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetStencilCompareMask)get_instance_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetStencilCompareMask)get_device_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }  
    
{
call_function(commandBuffer, faceMask, compareMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["compareMask"]=static_cast<uint>(compareMask);}();


        json["stream_type"]=static_cast<int>(VKCMDSETSTENCILCOMPAREMASK);
        writeToConn(json);
    }

    void handle_vkCmdSetStencilWriteMask(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t writeMask;
[&](){
            if (json["writeMask"].is_uint64_t()){
                writeMask=static_cast<uint32_t>(json["writeMask"].as_uint64_t());
            }else if (json["writeMask"].is_int64_t()){
                writeMask=static_cast<uint32_t>(json["writeMask"].as_int64_t());
            }else{
                writeMask=static_cast<uint32_t>(json["writeMask"].as_double());
            }
            }();

    PFN_vkCmdSetStencilWriteMask call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetStencilWriteMask)get_instance_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetStencilWriteMask)get_device_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }  
    
{
call_function(commandBuffer, faceMask, writeMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["writeMask"]=static_cast<uint>(writeMask);}();


        json["stream_type"]=static_cast<int>(VKCMDSETSTENCILWRITEMASK);
        writeToConn(json);
    }

    void handle_vkCmdSetStencilReference(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t reference;
[&](){
            if (json["reference"].is_uint64_t()){
                reference=static_cast<uint32_t>(json["reference"].as_uint64_t());
            }else if (json["reference"].is_int64_t()){
                reference=static_cast<uint32_t>(json["reference"].as_int64_t());
            }else{
                reference=static_cast<uint32_t>(json["reference"].as_double());
            }
            }();

    PFN_vkCmdSetStencilReference call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetStencilReference)get_instance_proc_addr(parent,"vkCmdSetStencilReference");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetStencilReference)get_device_proc_addr(parent,"vkCmdSetStencilReference");
    }  
    
{
call_function(commandBuffer, faceMask, reference);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["reference"]=static_cast<uint>(reference);}();


        json["stream_type"]=static_cast<int>(VKCMDSETSTENCILREFERENCE);
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorSets(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){
            if (json["firstSet"].is_uint64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_uint64_t());
            }else if (json["firstSet"].is_int64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_int64_t());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].as_double());
            }
            }();
uint32_t descriptorSetCount;
[&](){
            if (json["descriptorSetCount"].is_uint64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_uint64_t());
            }else if (json["descriptorSetCount"].is_int64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_int64_t());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_double());
            }
            }();
 VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].as_vector().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));auto& arr_EoTJzqV=json["pDescriptorSets"].as_vector();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], pDescriptorSets[ignhEiw]);}();
        }
        }();
uint32_t dynamicOffsetCount;
[&](){
            if (json["dynamicOffsetCount"].is_uint64_t()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_uint64_t());
            }else if (json["dynamicOffsetCount"].is_int64_t()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_int64_t());
            }else{
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_double());
            }
            }();
 uint32_t* pDynamicOffsets;
[&](){
            if (json["pDynamicOffsets"].as_vector().size()==0){
                pDynamicOffsets=NULL;
            return; }pDynamicOffsets=(uint32_t*)malloc(dynamicOffsetCount*sizeof(uint32_t));auto& arr_QbUQxOl=json["pDynamicOffsets"].as_vector();
        for(int yNPUnDM=0; yNPUnDM < dynamicOffsetCount; yNPUnDM++){
            [&](){
            if (arr_QbUQxOl[yNPUnDM].is_uint64_t()){
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].as_uint64_t());
            }else if (arr_QbUQxOl[yNPUnDM].is_int64_t()){
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].as_int64_t());
            }else{
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].as_double());
            }
            }();
        }
        }();

    PFN_vkCmdBindDescriptorSets call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindDescriptorSets)get_instance_proc_addr(parent,"vkCmdBindDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindDescriptorSets)get_device_proc_addr(parent,"vkCmdBindDescriptorSets");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=static_cast<uint>(firstSet);}();
[&](){json["descriptorSetCount"]=static_cast<uint>(descriptorSetCount);}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_JZNsxgK=json::vector(descriptorSetCount);
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        json["pDescriptorSets"]=arr_JZNsxgK;}();
[&](){json["dynamicOffsetCount"]=static_cast<uint>(dynamicOffsetCount);}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=json::vector();
            return; }auto arr_Zetuxcc=json::vector(dynamicOffsetCount);
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=static_cast<uint>(pDynamicOffsets[nxuqgVF]);}();
        }
        json["pDynamicOffsets"]=arr_Zetuxcc;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORSETS);
        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_uint64_t());
            }else if (json["indexType"].is_int64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_int64_t());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindIndexBuffer)get_device_proc_addr(parent,"vkCmdBindIndexBuffer");
    }  
    
{
call_function(commandBuffer, buffer, offset, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){[&](){json["indexType"]=static_cast<int>(indexType);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBINDINDEXBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].as_vector().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));auto& arr_ShVTBbp=json["pBuffers"].as_vector();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].as_vector().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_uWdiGtF=json["pOffsets"].as_vector();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_uint64_t());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_int64_t());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();

    PFN_vkCmdBindVertexBuffers call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindVertexBuffers)get_device_proc_addr(parent,"vkCmdBindVertexBuffers");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDVERTEXBUFFERS);
        writeToConn(json);
    }

    void handle_vkCmdDraw(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexCount;
[&](){
            if (json["vertexCount"].is_uint64_t()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_uint64_t());
            }else if (json["vertexCount"].is_int64_t()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_int64_t());
            }else{
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_double());
            }
            }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
uint32_t firstVertex;
[&](){
            if (json["firstVertex"].is_uint64_t()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_uint64_t());
            }else if (json["firstVertex"].is_int64_t()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_int64_t());
            }else{
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();

    PFN_vkCmdDraw call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDraw)get_instance_proc_addr(parent,"vkCmdDraw");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDraw)get_device_proc_addr(parent,"vkCmdDraw");
    }  
    
{
call_function(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=static_cast<uint>(vertexCount);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstVertex"]=static_cast<uint>(firstVertex);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAW);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexed(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t indexCount;
[&](){
            if (json["indexCount"].is_uint64_t()){
                indexCount=static_cast<uint32_t>(json["indexCount"].as_uint64_t());
            }else if (json["indexCount"].is_int64_t()){
                indexCount=static_cast<uint32_t>(json["indexCount"].as_int64_t());
            }else{
                indexCount=static_cast<uint32_t>(json["indexCount"].as_double());
            }
            }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
uint32_t firstIndex;
[&](){
            if (json["firstIndex"].is_uint64_t()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_uint64_t());
            }else if (json["firstIndex"].is_int64_t()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_int64_t());
            }else{
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_double());
            }
            }();
int32_t vertexOffset;
[&](){
            if (json["vertexOffset"].is_uint64_t()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_uint64_t());
            }else if (json["vertexOffset"].is_int64_t()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_int64_t());
            }else{
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();

    PFN_vkCmdDrawIndexed call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndexed)get_instance_proc_addr(parent,"vkCmdDrawIndexed");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndexed)get_device_proc_addr(parent,"vkCmdDrawIndexed");
    }  
    
{
call_function(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=static_cast<uint>(indexCount);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstIndex"]=static_cast<uint>(firstIndex);}();
[&](){json["vertexOffset"]=static_cast<int>(vertexOffset);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXED);
        writeToConn(json);
    }

    void handle_vkCmdDrawMultiEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
 VkMultiDrawInfoEXT* pVertexInfo;
[&](){
            if (json["pVertexInfo"].as_vector().size()==0){
                pVertexInfo=NULL;
            return; }pVertexInfo=(VkMultiDrawInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawInfoEXT));auto& arr_SygHzZS=json["pVertexInfo"].as_vector();
        for(int iVtYwjb=0; iVtYwjb < drawCount; iVtYwjb++){
            [&](){
            deserialize_struct(arr_SygHzZS[iVtYwjb].as_map(),pVertexInfo[iVtYwjb]);
            }();
        }
        }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawMultiEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMultiEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMultiEXT)get_device_proc_addr(parent,"vkCmdDrawMultiEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=json::vector();
            return; }auto arr_NmVssTF=json::vector(drawCount);
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexInfo[xJCsgzh]);
            arr_NmVssTF[xJCsgzh]=temp_map;
            return;
            }();
        }
        json["pVertexInfo"]=arr_NmVssTF;}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMULTIEXT);
        writeToConn(json);
    }

    void handle_vkCmdDrawMultiIndexedEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
 VkMultiDrawIndexedInfoEXT* pIndexInfo;
[&](){
            if (json["pIndexInfo"].as_vector().size()==0){
                pIndexInfo=NULL;
            return; }pIndexInfo=(VkMultiDrawIndexedInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawIndexedInfoEXT));auto& arr_jliksnn=json["pIndexInfo"].as_vector();
        for(int cbQpceE=0; cbQpceE < drawCount; cbQpceE++){
            [&](){
            deserialize_struct(arr_jliksnn[cbQpceE].as_map(),pIndexInfo[cbQpceE]);
            }();
        }
        }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();
 int32_t* pVertexOffset;
[&](){
            if (json["pVertexOffset"].as_vector().size()==0){
                pVertexOffset=NULL;
            return; }pVertexOffset=(int32_t*)malloc(1*sizeof(int32_t));auto& arr_IdSDtoD=json["pVertexOffset"].as_vector();
        for(int XPkpqBK=0; XPkpqBK < 1; XPkpqBK++){
            [&](){
            if (arr_IdSDtoD[XPkpqBK].is_uint64_t()){
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].as_uint64_t());
            }else if (arr_IdSDtoD[XPkpqBK].is_int64_t()){
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].as_int64_t());
            }else{
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].as_double());
            }
            }();
        }
        }();

    PFN_vkCmdDrawMultiIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_device_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=json::vector();
            return; }auto arr_OvAOCiL=json::vector(drawCount);
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIndexInfo[FmfkOAV]);
            arr_OvAOCiL[FmfkOAV]=temp_map;
            return;
            }();
        }
        json["pIndexInfo"]=arr_OvAOCiL;}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=json::vector();
            return; }auto arr_PavgIEG=json::vector(1);
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=static_cast<int>(pVertexOffset[PNvrUEs]);}();
        }
        json["pVertexOffset"]=arr_PavgIEG;}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMULTIINDEXEDEXT);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirect(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawIndirect call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndirect)get_device_proc_addr(parent,"vkCmdDrawIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECT);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirect(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawIndexedIndirect call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXEDINDIRECT);
        writeToConn(json);
    }

    void handle_vkCmdDispatch(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

    PFN_vkCmdDispatch call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDispatch)get_instance_proc_addr(parent,"vkCmdDispatch");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDispatch)get_device_proc_addr(parent,"vkCmdDispatch");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();


        json["stream_type"]=static_cast<int>(VKCMDDISPATCH);
        writeToConn(json);
    }

    void handle_vkCmdDispatchIndirect(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDispatchIndirect call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDispatchIndirect)get_instance_proc_addr(parent,"vkCmdDispatchIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDispatchIndirect)get_device_proc_addr(parent,"vkCmdDispatchIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();


        json["stream_type"]=static_cast<int>(VKCMDDISPATCHINDIRECT);
        writeToConn(json);
    }

    void handle_vkCmdSubpassShadingHUAWEI(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdSubpassShadingHUAWEI call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_instance_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_device_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDSUBPASSSHADINGHUAWEI);
        writeToConn(json);
    }

    void handle_vkCmdDrawClusterHUAWEI(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

    PFN_vkCmdDrawClusterHUAWEI call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWCLUSTERHUAWEI);
        writeToConn(json);
    }

    void handle_vkCmdDrawClusterIndirectHUAWEI(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDrawClusterIndirectHUAWEI call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWCLUSTERINDIRECTHUAWEI);
        writeToConn(json);
    }

    void handle_vkCmdUpdatePipelineIndirectBufferNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdUpdatePipelineIndirectBufferNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_instance_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_device_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        json["stream_type"]=static_cast<int>(VKCMDUPDATEPIPELINEINDIRECTBUFFERNV);
        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkBufferCopy* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferCopy*)malloc(regionCount*sizeof(VkBufferCopy));auto& arr_MJNgYRy=json["pRegions"].as_vector();
        for(int BwnoKUH=0; BwnoKUH < regionCount; BwnoKUH++){
            [&](){
            deserialize_struct(arr_MJNgYRy[BwnoKUH].as_map(),pRegions[BwnoKUH]);
            }();
        }
        }();

    PFN_vkCmdCopyBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyBuffer)get_instance_proc_addr(parent,"vkCmdCopyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyBuffer)get_device_proc_addr(parent,"vkCmdCopyBuffer");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_McSYWcQ=json::vector(regionCount);
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[IaMuFrO]);
            arr_McSYWcQ[IaMuFrO]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_McSYWcQ;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdCopyImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkImageCopy* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageCopy*)malloc(regionCount*sizeof(VkImageCopy));auto& arr_sMBHaLF=json["pRegions"].as_vector();
        for(int lLnttNm=0; lLnttNm < regionCount; lLnttNm++){
            [&](){
            deserialize_struct(arr_sMBHaLF[lLnttNm].as_map(),pRegions[lLnttNm]);
            }();
        }
        }();

    PFN_vkCmdCopyImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyImage)get_instance_proc_addr(parent,"vkCmdCopyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyImage)get_device_proc_addr(parent,"vkCmdCopyImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_HMPixWj=json::vector(regionCount);
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[TvxHvSV]);
            arr_HMPixWj[TvxHvSV]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_HMPixWj;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdBlitImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkImageBlit* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageBlit*)malloc(regionCount*sizeof(VkImageBlit));auto& arr_aDcnXeL=json["pRegions"].as_vector();
        for(int khqBNUP=0; khqBNUP < regionCount; khqBNUP++){
            [&](){
            deserialize_struct(arr_aDcnXeL[khqBNUP].as_map(),pRegions[khqBNUP]);
            }();
        }
        }();
VkFilter filter;
[&](){[&](){int temp_DaCTyEq;[&](){
            if (json["filter"].is_uint64_t()){
                temp_DaCTyEq=static_cast<int>(json["filter"].as_uint64_t());
            }else if (json["filter"].is_int64_t()){
                temp_DaCTyEq=static_cast<int>(json["filter"].as_int64_t());
            }else{
                temp_DaCTyEq=static_cast<int>(json["filter"].as_double());
            }
            }();filter=(VkFilter)temp_DaCTyEq;}();}();

    PFN_vkCmdBlitImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBlitImage)get_instance_proc_addr(parent,"vkCmdBlitImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBlitImage)get_device_proc_addr(parent,"vkCmdBlitImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_dQsoHhP=json::vector(regionCount);
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[YEXYPDJ]);
            arr_dQsoHhP[YEXYPDJ]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_dQsoHhP;}();
[&](){[&](){[&](){json["filter"]=static_cast<int>(filter);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBLITIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkBufferImageCopy* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));auto& arr_Gfapiec=json["pRegions"].as_vector();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            deserialize_struct(arr_Gfapiec[edvwarx].as_map(),pRegions[edvwarx]);
            }();
        }
        }();

    PFN_vkCmdCopyBufferToImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyBufferToImage)get_device_proc_addr(parent,"vkCmdCopyBufferToImage");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_igZnVsu=json::vector(regionCount);
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[yuuZKOo]);
            arr_igZnVsu[yuuZKOo]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_igZnVsu;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFERTOIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkBufferImageCopy* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));auto& arr_Gfapiec=json["pRegions"].as_vector();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            deserialize_struct(arr_Gfapiec[edvwarx].as_map(),pRegions[edvwarx]);
            }();
        }
        }();

    PFN_vkCmdCopyImageToBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyImageToBuffer)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_igZnVsu=json::vector(regionCount);
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[yuuZKOo]);
            arr_igZnVsu[yuuZKOo]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_igZnVsu;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGETOBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryIndirectNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_uint64_t());
            }else if (json["copyBufferAddress"].is_int64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_int64_t());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){
            if (json["copyCount"].is_uint64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_uint64_t());
            }else if (json["copyCount"].is_int64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_int64_t());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdCopyMemoryIndirectNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=static_cast<uint>(copyBufferAddress);}();}();
[&](){json["copyCount"]=static_cast<uint>(copyCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYINDIRECTNV);
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToImageIndirectNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_uint64_t());
            }else if (json["copyBufferAddress"].is_int64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_int64_t());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){
            if (json["copyCount"].is_uint64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_uint64_t());
            }else if (json["copyCount"].is_int64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_int64_t());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
 VkImageSubresourceLayers* pImageSubresources;
[&](){
            if (json["pImageSubresources"].as_vector().size()==0){
                pImageSubresources=NULL;
            return; }pImageSubresources=(VkImageSubresourceLayers*)malloc(copyCount*sizeof(VkImageSubresourceLayers));auto& arr_WxjWdjD=json["pImageSubresources"].as_vector();
        for(int ApBwZPM=0; ApBwZPM < copyCount; ApBwZPM++){
            [&](){
            deserialize_struct(arr_WxjWdjD[ApBwZPM].as_map(),pImageSubresources[ApBwZPM]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToImageIndirectNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=static_cast<uint>(copyBufferAddress);}();}();
[&](){json["copyCount"]=static_cast<uint>(copyCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=json::vector();
            return; }auto arr_hVMAkcO=json::vector(copyCount);
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageSubresources[OfGHasS]);
            arr_hVMAkcO[OfGHasS]=temp_map;
            return;
            }();
        }
        json["pImageSubresources"]=arr_hVMAkcO;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOIMAGEINDIRECTNV);
        writeToConn(json);
    }

    void handle_vkCmdUpdateBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize dataSize;
[&](){uint64_t temp_SwYyzuh;[&](){
            if (json["dataSize"].is_uint64_t()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_int64_t());
            }else{
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_double());
            }
            }();dataSize=(VkDeviceSize)temp_SwYyzuh;}();
 void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_eeRffBc;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_eeRffBc=NULL;
            return; }temp_eeRffBc=(char*)malloc(dataSize*sizeof(char));auto& arr_EOPGHRq=json["pData"].as_vector();
        for(int ElrKHKH=0; ElrKHKH < dataSize; ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64_t()){
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_uint64_t());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64_t()){
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_int64_t());
            }else{
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_double());
            }
            }();
        }
        }();pData=temp_eeRffBc;}();

    PFN_vkCmdUpdateBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdUpdateBuffer)get_instance_proc_addr(parent,"vkCmdUpdateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdUpdateBuffer)get_device_proc_addr(parent,"vkCmdUpdateBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["dataSize"]=static_cast<uint>(dataSize);}();}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(dataSize);
        for(int wgKJNeB=0; wgKJNeB < dataSize; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();


        json["stream_type"]=static_cast<int>(VKCMDUPDATEBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdFillBuffer(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
uint32_t data;
[&](){
            if (json["data"].is_uint64_t()){
                data=static_cast<uint32_t>(json["data"].as_uint64_t());
            }else if (json["data"].is_int64_t()){
                data=static_cast<uint32_t>(json["data"].as_int64_t());
            }else{
                data=static_cast<uint32_t>(json["data"].as_double());
            }
            }();

    PFN_vkCmdFillBuffer call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdFillBuffer)get_instance_proc_addr(parent,"vkCmdFillBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdFillBuffer)get_device_proc_addr(parent,"vkCmdFillBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, size, data);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){json["data"]=static_cast<uint>(data);}();


        json["stream_type"]=static_cast<int>(VKCMDFILLBUFFER);
        writeToConn(json);
    }

    void handle_vkCmdClearColorImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
 VkClearColorValue* pColor;
[&](){
            if (json["pColor"].as_vector().size()==0){
                pColor=NULL;
            return; }pColor=(VkClearColorValue*)malloc(1*sizeof(VkClearColorValue));auto& arr_GpwuhjC=json["pColor"].as_vector();
        for(int ltCZWMn=0; ltCZWMn < 1; ltCZWMn++){
            [&](){
            deserialize_struct(arr_GpwuhjC[ltCZWMn].as_map(),pColor[ltCZWMn]);
            }();
        }
        }();
uint32_t rangeCount;
[&](){
            if (json["rangeCount"].is_uint64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_uint64_t());
            }else if (json["rangeCount"].is_int64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_int64_t());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_double());
            }
            }();
 VkImageSubresourceRange* pRanges;
[&](){
            if (json["pRanges"].as_vector().size()==0){
                pRanges=NULL;
            return; }pRanges=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));auto& arr_HvOwEDl=json["pRanges"].as_vector();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            deserialize_struct(arr_HvOwEDl[zzMqHgz].as_map(),pRanges[zzMqHgz]);
            }();
        }
        }();

    PFN_vkCmdClearColorImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdClearColorImage)get_instance_proc_addr(parent,"vkCmdClearColorImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdClearColorImage)get_device_proc_addr(parent,"vkCmdClearColorImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=json::vector();
            return; }auto arr_SGRyjqE=json::vector(1);
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColor[ldPlUDi]);
            arr_SGRyjqE[ldPlUDi]=temp_map;
            return;
            }();
        }
        json["pColor"]=arr_SGRyjqE;}();
[&](){json["rangeCount"]=static_cast<uint>(rangeCount);}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=json::vector();
            return; }auto arr_BisbUqU=json::vector(rangeCount);
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRanges[IZgopUD]);
            arr_BisbUqU[IZgopUD]=temp_map;
            return;
            }();
        }
        json["pRanges"]=arr_BisbUqU;}();


        json["stream_type"]=static_cast<int>(VKCMDCLEARCOLORIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdClearDepthStencilImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
 VkClearDepthStencilValue* pDepthStencil;
[&](){
            if (json["pDepthStencil"].as_vector().size()==0){
                pDepthStencil=NULL;
            return; }pDepthStencil=(VkClearDepthStencilValue*)malloc(1*sizeof(VkClearDepthStencilValue));auto& arr_PIAYblz=json["pDepthStencil"].as_vector();
        for(int zQOULOl=0; zQOULOl < 1; zQOULOl++){
            [&](){
            deserialize_struct(arr_PIAYblz[zQOULOl].as_map(),pDepthStencil[zQOULOl]);
            }();
        }
        }();
uint32_t rangeCount;
[&](){
            if (json["rangeCount"].is_uint64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_uint64_t());
            }else if (json["rangeCount"].is_int64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_int64_t());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_double());
            }
            }();
 VkImageSubresourceRange* pRanges;
[&](){
            if (json["pRanges"].as_vector().size()==0){
                pRanges=NULL;
            return; }pRanges=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));auto& arr_HvOwEDl=json["pRanges"].as_vector();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            deserialize_struct(arr_HvOwEDl[zzMqHgz].as_map(),pRanges[zzMqHgz]);
            }();
        }
        }();

    PFN_vkCmdClearDepthStencilImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdClearDepthStencilImage)get_instance_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdClearDepthStencilImage)get_device_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=json::vector();
            return; }auto arr_gYzlVps=json::vector(1);
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDepthStencil[jJUemfv]);
            arr_gYzlVps[jJUemfv]=temp_map;
            return;
            }();
        }
        json["pDepthStencil"]=arr_gYzlVps;}();
[&](){json["rangeCount"]=static_cast<uint>(rangeCount);}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=json::vector();
            return; }auto arr_BisbUqU=json::vector(rangeCount);
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRanges[IZgopUD]);
            arr_BisbUqU[IZgopUD]=temp_map;
            return;
            }();
        }
        json["pRanges"]=arr_BisbUqU;}();


        json["stream_type"]=static_cast<int>(VKCMDCLEARDEPTHSTENCILIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdClearAttachments(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkClearAttachment* pAttachments;
[&](){
            if (json["pAttachments"].as_vector().size()==0){
                pAttachments=NULL;
            return; }pAttachments=(VkClearAttachment*)malloc(attachmentCount*sizeof(VkClearAttachment));auto& arr_cdEOPrs=json["pAttachments"].as_vector();
        for(int bLOSZTT=0; bLOSZTT < attachmentCount; bLOSZTT++){
            [&](){
            deserialize_struct(arr_cdEOPrs[bLOSZTT].as_map(),pAttachments[bLOSZTT]);
            }();
        }
        }();
uint32_t rectCount;
[&](){
            if (json["rectCount"].is_uint64_t()){
                rectCount=static_cast<uint32_t>(json["rectCount"].as_uint64_t());
            }else if (json["rectCount"].is_int64_t()){
                rectCount=static_cast<uint32_t>(json["rectCount"].as_int64_t());
            }else{
                rectCount=static_cast<uint32_t>(json["rectCount"].as_double());
            }
            }();
 VkClearRect* pRects;
[&](){
            if (json["pRects"].as_vector().size()==0){
                pRects=NULL;
            return; }pRects=(VkClearRect*)malloc(rectCount*sizeof(VkClearRect));auto& arr_cMVnppZ=json["pRects"].as_vector();
        for(int RmtJABT=0; RmtJABT < rectCount; RmtJABT++){
            [&](){
            deserialize_struct(arr_cMVnppZ[RmtJABT].as_map(),pRects[RmtJABT]);
            }();
        }
        }();

    PFN_vkCmdClearAttachments call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdClearAttachments)get_instance_proc_addr(parent,"vkCmdClearAttachments");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdClearAttachments)get_device_proc_addr(parent,"vkCmdClearAttachments");
    }  
    
{
call_function(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=json::vector();
            return; }auto arr_fOlilkR=json::vector(attachmentCount);
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAttachments[BsFiayf]);
            arr_fOlilkR[BsFiayf]=temp_map;
            return;
            }();
        }
        json["pAttachments"]=arr_fOlilkR;}();
[&](){json["rectCount"]=static_cast<uint>(rectCount);}();
[&](){
            if (pRects==NULL){
                json["pRects"]=json::vector();
            return; }auto arr_cgJwUFb=json::vector(rectCount);
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRects[HncrKEH]);
            arr_cgJwUFb[HncrKEH]=temp_map;
            return;
            }();
        }
        json["pRects"]=arr_cgJwUFb;}();


        json["stream_type"]=static_cast<int>(VKCMDCLEARATTACHMENTS);
        writeToConn(json);
    }

    void handle_vkCmdResolveImage(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();
 VkImageResolve* pRegions;
[&](){
            if (json["pRegions"].as_vector().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageResolve*)malloc(regionCount*sizeof(VkImageResolve));auto& arr_XxhLAuH=json["pRegions"].as_vector();
        for(int vuJYXjg=0; vuJYXjg < regionCount; vuJYXjg++){
            [&](){
            deserialize_struct(arr_XxhLAuH[vuJYXjg].as_map(),pRegions[vuJYXjg]);
            }();
        }
        }();

    PFN_vkCmdResolveImage call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdResolveImage)get_instance_proc_addr(parent,"vkCmdResolveImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdResolveImage)get_device_proc_addr(parent,"vkCmdResolveImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_OGNZeww=json::vector(regionCount);
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[UbqELUx]);
            arr_OGNZeww[UbqELUx]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_OGNZeww;}();


        json["stream_type"]=static_cast<int>(VKCMDRESOLVEIMAGE);
        writeToConn(json);
    }

    void handle_vkCmdSetEvent(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdSetEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetEvent)get_instance_proc_addr(parent,"vkCmdSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetEvent)get_device_proc_addr(parent,"vkCmdSetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETEVENT);
        writeToConn(json);
    }

    void handle_vkCmdResetEvent(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdResetEvent call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdResetEvent)get_instance_proc_addr(parent,"vkCmdResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdResetEvent)get_device_proc_addr(parent,"vkCmdResetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDRESETEVENT);
        writeToConn(json);
    }

    void handle_vkCmdWaitEvents(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){
            if (json["eventCount"].is_uint64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_uint64_t());
            }else if (json["eventCount"].is_int64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_int64_t());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].as_double());
            }
            }();
 VkEvent* pEvents;
[&](){
            if (json["pEvents"].as_vector().size()==0){
                pEvents=NULL;
            return; }pEvents=(VkEvent*)malloc(eventCount*sizeof(VkEvent));auto& arr_QYtHNne=json["pEvents"].as_vector();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], pEvents[RuhNVwi]);}();
        }
        }();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_uint64_t());
            }else if (json["srcStageMask"].is_int64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_int64_t());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_uint64_t());
            }else if (json["dstStageMask"].is_int64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_int64_t());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
uint32_t memoryBarrierCount;
[&](){
            if (json["memoryBarrierCount"].is_uint64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_uint64_t());
            }else if (json["memoryBarrierCount"].is_int64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_int64_t());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_double());
            }
            }();
 VkMemoryBarrier* pMemoryBarriers;
[&](){
            if (json["pMemoryBarriers"].as_vector().size()==0){
                pMemoryBarriers=NULL;
            return; }pMemoryBarriers=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));auto& arr_jpHrKrx=json["pMemoryBarriers"].as_vector();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            deserialize_struct(arr_jpHrKrx[TyfEutX].as_map(),pMemoryBarriers[TyfEutX]);
            }();
        }
        }();
uint32_t bufferMemoryBarrierCount;
[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_uint64_t());
            }else if (json["bufferMemoryBarrierCount"].is_int64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_int64_t());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_double());
            }
            }();
 VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){
            if (json["pBufferMemoryBarriers"].as_vector().size()==0){
                pBufferMemoryBarriers=NULL;
            return; }pBufferMemoryBarriers=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));auto& arr_gVbYbae=json["pBufferMemoryBarriers"].as_vector();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            deserialize_struct(arr_gVbYbae[ewqDhcn].as_map(),pBufferMemoryBarriers[ewqDhcn]);
            }();
        }
        }();
uint32_t imageMemoryBarrierCount;
[&](){
            if (json["imageMemoryBarrierCount"].is_uint64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_uint64_t());
            }else if (json["imageMemoryBarrierCount"].is_int64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_int64_t());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_double());
            }
            }();
 VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){
            if (json["pImageMemoryBarriers"].as_vector().size()==0){
                pImageMemoryBarriers=NULL;
            return; }pImageMemoryBarriers=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));auto& arr_bBtNYaN=json["pImageMemoryBarriers"].as_vector();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            deserialize_struct(arr_bBtNYaN[ASYxaRK].as_map(),pImageMemoryBarriers[ASYxaRK]);
            }();
        }
        }();

    PFN_vkCmdWaitEvents call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWaitEvents)get_instance_proc_addr(parent,"vkCmdWaitEvents");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWaitEvents)get_device_proc_addr(parent,"vkCmdWaitEvents");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=static_cast<uint>(eventCount);}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=json::vector();
            return; }auto arr_tUuyOPJ=json::vector(eventCount);
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        json["pEvents"]=arr_tUuyOPJ;}();
[&](){[&](){[&](){json["srcStageMask"]=static_cast<int>(srcStageMask);}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=static_cast<int>(dstStageMask);}();}();}();
[&](){json["memoryBarrierCount"]=static_cast<uint>(memoryBarrierCount);}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=json::vector();
            return; }auto arr_fXDYoDs=json::vector(memoryBarrierCount);
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryBarriers[JhnlCAW]);
            arr_fXDYoDs[JhnlCAW]=temp_map;
            return;
            }();
        }
        json["pMemoryBarriers"]=arr_fXDYoDs;}();
[&](){json["bufferMemoryBarrierCount"]=static_cast<uint>(bufferMemoryBarrierCount);}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=json::vector();
            return; }auto arr_FmJTDmX=json::vector(bufferMemoryBarrierCount);
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBufferMemoryBarriers[aFMQios]);
            arr_FmJTDmX[aFMQios]=temp_map;
            return;
            }();
        }
        json["pBufferMemoryBarriers"]=arr_FmJTDmX;}();
[&](){json["imageMemoryBarrierCount"]=static_cast<uint>(imageMemoryBarrierCount);}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=json::vector();
            return; }auto arr_nkkvvYR=json::vector(imageMemoryBarrierCount);
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageMemoryBarriers[trWYSmx]);
            arr_nkkvvYR[trWYSmx]=temp_map;
            return;
            }();
        }
        json["pImageMemoryBarriers"]=arr_nkkvvYR;}();


        json["stream_type"]=static_cast<int>(VKCMDWAITEVENTS);
        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_uint64_t());
            }else if (json["srcStageMask"].is_int64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_int64_t());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_uint64_t());
            }else if (json["dstStageMask"].is_int64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_int64_t());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
VkDependencyFlags dependencyFlags;
[&](){[&](){int temp_MJCELwI;[&](){
            if (json["dependencyFlags"].is_uint64_t()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_uint64_t());
            }else if (json["dependencyFlags"].is_int64_t()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_int64_t());
            }else{
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_double());
            }
            }();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
uint32_t memoryBarrierCount;
[&](){
            if (json["memoryBarrierCount"].is_uint64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_uint64_t());
            }else if (json["memoryBarrierCount"].is_int64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_int64_t());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_double());
            }
            }();
 VkMemoryBarrier* pMemoryBarriers;
[&](){
            if (json["pMemoryBarriers"].as_vector().size()==0){
                pMemoryBarriers=NULL;
            return; }pMemoryBarriers=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));auto& arr_jpHrKrx=json["pMemoryBarriers"].as_vector();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            deserialize_struct(arr_jpHrKrx[TyfEutX].as_map(),pMemoryBarriers[TyfEutX]);
            }();
        }
        }();
uint32_t bufferMemoryBarrierCount;
[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_uint64_t());
            }else if (json["bufferMemoryBarrierCount"].is_int64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_int64_t());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_double());
            }
            }();
 VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){
            if (json["pBufferMemoryBarriers"].as_vector().size()==0){
                pBufferMemoryBarriers=NULL;
            return; }pBufferMemoryBarriers=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));auto& arr_gVbYbae=json["pBufferMemoryBarriers"].as_vector();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            deserialize_struct(arr_gVbYbae[ewqDhcn].as_map(),pBufferMemoryBarriers[ewqDhcn]);
            }();
        }
        }();
uint32_t imageMemoryBarrierCount;
[&](){
            if (json["imageMemoryBarrierCount"].is_uint64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_uint64_t());
            }else if (json["imageMemoryBarrierCount"].is_int64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_int64_t());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_double());
            }
            }();
 VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){
            if (json["pImageMemoryBarriers"].as_vector().size()==0){
                pImageMemoryBarriers=NULL;
            return; }pImageMemoryBarriers=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));auto& arr_bBtNYaN=json["pImageMemoryBarriers"].as_vector();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            deserialize_struct(arr_bBtNYaN[ASYxaRK].as_map(),pImageMemoryBarriers[ASYxaRK]);
            }();
        }
        }();

    PFN_vkCmdPipelineBarrier call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPipelineBarrier)get_instance_proc_addr(parent,"vkCmdPipelineBarrier");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPipelineBarrier)get_device_proc_addr(parent,"vkCmdPipelineBarrier");
    }  
    
{
call_function(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=static_cast<int>(srcStageMask);}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=static_cast<int>(dstStageMask);}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=static_cast<int>(dependencyFlags);}();}();}();
[&](){json["memoryBarrierCount"]=static_cast<uint>(memoryBarrierCount);}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=json::vector();
            return; }auto arr_fXDYoDs=json::vector(memoryBarrierCount);
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryBarriers[JhnlCAW]);
            arr_fXDYoDs[JhnlCAW]=temp_map;
            return;
            }();
        }
        json["pMemoryBarriers"]=arr_fXDYoDs;}();
[&](){json["bufferMemoryBarrierCount"]=static_cast<uint>(bufferMemoryBarrierCount);}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=json::vector();
            return; }auto arr_FmJTDmX=json::vector(bufferMemoryBarrierCount);
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBufferMemoryBarriers[aFMQios]);
            arr_FmJTDmX[aFMQios]=temp_map;
            return;
            }();
        }
        json["pBufferMemoryBarriers"]=arr_FmJTDmX;}();
[&](){json["imageMemoryBarrierCount"]=static_cast<uint>(imageMemoryBarrierCount);}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=json::vector();
            return; }auto arr_nkkvvYR=json::vector(imageMemoryBarrierCount);
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageMemoryBarriers[trWYSmx]);
            arr_nkkvvYR[trWYSmx]=temp_map;
            return;
            }();
        }
        json["pImageMemoryBarriers"]=arr_nkkvvYR;}();


        json["stream_type"]=static_cast<int>(VKCMDPIPELINEBARRIER);
        writeToConn(json);
    }

    void handle_vkCmdBeginQuery(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

    PFN_vkCmdBeginQuery call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginQuery)get_instance_proc_addr(parent,"vkCmdBeginQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginQuery)get_device_proc_addr(parent,"vkCmdBeginQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINQUERY);
        writeToConn(json);
    }

    void handle_vkCmdEndQuery(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

    PFN_vkCmdEndQuery call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndQuery)get_instance_proc_addr(parent,"vkCmdEndQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndQuery)get_device_proc_addr(parent,"vkCmdEndQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();


        json["stream_type"]=static_cast<int>(VKCMDENDQUERY);
        writeToConn(json);
    }

    void handle_vkCmdBeginConditionalRenderingEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
[&](){
            if (json["pConditionalRenderingBegin"].as_vector().size()==0){
                pConditionalRenderingBegin=NULL;
            return; }pConditionalRenderingBegin=(VkConditionalRenderingBeginInfoEXT*)malloc(1*sizeof(VkConditionalRenderingBeginInfoEXT));auto& arr_OXqnNde=json["pConditionalRenderingBegin"].as_vector();
        for(int xncJDyc=0; xncJDyc < 1; xncJDyc++){
            [&](){
            deserialize_struct(arr_OXqnNde[xncJDyc].as_map(),pConditionalRenderingBegin[xncJDyc]);
            }();
        }
        }();

    PFN_vkCmdBeginConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer, pConditionalRenderingBegin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=json::vector();
            return; }auto arr_guEoeuh=json::vector(1);
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pConditionalRenderingBegin[KETgcvj]);
            arr_guEoeuh[KETgcvj]=temp_map;
            return;
            }();
        }
        json["pConditionalRenderingBegin"]=arr_guEoeuh;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINCONDITIONALRENDERINGEXT);
        writeToConn(json);
    }

    void handle_vkCmdEndConditionalRenderingEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDENDCONDITIONALRENDERINGEXT);
        writeToConn(json);
    }

    void handle_vkCmdResetQueryPool(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();

    PFN_vkCmdResetQueryPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdResetQueryPool)get_instance_proc_addr(parent,"vkCmdResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdResetQueryPool)get_device_proc_addr(parent,"vkCmdResetQueryPool");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();


        json["stream_type"]=static_cast<int>(VKCMDRESETQUERYPOOL);
        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_uint64_t());
            }else if (json["pipelineStage"].is_int64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_int64_t());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

    PFN_vkCmdWriteTimestamp call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteTimestamp)get_instance_proc_addr(parent,"vkCmdWriteTimestamp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteTimestamp)get_device_proc_addr(parent,"vkCmdWriteTimestamp");
    }  
    
{
call_function(commandBuffer, pipelineStage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=static_cast<int>(pipelineStage);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITETIMESTAMP);
        writeToConn(json);
    }

    void handle_vkCmdCopyQueryPoolResults(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_int64_t());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkCmdCopyQueryPoolResults call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_instance_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_device_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["stride"]=static_cast<uint>(stride);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYQUERYPOOLRESULTS);
        writeToConn(json);
    }

    void handle_vkCmdPushConstants(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
VkShaderStageFlags stageFlags;
[&](){[&](){int temp_oWGKgUV;[&](){
            if (json["stageFlags"].is_uint64_t()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_uint64_t());
            }else if (json["stageFlags"].is_int64_t()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_int64_t());
            }else{
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_double());
            }
            }();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
uint32_t offset;
[&](){
            if (json["offset"].is_uint64_t()){
                offset=static_cast<uint32_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                offset=static_cast<uint32_t>(json["offset"].as_int64_t());
            }else{
                offset=static_cast<uint32_t>(json["offset"].as_double());
            }
            }();
uint32_t size;
[&](){
            if (json["size"].is_uint64_t()){
                size=static_cast<uint32_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                size=static_cast<uint32_t>(json["size"].as_int64_t());
            }else{
                size=static_cast<uint32_t>(json["size"].as_double());
            }
            }();
 void* pValues;
[&](){
            if (json["pValues"].as_vector().size()==0){
                pValues=NULL;
            return; }char* temp_JvCgRni;[&](){
            if (json["pValues"].as_vector().size()==0){
                temp_JvCgRni=NULL;
            return; }temp_JvCgRni=(char*)malloc(size*sizeof(char));auto& arr_iKKgvyR=json["pValues"].as_vector();
        for(int msCxIJi=0; msCxIJi < size; msCxIJi++){
            [&](){
            if (arr_iKKgvyR[msCxIJi].is_uint64_t()){
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].as_uint64_t());
            }else if (arr_iKKgvyR[msCxIJi].is_int64_t()){
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].as_int64_t());
            }else{
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].as_double());
            }
            }();
        }
        }();pValues=temp_JvCgRni;}();

    PFN_vkCmdPushConstants call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPushConstants)get_instance_proc_addr(parent,"vkCmdPushConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPushConstants)get_device_proc_addr(parent,"vkCmdPushConstants");
    }  
    
{
call_function(commandBuffer, layout, stageFlags, offset, size, pValues);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=static_cast<int>(stageFlags);}();}();}();
[&](){json["offset"]=static_cast<uint>(offset);}();
[&](){json["size"]=static_cast<uint>(size);}();
[&](){
            if (pValues==NULL){
                json["pValues"]=json::vector();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=json::vector();
            return; }auto arr_xbuPmvw=json::vector(size);
        for(int vSvAlWQ=0; vSvAlWQ < size; vSvAlWQ++){
            [&](){arr_xbuPmvw[vSvAlWQ]=static_cast<uint>(((char*)(pValues))[vSvAlWQ]);}();
        }
        json["pValues"]=arr_xbuPmvw;}();}();


        json["stream_type"]=static_cast<int>(VKCMDPUSHCONSTANTS);
        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderPassBeginInfo* pRenderPassBegin;
[&](){
            if (json["pRenderPassBegin"].as_vector().size()==0){
                pRenderPassBegin=NULL;
            return; }pRenderPassBegin=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));auto& arr_DvmhBAI=json["pRenderPassBegin"].as_vector();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            deserialize_struct(arr_DvmhBAI[MzTximI].as_map(),pRenderPassBegin[MzTximI]);
            }();
        }
        }();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_uint64_t());
            }else if (json["contents"].is_int64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_int64_t());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].as_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdBeginRenderPass call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginRenderPass)get_instance_proc_addr(parent,"vkCmdBeginRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginRenderPass)get_device_proc_addr(parent,"vkCmdBeginRenderPass");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=json::vector();
            return; }auto arr_XtnTubd=json::vector(1);
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderPassBegin[lCAvoJt]);
            arr_XtnTubd[lCAvoJt]=temp_map;
            return;
            }();
        }
        json["pRenderPassBegin"]=arr_XtnTubd;}();
[&](){[&](){[&](){json["contents"]=static_cast<int>(contents);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERPASS);
        writeToConn(json);
    }

    void handle_vkCmdNextSubpass(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_uint64_t());
            }else if (json["contents"].is_int64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_int64_t());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].as_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdNextSubpass call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdNextSubpass)get_instance_proc_addr(parent,"vkCmdNextSubpass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdNextSubpass)get_device_proc_addr(parent,"vkCmdNextSubpass");
    }  
    
{
call_function(commandBuffer, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=static_cast<int>(contents);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDNEXTSUBPASS);
        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRenderPass call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndRenderPass)get_instance_proc_addr(parent,"vkCmdEndRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndRenderPass)get_device_proc_addr(parent,"vkCmdEndRenderPass");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDENDRENDERPASS);
        writeToConn(json);
    }

    void handle_vkCmdExecuteCommands(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t commandBufferCount;
[&](){
            if (json["commandBufferCount"].is_uint64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_uint64_t());
            }else if (json["commandBufferCount"].is_int64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_int64_t());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_double());
            }
            }();
 VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].as_vector().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));auto& arr_aIQpbyi=json["pCommandBuffers"].as_vector();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], pCommandBuffers[Neoyndt]);}();
        }
        }();

    PFN_vkCmdExecuteCommands call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdExecuteCommands)get_instance_proc_addr(parent,"vkCmdExecuteCommands");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdExecuteCommands)get_device_proc_addr(parent,"vkCmdExecuteCommands");
    }  
    
{
call_function(commandBuffer, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=static_cast<uint>(commandBufferCount);}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_PdRlpEO=json::vector(commandBufferCount);
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        json["pCommandBuffers"]=arr_PdRlpEO;}();


        json["stream_type"]=static_cast<int>(VKCMDEXECUTECOMMANDS);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPropertiesKHR));auto& arr_jKVTjSh=json["pProperties"].as_vector();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            deserialize_struct(arr_jKVTjSh[ULwTWiE].as_map(),pProperties[ULwTWiE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_jKVTjSh=json::vector(*pPropertyCount);
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[ULwTWiE]);
            arr_jKVTjSh[ULwTWiE]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_jKVTjSh;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayPlanePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlanePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlanePropertiesKHR));auto& arr_TBQSgXa=json["pProperties"].as_vector();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            deserialize_struct(arr_TBQSgXa[yGKhOKS].as_map(),pProperties[yGKhOKS]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_TBQSgXa=json::vector(*pPropertyCount);
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[yGKhOKS]);
            arr_TBQSgXa[yGKhOKS]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_TBQSgXa;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneSupportedDisplaysKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t planeIndex;
[&](){
            if (json["planeIndex"].is_uint64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_uint64_t());
            }else if (json["planeIndex"].is_int64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_int64_t());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_double());
            }
            }();
uint32_t* pDisplayCount;
[&](){
            if (json["pDisplayCount"].as_vector().size()==0){
                pDisplayCount=NULL;
            return; }pDisplayCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_HfQXIoE=json["pDisplayCount"].as_vector();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){
            if (arr_HfQXIoE[tJtenSc].is_uint64_t()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_uint64_t());
            }else if (arr_HfQXIoE[tJtenSc].is_int64_t()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_int64_t());
            }else{
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_double());
            }
            }();
        }
        }();
VkDisplayKHR* pDisplays;
[&](){
            if (json["pDisplays"].as_vector().size()==0){
                pDisplays=NULL;
            return; }pDisplays=(VkDisplayKHR*)malloc(*pDisplayCount*sizeof(VkDisplayKHR));auto& arr_zfKAWAH=json["pDisplays"].as_vector();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();

    PFN_vkGetDisplayPlaneSupportedDisplaysKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=static_cast<uint>(planeIndex);}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=json::vector();
            return; }auto arr_HfQXIoE=json::vector(1);
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=static_cast<uint>(pDisplayCount[tJtenSc]);}();
        }
        json["pDisplayCount"]=arr_HfQXIoE;}();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=json::vector();
            return; }auto arr_zfKAWAH=json::vector(*pDisplayCount);
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        json["pDisplays"]=arr_zfKAWAH;}();


        json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR);
        writeToConn(json);
    }

    void handle_vkGetDisplayModePropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayModePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayModePropertiesKHR));auto& arr_kllbUBl=json["pProperties"].as_vector();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            deserialize_struct(arr_kllbUBl[MCBnXbq].as_map(),pProperties[MCBnXbq]);
            }();
        }
        }();

    PFN_vkGetDisplayModePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_instance_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_device_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_kllbUBl=json::vector(*pPropertyCount);
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[MCBnXbq]);
            arr_kllbUBl[MCBnXbq]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_kllbUBl;}();


        json["stream_type"]=static_cast<int>(VKGETDISPLAYMODEPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkCreateDisplayModeKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayModeCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDisplayModeCreateInfoKHR*)malloc(1*sizeof(VkDisplayModeCreateInfoKHR));auto& arr_UCnUDZD=json["pCreateInfo"].as_vector();
        for(int WMiWEeP=0; WMiWEeP < 1; WMiWEeP++){
            [&](){
            deserialize_struct(arr_UCnUDZD[WMiWEeP].as_map(),pCreateInfo[WMiWEeP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDisplayModeKHR* pMode;
[&](){
            if (json["pMode"].as_vector().size()==0){
                pMode=NULL;
            return; }pMode=(VkDisplayModeKHR*)malloc(1*sizeof(VkDisplayModeKHR));auto& arr_CHqKWyT=json["pMode"].as_vector();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();

    PFN_vkCreateDisplayModeKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDisplayModeKHR)get_instance_proc_addr(parent,"vkCreateDisplayModeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDisplayModeKHR)get_device_proc_addr(parent,"vkCreateDisplayModeKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_mQflhNS=json::vector(1);
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[UOiSdEd]);
            arr_mQflhNS[UOiSdEd]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_mQflhNS;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMode==NULL){
                json["pMode"]=json::vector();
            return; }auto arr_CHqKWyT=json::vector(1);
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        json["pMode"]=arr_CHqKWyT;}();


        json["stream_type"]=static_cast<int>(VKCREATEDISPLAYMODEKHR);
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilitiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayModeKHR mode;
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
uint32_t planeIndex;
[&](){
            if (json["planeIndex"].is_uint64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_uint64_t());
            }else if (json["planeIndex"].is_int64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_int64_t());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_double());
            }
            }();
VkDisplayPlaneCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilitiesKHR*)malloc(1*sizeof(VkDisplayPlaneCapabilitiesKHR));auto& arr_HrzVMCr=json["pCapabilities"].as_vector();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            deserialize_struct(arr_HrzVMCr[aOxwnlc].as_map(),pCapabilities[aOxwnlc]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, mode, planeIndex, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=static_cast<uint>(planeIndex);}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_HrzVMCr=json::vector(1);
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[aOxwnlc]);
            arr_HrzVMCr[aOxwnlc]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_HrzVMCr;}();


        json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANECAPABILITIESKHR);
        writeToConn(json);
    }

    void handle_vkCreateDisplayPlaneSurfaceKHR(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDisplaySurfaceCreateInfoKHR*)malloc(1*sizeof(VkDisplaySurfaceCreateInfoKHR));auto& arr_KiZtqkd=json["pCreateInfo"].as_vector();
        for(int MxInMZf=0; MxInMZf < 1; MxInMZf++){
            [&](){
            deserialize_struct(arr_KiZtqkd[MxInMZf].as_map(),pCreateInfo[MxInMZf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateDisplayPlaneSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_instance_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_device_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_pnrRUFC=json::vector(1);
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[KAVLDOd]);
            arr_pnrRUFC[KAVLDOd]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_pnrRUFC;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();


        json["stream_type"]=static_cast<int>(VKCREATEDISPLAYPLANESURFACEKHR);
        writeToConn(json);
    }

    void handle_vkCreateSharedSwapchainsKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){
            if (json["swapchainCount"].is_uint64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_uint64_t());
            }else if (json["swapchainCount"].is_int64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_int64_t());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_double());
            }
            }();
 VkSwapchainCreateInfoKHR* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkSwapchainCreateInfoKHR*)malloc(swapchainCount*sizeof(VkSwapchainCreateInfoKHR));auto& arr_bfxCAiC=json["pCreateInfos"].as_vector();
        for(int hPtbvYT=0; hPtbvYT < swapchainCount; hPtbvYT++){
            [&](){
            deserialize_struct(arr_bfxCAiC[hPtbvYT].as_map(),pCreateInfos[hPtbvYT]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSwapchainKHR* pSwapchains;
[&](){
            if (json["pSwapchains"].as_vector().size()==0){
                pSwapchains=NULL;
            return; }pSwapchains=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));auto& arr_UlEaWkU=json["pSwapchains"].as_vector();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();

    PFN_vkCreateSharedSwapchainsKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_instance_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_device_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=static_cast<uint>(swapchainCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_GXhEUBn=json::vector(swapchainCount);
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[KSXdUUO]);
            arr_GXhEUBn[KSXdUUO]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_GXhEUBn;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=json::vector();
            return; }auto arr_UlEaWkU=json::vector(swapchainCount);
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        json["pSwapchains"]=arr_UlEaWkU;}();


        json["stream_type"]=static_cast<int>(VKCREATESHAREDSWAPCHAINSKHR);
        writeToConn(json);
    }

    void handle_vkDestroySurfaceKHR(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroySurfaceKHR)get_instance_proc_addr(parent,"vkDestroySurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroySurfaceKHR)get_device_proc_addr(parent,"vkDestroySurfaceKHR");
    }  
    
{
call_function(instance, surface, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSURFACEKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceSupportKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkBool32* pSupported;
[&](){
            if (json["pSupported"].as_vector().size()==0){
                pSupported=NULL;
            return; }pSupported=(VkBool32*)malloc(1*sizeof(VkBool32));auto& arr_SEnYPHg=json["pSupported"].as_vector();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){
            if (arr_SEnYPHg[rAhuVoM].is_uint64_t()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_uint64_t());
            }else if (arr_SEnYPHg[rAhuVoM].is_int64_t()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_int64_t());
            }else{
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_double());
            }
            }();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceSupportKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, queueFamilyIndex, surface, pSupported);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=json::vector();
            return; }auto arr_SEnYPHg=json::vector(1);
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=static_cast<uint>(pSupported[rAhuVoM]);}();}();
        }
        json["pSupported"]=arr_SEnYPHg;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACESUPPORTKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilitiesKHR*)malloc(1*sizeof(VkSurfaceCapabilitiesKHR));auto& arr_mjTYhnS=json["pSurfaceCapabilities"].as_vector();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            deserialize_struct(arr_mjTYhnS[MvYVwuP].as_map(),pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_mjTYhnS=json::vector(1);
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[MvYVwuP]);
            arr_mjTYhnS[MvYVwuP]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_mjTYhnS;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIESKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormatsKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].as_vector().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_vector();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_uint64_t());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_int64_t());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_double());
            }
            }();
        }
        }();
VkSurfaceFormatKHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].as_vector().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormatKHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormatKHR));auto& arr_FttXsVA=json["pSurfaceFormats"].as_vector();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            deserialize_struct(arr_FttXsVA[sioXabq].as_map(),pSurfaceFormats[sioXabq]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=json::vector();
            return; }auto arr_mbQwRYl=json::vector(1);
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=static_cast<uint>(pSurfaceFormatCount[bFtFQKD]);}();
        }
        json["pSurfaceFormatCount"]=arr_mbQwRYl;}();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=json::vector();
            return; }auto arr_FttXsVA=json::vector(*pSurfaceFormatCount);
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceFormats[sioXabq]);
            arr_FttXsVA[sioXabq]=temp_map;
            return;
            }();
        }
        json["pSurfaceFormats"]=arr_FttXsVA;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEFORMATSKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfacePresentModesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pPresentModeCount;
[&](){
            if (json["pPresentModeCount"].as_vector().size()==0){
                pPresentModeCount=NULL;
            return; }pPresentModeCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_jrQQyxv=json["pPresentModeCount"].as_vector();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){
            if (arr_jrQQyxv[yThsxfd].is_uint64_t()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_uint64_t());
            }else if (arr_jrQQyxv[yThsxfd].is_int64_t()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_int64_t());
            }else{
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_double());
            }
            }();
        }
        }();
VkPresentModeKHR* pPresentModes;
[&](){
            if (json["pPresentModes"].as_vector().size()==0){
                pPresentModes=NULL;
            return; }pPresentModes=(VkPresentModeKHR*)malloc(*pPresentModeCount*sizeof(VkPresentModeKHR));auto& arr_hrNyEFX=json["pPresentModes"].as_vector();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){
            if (arr_hrNyEFX[ULOmMaK].is_uint64_t()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_uint64_t());
            }else if (arr_hrNyEFX[ULOmMaK].is_int64_t()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_int64_t());
            }else{
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_double());
            }
            }();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=json::vector();
            return; }auto arr_jrQQyxv=json::vector(1);
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=static_cast<uint>(pPresentModeCount[yThsxfd]);}();
        }
        json["pPresentModeCount"]=arr_jrQQyxv;}();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=json::vector();
            return; }auto arr_hrNyEFX=json::vector(*pPresentModeCount);
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=static_cast<int>(pPresentModes[ULOmMaK]);}();}();}();
        }
        json["pPresentModes"]=arr_hrNyEFX;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR);
        writeToConn(json);
    }

    void handle_vkCreateSwapchainKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSwapchainCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSwapchainCreateInfoKHR*)malloc(1*sizeof(VkSwapchainCreateInfoKHR));auto& arr_ioKDSXs=json["pCreateInfo"].as_vector();
        for(int ugpCvwH=0; ugpCvwH < 1; ugpCvwH++){
            [&](){
            deserialize_struct(arr_ioKDSXs[ugpCvwH].as_map(),pCreateInfo[ugpCvwH]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSwapchainKHR* pSwapchain;
[&](){
            if (json["pSwapchain"].as_vector().size()==0){
                pSwapchain=NULL;
            return; }pSwapchain=(VkSwapchainKHR*)malloc(1*sizeof(VkSwapchainKHR));auto& arr_vaTnpgr=json["pSwapchain"].as_vector();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();

    PFN_vkCreateSwapchainKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateSwapchainKHR)get_instance_proc_addr(parent,"vkCreateSwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateSwapchainKHR)get_device_proc_addr(parent,"vkCreateSwapchainKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSwapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_egkAfIq=json::vector(1);
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[RzLCOHt]);
            arr_egkAfIq[RzLCOHt]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_egkAfIq;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=json::vector();
            return; }auto arr_vaTnpgr=json::vector(1);
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        json["pSwapchain"]=arr_vaTnpgr;}();

        auto& imageExtent1=json["pCreateInfo"].as_vector()[0].as_map().at("imageExtent").as_map();
        debug_printf("Swapchain extent: %d, %d\n", imageExtent1.at("width").as_uint64_t(), imageExtent1.at("height").as_uint64_t());
        


        json["stream_type"]=static_cast<int>(VKCREATESWAPCHAINKHR);
        writeToConn(json);
    }

    void handle_vkDestroySwapchainKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySwapchainKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroySwapchainKHR)get_instance_proc_addr(parent,"vkDestroySwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroySwapchainKHR)get_device_proc_addr(parent,"vkDestroySwapchainKHR");
    }  
    
{
call_function(device, swapchain, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSWAPCHAINKHR);
        writeToConn(json);
    }

    void handle_vkGetSwapchainImagesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pSwapchainImageCount;
[&](){
            if (json["pSwapchainImageCount"].as_vector().size()==0){
                pSwapchainImageCount=NULL;
            return; }pSwapchainImageCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_fUdbkNA=json["pSwapchainImageCount"].as_vector();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){
            if (arr_fUdbkNA[YVmxCel].is_uint64_t()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_uint64_t());
            }else if (arr_fUdbkNA[YVmxCel].is_int64_t()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_int64_t());
            }else{
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_double());
            }
            }();
        }
        }();
VkImage* pSwapchainImages;
[&](){
            if (json["pSwapchainImages"].as_vector().size()==0){
                pSwapchainImages=NULL;
            return; }pSwapchainImages=(VkImage*)malloc(*pSwapchainImageCount*sizeof(VkImage));auto& arr_KNYDiQo=json["pSwapchainImages"].as_vector();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();

    PFN_vkGetSwapchainImagesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSwapchainImagesKHR)get_instance_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSwapchainImagesKHR)get_device_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=json::vector();
            return; }auto arr_fUdbkNA=json::vector(1);
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=static_cast<uint>(pSwapchainImageCount[YVmxCel]);}();
        }
        json["pSwapchainImageCount"]=arr_fUdbkNA;}();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=json::vector();
            return; }auto arr_KNYDiQo=json::vector(*pSwapchainImageCount);
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        json["pSwapchainImages"]=arr_KNYDiQo;}();


        json["stream_type"]=static_cast<int>(VKGETSWAPCHAINIMAGESKHR);
        writeToConn(json);
    }

    void handle_vkAcquireNextImageKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].as_vector().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_oSqpNfH=json["pImageIndex"].as_vector();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_uint64_t());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_int64_t());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_double());
            }
            }();
        }
        }();

    PFN_vkAcquireNextImageKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAcquireNextImageKHR)get_instance_proc_addr(parent,"vkAcquireNextImageKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAcquireNextImageKHR)get_device_proc_addr(parent,"vkAcquireNextImageKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=json::vector();
            return; }auto arr_oSqpNfH=json::vector(1);
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=static_cast<uint>(pImageIndex[BEjuBtR]);}();
        }
        json["pImageIndex"]=arr_oSqpNfH;}();


        json["stream_type"]=static_cast<int>(VKACQUIRENEXTIMAGEKHR);
        writeToConn(json);
    }

    void handle_vkQueuePresentKHR(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkPresentInfoKHR* pPresentInfo;
[&](){
            if (json["pPresentInfo"].as_vector().size()==0){
                pPresentInfo=NULL;
            return; }pPresentInfo=(VkPresentInfoKHR*)malloc(1*sizeof(VkPresentInfoKHR));auto& arr_lGNUHER=json["pPresentInfo"].as_vector();
        for(int gefTrKz=0; gefTrKz < 1; gefTrKz++){
            [&](){
            deserialize_struct(arr_lGNUHER[gefTrKz].as_map(),pPresentInfo[gefTrKz]);
            }();
        }
        }();

    PFN_vkQueuePresentKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueuePresentKHR)get_instance_proc_addr(parent,"vkQueuePresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueuePresentKHR)get_device_proc_addr(parent,"vkQueuePresentKHR");
    }  
    
VkResult  result;
{
result=call_function(queue, pPresentInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=json::vector();
            return; }auto arr_EyhZHrS=json::vector(1);
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPresentInfo[EKHdNlu]);
            arr_EyhZHrS[EKHdNlu]=temp_map;
            return;
            }();
        }
        json["pPresentInfo"]=arr_EyhZHrS;}();


        json["stream_type"]=static_cast<int>(VKQUEUEPRESENTKHR);
        writeToConn(json);
    }

    void handle_vkCreateXlibSurfaceKHR(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkXlibSurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkXlibSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXlibSurfaceCreateInfoKHR));auto& arr_wdGSkCh=json["pCreateInfo"].as_vector();
        for(int iNgqKFe=0; iNgqKFe < 1; iNgqKFe++){
            [&](){
            deserialize_struct(arr_wdGSkCh[iNgqKFe].as_map(),pCreateInfo[iNgqKFe]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXlibSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_device_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_xAdBgFR=json::vector(1);
        for(int sMWpcdX=0; sMWpcdX < 1; sMWpcdX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[sMWpcdX]);
            arr_xAdBgFR[sMWpcdX]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_xAdBgFR;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();


        json["stream_type"]=static_cast<int>(VKCREATEXLIBSURFACEKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXlibPresentationSupportKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
Display* dpy;
[&](){
            if (json["dpy"].as_vector().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(json["dpy"].as_uint64_t());}();
VisualID visualID;
[&](){visualID=(VisualID )(json["visualID"].as_uint64_t());}();

    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }  
    
VkBool32  result;
{
result=call_function(physicalDevice, queueFamilyIndex, dpy, visualID);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (dpy==NULL){
                json["dpy"]=json::vector();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR);
        writeToConn(json);
    }

    void handle_vkCreateXcbSurfaceKHR(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkXcbSurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkXcbSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXcbSurfaceCreateInfoKHR));auto& arr_fIYRZSR=json["pCreateInfo"].as_vector();
        for(int QDYAgHl=0; QDYAgHl < 1; QDYAgHl++){
            [&](){
            deserialize_struct(arr_fIYRZSR[QDYAgHl].as_map(),pCreateInfo[QDYAgHl]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXcbSurfaceKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_device_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_yvWYCbg=json::vector(1);
        for(int DeNvCZU=0; DeNvCZU < 1; DeNvCZU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[DeNvCZU]);
            arr_yvWYCbg[DeNvCZU]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_yvWYCbg;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();


        json["stream_type"]=static_cast<int>(VKCREATEXCBSURFACEKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXcbPresentationSupportKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
xcb_connection_t* connection;
[&](){
            if (json["connection"].as_vector().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(json["connection"].as_uint64_t());}();
xcb_visualid_t visual_id;
[&](){visual_id=(xcb_visualid_t )(json["visual_id"].as_uint64_t());}();

    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }  
    
VkBool32  result;
{
result=call_function(physicalDevice, queueFamilyIndex, connection, visual_id);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (connection==NULL){
                json["connection"]=json::vector();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR);
        writeToConn(json);
    }

    void handle_vkCreateDebugReportCallbackEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDebugReportCallbackCreateInfoEXT*)malloc(1*sizeof(VkDebugReportCallbackCreateInfoEXT));auto& arr_bvXzZVI=json["pCreateInfo"].as_vector();
        for(int wOLpuxo=0; wOLpuxo < 1; wOLpuxo++){
            [&](){
            deserialize_struct(arr_bvXzZVI[wOLpuxo].as_map(),pCreateInfo[wOLpuxo]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDebugReportCallbackEXT* pCallback;
[&](){
            if (json["pCallback"].as_vector().size()==0){
                pCallback=NULL;
            return; }pCallback=(VkDebugReportCallbackEXT*)malloc(1*sizeof(VkDebugReportCallbackEXT));auto& arr_qwLilWz=json["pCallback"].as_vector();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();

    PFN_vkCreateDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_device_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pCallback);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_YvgjHhM=json::vector(1);
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[BsRBklZ]);
            arr_YvgjHhM[BsRBklZ]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_YvgjHhM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=json::vector();
            return; }auto arr_qwLilWz=json::vector(1);
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        json["pCallback"]=arr_qwLilWz;}();


        json["stream_type"]=static_cast<int>(VKCREATEDEBUGREPORTCALLBACKEXT);
        writeToConn(json);
    }

    void handle_vkDestroyDebugReportCallbackEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportCallbackEXT callback;
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_device_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }  
    
{
call_function(instance, callback, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDEBUGREPORTCALLBACKEXT);
        writeToConn(json);
    }

    void handle_vkDebugReportMessageEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportFlagsEXT flags;
[&](){[&](){int temp_tiROuYA;[&](){
            if (json["flags"].is_uint64_t()){
                temp_tiROuYA=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_tiROuYA=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_tiROuYA=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
VkDebugReportObjectTypeEXT objectType;
[&](){[&](){int temp_rGtGMFh;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
uint64_t object;
[&](){
            if (json["object"].is_uint64_t()){
                object=static_cast<uint64_t>(json["object"].as_uint64_t());
            }else if (json["object"].is_int64_t()){
                object=static_cast<uint64_t>(json["object"].as_int64_t());
            }else{
                object=static_cast<uint64_t>(json["object"].as_double());
            }
            }();
size_t location;
[&](){
            if (json["location"].is_uint64_t()){
                location=static_cast<size_t>(json["location"].as_uint64_t());
            }else if (json["location"].is_int64_t()){
                location=static_cast<size_t>(json["location"].as_int64_t());
            }else{
                location=static_cast<size_t>(json["location"].as_double());
            }
            }();
int32_t messageCode;
[&](){
            if (json["messageCode"].is_uint64_t()){
                messageCode=static_cast<int32_t>(json["messageCode"].as_uint64_t());
            }else if (json["messageCode"].is_int64_t()){
                messageCode=static_cast<int32_t>(json["messageCode"].as_int64_t());
            }else{
                messageCode=static_cast<int32_t>(json["messageCode"].as_double());
            }
            }();
 char* pLayerPrefix;
[&](){
            if (json["pLayerPrefix"].as_vector().size()==0){
                pLayerPrefix=NULL;
            return; }pLayerPrefix=(char*)malloc(json["pLayerPrefix"].as_vector().size()*sizeof(char));auto& arr_uXlnNyO=json["pLayerPrefix"].as_vector();
        for(int tgIwrYh=0; tgIwrYh < json["pLayerPrefix"].as_vector().size(); tgIwrYh++){
            [&](){
            if (arr_uXlnNyO[tgIwrYh].is_uint64_t()){
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].as_uint64_t());
            }else if (arr_uXlnNyO[tgIwrYh].is_int64_t()){
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].as_int64_t());
            }else{
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].as_double());
            }
            }();
        }
        }();
 char* pMessage;
[&](){
            if (json["pMessage"].as_vector().size()==0){
                pMessage=NULL;
            return; }pMessage=(char*)malloc(json["pMessage"].as_vector().size()*sizeof(char));auto& arr_hjvjHsV=json["pMessage"].as_vector();
        for(int WEDXGTi=0; WEDXGTi < json["pMessage"].as_vector().size(); WEDXGTi++){
            [&](){
            if (arr_hjvjHsV[WEDXGTi].is_uint64_t()){
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].as_uint64_t());
            }else if (arr_hjvjHsV[WEDXGTi].is_int64_t()){
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].as_int64_t());
            }else{
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].as_double());
            }
            }();
        }
        }();

    PFN_vkDebugReportMessageEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDebugReportMessageEXT)get_instance_proc_addr(parent,"vkDebugReportMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDebugReportMessageEXT)get_device_proc_addr(parent,"vkDebugReportMessageEXT");
    }  
    
{
call_function(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["object"]=static_cast<uint>(object);}();
[&](){json["location"]=static_cast<int>(location);}();
[&](){json["messageCode"]=static_cast<int>(messageCode);}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=json::vector();
            return; }auto arr_SZVAgkt=json::vector(strlen(pLayerPrefix)+1);
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=static_cast<uint>(pLayerPrefix[ESuRCqF]);}();
        }
        json["pLayerPrefix"]=arr_SZVAgkt;}();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=json::vector();
            return; }auto arr_rGBBIki=json::vector(strlen(pMessage)+1);
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=static_cast<uint>(pMessage[ZYKcZZQ]);}();
        }
        json["pMessage"]=arr_rGBBIki;}();


        json["stream_type"]=static_cast<int>(VKDEBUGREPORTMESSAGEEXT);
        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectNameEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugMarkerObjectNameInfoEXT* pNameInfo;
[&](){
            if (json["pNameInfo"].as_vector().size()==0){
                pNameInfo=NULL;
            return; }pNameInfo=(VkDebugMarkerObjectNameInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectNameInfoEXT));auto& arr_VqYlRlZ=json["pNameInfo"].as_vector();
        for(int rPEeNJT=0; rPEeNJT < 1; rPEeNJT++){
            [&](){
            deserialize_struct(arr_VqYlRlZ[rPEeNJT].as_map(),pNameInfo[rPEeNJT]);
            }();
        }
        }();

    PFN_vkDebugMarkerSetObjectNameEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=json::vector();
            return; }auto arr_WQmILKl=json::vector(1);
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pNameInfo[VlhHang]);
            arr_WQmILKl[VlhHang]=temp_map;
            return;
            }();
        }
        json["pNameInfo"]=arr_WQmILKl;}();


        json["stream_type"]=static_cast<int>(VKDEBUGMARKERSETOBJECTNAMEEXT);
        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectTagEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugMarkerObjectTagInfoEXT* pTagInfo;
[&](){
            if (json["pTagInfo"].as_vector().size()==0){
                pTagInfo=NULL;
            return; }pTagInfo=(VkDebugMarkerObjectTagInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectTagInfoEXT));auto& arr_RbbYJqv=json["pTagInfo"].as_vector();
        for(int RnIbuuZ=0; RnIbuuZ < 1; RnIbuuZ++){
            [&](){
            deserialize_struct(arr_RbbYJqv[RnIbuuZ].as_map(),pTagInfo[RnIbuuZ]);
            }();
        }
        }();

    PFN_vkDebugMarkerSetObjectTagEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=json::vector();
            return; }auto arr_uESKIxS=json::vector(1);
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTagInfo[fibGciH]);
            arr_uESKIxS[fibGciH]=temp_map;
            return;
            }();
        }
        json["pTagInfo"]=arr_uESKIxS;}();


        json["stream_type"]=static_cast<int>(VKDEBUGMARKERSETOBJECTTAGEXT);
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerBeginEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].as_vector().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));auto& arr_dufSdWh=json["pMarkerInfo"].as_vector();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            deserialize_struct(arr_dufSdWh[wWwHKWF].as_map(),pMarkerInfo[wWwHKWF]);
            }();
        }
        }();

    PFN_vkCmdDebugMarkerBeginEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_sUKpmoY=json::vector(1);
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[MSMqdqs]);
            arr_sUKpmoY[MSMqdqs]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_sUKpmoY;}();


        json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERBEGINEXT);
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerEndEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdDebugMarkerEndEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERENDEXT);
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerInsertEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].as_vector().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));auto& arr_dufSdWh=json["pMarkerInfo"].as_vector();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            deserialize_struct(arr_dufSdWh[wWwHKWF].as_map(),pMarkerInfo[wWwHKWF]);
            }();
        }
        }();

    PFN_vkCmdDebugMarkerInsertEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_sUKpmoY=json::vector(1);
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[MSMqdqs]);
            arr_sUKpmoY[MSMqdqs]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_sUKpmoY;}();


        json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERINSERTEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkExternalMemoryHandleTypeFlagsNV externalHandleType;
[&](){[&](){int temp_DSfbDyM;[&](){
            if (json["externalHandleType"].is_uint64_t()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_uint64_t());
            }else if (json["externalHandleType"].is_int64_t()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_int64_t());
            }else{
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_double());
            }
            }();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
[&](){
            if (json["pExternalImageFormatProperties"].as_vector().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }pExternalImageFormatProperties=(VkExternalImageFormatPropertiesNV*)malloc(1*sizeof(VkExternalImageFormatPropertiesNV));auto& arr_gXHGwln=json["pExternalImageFormatProperties"].as_vector();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            deserialize_struct(arr_gXHGwln[CfNLqMF].as_map(),pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=static_cast<int>(externalHandleType);}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=json::vector();
            return; }auto arr_gXHGwln=json::vector(1);
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalImageFormatProperties[CfNLqMF]);
            arr_gXHGwln[CfNLqMF]=temp_map;
            return;
            }();
        }
        json["pExternalImageFormatProperties"]=arr_gXHGwln;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV);
        writeToConn(json);
    }

    void handle_vkCmdExecuteGeneratedCommandsNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 isPreprocessed;
[&](){uint32_t temp_tPMaOPc;[&](){
            if (json["isPreprocessed"].is_uint64_t()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_uint64_t());
            }else if (json["isPreprocessed"].is_int64_t()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_int64_t());
            }else{
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_double());
            }
            }();isPreprocessed=(VkBool32)temp_tPMaOPc;}();
 VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){
            if (json["pGeneratedCommandsInfo"].as_vector().size()==0){
                pGeneratedCommandsInfo=NULL;
            return; }pGeneratedCommandsInfo=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].as_vector();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            deserialize_struct(arr_HWCDzqJ[ZktpRSr].as_map(),pGeneratedCommandsInfo[ZktpRSr]);
            }();
        }
        }();

    PFN_vkCmdExecuteGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=static_cast<uint>(isPreprocessed);}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=json::vector();
            return; }auto arr_mvZtJqS=json::vector(1);
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGeneratedCommandsInfo[breVZQP]);
            arr_mvZtJqS[breVZQP]=temp_map;
            return;
            }();
        }
        json["pGeneratedCommandsInfo"]=arr_mvZtJqS;}();


        json["stream_type"]=static_cast<int>(VKCMDEXECUTEGENERATEDCOMMANDSNV);
        writeToConn(json);
    }

    void handle_vkCmdPreprocessGeneratedCommandsNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){
            if (json["pGeneratedCommandsInfo"].as_vector().size()==0){
                pGeneratedCommandsInfo=NULL;
            return; }pGeneratedCommandsInfo=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].as_vector();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            deserialize_struct(arr_HWCDzqJ[ZktpRSr].as_map(),pGeneratedCommandsInfo[ZktpRSr]);
            }();
        }
        }();

    PFN_vkCmdPreprocessGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=json::vector();
            return; }auto arr_mvZtJqS=json::vector(1);
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGeneratedCommandsInfo[breVZQP]);
            arr_mvZtJqS[breVZQP]=temp_map;
            return;
            }();
        }
        json["pGeneratedCommandsInfo"]=arr_mvZtJqS;}();


        json["stream_type"]=static_cast<int>(VKCMDPREPROCESSGENERATEDCOMMANDSNV);
        writeToConn(json);
    }

    void handle_vkCmdBindPipelineShaderGroupNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t groupIndex;
[&](){
            if (json["groupIndex"].is_uint64_t()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_uint64_t());
            }else if (json["groupIndex"].is_int64_t()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_int64_t());
            }else{
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_double());
            }
            }();

    PFN_vkCmdBindPipelineShaderGroupNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_instance_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_device_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=static_cast<uint>(groupIndex);}();


        json["stream_type"]=static_cast<int>(VKCMDBINDPIPELINESHADERGROUPNV);
        writeToConn(json);
    }

    void handle_vkGetGeneratedCommandsMemoryRequirementsNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkGeneratedCommandsMemoryRequirementsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV));auto& arr_KgvktJY=json["pInfo"].as_vector();
        for(int JNwrpFH=0; JNwrpFH < 1; JNwrpFH++){
            [&](){
            deserialize_struct(arr_KgvktJY[JNwrpFH].as_map(),pInfo[JNwrpFH]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetGeneratedCommandsMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_bVjZkmU=json::vector(1);
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[suoLDtj]);
            arr_bVjZkmU[suoLDtj]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_bVjZkmU;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV);
        writeToConn(json);
    }

    void handle_vkCreateIndirectCommandsLayoutNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkIndirectCommandsLayoutCreateInfoNV*)malloc(1*sizeof(VkIndirectCommandsLayoutCreateInfoNV));auto& arr_moJlSYv=json["pCreateInfo"].as_vector();
        for(int GBtaMlf=0; GBtaMlf < 1; GBtaMlf++){
            [&](){
            deserialize_struct(arr_moJlSYv[GBtaMlf].as_map(),pCreateInfo[GBtaMlf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkIndirectCommandsLayoutNV* pIndirectCommandsLayout;
[&](){
            if (json["pIndirectCommandsLayout"].as_vector().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }pIndirectCommandsLayout=(VkIndirectCommandsLayoutNV*)malloc(1*sizeof(VkIndirectCommandsLayoutNV));auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].as_vector();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();

    PFN_vkCreateIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_EQPGiEt=json::vector(1);
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TPVCKbG]);
            arr_EQPGiEt[TPVCKbG]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_EQPGiEt;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=json::vector();
            return; }auto arr_lGdEoyU=json::vector(1);
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        json["pIndirectCommandsLayout"]=arr_lGdEoyU;}();


        json["stream_type"]=static_cast<int>(VKCREATEINDIRECTCOMMANDSLAYOUTNV);
        writeToConn(json);
    }

    void handle_vkDestroyIndirectCommandsLayoutNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkIndirectCommandsLayoutNV indirectCommandsLayout;
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }  
    
{
call_function(device, indirectCommandsLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYINDIRECTCOMMANDSLAYOUTNV);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures2* pFeatures;
[&](){
            if (json["pFeatures"].as_vector().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures2*)malloc(1*sizeof(VkPhysicalDeviceFeatures2));auto& arr_QUwriqy=json["pFeatures"].as_vector();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            deserialize_struct(arr_QUwriqy[AlewVZE].as_map(),pFeatures[AlewVZE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=json::vector();
            return; }auto arr_QUwriqy=json::vector(1);
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFeatures[AlewVZE]);
            arr_QUwriqy[AlewVZE]=temp_map;
            return;
            }();
        }
        json["pFeatures"]=arr_QUwriqy;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFEATURES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties2* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties2*)malloc(1*sizeof(VkPhysicalDeviceProperties2));auto& arr_oZVBLox=json["pProperties"].as_vector();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            deserialize_struct(arr_oZVBLox[pxUpVYV].as_map(),pProperties[pxUpVYV]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oZVBLox=json::vector(1);
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[pxUpVYV]);
            arr_oZVBLox[pxUpVYV]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oZVBLox;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties2* pFormatProperties;
[&](){
            if (json["pFormatProperties"].as_vector().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties2*)malloc(1*sizeof(VkFormatProperties2));auto& arr_RNYTnLU=json["pFormatProperties"].as_vector();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            deserialize_struct(arr_RNYTnLU[VZFdkqX].as_map(),pFormatProperties[VZFdkqX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=json::vector();
            return; }auto arr_RNYTnLU=json::vector(1);
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatProperties[VZFdkqX]);
            arr_RNYTnLU[VZFdkqX]=temp_map;
            return;
            }();
        }
        json["pFormatProperties"]=arr_RNYTnLU;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFORMATPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
[&](){
            if (json["pImageFormatInfo"].as_vector().size()==0){
                pImageFormatInfo=NULL;
            return; }pImageFormatInfo=(VkPhysicalDeviceImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceImageFormatInfo2));auto& arr_DmAdZhK=json["pImageFormatInfo"].as_vector();
        for(int ZeNdrVN=0; ZeNdrVN < 1; ZeNdrVN++){
            [&](){
            deserialize_struct(arr_DmAdZhK[ZeNdrVN].as_map(),pImageFormatInfo[ZeNdrVN]);
            }();
        }
        }();
VkImageFormatProperties2* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties2*)malloc(1*sizeof(VkImageFormatProperties2));auto& arr_wmAZzRc=json["pImageFormatProperties"].as_vector();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            deserialize_struct(arr_wmAZzRc[NQfBHSv].as_map(),pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=json::vector();
            return; }auto arr_MpVGyYe=json::vector(1);
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatInfo[YAeYFEt]);
            arr_MpVGyYe[YAeYFEt]=temp_map;
            return;
            }();
        }
        json["pImageFormatInfo"]=arr_MpVGyYe;}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_wmAZzRc=json::vector(1);
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[NQfBHSv]);
            arr_wmAZzRc[NQfBHSv]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_wmAZzRc;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].as_vector().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_vector();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_uint64_t());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_int64_t());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_double());
            }
            }();
        }
        }();
VkQueueFamilyProperties2* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].as_vector().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties2*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties2));auto& arr_NqmNsHw=json["pQueueFamilyProperties"].as_vector();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            deserialize_struct(arr_NqmNsHw[UxEWlik].as_map(),pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=json::vector();
            return; }auto arr_tzRlmPf=json::vector(1);
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=static_cast<uint>(pQueueFamilyPropertyCount[cPKCUxv]);}();
        }
        json["pQueueFamilyPropertyCount"]=arr_tzRlmPf;}();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=json::vector();
            return; }auto arr_NqmNsHw=json::vector(*pQueueFamilyPropertyCount);
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueFamilyProperties[UxEWlik]);
            arr_NqmNsHw[UxEWlik]=temp_map;
            return;
            }();
        }
        json["pQueueFamilyProperties"]=arr_NqmNsHw;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].as_vector().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties2*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties2));auto& arr_nJXNYGt=json["pMemoryProperties"].as_vector();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            deserialize_struct(arr_nJXNYGt[tFDFCkf].as_map(),pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=json::vector();
            return; }auto arr_nJXNYGt=json::vector(1);
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryProperties[tFDFCkf]);
            arr_nJXNYGt[tFDFCkf]=temp_map;
            return;
            }();
        }
        json["pMemoryProperties"]=arr_nJXNYGt;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMEMORYPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties2(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
[&](){
            if (json["pFormatInfo"].as_vector().size()==0){
                pFormatInfo=NULL;
            return; }pFormatInfo=(VkPhysicalDeviceSparseImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceSparseImageFormatInfo2));auto& arr_NQMYVvv=json["pFormatInfo"].as_vector();
        for(int SsKlkUy=0; SsKlkUy < 1; SsKlkUy++){
            [&](){
            deserialize_struct(arr_NQMYVvv[SsKlkUy].as_map(),pFormatInfo[SsKlkUy]);
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkSparseImageFormatProperties2* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties2*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties2));auto& arr_YaLkATe=json["pProperties"].as_vector();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            deserialize_struct(arr_YaLkATe[lIrIGCv].as_map(),pProperties[lIrIGCv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }  
    
{
call_function(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=json::vector();
            return; }auto arr_nZOUWlt=json::vector(1);
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatInfo[cvknnOe]);
            arr_nZOUWlt[cvknnOe]=temp_map;
            return;
            }();
        }
        json["pFormatInfo"]=arr_nZOUWlt;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_YaLkATe=json::vector(*pPropertyCount);
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[lIrIGCv]);
            arr_YaLkATe[lIrIGCv]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_YaLkATe;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2);
        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();
uint32_t descriptorWriteCount;
[&](){
            if (json["descriptorWriteCount"].is_uint64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_uint64_t());
            }else if (json["descriptorWriteCount"].is_int64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_int64_t());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_double());
            }
            }();
 VkWriteDescriptorSet* pDescriptorWrites;
[&](){
            if (json["pDescriptorWrites"].as_vector().size()==0){
                pDescriptorWrites=NULL;
            return; }pDescriptorWrites=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));auto& arr_YJcGFpk=json["pDescriptorWrites"].as_vector();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            deserialize_struct(arr_YJcGFpk[PyFuMgH].as_map(),pDescriptorWrites[PyFuMgH]);
            }();
        }
        }();

    PFN_vkCmdPushDescriptorSetKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();
[&](){json["descriptorWriteCount"]=static_cast<uint>(descriptorWriteCount);}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=json::vector();
            return; }auto arr_AuOrFWk=json::vector(descriptorWriteCount);
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorWrites[qJACxKx]);
            arr_AuOrFWk[qJACxKx]=temp_map;
            return;
            }();
        }
        json["pDescriptorWrites"]=arr_AuOrFWk;}();


        json["stream_type"]=static_cast<int>(VKCMDPUSHDESCRIPTORSETKHR);
        writeToConn(json);
    }

    void handle_vkTrimCommandPool(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolTrimFlags flags;
[&](){[&](){int temp_FGvozFl;[&](){
            if (json["flags"].is_uint64_t()){
                temp_FGvozFl=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_FGvozFl=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_FGvozFl=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

    PFN_vkTrimCommandPool call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkTrimCommandPool)get_instance_proc_addr(parent,"vkTrimCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkTrimCommandPool)get_device_proc_addr(parent,"vkTrimCommandPool");
    }  
    
{
call_function(device, commandPool, flags);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();


        json["stream_type"]=static_cast<int>(VKTRIMCOMMANDPOOL);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalBufferProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
[&](){
            if (json["pExternalBufferInfo"].as_vector().size()==0){
                pExternalBufferInfo=NULL;
            return; }pExternalBufferInfo=(VkPhysicalDeviceExternalBufferInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalBufferInfo));auto& arr_ISfKJVQ=json["pExternalBufferInfo"].as_vector();
        for(int rmWnLWl=0; rmWnLWl < 1; rmWnLWl++){
            [&](){
            deserialize_struct(arr_ISfKJVQ[rmWnLWl].as_map(),pExternalBufferInfo[rmWnLWl]);
            }();
        }
        }();
VkExternalBufferProperties* pExternalBufferProperties;
[&](){
            if (json["pExternalBufferProperties"].as_vector().size()==0){
                pExternalBufferProperties=NULL;
            return; }pExternalBufferProperties=(VkExternalBufferProperties*)malloc(1*sizeof(VkExternalBufferProperties));auto& arr_oXzExYk=json["pExternalBufferProperties"].as_vector();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            deserialize_struct(arr_oXzExYk[ufvutei].as_map(),pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalBufferProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }  
    
{
call_function(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=json::vector();
            return; }auto arr_VbIxQJg=json::vector(1);
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalBufferInfo[XeSwNaV]);
            arr_VbIxQJg[XeSwNaV]=temp_map;
            return;
            }();
        }
        json["pExternalBufferInfo"]=arr_VbIxQJg;}();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=json::vector();
            return; }auto arr_oXzExYk=json::vector(1);
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalBufferProperties[ufvutei]);
            arr_oXzExYk[ufvutei]=temp_map;
            return;
            }();
        }
        json["pExternalBufferProperties"]=arr_oXzExYk;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetMemoryFdKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].as_vector().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkMemoryGetFdInfoKHR*)malloc(1*sizeof(VkMemoryGetFdInfoKHR));auto& arr_YGnGiDl=json["pGetFdInfo"].as_vector();
        for(int QwmRuDs=0; QwmRuDs < 1; QwmRuDs++){
            [&](){
            deserialize_struct(arr_YGnGiDl[QwmRuDs].as_map(),pGetFdInfo[QwmRuDs]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();

    PFN_vkGetMemoryFdKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetMemoryFdKHR)get_instance_proc_addr(parent,"vkGetMemoryFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetMemoryFdKHR)get_device_proc_addr(parent,"vkGetMemoryFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_imCbcqk=json::vector(1);
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[oZoTEJx]);
            arr_imCbcqk[oZoTEJx]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_imCbcqk;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();


        json["stream_type"]=static_cast<int>(VKGETMEMORYFDKHR);
        writeToConn(json);
    }

    void handle_vkGetMemoryFdPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_uint64_t());
            }else if (json["handleType"].is_int64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_int64_t());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
int fd;
[&](){
            if (json["fd"].is_uint64_t()){
                fd=static_cast<int>(json["fd"].as_uint64_t());
            }else if (json["fd"].is_int64_t()){
                fd=static_cast<int>(json["fd"].as_int64_t());
            }else{
                fd=static_cast<int>(json["fd"].as_double());
            }
            }();
VkMemoryFdPropertiesKHR* pMemoryFdProperties;
[&](){
            if (json["pMemoryFdProperties"].as_vector().size()==0){
                pMemoryFdProperties=NULL;
            return; }pMemoryFdProperties=(VkMemoryFdPropertiesKHR*)malloc(1*sizeof(VkMemoryFdPropertiesKHR));auto& arr_tzzZhYk=json["pMemoryFdProperties"].as_vector();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            deserialize_struct(arr_tzzZhYk[UpKTZRJ].as_map(),pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();

    PFN_vkGetMemoryFdPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_instance_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_device_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, handleType, fd, pMemoryFdProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=static_cast<int>(handleType);}();}();}();
[&](){json["fd"]=static_cast<int>(fd);}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=json::vector();
            return; }auto arr_tzzZhYk=json::vector(1);
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryFdProperties[UpKTZRJ]);
            arr_tzzZhYk[UpKTZRJ]=temp_map;
            return;
            }();
        }
        json["pMemoryFdProperties"]=arr_tzzZhYk;}();


        json["stream_type"]=static_cast<int>(VKGETMEMORYFDPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkGetMemoryRemoteAddressNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo;
[&](){
            if (json["pMemoryGetRemoteAddressInfo"].as_vector().size()==0){
                pMemoryGetRemoteAddressInfo=NULL;
            return; }pMemoryGetRemoteAddressInfo=(VkMemoryGetRemoteAddressInfoNV*)malloc(1*sizeof(VkMemoryGetRemoteAddressInfoNV));auto& arr_qzVONyK=json["pMemoryGetRemoteAddressInfo"].as_vector();
        for(int vBoigyh=0; vBoigyh < 1; vBoigyh++){
            [&](){
            deserialize_struct(arr_qzVONyK[vBoigyh].as_map(),pMemoryGetRemoteAddressInfo[vBoigyh]);
            }();
        }
        }();
VkRemoteAddressNV* pAddress;
[&](){
            if (json["pAddress"].as_vector().size()==0){
                pAddress=NULL;
            return; }pAddress=(VkRemoteAddressNV*)malloc(1*sizeof(VkRemoteAddressNV));auto& arr_LTIxmQF=json["pAddress"].as_vector();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].as_vector().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].as_vector().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].as_vector().size()*sizeof(char));auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].as_vector();
        for(int lBwzqzO=0; lBwzqzO < arr_LTIxmQF[LIvckbR].as_vector().size(); lBwzqzO++){
            [&](){
            if (arr_FUzakvN[lBwzqzO].is_uint64_t()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_uint64_t());
            }else if (arr_FUzakvN[lBwzqzO].is_int64_t()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_int64_t());
            }else{
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_double());
            }
            }();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();

    PFN_vkGetMemoryRemoteAddressNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_instance_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_device_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryGetRemoteAddressInfo, pAddress);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=json::vector();
            return; }auto arr_JYmQngD=json::vector(1);
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryGetRemoteAddressInfo[tlzypUU]);
            arr_JYmQngD[tlzypUU]=temp_map;
            return;
            }();
        }
        json["pMemoryGetRemoteAddressInfo"]=arr_JYmQngD;}();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=json::vector();
            return; }auto arr_LTIxmQF=json::vector(1);
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=json::vector();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=json::vector();
            return; }auto arr_FUzakvN=json::vector(strlen(((char*)(pAddress[LIvckbR])))+1);
        for(int lBwzqzO=0; lBwzqzO < strlen(((char*)(pAddress[LIvckbR])))+1; lBwzqzO++){
            [&](){arr_FUzakvN[lBwzqzO]=static_cast<uint>(((char*)(pAddress[LIvckbR]))[lBwzqzO]);}();
        }
        arr_LTIxmQF[LIvckbR]=arr_FUzakvN;}();}();}();
        }
        json["pAddress"]=arr_LTIxmQF;}();


        json["stream_type"]=static_cast<int>(VKGETMEMORYREMOTEADDRESSNV);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalSemaphoreProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
[&](){
            if (json["pExternalSemaphoreInfo"].as_vector().size()==0){
                pExternalSemaphoreInfo=NULL;
            return; }pExternalSemaphoreInfo=(VkPhysicalDeviceExternalSemaphoreInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalSemaphoreInfo));auto& arr_giUwPMB=json["pExternalSemaphoreInfo"].as_vector();
        for(int gtMcAOQ=0; gtMcAOQ < 1; gtMcAOQ++){
            [&](){
            deserialize_struct(arr_giUwPMB[gtMcAOQ].as_map(),pExternalSemaphoreInfo[gtMcAOQ]);
            }();
        }
        }();
VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
[&](){
            if (json["pExternalSemaphoreProperties"].as_vector().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }pExternalSemaphoreProperties=(VkExternalSemaphoreProperties*)malloc(1*sizeof(VkExternalSemaphoreProperties));auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].as_vector();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            deserialize_struct(arr_yLCjbDt[rKjPzGR].as_map(),pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }  
    
{
call_function(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=json::vector();
            return; }auto arr_qgIgkyH=json::vector(1);
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalSemaphoreInfo[VMbMUUS]);
            arr_qgIgkyH[VMbMUUS]=temp_map;
            return;
            }();
        }
        json["pExternalSemaphoreInfo"]=arr_qgIgkyH;}();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=json::vector();
            return; }auto arr_yLCjbDt=json::vector(1);
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalSemaphoreProperties[rKjPzGR]);
            arr_yLCjbDt[rKjPzGR]=temp_map;
            return;
            }();
        }
        json["pExternalSemaphoreProperties"]=arr_yLCjbDt;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetSemaphoreFdKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].as_vector().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkSemaphoreGetFdInfoKHR*)malloc(1*sizeof(VkSemaphoreGetFdInfoKHR));auto& arr_BVoUZWb=json["pGetFdInfo"].as_vector();
        for(int BGuubyW=0; BGuubyW < 1; BGuubyW++){
            [&](){
            deserialize_struct(arr_BVoUZWb[BGuubyW].as_map(),pGetFdInfo[BGuubyW]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();

    PFN_vkGetSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSemaphoreFdKHR)get_instance_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSemaphoreFdKHR)get_device_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_fyTHWII=json::vector(1);
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[dBynwwO]);
            arr_fyTHWII[dBynwwO]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_fyTHWII;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();


        json["stream_type"]=static_cast<int>(VKGETSEMAPHOREFDKHR);
        writeToConn(json);
    }

    void handle_vkImportSemaphoreFdKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
[&](){
            if (json["pImportSemaphoreFdInfo"].as_vector().size()==0){
                pImportSemaphoreFdInfo=NULL;
            return; }pImportSemaphoreFdInfo=(VkImportSemaphoreFdInfoKHR*)malloc(1*sizeof(VkImportSemaphoreFdInfoKHR));auto& arr_UrxNRxs=json["pImportSemaphoreFdInfo"].as_vector();
        for(int QfVGtJH=0; QfVGtJH < 1; QfVGtJH++){
            [&](){
            deserialize_struct(arr_UrxNRxs[QfVGtJH].as_map(),pImportSemaphoreFdInfo[QfVGtJH]);
            }();
        }
        }();

    PFN_vkImportSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkImportSemaphoreFdKHR)get_instance_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkImportSemaphoreFdKHR)get_device_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pImportSemaphoreFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=json::vector();
            return; }auto arr_vWNEWeX=json::vector(1);
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImportSemaphoreFdInfo[kfpLCyT]);
            arr_vWNEWeX[kfpLCyT]=temp_map;
            return;
            }();
        }
        json["pImportSemaphoreFdInfo"]=arr_vWNEWeX;}();


        json["stream_type"]=static_cast<int>(VKIMPORTSEMAPHOREFDKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalFenceProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
[&](){
            if (json["pExternalFenceInfo"].as_vector().size()==0){
                pExternalFenceInfo=NULL;
            return; }pExternalFenceInfo=(VkPhysicalDeviceExternalFenceInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalFenceInfo));auto& arr_cmsSEwq=json["pExternalFenceInfo"].as_vector();
        for(int qxHSgjk=0; qxHSgjk < 1; qxHSgjk++){
            [&](){
            deserialize_struct(arr_cmsSEwq[qxHSgjk].as_map(),pExternalFenceInfo[qxHSgjk]);
            }();
        }
        }();
VkExternalFenceProperties* pExternalFenceProperties;
[&](){
            if (json["pExternalFenceProperties"].as_vector().size()==0){
                pExternalFenceProperties=NULL;
            return; }pExternalFenceProperties=(VkExternalFenceProperties*)malloc(1*sizeof(VkExternalFenceProperties));auto& arr_nPbItsj=json["pExternalFenceProperties"].as_vector();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            deserialize_struct(arr_nPbItsj[VoSEUdo].as_map(),pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalFenceProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }  
    
{
call_function(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=json::vector();
            return; }auto arr_DSVeGvM=json::vector(1);
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalFenceInfo[ApMvCYQ]);
            arr_DSVeGvM[ApMvCYQ]=temp_map;
            return;
            }();
        }
        json["pExternalFenceInfo"]=arr_DSVeGvM;}();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=json::vector();
            return; }auto arr_nPbItsj=json::vector(1);
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalFenceProperties[VoSEUdo]);
            arr_nPbItsj[VoSEUdo]=temp_map;
            return;
            }();
        }
        json["pExternalFenceProperties"]=arr_nPbItsj;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES);
        writeToConn(json);
    }

    void handle_vkGetFenceFdKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFenceGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].as_vector().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkFenceGetFdInfoKHR*)malloc(1*sizeof(VkFenceGetFdInfoKHR));auto& arr_xyswZQS=json["pGetFdInfo"].as_vector();
        for(int pCVXTsZ=0; pCVXTsZ < 1; pCVXTsZ++){
            [&](){
            deserialize_struct(arr_xyswZQS[pCVXTsZ].as_map(),pGetFdInfo[pCVXTsZ]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();

    PFN_vkGetFenceFdKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetFenceFdKHR)get_instance_proc_addr(parent,"vkGetFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetFenceFdKHR)get_device_proc_addr(parent,"vkGetFenceFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_mgmOmEV=json::vector(1);
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[DYSusBe]);
            arr_mgmOmEV[DYSusBe]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_mgmOmEV;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();


        json["stream_type"]=static_cast<int>(VKGETFENCEFDKHR);
        writeToConn(json);
    }

    void handle_vkImportFenceFdKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImportFenceFdInfoKHR* pImportFenceFdInfo;
[&](){
            if (json["pImportFenceFdInfo"].as_vector().size()==0){
                pImportFenceFdInfo=NULL;
            return; }pImportFenceFdInfo=(VkImportFenceFdInfoKHR*)malloc(1*sizeof(VkImportFenceFdInfoKHR));auto& arr_fzWADTd=json["pImportFenceFdInfo"].as_vector();
        for(int nbyOjBi=0; nbyOjBi < 1; nbyOjBi++){
            [&](){
            deserialize_struct(arr_fzWADTd[nbyOjBi].as_map(),pImportFenceFdInfo[nbyOjBi]);
            }();
        }
        }();

    PFN_vkImportFenceFdKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkImportFenceFdKHR)get_instance_proc_addr(parent,"vkImportFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkImportFenceFdKHR)get_device_proc_addr(parent,"vkImportFenceFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pImportFenceFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=json::vector();
            return; }auto arr_PmxwQMO=json::vector(1);
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImportFenceFdInfo[QSUnAUF]);
            arr_PmxwQMO[QSUnAUF]=temp_map;
            return;
            }();
        }
        json["pImportFenceFdInfo"]=arr_PmxwQMO;}();


        json["stream_type"]=static_cast<int>(VKIMPORTFENCEFDKHR);
        writeToConn(json);
    }

    void handle_vkReleaseDisplayEXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkReleaseDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkReleaseDisplayEXT)get_instance_proc_addr(parent,"vkReleaseDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkReleaseDisplayEXT)get_device_proc_addr(parent,"vkReleaseDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        json["stream_type"]=static_cast<int>(VKRELEASEDISPLAYEXT);
        writeToConn(json);
    }

    void handle_vkDisplayPowerControlEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayPowerInfoEXT* pDisplayPowerInfo;
[&](){
            if (json["pDisplayPowerInfo"].as_vector().size()==0){
                pDisplayPowerInfo=NULL;
            return; }pDisplayPowerInfo=(VkDisplayPowerInfoEXT*)malloc(1*sizeof(VkDisplayPowerInfoEXT));auto& arr_VSwTzCL=json["pDisplayPowerInfo"].as_vector();
        for(int KtsnURa=0; KtsnURa < 1; KtsnURa++){
            [&](){
            deserialize_struct(arr_VSwTzCL[KtsnURa].as_map(),pDisplayPowerInfo[KtsnURa]);
            }();
        }
        }();

    PFN_vkDisplayPowerControlEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDisplayPowerControlEXT)get_instance_proc_addr(parent,"vkDisplayPowerControlEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDisplayPowerControlEXT)get_device_proc_addr(parent,"vkDisplayPowerControlEXT");
    }  
    
VkResult  result;
{
result=call_function(device, display, pDisplayPowerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=json::vector();
            return; }auto arr_MrfcjyV=json::vector(1);
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayPowerInfo[xtIgTXd]);
            arr_MrfcjyV[xtIgTXd]=temp_map;
            return;
            }();
        }
        json["pDisplayPowerInfo"]=arr_MrfcjyV;}();


        json["stream_type"]=static_cast<int>(VKDISPLAYPOWERCONTROLEXT);
        writeToConn(json);
    }

    void handle_vkRegisterDeviceEventEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceEventInfoEXT* pDeviceEventInfo;
[&](){
            if (json["pDeviceEventInfo"].as_vector().size()==0){
                pDeviceEventInfo=NULL;
            return; }pDeviceEventInfo=(VkDeviceEventInfoEXT*)malloc(1*sizeof(VkDeviceEventInfoEXT));auto& arr_EoseEDE=json["pDeviceEventInfo"].as_vector();
        for(int obNGZvs=0; obNGZvs < 1; obNGZvs++){
            [&](){
            deserialize_struct(arr_EoseEDE[obNGZvs].as_map(),pDeviceEventInfo[obNGZvs]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDeviceEventEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkRegisterDeviceEventEXT)get_instance_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkRegisterDeviceEventEXT)get_device_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pDeviceEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=json::vector();
            return; }auto arr_PBonFka=json::vector(1);
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDeviceEventInfo[JNqwWzK]);
            arr_PBonFka[JNqwWzK]=temp_map;
            return;
            }();
        }
        json["pDeviceEventInfo"]=arr_PBonFka;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();


        json["stream_type"]=static_cast<int>(VKREGISTERDEVICEEVENTEXT);
        writeToConn(json);
    }

    void handle_vkRegisterDisplayEventEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayEventInfoEXT* pDisplayEventInfo;
[&](){
            if (json["pDisplayEventInfo"].as_vector().size()==0){
                pDisplayEventInfo=NULL;
            return; }pDisplayEventInfo=(VkDisplayEventInfoEXT*)malloc(1*sizeof(VkDisplayEventInfoEXT));auto& arr_dFojYev=json["pDisplayEventInfo"].as_vector();
        for(int ABwoOha=0; ABwoOha < 1; ABwoOha++){
            [&](){
            deserialize_struct(arr_dFojYev[ABwoOha].as_map(),pDisplayEventInfo[ABwoOha]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDisplayEventEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkRegisterDisplayEventEXT)get_instance_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkRegisterDisplayEventEXT)get_device_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }  
    
VkResult  result;
{
result=call_function(device, display, pDisplayEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=json::vector();
            return; }auto arr_EEWRWgk=json::vector(1);
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayEventInfo[ZywgBIl]);
            arr_EEWRWgk[ZywgBIl]=temp_map;
            return;
            }();
        }
        json["pDisplayEventInfo"]=arr_EEWRWgk;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();


        json["stream_type"]=static_cast<int>(VKREGISTERDISPLAYEVENTEXT);
        writeToConn(json);
    }

    void handle_vkGetSwapchainCounterEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkSurfaceCounterFlagBitsEXT counter;
[&](){[&](){int temp_RusGBTK;[&](){
            if (json["counter"].is_uint64_t()){
                temp_RusGBTK=static_cast<int>(json["counter"].as_uint64_t());
            }else if (json["counter"].is_int64_t()){
                temp_RusGBTK=static_cast<int>(json["counter"].as_int64_t());
            }else{
                temp_RusGBTK=static_cast<int>(json["counter"].as_double());
            }
            }();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
uint64_t* pCounterValue;
[&](){
            if (json["pCounterValue"].as_vector().size()==0){
                pCounterValue=NULL;
            return; }pCounterValue=(uint64_t*)malloc(1*sizeof(uint64_t));auto& arr_VmPfCNz=json["pCounterValue"].as_vector();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){
            if (arr_VmPfCNz[BVcpEyO].is_uint64_t()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_uint64_t());
            }else if (arr_VmPfCNz[BVcpEyO].is_int64_t()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_int64_t());
            }else{
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_double());
            }
            }();
        }
        }();

    PFN_vkGetSwapchainCounterEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSwapchainCounterEXT)get_instance_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSwapchainCounterEXT)get_device_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, counter, pCounterValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=static_cast<int>(counter);}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=json::vector();
            return; }auto arr_VmPfCNz=json::vector(1);
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=static_cast<uint>(pCounterValue[BVcpEyO]);}();
        }
        json["pCounterValue"]=arr_VmPfCNz;}();


        json["stream_type"]=static_cast<int>(VKGETSWAPCHAINCOUNTEREXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2EXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2EXT*)malloc(1*sizeof(VkSurfaceCapabilities2EXT));auto& arr_KYzynfJ=json["pSurfaceCapabilities"].as_vector();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            deserialize_struct(arr_KYzynfJ[QJCcfVY].as_map(),pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_KYzynfJ=json::vector(1);
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[QJCcfVY]);
            arr_KYzynfJ[QJCcfVY]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_KYzynfJ;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT);
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceGroups(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceGroupCount;
[&](){
            if (json["pPhysicalDeviceGroupCount"].as_vector().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }pPhysicalDeviceGroupCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].as_vector();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){
            if (arr_Cmahtvc[SYfwvYv].is_uint64_t()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_uint64_t());
            }else if (arr_Cmahtvc[SYfwvYv].is_int64_t()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_int64_t());
            }else{
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_double());
            }
            }();
        }
        }();
VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
[&](){
            if (json["pPhysicalDeviceGroupProperties"].as_vector().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }pPhysicalDeviceGroupProperties=(VkPhysicalDeviceGroupProperties*)malloc(*pPhysicalDeviceGroupCount*sizeof(VkPhysicalDeviceGroupProperties));auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].as_vector();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            deserialize_struct(arr_kSmADNy[LorZWUi].as_map(),pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceGroups call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }  
    
VkResult  result;
{
result=call_function(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=json::vector();
            return; }auto arr_Cmahtvc=json::vector(1);
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=static_cast<uint>(pPhysicalDeviceGroupCount[SYfwvYv]);}();
        }
        json["pPhysicalDeviceGroupCount"]=arr_Cmahtvc;}();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=json::vector();
            return; }auto arr_kSmADNy=json::vector(*pPhysicalDeviceGroupCount);
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPhysicalDeviceGroupProperties[LorZWUi]);
            arr_kSmADNy[LorZWUi]=temp_map;
            return;
            }();
        }
        json["pPhysicalDeviceGroupProperties"]=arr_kSmADNy;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICEGROUPS);
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPeerMemoryFeatures(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t heapIndex;
[&](){
            if (json["heapIndex"].is_uint64_t()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_uint64_t());
            }else if (json["heapIndex"].is_int64_t()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_int64_t());
            }else{
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_double());
            }
            }();
uint32_t localDeviceIndex;
[&](){
            if (json["localDeviceIndex"].is_uint64_t()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_uint64_t());
            }else if (json["localDeviceIndex"].is_int64_t()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_int64_t());
            }else{
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_double());
            }
            }();
uint32_t remoteDeviceIndex;
[&](){
            if (json["remoteDeviceIndex"].is_uint64_t()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_uint64_t());
            }else if (json["remoteDeviceIndex"].is_int64_t()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_int64_t());
            }else{
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_double());
            }
            }();
VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
[&](){
            if (json["pPeerMemoryFeatures"].as_vector().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }pPeerMemoryFeatures=(VkPeerMemoryFeatureFlags*)malloc(1*sizeof(VkPeerMemoryFeatureFlags));auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].as_vector();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){
            if (arr_IMNDPVx[dvtpqQO].is_uint64_t()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_uint64_t());
            }else if (arr_IMNDPVx[dvtpqQO].is_int64_t()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_int64_t());
            }else{
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_double());
            }
            }();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

    PFN_vkGetDeviceGroupPeerMemoryFeatures call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_instance_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_device_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }  
    
{
call_function(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=static_cast<uint>(heapIndex);}();
[&](){json["localDeviceIndex"]=static_cast<uint>(localDeviceIndex);}();
[&](){json["remoteDeviceIndex"]=static_cast<uint>(remoteDeviceIndex);}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=json::vector();
            return; }auto arr_IMNDPVx=json::vector(1);
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=static_cast<int>(pPeerMemoryFeatures[dvtpqQO]);}();}();}();
        }
        json["pPeerMemoryFeatures"]=arr_IMNDPVx;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPPEERMEMORYFEATURES);
        writeToConn(json);
    }

    void handle_vkBindBufferMemory2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();
 VkBindBufferMemoryInfo* pBindInfos;
[&](){
            if (json["pBindInfos"].as_vector().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindBufferMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindBufferMemoryInfo));auto& arr_KcaAJZC=json["pBindInfos"].as_vector();
        for(int sAHPDKw=0; sAHPDKw < bindInfoCount; sAHPDKw++){
            [&](){
            deserialize_struct(arr_KcaAJZC[sAHPDKw].as_map(),pBindInfos[sAHPDKw]);
            }();
        }
        }();

    PFN_vkBindBufferMemory2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindBufferMemory2)get_instance_proc_addr(parent,"vkBindBufferMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindBufferMemory2)get_device_proc_addr(parent,"vkBindBufferMemory2");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_NWunNSr=json::vector(bindInfoCount);
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[DbCSPHR]);
            arr_NWunNSr[DbCSPHR]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_NWunNSr;}();


        json["stream_type"]=static_cast<int>(VKBINDBUFFERMEMORY2);
        writeToConn(json);
    }

    void handle_vkBindImageMemory2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();
 VkBindImageMemoryInfo* pBindInfos;
[&](){
            if (json["pBindInfos"].as_vector().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindImageMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindImageMemoryInfo));auto& arr_OyrgWGZ=json["pBindInfos"].as_vector();
        for(int jeBxOVo=0; jeBxOVo < bindInfoCount; jeBxOVo++){
            [&](){
            deserialize_struct(arr_OyrgWGZ[jeBxOVo].as_map(),pBindInfos[jeBxOVo]);
            }();
        }
        }();

    PFN_vkBindImageMemory2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindImageMemory2)get_instance_proc_addr(parent,"vkBindImageMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindImageMemory2)get_device_proc_addr(parent,"vkBindImageMemory2");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_FifZmRy=json::vector(bindInfoCount);
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[TInZfLo]);
            arr_FifZmRy[TInZfLo]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_FifZmRy;}();


        json["stream_type"]=static_cast<int>(VKBINDIMAGEMEMORY2);
        writeToConn(json);
    }

    void handle_vkCmdSetDeviceMask(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t deviceMask;
[&](){
            if (json["deviceMask"].is_uint64_t()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_uint64_t());
            }else if (json["deviceMask"].is_int64_t()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_int64_t());
            }else{
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_double());
            }
            }();

    PFN_vkCmdSetDeviceMask call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDeviceMask)get_instance_proc_addr(parent,"vkCmdSetDeviceMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDeviceMask)get_device_proc_addr(parent,"vkCmdSetDeviceMask");
    }  
    
{
call_function(commandBuffer, deviceMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=static_cast<uint>(deviceMask);}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEVICEMASK);
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPresentCapabilitiesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
[&](){
            if (json["pDeviceGroupPresentCapabilities"].as_vector().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }pDeviceGroupPresentCapabilities=(VkDeviceGroupPresentCapabilitiesKHR*)malloc(1*sizeof(VkDeviceGroupPresentCapabilitiesKHR));auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].as_vector();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            deserialize_struct(arr_gEodIfI[HHoUQIw].as_map(),pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();

    PFN_vkGetDeviceGroupPresentCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pDeviceGroupPresentCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=json::vector();
            return; }auto arr_gEodIfI=json::vector(1);
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDeviceGroupPresentCapabilities[HHoUQIw]);
            arr_gEodIfI[HHoUQIw]=temp_map;
            return;
            }();
        }
        json["pDeviceGroupPresentCapabilities"]=arr_gEodIfI;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPPRESENTCAPABILITIESKHR);
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupSurfacePresentModesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkDeviceGroupPresentModeFlagsKHR* pModes;
[&](){
            if (json["pModes"].as_vector().size()==0){
                pModes=NULL;
            return; }pModes=(VkDeviceGroupPresentModeFlagsKHR*)malloc(1*sizeof(VkDeviceGroupPresentModeFlagsKHR));auto& arr_RUtBuZy=json["pModes"].as_vector();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){
            if (arr_RUtBuZy[OxSHrMn].is_uint64_t()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_uint64_t());
            }else if (arr_RUtBuZy[OxSHrMn].is_int64_t()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_int64_t());
            }else{
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_double());
            }
            }();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();

    PFN_vkGetDeviceGroupSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, surface, pModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=json::vector();
            return; }auto arr_RUtBuZy=json::vector(1);
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=static_cast<int>(pModes[OxSHrMn]);}();}();}();
        }
        json["pModes"]=arr_RUtBuZy;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPSURFACEPRESENTMODESKHR);
        writeToConn(json);
    }

    void handle_vkAcquireNextImage2KHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAcquireNextImageInfoKHR* pAcquireInfo;
[&](){
            if (json["pAcquireInfo"].as_vector().size()==0){
                pAcquireInfo=NULL;
            return; }pAcquireInfo=(VkAcquireNextImageInfoKHR*)malloc(1*sizeof(VkAcquireNextImageInfoKHR));auto& arr_DnycGJU=json["pAcquireInfo"].as_vector();
        for(int tNYAOen=0; tNYAOen < 1; tNYAOen++){
            [&](){
            deserialize_struct(arr_DnycGJU[tNYAOen].as_map(),pAcquireInfo[tNYAOen]);
            }();
        }
        }();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].as_vector().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_oSqpNfH=json["pImageIndex"].as_vector();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_uint64_t());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_int64_t());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_double());
            }
            }();
        }
        }();

    PFN_vkAcquireNextImage2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAcquireNextImage2KHR)get_instance_proc_addr(parent,"vkAcquireNextImage2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAcquireNextImage2KHR)get_device_proc_addr(parent,"vkAcquireNextImage2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pAcquireInfo, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=json::vector();
            return; }auto arr_plPbild=json::vector(1);
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAcquireInfo[QzLRJum]);
            arr_plPbild[QzLRJum]=temp_map;
            return;
            }();
        }
        json["pAcquireInfo"]=arr_plPbild;}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=json::vector();
            return; }auto arr_oSqpNfH=json::vector(1);
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=static_cast<uint>(pImageIndex[BEjuBtR]);}();
        }
        json["pImageIndex"]=arr_oSqpNfH;}();


        json["stream_type"]=static_cast<int>(VKACQUIRENEXTIMAGE2KHR);
        writeToConn(json);
    }

    void handle_vkCmdDispatchBase(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t baseGroupX;
[&](){
            if (json["baseGroupX"].is_uint64_t()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_uint64_t());
            }else if (json["baseGroupX"].is_int64_t()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_int64_t());
            }else{
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_double());
            }
            }();
uint32_t baseGroupY;
[&](){
            if (json["baseGroupY"].is_uint64_t()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_uint64_t());
            }else if (json["baseGroupY"].is_int64_t()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_int64_t());
            }else{
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_double());
            }
            }();
uint32_t baseGroupZ;
[&](){
            if (json["baseGroupZ"].is_uint64_t()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_uint64_t());
            }else if (json["baseGroupZ"].is_int64_t()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_int64_t());
            }else{
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_double());
            }
            }();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

    PFN_vkCmdDispatchBase call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDispatchBase)get_instance_proc_addr(parent,"vkCmdDispatchBase");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDispatchBase)get_device_proc_addr(parent,"vkCmdDispatchBase");
    }  
    
{
call_function(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=static_cast<uint>(baseGroupX);}();
[&](){json["baseGroupY"]=static_cast<uint>(baseGroupY);}();
[&](){json["baseGroupZ"]=static_cast<uint>(baseGroupZ);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();


        json["stream_type"]=static_cast<int>(VKCMDDISPATCHBASE);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDevicePresentRectanglesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pRectCount;
[&](){
            if (json["pRectCount"].as_vector().size()==0){
                pRectCount=NULL;
            return; }pRectCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_vsEoMvr=json["pRectCount"].as_vector();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){
            if (arr_vsEoMvr[TgFYlRi].is_uint64_t()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_uint64_t());
            }else if (arr_vsEoMvr[TgFYlRi].is_int64_t()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_int64_t());
            }else{
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_double());
            }
            }();
        }
        }();
VkRect2D* pRects;
[&](){
            if (json["pRects"].as_vector().size()==0){
                pRects=NULL;
            return; }pRects=(VkRect2D*)malloc(*pRectCount*sizeof(VkRect2D));auto& arr_BxIGDMm=json["pRects"].as_vector();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            deserialize_struct(arr_BxIGDMm[LNnHsjT].as_map(),pRects[LNnHsjT]);
            }();
        }
        }();

    PFN_vkGetPhysicalDevicePresentRectanglesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_device_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pRectCount, pRects);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=json::vector();
            return; }auto arr_vsEoMvr=json::vector(1);
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=static_cast<uint>(pRectCount[TgFYlRi]);}();
        }
        json["pRectCount"]=arr_vsEoMvr;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=json::vector();
            return; }auto arr_BxIGDMm=json::vector(*pRectCount);
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRects[LNnHsjT]);
            arr_BxIGDMm[LNnHsjT]=temp_map;
            return;
            }();
        }
        json["pRects"]=arr_BxIGDMm;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR);
        writeToConn(json);
    }

    void handle_vkCreateDescriptorUpdateTemplate(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorUpdateTemplateCreateInfo*)malloc(1*sizeof(VkDescriptorUpdateTemplateCreateInfo));auto& arr_VGzFxGk=json["pCreateInfo"].as_vector();
        for(int nfmnALE=0; nfmnALE < 1; nfmnALE++){
            [&](){
            deserialize_struct(arr_VGzFxGk[nfmnALE].as_map(),pCreateInfo[nfmnALE]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
[&](){
            if (json["pDescriptorUpdateTemplate"].as_vector().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }pDescriptorUpdateTemplate=(VkDescriptorUpdateTemplate*)malloc(1*sizeof(VkDescriptorUpdateTemplate));auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].as_vector();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();

    PFN_vkCreateDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_GOaQfzV=json::vector(1);
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[bDXkRSI]);
            arr_GOaQfzV[bDXkRSI]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_GOaQfzV;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=json::vector();
            return; }auto arr_wchWplA=json::vector(1);
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        json["pDescriptorUpdateTemplate"]=arr_wchWplA;}();


        json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORUPDATETEMPLATE);
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorUpdateTemplate(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }  
    
{
call_function(device, descriptorUpdateTemplate, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORUPDATETEMPLATE);
        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSetWithTemplate(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
 void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_EOPGHRq=json["pData"].as_vector();
        for(int ElrKHKH=0; ElrKHKH < json["pData"].as_vector().size(); ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64_t()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_uint64_t());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64_t()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_int64_t());
            }else{
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_double());
            }
            }();
        }
        }();pData=temp_cNzVPDf;}();

    PFN_vkUpdateDescriptorSetWithTemplate call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_instance_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_device_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }  
    
{
call_function(device, descriptorSet, descriptorUpdateTemplate, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(strlen(((char*)(pData)))+1);
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();


        json["stream_type"]=static_cast<int>(VKUPDATEDESCRIPTORSETWITHTEMPLATE);
        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetWithTemplateKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();
 void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_EOPGHRq=json["pData"].as_vector();
        for(int ElrKHKH=0; ElrKHKH < json["pData"].as_vector().size(); ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64_t()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_uint64_t());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64_t()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_int64_t());
            }else{
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].as_double());
            }
            }();
        }
        }();pData=temp_cNzVPDf;}();

    PFN_vkCmdPushDescriptorSetWithTemplateKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }  
    
{
call_function(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(strlen(((char*)(pData)))+1);
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();


        json["stream_type"]=static_cast<int>(VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR);
        writeToConn(json);
    }

    void handle_vkSetHdrMetadataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){
            if (json["swapchainCount"].is_uint64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_uint64_t());
            }else if (json["swapchainCount"].is_int64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_int64_t());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_double());
            }
            }();
 VkSwapchainKHR* pSwapchains;
[&](){
            if (json["pSwapchains"].as_vector().size()==0){
                pSwapchains=NULL;
            return; }pSwapchains=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));auto& arr_iHlSrAW=json["pSwapchains"].as_vector();
        for(int IasqrAl=0; IasqrAl < swapchainCount; IasqrAl++){
            [&](){deserialize_VkSwapchainKHR(arr_iHlSrAW[IasqrAl], pSwapchains[IasqrAl]);}();
        }
        }();
 VkHdrMetadataEXT* pMetadata;
[&](){
            if (json["pMetadata"].as_vector().size()==0){
                pMetadata=NULL;
            return; }pMetadata=(VkHdrMetadataEXT*)malloc(swapchainCount*sizeof(VkHdrMetadataEXT));auto& arr_kUxcKTi=json["pMetadata"].as_vector();
        for(int IpDaPDf=0; IpDaPDf < swapchainCount; IpDaPDf++){
            [&](){
            deserialize_struct(arr_kUxcKTi[IpDaPDf].as_map(),pMetadata[IpDaPDf]);
            }();
        }
        }();

    PFN_vkSetHdrMetadataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetHdrMetadataEXT)get_instance_proc_addr(parent,"vkSetHdrMetadataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetHdrMetadataEXT)get_device_proc_addr(parent,"vkSetHdrMetadataEXT");
    }  
    
{
call_function(device, swapchainCount, pSwapchains, pMetadata);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=static_cast<uint>(swapchainCount);}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=json::vector();
            return; }auto arr_ItrwriJ=json::vector(swapchainCount);
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        json["pSwapchains"]=arr_ItrwriJ;}();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=json::vector();
            return; }auto arr_gUCeGgy=json::vector(swapchainCount);
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMetadata[qGnEfca]);
            arr_gUCeGgy[qGnEfca]=temp_map;
            return;
            }();
        }
        json["pMetadata"]=arr_gUCeGgy;}();


        json["stream_type"]=static_cast<int>(VKSETHDRMETADATAEXT);
        writeToConn(json);
    }

    void handle_vkGetSwapchainStatusKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();

    PFN_vkGetSwapchainStatusKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSwapchainStatusKHR)get_instance_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSwapchainStatusKHR)get_device_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();


        json["stream_type"]=static_cast<int>(VKGETSWAPCHAINSTATUSKHR);
        writeToConn(json);
    }

    void handle_vkGetRefreshCycleDurationGOOGLE(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
[&](){
            if (json["pDisplayTimingProperties"].as_vector().size()==0){
                pDisplayTimingProperties=NULL;
            return; }pDisplayTimingProperties=(VkRefreshCycleDurationGOOGLE*)malloc(1*sizeof(VkRefreshCycleDurationGOOGLE));auto& arr_nDUaeZL=json["pDisplayTimingProperties"].as_vector();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            deserialize_struct(arr_nDUaeZL[NSFWKiB].as_map(),pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();

    PFN_vkGetRefreshCycleDurationGOOGLE call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_instance_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_device_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pDisplayTimingProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=json::vector();
            return; }auto arr_nDUaeZL=json::vector(1);
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayTimingProperties[NSFWKiB]);
            arr_nDUaeZL[NSFWKiB]=temp_map;
            return;
            }();
        }
        json["pDisplayTimingProperties"]=arr_nDUaeZL;}();


        json["stream_type"]=static_cast<int>(VKGETREFRESHCYCLEDURATIONGOOGLE);
        writeToConn(json);
    }

    void handle_vkGetPastPresentationTimingGOOGLE(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pPresentationTimingCount;
[&](){
            if (json["pPresentationTimingCount"].as_vector().size()==0){
                pPresentationTimingCount=NULL;
            return; }pPresentationTimingCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_LiCpViZ=json["pPresentationTimingCount"].as_vector();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){
            if (arr_LiCpViZ[ihpxywU].is_uint64_t()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_uint64_t());
            }else if (arr_LiCpViZ[ihpxywU].is_int64_t()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_int64_t());
            }else{
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_double());
            }
            }();
        }
        }();
VkPastPresentationTimingGOOGLE* pPresentationTimings;
[&](){
            if (json["pPresentationTimings"].as_vector().size()==0){
                pPresentationTimings=NULL;
            return; }pPresentationTimings=(VkPastPresentationTimingGOOGLE*)malloc(*pPresentationTimingCount*sizeof(VkPastPresentationTimingGOOGLE));auto& arr_CGvQjMK=json["pPresentationTimings"].as_vector();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            deserialize_struct(arr_CGvQjMK[CzbyDFb].as_map(),pPresentationTimings[CzbyDFb]);
            }();
        }
        }();

    PFN_vkGetPastPresentationTimingGOOGLE call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_instance_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_device_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=json::vector();
            return; }auto arr_LiCpViZ=json::vector(1);
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=static_cast<uint>(pPresentationTimingCount[ihpxywU]);}();
        }
        json["pPresentationTimingCount"]=arr_LiCpViZ;}();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=json::vector();
            return; }auto arr_CGvQjMK=json::vector(*pPresentationTimingCount);
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPresentationTimings[CzbyDFb]);
            arr_CGvQjMK[CzbyDFb]=temp_map;
            return;
            }();
        }
        json["pPresentationTimings"]=arr_CGvQjMK;}();


        json["stream_type"]=static_cast<int>(VKGETPASTPRESENTATIONTIMINGGOOGLE);
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();
 VkViewportWScalingNV* pViewportWScalings;
[&](){
            if (json["pViewportWScalings"].as_vector().size()==0){
                pViewportWScalings=NULL;
            return; }pViewportWScalings=(VkViewportWScalingNV*)malloc(viewportCount*sizeof(VkViewportWScalingNV));auto& arr_mRBzXTN=json["pViewportWScalings"].as_vector();
        for(int jZGgaiG=0; jZGgaiG < viewportCount; jZGgaiG++){
            [&](){
            deserialize_struct(arr_mRBzXTN[jZGgaiG].as_map(),pViewportWScalings[jZGgaiG]);
            }();
        }
        }();

    PFN_vkCmdSetViewportWScalingNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=json::vector();
            return; }auto arr_gZVGKnq=json::vector(viewportCount);
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewportWScalings[GRZXlou]);
            arr_gZVGKnq[GRZXlou]=temp_map;
            return;
            }();
        }
        json["pViewportWScalings"]=arr_gZVGKnq;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWSCALINGNV);
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstDiscardRectangle;
[&](){
            if (json["firstDiscardRectangle"].is_uint64_t()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_uint64_t());
            }else if (json["firstDiscardRectangle"].is_int64_t()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_int64_t());
            }else{
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_double());
            }
            }();
uint32_t discardRectangleCount;
[&](){
            if (json["discardRectangleCount"].is_uint64_t()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_uint64_t());
            }else if (json["discardRectangleCount"].is_int64_t()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_int64_t());
            }else{
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_double());
            }
            }();
 VkRect2D* pDiscardRectangles;
[&](){
            if (json["pDiscardRectangles"].as_vector().size()==0){
                pDiscardRectangles=NULL;
            return; }pDiscardRectangles=(VkRect2D*)malloc(discardRectangleCount*sizeof(VkRect2D));auto& arr_GRSsdXy=json["pDiscardRectangles"].as_vector();
        for(int sWyneMb=0; sWyneMb < discardRectangleCount; sWyneMb++){
            [&](){
            deserialize_struct(arr_GRSsdXy[sWyneMb].as_map(),pDiscardRectangles[sWyneMb]);
            }();
        }
        }();

    PFN_vkCmdSetDiscardRectangleEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }  
    
{
call_function(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=static_cast<uint>(firstDiscardRectangle);}();
[&](){json["discardRectangleCount"]=static_cast<uint>(discardRectangleCount);}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=json::vector();
            return; }auto arr_uUeweOj=json::vector(discardRectangleCount);
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDiscardRectangles[WtUHHLW]);
            arr_uUeweOj[WtUHHLW]=temp_map;
            return;
            }();
        }
        json["pDiscardRectangles"]=arr_uUeweOj;}();


        json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 discardRectangleEnable;
[&](){uint32_t temp_GnHxsqE;[&](){
            if (json["discardRectangleEnable"].is_uint64_t()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_uint64_t());
            }else if (json["discardRectangleEnable"].is_int64_t()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_int64_t());
            }else{
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_double());
            }
            }();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

    PFN_vkCmdSetDiscardRectangleEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=static_cast<uint>(discardRectangleEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleModeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDiscardRectangleModeEXT discardRectangleMode;
[&](){[&](){int temp_iBxDvRc;[&](){
            if (json["discardRectangleMode"].is_uint64_t()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_uint64_t());
            }else if (json["discardRectangleMode"].is_int64_t()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_int64_t());
            }else{
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_double());
            }
            }();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

    PFN_vkCmdSetDiscardRectangleModeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=static_cast<int>(discardRectangleMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEMODEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSampleLocationsInfoEXT* pSampleLocationsInfo;
[&](){
            if (json["pSampleLocationsInfo"].as_vector().size()==0){
                pSampleLocationsInfo=NULL;
            return; }pSampleLocationsInfo=(VkSampleLocationsInfoEXT*)malloc(1*sizeof(VkSampleLocationsInfoEXT));auto& arr_bqTfGpl=json["pSampleLocationsInfo"].as_vector();
        for(int zJxCCYx=0; zJxCCYx < 1; zJxCCYx++){
            [&](){
            deserialize_struct(arr_bqTfGpl[zJxCCYx].as_map(),pSampleLocationsInfo[zJxCCYx]);
            }();
        }
        }();

    PFN_vkCmdSetSampleLocationsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }  
    
{
call_function(commandBuffer, pSampleLocationsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=json::vector();
            return; }auto arr_KfRxBlJ=json::vector(1);
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSampleLocationsInfo[XjGOezZ]);
            arr_KfRxBlJ[XjGOezZ]=temp_map;
            return;
            }();
        }
        json["pSampleLocationsInfo"]=arr_KfRxBlJ;}();


        json["stream_type"]=static_cast<int>(VKCMDSETSAMPLELOCATIONSEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMultisamplePropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkMultisamplePropertiesEXT* pMultisampleProperties;
[&](){
            if (json["pMultisampleProperties"].as_vector().size()==0){
                pMultisampleProperties=NULL;
            return; }pMultisampleProperties=(VkMultisamplePropertiesEXT*)malloc(1*sizeof(VkMultisamplePropertiesEXT));auto& arr_IduiRHb=json["pMultisampleProperties"].as_vector();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            deserialize_struct(arr_IduiRHb[xJhEIjr].as_map(),pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }  
    
{
call_function(physicalDevice, samples, pMultisampleProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=json::vector();
            return; }auto arr_IduiRHb=json::vector(1);
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMultisampleProperties[xJhEIjr]);
            arr_IduiRHb[xJhEIjr]=temp_map;
            return;
            }();
        }
        json["pMultisampleProperties"]=arr_IduiRHb;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){
            if (json["pSurfaceInfo"].as_vector().size()==0){
                pSurfaceInfo=NULL;
            return; }pSurfaceInfo=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));auto& arr_wNHWsze=json["pSurfaceInfo"].as_vector();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            deserialize_struct(arr_wNHWsze[lTfpfvZ].as_map(),pSurfaceInfo[lTfpfvZ]);
            }();
        }
        }();
VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2KHR*)malloc(1*sizeof(VkSurfaceCapabilities2KHR));auto& arr_JfroxEi=json["pSurfaceCapabilities"].as_vector();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            deserialize_struct(arr_JfroxEi[Baebpht].as_map(),pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=json::vector();
            return; }auto arr_kqlTDpj=json::vector(1);
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceInfo[yiVsRWe]);
            arr_kqlTDpj[yiVsRWe]=temp_map;
            return;
            }();
        }
        json["pSurfaceInfo"]=arr_kqlTDpj;}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_JfroxEi=json::vector(1);
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[Baebpht]);
            arr_JfroxEi[Baebpht]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_JfroxEi;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormats2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){
            if (json["pSurfaceInfo"].as_vector().size()==0){
                pSurfaceInfo=NULL;
            return; }pSurfaceInfo=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));auto& arr_wNHWsze=json["pSurfaceInfo"].as_vector();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            deserialize_struct(arr_wNHWsze[lTfpfvZ].as_map(),pSurfaceInfo[lTfpfvZ]);
            }();
        }
        }();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].as_vector().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_vector();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_uint64_t());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_int64_t());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_double());
            }
            }();
        }
        }();
VkSurfaceFormat2KHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].as_vector().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormat2KHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormat2KHR));auto& arr_AuCicsY=json["pSurfaceFormats"].as_vector();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            deserialize_struct(arr_AuCicsY[lVrVWxA].as_map(),pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=json::vector();
            return; }auto arr_kqlTDpj=json::vector(1);
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceInfo[yiVsRWe]);
            arr_kqlTDpj[yiVsRWe]=temp_map;
            return;
            }();
        }
        json["pSurfaceInfo"]=arr_kqlTDpj;}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=json::vector();
            return; }auto arr_mbQwRYl=json::vector(1);
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=static_cast<uint>(pSurfaceFormatCount[bFtFQKD]);}();
        }
        json["pSurfaceFormatCount"]=arr_mbQwRYl;}();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=json::vector();
            return; }auto arr_AuCicsY=json::vector(*pSurfaceFormatCount);
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceFormats[lVrVWxA]);
            arr_AuCicsY[lVrVWxA]=temp_map;
            return;
            }();
        }
        json["pSurfaceFormats"]=arr_AuCicsY;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEFORMATS2KHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayProperties2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayProperties2KHR));auto& arr_WgClQQW=json["pProperties"].as_vector();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            deserialize_struct(arr_WgClQQW[IPCMyur].as_map(),pProperties[IPCMyur]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_WgClQQW=json::vector(*pPropertyCount);
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[IPCMyur]);
            arr_WgClQQW[IPCMyur]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_WgClQQW;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayPlaneProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlaneProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlaneProperties2KHR));auto& arr_oqLTQEe=json["pProperties"].as_vector();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            deserialize_struct(arr_oqLTQEe[KJvijjP].as_map(),pProperties[KJvijjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oqLTQEe=json::vector(*pPropertyCount);
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[KJvijjP]);
            arr_oqLTQEe[KJvijjP]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oqLTQEe;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR);
        writeToConn(json);
    }

    void handle_vkGetDisplayModeProperties2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkDisplayModeProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModeProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayModeProperties2KHR));auto& arr_LvUqkhm=json["pProperties"].as_vector();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            deserialize_struct(arr_LvUqkhm[gThvzcU].as_map(),pProperties[gThvzcU]);
            }();
        }
        }();

    PFN_vkGetDisplayModeProperties2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_instance_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_device_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_LvUqkhm=json::vector(*pPropertyCount);
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[gThvzcU]);
            arr_LvUqkhm[gThvzcU]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_LvUqkhm;}();


        json["stream_type"]=static_cast<int>(VKGETDISPLAYMODEPROPERTIES2KHR);
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilities2KHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
[&](){
            if (json["pDisplayPlaneInfo"].as_vector().size()==0){
                pDisplayPlaneInfo=NULL;
            return; }pDisplayPlaneInfo=(VkDisplayPlaneInfo2KHR*)malloc(1*sizeof(VkDisplayPlaneInfo2KHR));auto& arr_TBmwloa=json["pDisplayPlaneInfo"].as_vector();
        for(int OOfQKMi=0; OOfQKMi < 1; OOfQKMi++){
            [&](){
            deserialize_struct(arr_TBmwloa[OOfQKMi].as_map(),pDisplayPlaneInfo[OOfQKMi]);
            }();
        }
        }();
VkDisplayPlaneCapabilities2KHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilities2KHR*)malloc(1*sizeof(VkDisplayPlaneCapabilities2KHR));auto& arr_perBkIp=json["pCapabilities"].as_vector();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            deserialize_struct(arr_perBkIp[wDZGRHI].as_map(),pCapabilities[wDZGRHI]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=json::vector();
            return; }auto arr_rwBYAlG=json::vector(1);
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayPlaneInfo[iEdZMtQ]);
            arr_rwBYAlG[iEdZMtQ]=temp_map;
            return;
            }();
        }
        json["pDisplayPlaneInfo"]=arr_rwBYAlG;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_perBkIp=json::vector(1);
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[wDZGRHI]);
            arr_perBkIp[wDZGRHI]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_perBkIp;}();


        json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANECAPABILITIES2KHR);
        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferMemoryRequirementsInfo2*)malloc(1*sizeof(VkBufferMemoryRequirementsInfo2));auto& arr_ollhCFD=json["pInfo"].as_vector();
        for(int XMajJXL=0; XMajJXL < 1; XMajJXL++){
            [&](){
            deserialize_struct(arr_ollhCFD[XMajJXL].as_map(),pInfo[XMajJXL]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_xrBSgMU=json::vector(1);
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[XaVdoIX]);
            arr_xrBSgMU[XaVdoIX]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_xrBSgMU;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETBUFFERMEMORYREQUIREMENTS2);
        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageMemoryRequirementsInfo2));auto& arr_TCaTbMc=json["pInfo"].as_vector();
        for(int fOqTthF=0; fOqTthF < 1; fOqTthF++){
            [&](){
            deserialize_struct(arr_TCaTbMc[fOqTthF].as_map(),pInfo[fOqTthF]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_OVesMNt=json::vector(1);
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[xSwhhlO]);
            arr_OVesMNt[xSwhhlO]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_OVesMNt;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEMEMORYREQUIREMENTS2);
        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageSparseMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageSparseMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageSparseMemoryRequirementsInfo2));auto& arr_lAUqSdP=json["pInfo"].as_vector();
        for(int HzCSbsD=0; HzCSbsD < 1; HzCSbsD++){
            [&](){
            deserialize_struct(arr_lAUqSdP[HzCSbsD].as_map(),pInfo[HzCSbsD]);
            }();
        }
        }();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_vector();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            deserialize_struct(arr_vCRbLVA[QTojQNx].as_map(),pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_frlqZZl=json::vector(1);
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[DnuwqwS]);
            arr_frlqZZl[DnuwqwS]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_frlqZZl;}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_vCRbLVA=json::vector(*pSparseMemoryRequirementCount);
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[QTojQNx]);
            arr_vCRbLVA[QTojQNx]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_vCRbLVA;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGESPARSEMEMORYREQUIREMENTS2);
        writeToConn(json);
    }

    void handle_vkGetDeviceBufferMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceBufferMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceBufferMemoryRequirements*)malloc(1*sizeof(VkDeviceBufferMemoryRequirements));auto& arr_YweeoPK=json["pInfo"].as_vector();
        for(int AxMxoFf=0; AxMxoFf < 1; AxMxoFf++){
            [&](){
            deserialize_struct(arr_YweeoPK[AxMxoFf].as_map(),pInfo[AxMxoFf]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LbYKRdp=json::vector(1);
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[sabbuKR]);
            arr_LbYKRdp[sabbuKR]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LbYKRdp;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEBUFFERMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkGetDeviceImageMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));auto& arr_dPaAvfp=json["pInfo"].as_vector();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            deserialize_struct(arr_dPaAvfp[xoxwYjr].as_map(),pInfo[xoxwYjr]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_dGiJKQX=json::vector(1);
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[Hfcgcwr]);
            arr_dGiJKQX[Hfcgcwr]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_dGiJKQX;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGEMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkGetDeviceImageSparseMemoryRequirements(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));auto& arr_dPaAvfp=json["pInfo"].as_vector();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            deserialize_struct(arr_dPaAvfp[xoxwYjr].as_map(),pInfo[xoxwYjr]);
            }();
        }
        }();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_vector();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            deserialize_struct(arr_vCRbLVA[QTojQNx].as_map(),pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_dGiJKQX=json::vector(1);
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[Hfcgcwr]);
            arr_dGiJKQX[Hfcgcwr]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_dGiJKQX;}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_vCRbLVA=json::vector(*pSparseMemoryRequirementCount);
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[QTojQNx]);
            arr_vCRbLVA[QTojQNx]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_vCRbLVA;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS);
        writeToConn(json);
    }

    void handle_vkCreateSamplerYcbcrConversion(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSamplerYcbcrConversionCreateInfo*)malloc(1*sizeof(VkSamplerYcbcrConversionCreateInfo));auto& arr_oCKmosw=json["pCreateInfo"].as_vector();
        for(int LUUMfzS=0; LUUMfzS < 1; LUUMfzS++){
            [&](){
            deserialize_struct(arr_oCKmosw[LUUMfzS].as_map(),pCreateInfo[LUUMfzS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSamplerYcbcrConversion* pYcbcrConversion;
[&](){
            if (json["pYcbcrConversion"].as_vector().size()==0){
                pYcbcrConversion=NULL;
            return; }pYcbcrConversion=(VkSamplerYcbcrConversion*)malloc(1*sizeof(VkSamplerYcbcrConversion));auto& arr_joRRIst=json["pYcbcrConversion"].as_vector();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();

    PFN_vkCreateSamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_instance_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_device_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_kLHhxUL=json::vector(1);
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[zgqBgkX]);
            arr_kLHhxUL[zgqBgkX]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_kLHhxUL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=json::vector();
            return; }auto arr_joRRIst=json::vector(1);
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        json["pYcbcrConversion"]=arr_joRRIst;}();


        json["stream_type"]=static_cast<int>(VKCREATESAMPLERYCBCRCONVERSION);
        writeToConn(json);
    }

    void handle_vkDestroySamplerYcbcrConversion(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerYcbcrConversion ycbcrConversion;
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_instance_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_device_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }  
    
{
call_function(device, ycbcrConversion, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSAMPLERYCBCRCONVERSION);
        writeToConn(json);
    }

    void handle_vkGetDeviceQueue2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceQueueInfo2* pQueueInfo;
[&](){
            if (json["pQueueInfo"].as_vector().size()==0){
                pQueueInfo=NULL;
            return; }pQueueInfo=(VkDeviceQueueInfo2*)malloc(1*sizeof(VkDeviceQueueInfo2));auto& arr_GihFKhN=json["pQueueInfo"].as_vector();
        for(int cWpAFXW=0; cWpAFXW < 1; cWpAFXW++){
            [&](){
            deserialize_struct(arr_GihFKhN[cWpAFXW].as_map(),pQueueInfo[cWpAFXW]);
            }();
        }
        }();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].as_vector().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));auto& arr_rYZbcEA=json["pQueue"].as_vector();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceQueue2)get_instance_proc_addr(parent,"vkGetDeviceQueue2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceQueue2)get_device_proc_addr(parent,"vkGetDeviceQueue2");
    }  
    
{
call_function(device, pQueueInfo, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=json::vector();
            return; }auto arr_bNCRimR=json::vector(1);
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueInfo[ubuvbaB]);
            arr_bNCRimR[ubuvbaB]=temp_map;
            return;
            }();
        }
        json["pQueueInfo"]=arr_bNCRimR;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=json::vector();
            return; }auto arr_rYZbcEA=json::vector(1);
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        json["pQueue"]=arr_rYZbcEA;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEQUEUE2);
        writeToConn(json);
    }

    void handle_vkCreateValidationCacheEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkValidationCacheCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkValidationCacheCreateInfoEXT*)malloc(1*sizeof(VkValidationCacheCreateInfoEXT));auto& arr_xouGZzH=json["pCreateInfo"].as_vector();
        for(int kadSIIj=0; kadSIIj < 1; kadSIIj++){
            [&](){
            deserialize_struct(arr_xouGZzH[kadSIIj].as_map(),pCreateInfo[kadSIIj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkValidationCacheEXT* pValidationCache;
[&](){
            if (json["pValidationCache"].as_vector().size()==0){
                pValidationCache=NULL;
            return; }pValidationCache=(VkValidationCacheEXT*)malloc(1*sizeof(VkValidationCacheEXT));auto& arr_oYoDWhC=json["pValidationCache"].as_vector();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();

    PFN_vkCreateValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateValidationCacheEXT)get_instance_proc_addr(parent,"vkCreateValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateValidationCacheEXT)get_device_proc_addr(parent,"vkCreateValidationCacheEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pValidationCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_ZCXiwLp=json::vector(1);
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XeWuaSR]);
            arr_ZCXiwLp[XeWuaSR]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_ZCXiwLp;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=json::vector();
            return; }auto arr_oYoDWhC=json::vector(1);
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        json["pValidationCache"]=arr_oYoDWhC;}();


        json["stream_type"]=static_cast<int>(VKCREATEVALIDATIONCACHEEXT);
        writeToConn(json);
    }

    void handle_vkDestroyValidationCacheEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyValidationCacheEXT)get_instance_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyValidationCacheEXT)get_device_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }  
    
{
call_function(device, validationCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYVALIDATIONCACHEEXT);
        writeToConn(json);
    }

    void handle_vkGetValidationCacheDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetValidationCacheDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetValidationCacheDataEXT)get_instance_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetValidationCacheDataEXT)get_device_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, validationCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETVALIDATIONCACHEDATAEXT);
        writeToConn(json);
    }

    void handle_vkMergeValidationCachesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT dstCache;
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){
            if (json["srcCacheCount"].is_uint64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_uint64_t());
            }else if (json["srcCacheCount"].is_int64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_int64_t());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_double());
            }
            }();
 VkValidationCacheEXT* pSrcCaches;
[&](){
            if (json["pSrcCaches"].as_vector().size()==0){
                pSrcCaches=NULL;
            return; }pSrcCaches=(VkValidationCacheEXT*)malloc(srcCacheCount*sizeof(VkValidationCacheEXT));auto& arr_viZfWEe=json["pSrcCaches"].as_vector();
        for(int svBdHjE=0; svBdHjE < srcCacheCount; svBdHjE++){
            [&](){deserialize_VkValidationCacheEXT(arr_viZfWEe[svBdHjE], pSrcCaches[svBdHjE]);}();
        }
        }();

    PFN_vkMergeValidationCachesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkMergeValidationCachesEXT)get_instance_proc_addr(parent,"vkMergeValidationCachesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkMergeValidationCachesEXT)get_device_proc_addr(parent,"vkMergeValidationCachesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=static_cast<uint>(srcCacheCount);}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=json::vector();
            return; }auto arr_xXUlTaQ=json::vector(srcCacheCount);
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        json["pSrcCaches"]=arr_xXUlTaQ;}();


        json["stream_type"]=static_cast<int>(VKMERGEVALIDATIONCACHESEXT);
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSupport(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));auto& arr_oELBvJU=json["pCreateInfo"].as_vector();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            deserialize_struct(arr_oELBvJU[RmYFXzA].as_map(),pCreateInfo[RmYFXzA]);
            }();
        }
        }();
VkDescriptorSetLayoutSupport* pSupport;
[&](){
            if (json["pSupport"].as_vector().size()==0){
                pSupport=NULL;
            return; }pSupport=(VkDescriptorSetLayoutSupport*)malloc(1*sizeof(VkDescriptorSetLayoutSupport));auto& arr_xgzGluH=json["pSupport"].as_vector();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            deserialize_struct(arr_xgzGluH[UvZyHDI].as_map(),pSupport[UvZyHDI]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSupport call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }  
    
{
call_function(device, pCreateInfo, pSupport);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dFRsqIW=json::vector(1);
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tUGauKK]);
            arr_dFRsqIW[tUGauKK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dFRsqIW;}();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=json::vector();
            return; }auto arr_xgzGluH=json::vector(1);
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSupport[UvZyHDI]);
            arr_xgzGluH[UvZyHDI]=temp_map;
            return;
            }();
        }
        json["pSupport"]=arr_xgzGluH;}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTSUPPORT);
        writeToConn(json);
    }

    void handle_vkGetShaderInfoAMD(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
VkShaderStageFlagBits shaderStage;
[&](){[&](){int temp_nGZQHxq;[&](){
            if (json["shaderStage"].is_uint64_t()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_uint64_t());
            }else if (json["shaderStage"].is_int64_t()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_int64_t());
            }else{
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_double());
            }
            }();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
VkShaderInfoTypeAMD infoType;
[&](){[&](){int temp_nNfHNkf;[&](){
            if (json["infoType"].is_uint64_t()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_uint64_t());
            }else if (json["infoType"].is_int64_t()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_int64_t());
            }else{
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_double());
            }
            }();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
size_t* pInfoSize;
[&](){
            if (json["pInfoSize"].as_vector().size()==0){
                pInfoSize=NULL;
            return; }pInfoSize=(size_t*)malloc(1*sizeof(size_t));auto& arr_ouDPuUh=json["pInfoSize"].as_vector();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){
            if (arr_ouDPuUh[wpUCmEy].is_uint64_t()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_uint64_t());
            }else if (arr_ouDPuUh[wpUCmEy].is_int64_t()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_int64_t());
            }else{
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_double());
            }
            }();
        }
        }();
void* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].as_vector().size()==0){
                temp_ziBtDwK=NULL;
            return; }temp_ziBtDwK=(char*)malloc(*pInfoSize*sizeof(char));auto& arr_UHSCjHI=json["pInfo"].as_vector();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){
            if (arr_UHSCjHI[rexTFCi].is_uint64_t()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_uint64_t());
            }else if (arr_UHSCjHI[rexTFCi].is_int64_t()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_int64_t());
            }else{
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_double());
            }
            }();
        }
        }();pInfo=temp_ziBtDwK;}();

    PFN_vkGetShaderInfoAMD call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetShaderInfoAMD)get_instance_proc_addr(parent,"vkGetShaderInfoAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetShaderInfoAMD)get_device_proc_addr(parent,"vkGetShaderInfoAMD");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=static_cast<int>(shaderStage);}();}();}();
[&](){[&](){[&](){json["infoType"]=static_cast<int>(infoType);}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=json::vector();
            return; }auto arr_ouDPuUh=json::vector(1);
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=static_cast<int>(pInfoSize[wpUCmEy]);}();
        }
        json["pInfoSize"]=arr_ouDPuUh;}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UHSCjHI=json::vector(*pInfoSize);
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){arr_UHSCjHI[rexTFCi]=static_cast<uint>(((char*)(pInfo))[rexTFCi]);}();
        }
        json["pInfo"]=arr_UHSCjHI;}();}();


        json["stream_type"]=static_cast<int>(VKGETSHADERINFOAMD);
        writeToConn(json);
    }

    void handle_vkSetLocalDimmingAMD(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapChain;
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
VkBool32 localDimmingEnable;
[&](){uint32_t temp_jfGMipq;[&](){
            if (json["localDimmingEnable"].is_uint64_t()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_uint64_t());
            }else if (json["localDimmingEnable"].is_int64_t()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_int64_t());
            }else{
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_double());
            }
            }();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

    PFN_vkSetLocalDimmingAMD call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetLocalDimmingAMD)get_instance_proc_addr(parent,"vkSetLocalDimmingAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetLocalDimmingAMD)get_device_proc_addr(parent,"vkSetLocalDimmingAMD");
    }  
    
{
call_function(device, swapChain, localDimmingEnable);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=static_cast<uint>(localDimmingEnable);}();}();


        json["stream_type"]=static_cast<int>(VKSETLOCALDIMMINGAMD);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pTimeDomainCount;
[&](){
            if (json["pTimeDomainCount"].as_vector().size()==0){
                pTimeDomainCount=NULL;
            return; }pTimeDomainCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_siSbERs=json["pTimeDomainCount"].as_vector();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){
            if (arr_siSbERs[xFQhUzA].is_uint64_t()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_uint64_t());
            }else if (arr_siSbERs[xFQhUzA].is_int64_t()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_int64_t());
            }else{
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_double());
            }
            }();
        }
        }();
VkTimeDomainEXT* pTimeDomains;
[&](){
            if (json["pTimeDomains"].as_vector().size()==0){
                pTimeDomains=NULL;
            return; }pTimeDomains=(VkTimeDomainEXT*)malloc(*pTimeDomainCount*sizeof(VkTimeDomainEXT));auto& arr_fMkUaJq=json["pTimeDomains"].as_vector();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){
            if (arr_fMkUaJq[ZiXuFCL].is_uint64_t()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_uint64_t());
            }else if (arr_fMkUaJq[ZiXuFCL].is_int64_t()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_int64_t());
            }else{
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_double());
            }
            }();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pTimeDomainCount, pTimeDomains);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=json::vector();
            return; }auto arr_siSbERs=json::vector(1);
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=static_cast<uint>(pTimeDomainCount[xFQhUzA]);}();
        }
        json["pTimeDomainCount"]=arr_siSbERs;}();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=json::vector();
            return; }auto arr_fMkUaJq=json::vector(*pTimeDomainCount);
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=static_cast<int>(pTimeDomains[ZiXuFCL]);}();}();}();
        }
        json["pTimeDomains"]=arr_fMkUaJq;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT);
        writeToConn(json);
    }

    void handle_vkGetCalibratedTimestampsEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t timestampCount;
[&](){
            if (json["timestampCount"].is_uint64_t()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_uint64_t());
            }else if (json["timestampCount"].is_int64_t()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_int64_t());
            }else{
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_double());
            }
            }();
 VkCalibratedTimestampInfoEXT* pTimestampInfos;
[&](){
            if (json["pTimestampInfos"].as_vector().size()==0){
                pTimestampInfos=NULL;
            return; }pTimestampInfos=(VkCalibratedTimestampInfoEXT*)malloc(timestampCount*sizeof(VkCalibratedTimestampInfoEXT));auto& arr_nEtDxWp=json["pTimestampInfos"].as_vector();
        for(int GetmFjY=0; GetmFjY < timestampCount; GetmFjY++){
            [&](){
            deserialize_struct(arr_nEtDxWp[GetmFjY].as_map(),pTimestampInfos[GetmFjY]);
            }();
        }
        }();
uint64_t* pTimestamps;
[&](){
            if (json["pTimestamps"].as_vector().size()==0){
                pTimestamps=NULL;
            return; }pTimestamps=(uint64_t*)malloc(timestampCount*sizeof(uint64_t));auto& arr_CHzcvgg=json["pTimestamps"].as_vector();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){
            if (arr_CHzcvgg[ptqlrVt].is_uint64_t()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_uint64_t());
            }else if (arr_CHzcvgg[ptqlrVt].is_int64_t()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_int64_t());
            }else{
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_double());
            }
            }();
        }
        }();
uint64_t* pMaxDeviation;
[&](){
            if (json["pMaxDeviation"].as_vector().size()==0){
                pMaxDeviation=NULL;
            return; }pMaxDeviation=(uint64_t*)malloc(1*sizeof(uint64_t));auto& arr_zQmthvJ=json["pMaxDeviation"].as_vector();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){
            if (arr_zQmthvJ[FUkBved].is_uint64_t()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_uint64_t());
            }else if (arr_zQmthvJ[FUkBved].is_int64_t()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_int64_t());
            }else{
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_double());
            }
            }();
        }
        }();

    PFN_vkGetCalibratedTimestampsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_instance_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_device_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }  
    
VkResult  result;
{
result=call_function(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=static_cast<uint>(timestampCount);}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=json::vector();
            return; }auto arr_XQeyMsT=json::vector(timestampCount);
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTimestampInfos[aXwwgcz]);
            arr_XQeyMsT[aXwwgcz]=temp_map;
            return;
            }();
        }
        json["pTimestampInfos"]=arr_XQeyMsT;}();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=json::vector();
            return; }auto arr_CHzcvgg=json::vector(timestampCount);
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=static_cast<uint>(pTimestamps[ptqlrVt]);}();
        }
        json["pTimestamps"]=arr_CHzcvgg;}();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=json::vector();
            return; }auto arr_zQmthvJ=json::vector(1);
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=static_cast<uint>(pMaxDeviation[FUkBved]);}();
        }
        json["pMaxDeviation"]=arr_zQmthvJ;}();


        json["stream_type"]=static_cast<int>(VKGETCALIBRATEDTIMESTAMPSEXT);
        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectNameEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugUtilsObjectNameInfoEXT* pNameInfo;
[&](){
            if (json["pNameInfo"].as_vector().size()==0){
                pNameInfo=NULL;
            return; }pNameInfo=(VkDebugUtilsObjectNameInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectNameInfoEXT));auto& arr_xezbRdt=json["pNameInfo"].as_vector();
        for(int bpyMrKI=0; bpyMrKI < 1; bpyMrKI++){
            [&](){
            deserialize_struct(arr_xezbRdt[bpyMrKI].as_map(),pNameInfo[bpyMrKI]);
            }();
        }
        }();

    PFN_vkSetDebugUtilsObjectNameEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=json::vector();
            return; }auto arr_gpHzyjV=json::vector(1);
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pNameInfo[sXDrIfX]);
            arr_gpHzyjV[sXDrIfX]=temp_map;
            return;
            }();
        }
        json["pNameInfo"]=arr_gpHzyjV;}();


        json["stream_type"]=static_cast<int>(VKSETDEBUGUTILSOBJECTNAMEEXT);
        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectTagEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugUtilsObjectTagInfoEXT* pTagInfo;
[&](){
            if (json["pTagInfo"].as_vector().size()==0){
                pTagInfo=NULL;
            return; }pTagInfo=(VkDebugUtilsObjectTagInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectTagInfoEXT));auto& arr_Ltvhugt=json["pTagInfo"].as_vector();
        for(int kYwKoxa=0; kYwKoxa < 1; kYwKoxa++){
            [&](){
            deserialize_struct(arr_Ltvhugt[kYwKoxa].as_map(),pTagInfo[kYwKoxa]);
            }();
        }
        }();

    PFN_vkSetDebugUtilsObjectTagEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=json::vector();
            return; }auto arr_jMraQzd=json::vector(1);
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTagInfo[lQZzjnQ]);
            arr_jMraQzd[lQZzjnQ]=temp_map;
            return;
            }();
        }
        json["pTagInfo"]=arr_jMraQzd;}();


        json["stream_type"]=static_cast<int>(VKSETDEBUGUTILSOBJECTTAGEXT);
        writeToConn(json);
    }

    void handle_vkQueueBeginDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].as_vector().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));auto& arr_dixLKcm=json["pLabelInfo"].as_vector();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            deserialize_struct(arr_dixLKcm[lWNBzGj].as_map(),pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkQueueBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();


        json["stream_type"]=static_cast<int>(VKQUEUEBEGINDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkQueueEndDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }  
    
{
call_function(queue);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();


        json["stream_type"]=static_cast<int>(VKQUEUEENDDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkQueueInsertDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].as_vector().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));auto& arr_dixLKcm=json["pLabelInfo"].as_vector();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            deserialize_struct(arr_dixLKcm[lWNBzGj].as_map(),pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkQueueInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();


        json["stream_type"]=static_cast<int>(VKQUEUEINSERTDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkCmdBeginDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].as_vector().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));auto& arr_dixLKcm=json["pLabelInfo"].as_vector();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            deserialize_struct(arr_dixLKcm[lWNBzGj].as_map(),pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkCmdBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkCmdEndDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDENDDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkCmdInsertDebugUtilsLabelEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].as_vector().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));auto& arr_dixLKcm=json["pLabelInfo"].as_vector();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            deserialize_struct(arr_dixLKcm[lWNBzGj].as_map(),pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkCmdInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();


        json["stream_type"]=static_cast<int>(VKCMDINSERTDEBUGUTILSLABELEXT);
        writeToConn(json);
    }

    void handle_vkCreateDebugUtilsMessengerEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDebugUtilsMessengerCreateInfoEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCreateInfoEXT));auto& arr_kPYPRLp=json["pCreateInfo"].as_vector();
        for(int XvRVXaf=0; XvRVXaf < 1; XvRVXaf++){
            [&](){
            deserialize_struct(arr_kPYPRLp[XvRVXaf].as_map(),pCreateInfo[XvRVXaf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDebugUtilsMessengerEXT* pMessenger;
[&](){
            if (json["pMessenger"].as_vector().size()==0){
                pMessenger=NULL;
            return; }pMessenger=(VkDebugUtilsMessengerEXT*)malloc(1*sizeof(VkDebugUtilsMessengerEXT));auto& arr_INDwqtI=json["pMessenger"].as_vector();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();

    PFN_vkCreateDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pMessenger);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_alrnjyY=json::vector(1);
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[uDOYkhP]);
            arr_alrnjyY[uDOYkhP]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_alrnjyY;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=json::vector();
            return; }auto arr_INDwqtI=json::vector(1);
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        json["pMessenger"]=arr_INDwqtI;}();


        json["stream_type"]=static_cast<int>(VKCREATEDEBUGUTILSMESSENGEREXT);
        writeToConn(json);
    }

    void handle_vkDestroyDebugUtilsMessengerEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessengerEXT messenger;
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }  
    
{
call_function(instance, messenger, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDEBUGUTILSMESSENGEREXT);
        writeToConn(json);
    }

    void handle_vkSubmitDebugUtilsMessageEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
[&](){[&](){int temp_UpocUQR;[&](){
            if (json["messageSeverity"].is_uint64_t()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_uint64_t());
            }else if (json["messageSeverity"].is_int64_t()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_int64_t());
            }else{
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_double());
            }
            }();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
VkDebugUtilsMessageTypeFlagsEXT messageTypes;
[&](){[&](){int temp_vbjSEUE;[&](){
            if (json["messageTypes"].is_uint64_t()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_uint64_t());
            }else if (json["messageTypes"].is_int64_t()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_int64_t());
            }else{
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_double());
            }
            }();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();
 VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
[&](){
            if (json["pCallbackData"].as_vector().size()==0){
                pCallbackData=NULL;
            return; }pCallbackData=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCallbackDataEXT));auto& arr_MlNAOAx=json["pCallbackData"].as_vector();
        for(int EdtNsto=0; EdtNsto < 1; EdtNsto++){
            [&](){
            deserialize_struct(arr_MlNAOAx[EdtNsto].as_map(),pCallbackData[EdtNsto]);
            }();
        }
        }();

    PFN_vkSubmitDebugUtilsMessageEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_instance_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_device_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }  
    
{
call_function(instance, messageSeverity, messageTypes, pCallbackData);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=static_cast<int>(messageSeverity);}();}();}();
[&](){[&](){[&](){json["messageTypes"]=static_cast<int>(messageTypes);}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=json::vector();
            return; }auto arr_kahfHKb=json::vector(1);
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallbackData[YuXULtv]);
            arr_kahfHKb[YuXULtv]=temp_map;
            return;
            }();
        }
        json["pCallbackData"]=arr_kahfHKb;}();


        json["stream_type"]=static_cast<int>(VKSUBMITDEBUGUTILSMESSAGEEXT);
        writeToConn(json);
    }

    void handle_vkGetMemoryHostPointerPropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_uint64_t());
            }else if (json["handleType"].is_int64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_int64_t());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
 void* pHostPointer;
[&](){
            if (json["pHostPointer"].as_vector().size()==0){
                pHostPointer=NULL;
            return; }char* temp_EiZqusU;[&](){
            if (json["pHostPointer"].as_vector().size()==0){
                temp_EiZqusU=NULL;
            return; }temp_EiZqusU=(char*)malloc(json["pHostPointer"].as_vector().size()*sizeof(char));auto& arr_FmrmuUL=json["pHostPointer"].as_vector();
        for(int SfNZViD=0; SfNZViD < json["pHostPointer"].as_vector().size(); SfNZViD++){
            [&](){
            if (arr_FmrmuUL[SfNZViD].is_uint64_t()){
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].as_uint64_t());
            }else if (arr_FmrmuUL[SfNZViD].is_int64_t()){
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].as_int64_t());
            }else{
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].as_double());
            }
            }();
        }
        }();pHostPointer=temp_EiZqusU;}();
VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
[&](){
            if (json["pMemoryHostPointerProperties"].as_vector().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }pMemoryHostPointerProperties=(VkMemoryHostPointerPropertiesEXT*)malloc(1*sizeof(VkMemoryHostPointerPropertiesEXT));auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].as_vector();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            deserialize_struct(arr_CBNxdHG[hqDeAHT].as_map(),pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();

    PFN_vkGetMemoryHostPointerPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_instance_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_device_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=static_cast<int>(handleType);}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=json::vector();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=json::vector();
            return; }auto arr_iKHPNio=json::vector(strlen(((char*)(pHostPointer)))+1);
        for(int UFxRrhm=0; UFxRrhm < strlen(((char*)(pHostPointer)))+1; UFxRrhm++){
            [&](){arr_iKHPNio[UFxRrhm]=static_cast<uint>(((char*)(pHostPointer))[UFxRrhm]);}();
        }
        json["pHostPointer"]=arr_iKHPNio;}();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=json::vector();
            return; }auto arr_CBNxdHG=json::vector(1);
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryHostPointerProperties[hqDeAHT]);
            arr_CBNxdHG[hqDeAHT]=temp_map;
            return;
            }();
        }
        json["pMemoryHostPointerProperties"]=arr_CBNxdHG;}();


        json["stream_type"]=static_cast<int>(VKGETMEMORYHOSTPOINTERPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarkerAMD(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_uint64_t());
            }else if (json["pipelineStage"].is_int64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_int64_t());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){
            if (json["marker"].is_uint64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_uint64_t());
            }else if (json["marker"].is_int64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_int64_t());
            }else{
                marker=static_cast<uint32_t>(json["marker"].as_double());
            }
            }();

    PFN_vkCmdWriteBufferMarkerAMD call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }  
    
{
call_function(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=static_cast<int>(pipelineStage);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){json["marker"]=static_cast<uint>(marker);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITEBUFFERMARKERAMD);
        writeToConn(json);
    }

    void handle_vkCreateRenderPass2(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderPassCreateInfo2* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkRenderPassCreateInfo2*)malloc(1*sizeof(VkRenderPassCreateInfo2));auto& arr_wVuIjAr=json["pCreateInfo"].as_vector();
        for(int LBnjMyA=0; LBnjMyA < 1; LBnjMyA++){
            [&](){
            deserialize_struct(arr_wVuIjAr[LBnjMyA].as_map(),pCreateInfo[LBnjMyA]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].as_vector().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));auto& arr_ZwdXTfx=json["pRenderPass"].as_vector();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateRenderPass2)get_instance_proc_addr(parent,"vkCreateRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateRenderPass2)get_device_proc_addr(parent,"vkCreateRenderPass2");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_cDssBor=json::vector(1);
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[SgbVidQ]);
            arr_cDssBor[SgbVidQ]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_cDssBor;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=json::vector();
            return; }auto arr_ZwdXTfx=json::vector(1);
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        json["pRenderPass"]=arr_ZwdXTfx;}();


        json["stream_type"]=static_cast<int>(VKCREATERENDERPASS2);
        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderPassBeginInfo* pRenderPassBegin;
[&](){
            if (json["pRenderPassBegin"].as_vector().size()==0){
                pRenderPassBegin=NULL;
            return; }pRenderPassBegin=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));auto& arr_DvmhBAI=json["pRenderPassBegin"].as_vector();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            deserialize_struct(arr_DvmhBAI[MzTximI].as_map(),pRenderPassBegin[MzTximI]);
            }();
        }
        }();
 VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){
            if (json["pSubpassBeginInfo"].as_vector().size()==0){
                pSubpassBeginInfo=NULL;
            return; }pSubpassBeginInfo=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));auto& arr_EzXVEdi=json["pSubpassBeginInfo"].as_vector();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            deserialize_struct(arr_EzXVEdi[nrSIqlz].as_map(),pSubpassBeginInfo[nrSIqlz]);
            }();
        }
        }();

    PFN_vkCmdBeginRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginRenderPass2)get_instance_proc_addr(parent,"vkCmdBeginRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginRenderPass2)get_device_proc_addr(parent,"vkCmdBeginRenderPass2");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=json::vector();
            return; }auto arr_XtnTubd=json::vector(1);
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderPassBegin[lCAvoJt]);
            arr_XtnTubd[lCAvoJt]=temp_map;
            return;
            }();
        }
        json["pRenderPassBegin"]=arr_XtnTubd;}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=json::vector();
            return; }auto arr_yxkVVDb=json::vector(1);
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassBeginInfo[nzkBQUL]);
            arr_yxkVVDb[nzkBQUL]=temp_map;
            return;
            }();
        }
        json["pSubpassBeginInfo"]=arr_yxkVVDb;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERPASS2);
        writeToConn(json);
    }

    void handle_vkCmdNextSubpass2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){
            if (json["pSubpassBeginInfo"].as_vector().size()==0){
                pSubpassBeginInfo=NULL;
            return; }pSubpassBeginInfo=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));auto& arr_EzXVEdi=json["pSubpassBeginInfo"].as_vector();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            deserialize_struct(arr_EzXVEdi[nrSIqlz].as_map(),pSubpassBeginInfo[nrSIqlz]);
            }();
        }
        }();
 VkSubpassEndInfo* pSubpassEndInfo;
[&](){
            if (json["pSubpassEndInfo"].as_vector().size()==0){
                pSubpassEndInfo=NULL;
            return; }pSubpassEndInfo=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));auto& arr_GcsVuns=json["pSubpassEndInfo"].as_vector();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            deserialize_struct(arr_GcsVuns[rFLLcAK].as_map(),pSubpassEndInfo[rFLLcAK]);
            }();
        }
        }();

    PFN_vkCmdNextSubpass2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdNextSubpass2)get_instance_proc_addr(parent,"vkCmdNextSubpass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdNextSubpass2)get_device_proc_addr(parent,"vkCmdNextSubpass2");
    }  
    
{
call_function(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=json::vector();
            return; }auto arr_yxkVVDb=json::vector(1);
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassBeginInfo[nzkBQUL]);
            arr_yxkVVDb[nzkBQUL]=temp_map;
            return;
            }();
        }
        json["pSubpassBeginInfo"]=arr_yxkVVDb;}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=json::vector();
            return; }auto arr_mmmwoMH=json::vector(1);
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassEndInfo[oMdHEHu]);
            arr_mmmwoMH[oMdHEHu]=temp_map;
            return;
            }();
        }
        json["pSubpassEndInfo"]=arr_mmmwoMH;}();


        json["stream_type"]=static_cast<int>(VKCMDNEXTSUBPASS2);
        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSubpassEndInfo* pSubpassEndInfo;
[&](){
            if (json["pSubpassEndInfo"].as_vector().size()==0){
                pSubpassEndInfo=NULL;
            return; }pSubpassEndInfo=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));auto& arr_GcsVuns=json["pSubpassEndInfo"].as_vector();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            deserialize_struct(arr_GcsVuns[rFLLcAK].as_map(),pSubpassEndInfo[rFLLcAK]);
            }();
        }
        }();

    PFN_vkCmdEndRenderPass2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndRenderPass2)get_instance_proc_addr(parent,"vkCmdEndRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndRenderPass2)get_device_proc_addr(parent,"vkCmdEndRenderPass2");
    }  
    
{
call_function(commandBuffer, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=json::vector();
            return; }auto arr_mmmwoMH=json::vector(1);
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassEndInfo[oMdHEHu]);
            arr_mmmwoMH[oMdHEHu]=temp_map;
            return;
            }();
        }
        json["pSubpassEndInfo"]=arr_mmmwoMH;}();


        json["stream_type"]=static_cast<int>(VKCMDENDRENDERPASS2);
        writeToConn(json);
    }

    void handle_vkGetSemaphoreCounterValue(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
uint64_t* pValue;
[&](){
            if (json["pValue"].as_vector().size()==0){
                pValue=NULL;
            return; }pValue=(uint64_t*)malloc(1*sizeof(uint64_t));auto& arr_xnMrErb=json["pValue"].as_vector();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){
            if (arr_xnMrErb[fdUIVMD].is_uint64_t()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_uint64_t());
            }else if (arr_xnMrErb[fdUIVMD].is_int64_t()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_int64_t());
            }else{
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_double());
            }
            }();
        }
        }();

    PFN_vkGetSemaphoreCounterValue call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSemaphoreCounterValue)get_instance_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSemaphoreCounterValue)get_device_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }  
    
VkResult  result;
{
result=call_function(device, semaphore, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=json::vector();
            return; }auto arr_xnMrErb=json::vector(1);
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=static_cast<uint>(pValue[fdUIVMD]);}();
        }
        json["pValue"]=arr_xnMrErb;}();


        json["stream_type"]=static_cast<int>(VKGETSEMAPHORECOUNTERVALUE);
        writeToConn(json);
    }

    void handle_vkWaitSemaphores(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreWaitInfo* pWaitInfo;
[&](){
            if (json["pWaitInfo"].as_vector().size()==0){
                pWaitInfo=NULL;
            return; }pWaitInfo=(VkSemaphoreWaitInfo*)malloc(1*sizeof(VkSemaphoreWaitInfo));auto& arr_saOfReP=json["pWaitInfo"].as_vector();
        for(int PdcqhvB=0; PdcqhvB < 1; PdcqhvB++){
            [&](){
            deserialize_struct(arr_saOfReP[PdcqhvB].as_map(),pWaitInfo[PdcqhvB]);
            }();
        }
        }();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();

    PFN_vkWaitSemaphores call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkWaitSemaphores)get_instance_proc_addr(parent,"vkWaitSemaphores");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkWaitSemaphores)get_device_proc_addr(parent,"vkWaitSemaphores");
    }  
    
VkResult  result;
{
result=call_function(device, pWaitInfo, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=json::vector();
            return; }auto arr_xzakrWz=json::vector(1);
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pWaitInfo[hsOLCWG]);
            arr_xzakrWz[hsOLCWG]=temp_map;
            return;
            }();
        }
        json["pWaitInfo"]=arr_xzakrWz;}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();


        json["stream_type"]=static_cast<int>(VKWAITSEMAPHORES);
        writeToConn(json);
    }

    void handle_vkSignalSemaphore(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreSignalInfo* pSignalInfo;
[&](){
            if (json["pSignalInfo"].as_vector().size()==0){
                pSignalInfo=NULL;
            return; }pSignalInfo=(VkSemaphoreSignalInfo*)malloc(1*sizeof(VkSemaphoreSignalInfo));auto& arr_NpBehDR=json["pSignalInfo"].as_vector();
        for(int AsjxdFQ=0; AsjxdFQ < 1; AsjxdFQ++){
            [&](){
            deserialize_struct(arr_NpBehDR[AsjxdFQ].as_map(),pSignalInfo[AsjxdFQ]);
            }();
        }
        }();

    PFN_vkSignalSemaphore call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSignalSemaphore)get_instance_proc_addr(parent,"vkSignalSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSignalSemaphore)get_device_proc_addr(parent,"vkSignalSemaphore");
    }  
    
VkResult  result;
{
result=call_function(device, pSignalInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=json::vector();
            return; }auto arr_WdRQTJS=json::vector(1);
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSignalInfo[MYLvJyX]);
            arr_WdRQTJS[MYLvJyX]=temp_map;
            return;
            }();
        }
        json["pSignalInfo"]=arr_WdRQTJS;}();


        json["stream_type"]=static_cast<int>(VKSIGNALSEMAPHORE);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectCount(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawIndirectCount call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECTCOUNT);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirectCount(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawIndexedIndirectCount call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXEDINDIRECTCOUNT);
        writeToConn(json);
    }

    void handle_vkCmdSetCheckpointNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 void* pCheckpointMarker;
[&](){
            if (json["pCheckpointMarker"].as_vector().size()==0){
                pCheckpointMarker=NULL;
            return; }char* temp_AspjKUC;[&](){
            if (json["pCheckpointMarker"].as_vector().size()==0){
                temp_AspjKUC=NULL;
            return; }temp_AspjKUC=(char*)malloc(json["pCheckpointMarker"].as_vector().size()*sizeof(char));auto& arr_xxgFDIv=json["pCheckpointMarker"].as_vector();
        for(int ymeyWZR=0; ymeyWZR < json["pCheckpointMarker"].as_vector().size(); ymeyWZR++){
            [&](){
            if (arr_xxgFDIv[ymeyWZR].is_uint64_t()){
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].as_uint64_t());
            }else if (arr_xxgFDIv[ymeyWZR].is_int64_t()){
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].as_int64_t());
            }else{
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].as_double());
            }
            }();
        }
        }();pCheckpointMarker=temp_AspjKUC;}();

    PFN_vkCmdSetCheckpointNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCheckpointNV)get_instance_proc_addr(parent,"vkCmdSetCheckpointNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCheckpointNV)get_device_proc_addr(parent,"vkCmdSetCheckpointNV");
    }  
    
{
call_function(commandBuffer, pCheckpointMarker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=json::vector();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=json::vector();
            return; }auto arr_eBRjtYz=json::vector(strlen(((char*)(pCheckpointMarker)))+1);
        for(int VYoknaS=0; VYoknaS < strlen(((char*)(pCheckpointMarker)))+1; VYoknaS++){
            [&](){arr_eBRjtYz[VYoknaS]=static_cast<uint>(((char*)(pCheckpointMarker))[VYoknaS]);}();
        }
        json["pCheckpointMarker"]=arr_eBRjtYz;}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCHECKPOINTNV);
        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointDataNV(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].as_vector().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_vector();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_uint64_t());
            }else if (arr_LsYqVIK[lgasnOP].is_int64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_int64_t());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_double());
            }
            }();
        }
        }();
VkCheckpointDataNV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].as_vector().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointDataNV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointDataNV));auto& arr_gxwhODc=json["pCheckpointData"].as_vector();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            deserialize_struct(arr_gxwhODc[TfFHlNo].as_map(),pCheckpointData[TfFHlNo]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointDataNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_instance_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_device_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=json::vector();
            return; }auto arr_LsYqVIK=json::vector(1);
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=static_cast<uint>(pCheckpointDataCount[lgasnOP]);}();
        }
        json["pCheckpointDataCount"]=arr_LsYqVIK;}();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=json::vector();
            return; }auto arr_gxwhODc=json::vector(*pCheckpointDataCount);
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCheckpointData[TfFHlNo]);
            arr_gxwhODc[TfFHlNo]=temp_map;
            return;
            }();
        }
        json["pCheckpointData"]=arr_gxwhODc;}();


        json["stream_type"]=static_cast<int>(VKGETQUEUECHECKPOINTDATANV);
        writeToConn(json);
    }

    void handle_vkCmdBindTransformFeedbackBuffersEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].as_vector().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));auto& arr_ShVTBbp=json["pBuffers"].as_vector();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].as_vector().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_uWdiGtF=json["pOffsets"].as_vector();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_uint64_t());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_int64_t());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();
 VkDeviceSize* pSizes;
[&](){
            if (json["pSizes"].as_vector().size()==0){
                pSizes=NULL;
            return; }pSizes=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_cHIDMyb=json["pSizes"].as_vector();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){
            if (arr_cHIDMyb[yLUmhkZ].is_uint64_t()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_uint64_t());
            }else if (arr_cHIDMyb[yLUmhkZ].is_int64_t()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_int64_t());
            }else{
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_double());
            }
            }();pSizes[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();

    PFN_vkCmdBindTransformFeedbackBuffersEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_device_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=json::vector();
            return; }auto arr_OwyEmcF=json::vector(bindingCount);
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=static_cast<uint>(pSizes[YFhxzVl]);}();}();
        }
        json["pSizes"]=arr_OwyEmcF;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT);
        writeToConn(json);
    }

    void handle_vkCmdBeginTransformFeedbackEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){
            if (json["firstCounterBuffer"].is_uint64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_uint64_t());
            }else if (json["firstCounterBuffer"].is_int64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_int64_t());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_double());
            }
            }();
uint32_t counterBufferCount;
[&](){
            if (json["counterBufferCount"].is_uint64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_uint64_t());
            }else if (json["counterBufferCount"].is_int64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_int64_t());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_double());
            }
            }();
 VkBuffer* pCounterBuffers;
[&](){
            if (json["pCounterBuffers"].as_vector().size()==0){
                pCounterBuffers=NULL;
            return; }pCounterBuffers=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));auto& arr_BxMTckm=json["pCounterBuffers"].as_vector();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], pCounterBuffers[TXsvtyB]);}();
        }
        }();
 VkDeviceSize* pCounterBufferOffsets;
[&](){
            if (json["pCounterBufferOffsets"].as_vector().size()==0){
                pCounterBufferOffsets=NULL;
            return; }pCounterBufferOffsets=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));auto& arr_LrVQuLK=json["pCounterBufferOffsets"].as_vector();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){
            if (arr_LrVQuLK[FmZEqMc].is_uint64_t()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_uint64_t());
            }else if (arr_LrVQuLK[FmZEqMc].is_int64_t()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_int64_t());
            }else{
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_double());
            }
            }();pCounterBufferOffsets[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();

    PFN_vkCmdBeginTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=static_cast<uint>(firstCounterBuffer);}();
[&](){json["counterBufferCount"]=static_cast<uint>(counterBufferCount);}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=json::vector();
            return; }auto arr_eyGyJgR=json::vector(counterBufferCount);
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        json["pCounterBuffers"]=arr_eyGyJgR;}();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=json::vector();
            return; }auto arr_AiSbQbQ=json::vector(counterBufferCount);
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=static_cast<uint>(pCounterBufferOffsets[ThYypfr]);}();}();
        }
        json["pCounterBufferOffsets"]=arr_AiSbQbQ;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINTRANSFORMFEEDBACKEXT);
        writeToConn(json);
    }

    void handle_vkCmdEndTransformFeedbackEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){
            if (json["firstCounterBuffer"].is_uint64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_uint64_t());
            }else if (json["firstCounterBuffer"].is_int64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_int64_t());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_double());
            }
            }();
uint32_t counterBufferCount;
[&](){
            if (json["counterBufferCount"].is_uint64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_uint64_t());
            }else if (json["counterBufferCount"].is_int64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_int64_t());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_double());
            }
            }();
 VkBuffer* pCounterBuffers;
[&](){
            if (json["pCounterBuffers"].as_vector().size()==0){
                pCounterBuffers=NULL;
            return; }pCounterBuffers=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));auto& arr_BxMTckm=json["pCounterBuffers"].as_vector();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], pCounterBuffers[TXsvtyB]);}();
        }
        }();
 VkDeviceSize* pCounterBufferOffsets;
[&](){
            if (json["pCounterBufferOffsets"].as_vector().size()==0){
                pCounterBufferOffsets=NULL;
            return; }pCounterBufferOffsets=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));auto& arr_LrVQuLK=json["pCounterBufferOffsets"].as_vector();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){
            if (arr_LrVQuLK[FmZEqMc].is_uint64_t()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_uint64_t());
            }else if (arr_LrVQuLK[FmZEqMc].is_int64_t()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_int64_t());
            }else{
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].as_double());
            }
            }();pCounterBufferOffsets[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();

    PFN_vkCmdEndTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=static_cast<uint>(firstCounterBuffer);}();
[&](){json["counterBufferCount"]=static_cast<uint>(counterBufferCount);}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=json::vector();
            return; }auto arr_eyGyJgR=json::vector(counterBufferCount);
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        json["pCounterBuffers"]=arr_eyGyJgR;}();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=json::vector();
            return; }auto arr_AiSbQbQ=json::vector(counterBufferCount);
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=static_cast<uint>(pCounterBufferOffsets[ThYypfr]);}();}();
        }
        json["pCounterBufferOffsets"]=arr_AiSbQbQ;}();


        json["stream_type"]=static_cast<int>(VKCMDENDTRANSFORMFEEDBACKEXT);
        writeToConn(json);
    }

    void handle_vkCmdBeginQueryIndexedEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
uint32_t index;
[&](){
            if (json["index"].is_uint64_t()){
                index=static_cast<uint32_t>(json["index"].as_uint64_t());
            }else if (json["index"].is_int64_t()){
                index=static_cast<uint32_t>(json["index"].as_int64_t());
            }else{
                index=static_cast<uint32_t>(json["index"].as_double());
            }
            }();

    PFN_vkCmdBeginQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){json["index"]=static_cast<uint>(index);}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINQUERYINDEXEDEXT);
        writeToConn(json);
    }

    void handle_vkCmdEndQueryIndexedEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
uint32_t index;
[&](){
            if (json["index"].is_uint64_t()){
                index=static_cast<uint32_t>(json["index"].as_uint64_t());
            }else if (json["index"].is_int64_t()){
                index=static_cast<uint32_t>(json["index"].as_int64_t());
            }else{
                index=static_cast<uint32_t>(json["index"].as_double());
            }
            }();

    PFN_vkCmdEndQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){json["index"]=static_cast<uint>(index);}();


        json["stream_type"]=static_cast<int>(VKCMDENDQUERYINDEXEDEXT);
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectByteCountEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
VkBuffer counterBuffer;
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
VkDeviceSize counterBufferOffset;
[&](){uint64_t temp_AQwWAlK;[&](){
            if (json["counterBufferOffset"].is_uint64_t()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_uint64_t());
            }else if (json["counterBufferOffset"].is_int64_t()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_int64_t());
            }else{
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_double());
            }
            }();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
uint32_t counterOffset;
[&](){
            if (json["counterOffset"].is_uint64_t()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_uint64_t());
            }else if (json["counterOffset"].is_int64_t()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_int64_t());
            }else{
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_double());
            }
            }();
uint32_t vertexStride;
[&](){
            if (json["vertexStride"].is_uint64_t()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_uint64_t());
            }else if (json["vertexStride"].is_int64_t()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_int64_t());
            }else{
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_double());
            }
            }();

    PFN_vkCmdDrawIndirectByteCountEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_instance_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_device_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }  
    
{
call_function(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=static_cast<uint>(counterBufferOffset);}();}();
[&](){json["counterOffset"]=static_cast<uint>(counterOffset);}();
[&](){json["vertexStride"]=static_cast<uint>(vertexStride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECTBYTECOUNTEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){
            if (json["firstExclusiveScissor"].is_uint64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_uint64_t());
            }else if (json["firstExclusiveScissor"].is_int64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_int64_t());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_double());
            }
            }();
uint32_t exclusiveScissorCount;
[&](){
            if (json["exclusiveScissorCount"].is_uint64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_uint64_t());
            }else if (json["exclusiveScissorCount"].is_int64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_int64_t());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_double());
            }
            }();
 VkRect2D* pExclusiveScissors;
[&](){
            if (json["pExclusiveScissors"].as_vector().size()==0){
                pExclusiveScissors=NULL;
            return; }pExclusiveScissors=(VkRect2D*)malloc(exclusiveScissorCount*sizeof(VkRect2D));auto& arr_ZinqSQR=json["pExclusiveScissors"].as_vector();
        for(int SkofLXN=0; SkofLXN < exclusiveScissorCount; SkofLXN++){
            [&](){
            deserialize_struct(arr_ZinqSQR[SkofLXN].as_map(),pExclusiveScissors[SkofLXN]);
            }();
        }
        }();

    PFN_vkCmdSetExclusiveScissorNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=static_cast<uint>(firstExclusiveScissor);}();
[&](){json["exclusiveScissorCount"]=static_cast<uint>(exclusiveScissorCount);}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=json::vector();
            return; }auto arr_aPFLQnr=json::vector(exclusiveScissorCount);
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExclusiveScissors[uoWCiOs]);
            arr_aPFLQnr[uoWCiOs]=temp_map;
            return;
            }();
        }
        json["pExclusiveScissors"]=arr_aPFLQnr;}();


        json["stream_type"]=static_cast<int>(VKCMDSETEXCLUSIVESCISSORNV);
        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){
            if (json["firstExclusiveScissor"].is_uint64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_uint64_t());
            }else if (json["firstExclusiveScissor"].is_int64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_int64_t());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_double());
            }
            }();
uint32_t exclusiveScissorCount;
[&](){
            if (json["exclusiveScissorCount"].is_uint64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_uint64_t());
            }else if (json["exclusiveScissorCount"].is_int64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_int64_t());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_double());
            }
            }();
 VkBool32* pExclusiveScissorEnables;
[&](){
            if (json["pExclusiveScissorEnables"].as_vector().size()==0){
                pExclusiveScissorEnables=NULL;
            return; }pExclusiveScissorEnables=(VkBool32*)malloc(exclusiveScissorCount*sizeof(VkBool32));auto& arr_gutsiaF=json["pExclusiveScissorEnables"].as_vector();
        for(int DJnjHfh=0; DJnjHfh < exclusiveScissorCount; DJnjHfh++){
            [&](){uint32_t temp_gutsiaF;[&](){
            if (arr_gutsiaF[DJnjHfh].is_uint64_t()){
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].as_uint64_t());
            }else if (arr_gutsiaF[DJnjHfh].is_int64_t()){
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].as_int64_t());
            }else{
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].as_double());
            }
            }();pExclusiveScissorEnables[DJnjHfh]=(VkBool32)temp_gutsiaF;}();
        }
        }();

    PFN_vkCmdSetExclusiveScissorEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=static_cast<uint>(firstExclusiveScissor);}();
[&](){json["exclusiveScissorCount"]=static_cast<uint>(exclusiveScissorCount);}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=json::vector();
            return; }auto arr_xqHCjsr=json::vector(exclusiveScissorCount);
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=static_cast<uint>(pExclusiveScissorEnables[ZwZaOgk]);}();}();
        }
        json["pExclusiveScissorEnables"]=arr_xqHCjsr;}();


        json["stream_type"]=static_cast<int>(VKCMDSETEXCLUSIVESCISSORENABLENV);
        writeToConn(json);
    }

    void handle_vkCmdBindShadingRateImageNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindShadingRateImageNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_instance_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_device_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBINDSHADINGRATEIMAGENV);
        writeToConn(json);
    }

    void handle_vkCmdSetViewportShadingRatePaletteNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();
 VkShadingRatePaletteNV* pShadingRatePalettes;
[&](){
            if (json["pShadingRatePalettes"].as_vector().size()==0){
                pShadingRatePalettes=NULL;
            return; }pShadingRatePalettes=(VkShadingRatePaletteNV*)malloc(viewportCount*sizeof(VkShadingRatePaletteNV));auto& arr_wkMlexp=json["pShadingRatePalettes"].as_vector();
        for(int SqzUOqM=0; SqzUOqM < viewportCount; SqzUOqM++){
            [&](){
            deserialize_struct(arr_wkMlexp[SqzUOqM].as_map(),pShadingRatePalettes[SqzUOqM]);
            }();
        }
        }();

    PFN_vkCmdSetViewportShadingRatePaletteNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_instance_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_device_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=json::vector();
            return; }auto arr_QGCIyPL=json::vector(viewportCount);
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pShadingRatePalettes[iwmSeHU]);
            arr_QGCIyPL[iwmSeHU]=temp_map;
            return;
            }();
        }
        json["pShadingRatePalettes"]=arr_QGCIyPL;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTSHADINGRATEPALETTENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoarseSampleOrderNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoarseSampleOrderTypeNV sampleOrderType;
[&](){[&](){int temp_iGYbmmy;[&](){
            if (json["sampleOrderType"].is_uint64_t()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_uint64_t());
            }else if (json["sampleOrderType"].is_int64_t()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_int64_t());
            }else{
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_double());
            }
            }();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
uint32_t customSampleOrderCount;
[&](){
            if (json["customSampleOrderCount"].is_uint64_t()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_uint64_t());
            }else if (json["customSampleOrderCount"].is_int64_t()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_int64_t());
            }else{
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_double());
            }
            }();
 VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
[&](){
            if (json["pCustomSampleOrders"].as_vector().size()==0){
                pCustomSampleOrders=NULL;
            return; }pCustomSampleOrders=(VkCoarseSampleOrderCustomNV*)malloc(customSampleOrderCount*sizeof(VkCoarseSampleOrderCustomNV));auto& arr_XDqsEzE=json["pCustomSampleOrders"].as_vector();
        for(int MsAfwio=0; MsAfwio < customSampleOrderCount; MsAfwio++){
            [&](){
            deserialize_struct(arr_XDqsEzE[MsAfwio].as_map(),pCustomSampleOrders[MsAfwio]);
            }();
        }
        }();

    PFN_vkCmdSetCoarseSampleOrderNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_instance_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_device_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }  
    
{
call_function(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=static_cast<int>(sampleOrderType);}();}();}();
[&](){json["customSampleOrderCount"]=static_cast<uint>(customSampleOrderCount);}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=json::vector();
            return; }auto arr_UoJKhih=json::vector(customSampleOrderCount);
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCustomSampleOrders[nBPVlSV]);
            arr_UoJKhih[nBPVlSV]=temp_map;
            return;
            }();
        }
        json["pCustomSampleOrders"]=arr_UoJKhih;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOARSESAMPLEORDERNV);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t taskCount;
[&](){
            if (json["taskCount"].is_uint64_t()){
                taskCount=static_cast<uint32_t>(json["taskCount"].as_uint64_t());
            }else if (json["taskCount"].is_int64_t()){
                taskCount=static_cast<uint32_t>(json["taskCount"].as_int64_t());
            }else{
                taskCount=static_cast<uint32_t>(json["taskCount"].as_double());
            }
            }();
uint32_t firstTask;
[&](){
            if (json["firstTask"].is_uint64_t()){
                firstTask=static_cast<uint32_t>(json["firstTask"].as_uint64_t());
            }else if (json["firstTask"].is_int64_t()){
                firstTask=static_cast<uint32_t>(json["firstTask"].as_int64_t());
            }else{
                firstTask=static_cast<uint32_t>(json["firstTask"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }  
    
{
call_function(commandBuffer, taskCount, firstTask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=static_cast<uint>(taskCount);}();
[&](){json["firstTask"]=static_cast<uint>(firstTask);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSNV);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTNV);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectCountNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTCOUNTNV);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSEXT);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTEXT);
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectCountEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT);
        writeToConn(json);
    }

    void handle_vkCompileDeferredNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t shader;
[&](){
            if (json["shader"].is_uint64_t()){
                shader=static_cast<uint32_t>(json["shader"].as_uint64_t());
            }else if (json["shader"].is_int64_t()){
                shader=static_cast<uint32_t>(json["shader"].as_int64_t());
            }else{
                shader=static_cast<uint32_t>(json["shader"].as_double());
            }
            }();

    PFN_vkCompileDeferredNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCompileDeferredNV)get_instance_proc_addr(parent,"vkCompileDeferredNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCompileDeferredNV)get_device_proc_addr(parent,"vkCompileDeferredNV");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, shader);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=static_cast<uint>(shader);}();


        json["stream_type"]=static_cast<int>(VKCOMPILEDEFERREDNV);
        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkAccelerationStructureCreateInfoNV*)malloc(1*sizeof(VkAccelerationStructureCreateInfoNV));auto& arr_CZnEXLZ=json["pCreateInfo"].as_vector();
        for(int HkuZrvQ=0; HkuZrvQ < 1; HkuZrvQ++){
            [&](){
            deserialize_struct(arr_CZnEXLZ[HkuZrvQ].as_map(),pCreateInfo[HkuZrvQ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkAccelerationStructureNV* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].as_vector().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureNV*)malloc(1*sizeof(VkAccelerationStructureNV));auto& arr_FUsucto=json["pAccelerationStructure"].as_vector();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateAccelerationStructureNV)get_instance_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateAccelerationStructureNV)get_device_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_cRwwWhs=json::vector(1);
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[oEOLGTm]);
            arr_cRwwWhs[oEOLGTm]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_cRwwWhs;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=json::vector();
            return; }auto arr_FUsucto=json::vector(1);
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        json["pAccelerationStructure"]=arr_FUsucto;}();


        json["stream_type"]=static_cast<int>(VKCREATEACCELERATIONSTRUCTURENV);
        writeToConn(json);
    }

    void handle_vkCmdBindInvocationMaskHUAWEI(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindInvocationMaskHUAWEI call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_instance_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_device_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBINDINVOCATIONMASKHUAWEI);
        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureKHR accelerationStructure;
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_device_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_device_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYACCELERATIONSTRUCTURENV);
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureMemoryRequirementsNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureMemoryRequirementsInfoNV* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureMemoryRequirementsInfoNV*)malloc(1*sizeof(VkAccelerationStructureMemoryRequirementsInfoNV));auto& arr_VDaHmqz=json["pInfo"].as_vector();
        for(int wDTIoch=0; wDTIoch < 1; wDTIoch++){
            [&](){
            deserialize_struct(arr_VDaHmqz[wDTIoch].as_map(),pInfo[wDTIoch]);
            }();
        }
        }();
VkMemoryRequirements2KHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2KHR*)malloc(1*sizeof(VkMemoryRequirements2KHR));auto& arr_lzklPBG=json["pMemoryRequirements"].as_vector();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            deserialize_struct(arr_lzklPBG[HmtSVPA].as_map(),pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QKzjkmC=json::vector(1);
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[eEDmZTf]);
            arr_QKzjkmC[eEDmZTf]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QKzjkmC;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_lzklPBG=json::vector(1);
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[HmtSVPA]);
            arr_lzklPBG[HmtSVPA]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_lzklPBG;}();


        json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV);
        writeToConn(json);
    }

    void handle_vkBindAccelerationStructureMemoryNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();
 VkBindAccelerationStructureMemoryInfoNV* pBindInfos;
[&](){
            if (json["pBindInfos"].as_vector().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindAccelerationStructureMemoryInfoNV*)malloc(bindInfoCount*sizeof(VkBindAccelerationStructureMemoryInfoNV));auto& arr_AgWFhtE=json["pBindInfos"].as_vector();
        for(int NpOYBOz=0; NpOYBOz < bindInfoCount; NpOYBOz++){
            [&](){
            deserialize_struct(arr_AgWFhtE[NpOYBOz].as_map(),pBindInfos[NpOYBOz]);
            }();
        }
        }();

    PFN_vkBindAccelerationStructureMemoryNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_instance_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_device_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_rhzkvXd=json::vector(bindInfoCount);
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[tRvmYFr]);
            arr_rhzkvXd[tRvmYFr]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_rhzkvXd;}();


        json["stream_type"]=static_cast<int>(VKBINDACCELERATIONSTRUCTUREMEMORYNV);
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkCopyAccelerationStructureModeKHR mode;
[&](){[&](){int temp_KfOqWqs;[&](){
            if (json["mode"].is_uint64_t()){
                temp_KfOqWqs=static_cast<int>(json["mode"].as_uint64_t());
            }else if (json["mode"].is_int64_t()){
                temp_KfOqWqs=static_cast<int>(json["mode"].as_int64_t());
            }else{
                temp_KfOqWqs=static_cast<int>(json["mode"].as_double());
            }
            }();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

    PFN_vkCmdCopyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, dst, src, mode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=static_cast<int>(mode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTURENV);
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));auto& arr_WSMeNoY=json["pInfo"].as_vector();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            deserialize_struct(arr_WSMeNoY[qgjgiZh].as_map(),pInfo[qgjgiZh]);
            }();
        }
        }();

    PFN_vkCmdCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mSSajtp=json::vector(1);
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ghvrBgW]);
            arr_mSSajtp[ghvrBgW]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mSSajtp;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));auto& arr_WSMeNoY=json["pInfo"].as_vector();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            deserialize_struct(arr_WSMeNoY[qgjgiZh].as_map(),pInfo[qgjgiZh]);
            }();
        }
        }();

    PFN_vkCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mSSajtp=json::vector(1);
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ghvrBgW]);
            arr_mSSajtp[ghvrBgW]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mSSajtp;}();


        json["stream_type"]=static_cast<int>(VKCOPYACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureToMemoryKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));auto& arr_lkaVawI=json["pInfo"].as_vector();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            deserialize_struct(arr_lkaVawI[qcYcnXp].as_map(),pInfo[qcYcnXp]);
            }();
        }
        }();

    PFN_vkCmdCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_MpzusRq=json::vector(1);
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[hToWSKz]);
            arr_MpzusRq[hToWSKz]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_MpzusRq;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR);
        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureToMemoryKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));auto& arr_lkaVawI=json["pInfo"].as_vector();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            deserialize_struct(arr_lkaVawI[qcYcnXp].as_map(),pInfo[qcYcnXp]);
            }();
        }
        }();

    PFN_vkCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_MpzusRq=json::vector(1);
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[hToWSKz]);
            arr_MpzusRq[hToWSKz]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_MpzusRq;}();


        json["stream_type"]=static_cast<int>(VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR);
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));auto& arr_bZDMHqg=json["pInfo"].as_vector();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            deserialize_struct(arr_bZDMHqg[exexFjs].as_map(),pInfo[exexFjs]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_yRNSaUF=json::vector(1);
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ulOBYSb]);
            arr_yRNSaUF[ulOBYSb]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_yRNSaUF;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkCopyMemoryToAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));auto& arr_bZDMHqg=json["pInfo"].as_vector();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            deserialize_struct(arr_bZDMHqg[exexFjs].as_map(),pInfo[exexFjs]);
            }();
        }
        }();

    PFN_vkCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_yRNSaUF=json::vector(1);
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ulOBYSb]);
            arr_yRNSaUF[ulOBYSb]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_yRNSaUF;}();


        json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();
 VkAccelerationStructureKHR* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].as_vector().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));auto& arr_QDDZeVb=json["pAccelerationStructures"].as_vector();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], pAccelerationStructures[dBhihII]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_oCGlcEh=json::vector(accelerationStructureCount);
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        json["pAccelerationStructures"]=arr_oCGlcEh;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();
 VkAccelerationStructureNV* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].as_vector().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureNV*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureNV));auto& arr_jMdvwQK=json["pAccelerationStructures"].as_vector();
        for(int lmeuIny=0; lmeuIny < accelerationStructureCount; lmeuIny++){
            [&](){deserialize_VkAccelerationStructureNV(arr_jMdvwQK[lmeuIny], pAccelerationStructures[lmeuIny]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

    PFN_vkCmdWriteAccelerationStructuresPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_NSQEnJt=json::vector(accelerationStructureCount);
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        json["pAccelerationStructures"]=arr_NSQEnJt;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV);
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructureNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkAccelerationStructureInfoNV* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureInfoNV*)malloc(1*sizeof(VkAccelerationStructureInfoNV));auto& arr_lerVBoc=json["pInfo"].as_vector();
        for(int mMkuLVq=0; mMkuLVq < 1; mMkuLVq++){
            [&](){
            deserialize_struct(arr_lerVBoc[mMkuLVq].as_map(),pInfo[mMkuLVq]);
            }();
        }
        }();
VkBuffer instanceData;
[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
VkDeviceSize instanceOffset;
[&](){uint64_t temp_sEYJico;[&](){
            if (json["instanceOffset"].is_uint64_t()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_uint64_t());
            }else if (json["instanceOffset"].is_int64_t()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_int64_t());
            }else{
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_double());
            }
            }();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
VkBool32 update;
[&](){uint32_t temp_LpVZhJf;[&](){
            if (json["update"].is_uint64_t()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_uint64_t());
            }else if (json["update"].is_int64_t()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_int64_t());
            }else{
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_double());
            }
            }();update=(VkBool32)temp_LpVZhJf;}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkBuffer scratch;
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
VkDeviceSize scratchOffset;
[&](){uint64_t temp_rbfZpmL;[&](){
            if (json["scratchOffset"].is_uint64_t()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_uint64_t());
            }else if (json["scratchOffset"].is_int64_t()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_int64_t());
            }else{
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_double());
            }
            }();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

    PFN_vkCmdBuildAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_GYyRhgo=json::vector(1);
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[jJuvWAP]);
            arr_GYyRhgo[jJuvWAP]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_GYyRhgo;}();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=static_cast<uint>(instanceOffset);}();}();
[&](){[&](){json["update"]=static_cast<uint>(update);}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=static_cast<uint>(scratchOffset);}();}();


        json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURENV);
        writeToConn(json);
    }

    void handle_vkWriteAccelerationStructuresPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();
 VkAccelerationStructureKHR* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].as_vector().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));auto& arr_QDDZeVb=json["pAccelerationStructures"].as_vector();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], pAccelerationStructures[dBhihII]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<size_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<size_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<size_t>(json["stride"].as_double());
            }
            }();

    PFN_vkWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_oCGlcEh=json::vector(accelerationStructureCount);
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        json["pAccelerationStructures"]=arr_oCGlcEh;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){json["stride"]=static_cast<int>(stride);}();


        json["stream_type"]=static_cast<int>(VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){
            if (json["pRaygenShaderBindingTable"].as_vector().size()==0){
                pRaygenShaderBindingTable=NULL;
            return; }pRaygenShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].as_vector();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            deserialize_struct(arr_vmdxRLm[xvlAiIt].as_map(),pRaygenShaderBindingTable[xvlAiIt]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){
            if (json["pMissShaderBindingTable"].as_vector().size()==0){
                pMissShaderBindingTable=NULL;
            return; }pMissShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_aiNBoIa=json["pMissShaderBindingTable"].as_vector();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            deserialize_struct(arr_aiNBoIa[fjwDbNz].as_map(),pMissShaderBindingTable[fjwDbNz]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){
            if (json["pHitShaderBindingTable"].as_vector().size()==0){
                pHitShaderBindingTable=NULL;
            return; }pHitShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_MsArahD=json["pHitShaderBindingTable"].as_vector();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            deserialize_struct(arr_MsArahD[TYXtQRB].as_map(),pHitShaderBindingTable[TYXtQRB]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){
            if (json["pCallableShaderBindingTable"].as_vector().size()==0){
                pCallableShaderBindingTable=NULL;
            return; }pCallableShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].as_vector();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            deserialize_struct(arr_ZxEGCDr[rzAeWYt].as_map(),pCallableShaderBindingTable[rzAeWYt]);
            }();
        }
        }();
uint32_t width;
[&](){
            if (json["width"].is_uint64_t()){
                width=static_cast<uint32_t>(json["width"].as_uint64_t());
            }else if (json["width"].is_int64_t()){
                width=static_cast<uint32_t>(json["width"].as_int64_t());
            }else{
                width=static_cast<uint32_t>(json["width"].as_double());
            }
            }();
uint32_t height;
[&](){
            if (json["height"].is_uint64_t()){
                height=static_cast<uint32_t>(json["height"].as_uint64_t());
            }else if (json["height"].is_int64_t()){
                height=static_cast<uint32_t>(json["height"].as_int64_t());
            }else{
                height=static_cast<uint32_t>(json["height"].as_double());
            }
            }();
uint32_t depth;
[&](){
            if (json["depth"].is_uint64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_uint64_t());
            }else if (json["depth"].is_int64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_int64_t());
            }else{
                depth=static_cast<uint32_t>(json["depth"].as_double());
            }
            }();

    PFN_vkCmdTraceRaysKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdTraceRaysKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdTraceRaysKHR)get_device_proc_addr(parent,"vkCmdTraceRaysKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=json::vector();
            return; }auto arr_SlnAEUX=json::vector(1);
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRaygenShaderBindingTable[VKRuDIv]);
            arr_SlnAEUX[VKRuDIv]=temp_map;
            return;
            }();
        }
        json["pRaygenShaderBindingTable"]=arr_SlnAEUX;}();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=json::vector();
            return; }auto arr_vBQknzc=json::vector(1);
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMissShaderBindingTable[ZhvHpIX]);
            arr_vBQknzc[ZhvHpIX]=temp_map;
            return;
            }();
        }
        json["pMissShaderBindingTable"]=arr_vBQknzc;}();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=json::vector();
            return; }auto arr_IhHhjXk=json::vector(1);
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHitShaderBindingTable[yriMdrU]);
            arr_IhHhjXk[yriMdrU]=temp_map;
            return;
            }();
        }
        json["pHitShaderBindingTable"]=arr_IhHhjXk;}();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=json::vector();
            return; }auto arr_EmEYSBY=json::vector(1);
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallableShaderBindingTable[TiOHiqW]);
            arr_EmEYSBY[TiOHiqW]=temp_map;
            return;
            }();
        }
        json["pCallableShaderBindingTable"]=arr_EmEYSBY;}();
[&](){json["width"]=static_cast<uint>(width);}();
[&](){json["height"]=static_cast<uint>(height);}();
[&](){json["depth"]=static_cast<uint>(depth);}();


        json["stream_type"]=static_cast<int>(VKCMDTRACERAYSKHR);
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer raygenShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
VkDeviceSize raygenShaderBindingOffset;
[&](){uint64_t temp_nbAYEyt;[&](){
            if (json["raygenShaderBindingOffset"].is_uint64_t()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_uint64_t());
            }else if (json["raygenShaderBindingOffset"].is_int64_t()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_int64_t());
            }else{
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_double());
            }
            }();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
VkBuffer missShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
VkDeviceSize missShaderBindingOffset;
[&](){uint64_t temp_ORIaXGF;[&](){
            if (json["missShaderBindingOffset"].is_uint64_t()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_uint64_t());
            }else if (json["missShaderBindingOffset"].is_int64_t()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_int64_t());
            }else{
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_double());
            }
            }();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
VkDeviceSize missShaderBindingStride;
[&](){uint64_t temp_BOvfilr;[&](){
            if (json["missShaderBindingStride"].is_uint64_t()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_uint64_t());
            }else if (json["missShaderBindingStride"].is_int64_t()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_int64_t());
            }else{
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_double());
            }
            }();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
VkBuffer hitShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
VkDeviceSize hitShaderBindingOffset;
[&](){uint64_t temp_oKlCsJj;[&](){
            if (json["hitShaderBindingOffset"].is_uint64_t()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_uint64_t());
            }else if (json["hitShaderBindingOffset"].is_int64_t()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_int64_t());
            }else{
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_double());
            }
            }();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
VkDeviceSize hitShaderBindingStride;
[&](){uint64_t temp_qhwyGdu;[&](){
            if (json["hitShaderBindingStride"].is_uint64_t()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_uint64_t());
            }else if (json["hitShaderBindingStride"].is_int64_t()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_int64_t());
            }else{
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_double());
            }
            }();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
VkBuffer callableShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
VkDeviceSize callableShaderBindingOffset;
[&](){uint64_t temp_WmjXZmz;[&](){
            if (json["callableShaderBindingOffset"].is_uint64_t()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_uint64_t());
            }else if (json["callableShaderBindingOffset"].is_int64_t()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_int64_t());
            }else{
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_double());
            }
            }();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
VkDeviceSize callableShaderBindingStride;
[&](){uint64_t temp_giLAAVF;[&](){
            if (json["callableShaderBindingStride"].is_uint64_t()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_uint64_t());
            }else if (json["callableShaderBindingStride"].is_int64_t()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_int64_t());
            }else{
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_double());
            }
            }();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
uint32_t width;
[&](){
            if (json["width"].is_uint64_t()){
                width=static_cast<uint32_t>(json["width"].as_uint64_t());
            }else if (json["width"].is_int64_t()){
                width=static_cast<uint32_t>(json["width"].as_int64_t());
            }else{
                width=static_cast<uint32_t>(json["width"].as_double());
            }
            }();
uint32_t height;
[&](){
            if (json["height"].is_uint64_t()){
                height=static_cast<uint32_t>(json["height"].as_uint64_t());
            }else if (json["height"].is_int64_t()){
                height=static_cast<uint32_t>(json["height"].as_int64_t());
            }else{
                height=static_cast<uint32_t>(json["height"].as_double());
            }
            }();
uint32_t depth;
[&](){
            if (json["depth"].is_uint64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_uint64_t());
            }else if (json["depth"].is_int64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_int64_t());
            }else{
                depth=static_cast<uint32_t>(json["depth"].as_double());
            }
            }();

    PFN_vkCmdTraceRaysNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdTraceRaysNV)get_instance_proc_addr(parent,"vkCmdTraceRaysNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdTraceRaysNV)get_device_proc_addr(parent,"vkCmdTraceRaysNV");
    }  
    
{
call_function(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=static_cast<uint>(raygenShaderBindingOffset);}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=static_cast<uint>(missShaderBindingOffset);}();}();
[&](){[&](){json["missShaderBindingStride"]=static_cast<uint>(missShaderBindingStride);}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=static_cast<uint>(hitShaderBindingOffset);}();}();
[&](){[&](){json["hitShaderBindingStride"]=static_cast<uint>(hitShaderBindingStride);}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=static_cast<uint>(callableShaderBindingOffset);}();}();
[&](){[&](){json["callableShaderBindingStride"]=static_cast<uint>(callableShaderBindingStride);}();}();
[&](){json["width"]=static_cast<uint>(width);}();
[&](){json["height"]=static_cast<uint>(height);}();
[&](){json["depth"]=static_cast<uint>(depth);}();


        json["stream_type"]=static_cast<int>(VKCMDTRACERAYSNV);
        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupHandlesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){
            if (json["firstGroup"].is_uint64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_uint64_t());
            }else if (json["firstGroup"].is_int64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_int64_t());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_double());
            }
            }();
uint32_t groupCount;
[&](){
            if (json["groupCount"].is_uint64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_uint64_t());
            }else if (json["groupCount"].is_int64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_int64_t());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].as_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=static_cast<uint>(firstGroup);}();
[&](){json["groupCount"]=static_cast<uint>(groupCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETRAYTRACINGSHADERGROUPHANDLESKHR);
        writeToConn(json);
    }

    void handle_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){
            if (json["firstGroup"].is_uint64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_uint64_t());
            }else if (json["firstGroup"].is_int64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_int64_t());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_double());
            }
            }();
uint32_t groupCount;
[&](){
            if (json["groupCount"].is_uint64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_uint64_t());
            }else if (json["groupCount"].is_int64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_int64_t());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].as_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=static_cast<uint>(firstGroup);}();
[&](){json["groupCount"]=static_cast<uint>(groupCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR);
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureHandleNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetAccelerationStructureHandleNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_device_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }  
    
VkResult  result;
{
result=call_function(device, accelerationStructure, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREHANDLENV);
        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();
 VkRayTracingPipelineCreateInfoNV* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkRayTracingPipelineCreateInfoNV*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoNV));auto& arr_XJbewcz=json["pCreateInfos"].as_vector();
        for(int OYHdDIG=0; OYHdDIG < createInfoCount; OYHdDIG++){
            [&](){
            deserialize_struct(arr_XJbewcz[OYHdDIG].as_map(),pCreateInfos[OYHdDIG]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_bzMTsat=json::vector(createInfoCount);
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[oRbABSQ]);
            arr_bzMTsat[oRbABSQ]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_bzMTsat;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();


        json["stream_type"]=static_cast<int>(VKCREATERAYTRACINGPIPELINESNV);
        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();
 VkRayTracingPipelineCreateInfoKHR* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkRayTracingPipelineCreateInfoKHR*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoKHR));auto& arr_IiabYtV=json["pCreateInfos"].as_vector();
        for(int NFMtVfO=0; NFMtVfO < createInfoCount; NFMtVfO++){
            [&](){
            deserialize_struct(arr_IiabYtV[NFMtVfO].as_map(),pCreateInfos[NFMtVfO]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_zltFjJj=json::vector(createInfoCount);
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[Szqaxlk]);
            arr_zltFjJj[Szqaxlk]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_zltFjJj;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();


        json["stream_type"]=static_cast<int>(VKCREATERAYTRACINGPIPELINESKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkCooperativeMatrixPropertiesNV* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesNV*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesNV));auto& arr_kVfVVDF=json["pProperties"].as_vector();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            deserialize_struct(arr_kVfVVDF[WfgOgPA].as_map(),pProperties[WfgOgPA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_kVfVVDF=json::vector(*pPropertyCount);
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[WfgOgPA]);
            arr_kVfVVDF[WfgOgPA]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_kVfVVDF;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV);
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirectKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){
            if (json["pRaygenShaderBindingTable"].as_vector().size()==0){
                pRaygenShaderBindingTable=NULL;
            return; }pRaygenShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].as_vector();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            deserialize_struct(arr_vmdxRLm[xvlAiIt].as_map(),pRaygenShaderBindingTable[xvlAiIt]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){
            if (json["pMissShaderBindingTable"].as_vector().size()==0){
                pMissShaderBindingTable=NULL;
            return; }pMissShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_aiNBoIa=json["pMissShaderBindingTable"].as_vector();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            deserialize_struct(arr_aiNBoIa[fjwDbNz].as_map(),pMissShaderBindingTable[fjwDbNz]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){
            if (json["pHitShaderBindingTable"].as_vector().size()==0){
                pHitShaderBindingTable=NULL;
            return; }pHitShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_MsArahD=json["pHitShaderBindingTable"].as_vector();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            deserialize_struct(arr_MsArahD[TYXtQRB].as_map(),pHitShaderBindingTable[TYXtQRB]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){
            if (json["pCallableShaderBindingTable"].as_vector().size()==0){
                pCallableShaderBindingTable=NULL;
            return; }pCallableShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].as_vector();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            deserialize_struct(arr_ZxEGCDr[rzAeWYt].as_map(),pCallableShaderBindingTable[rzAeWYt]);
            }();
        }
        }();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_uint64_t());
            }else if (json["indirectDeviceAddress"].is_int64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_int64_t());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirectKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=json::vector();
            return; }auto arr_SlnAEUX=json::vector(1);
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRaygenShaderBindingTable[VKRuDIv]);
            arr_SlnAEUX[VKRuDIv]=temp_map;
            return;
            }();
        }
        json["pRaygenShaderBindingTable"]=arr_SlnAEUX;}();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=json::vector();
            return; }auto arr_vBQknzc=json::vector(1);
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMissShaderBindingTable[ZhvHpIX]);
            arr_vBQknzc[ZhvHpIX]=temp_map;
            return;
            }();
        }
        json["pMissShaderBindingTable"]=arr_vBQknzc;}();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=json::vector();
            return; }auto arr_IhHhjXk=json::vector(1);
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHitShaderBindingTable[yriMdrU]);
            arr_IhHhjXk[yriMdrU]=temp_map;
            return;
            }();
        }
        json["pHitShaderBindingTable"]=arr_IhHhjXk;}();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=json::vector();
            return; }auto arr_EmEYSBY=json::vector(1);
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallableShaderBindingTable[TiOHiqW]);
            arr_EmEYSBY[TiOHiqW]=temp_map;
            return;
            }();
        }
        json["pCallableShaderBindingTable"]=arr_EmEYSBY;}();
[&](){[&](){json["indirectDeviceAddress"]=static_cast<uint>(indirectDeviceAddress);}();}();


        json["stream_type"]=static_cast<int>(VKCMDTRACERAYSINDIRECTKHR);
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirect2KHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_uint64_t());
            }else if (json["indirectDeviceAddress"].is_int64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_int64_t());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirect2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }  
    
{
call_function(commandBuffer, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=static_cast<uint>(indirectDeviceAddress);}();}();


        json["stream_type"]=static_cast<int>(VKCMDTRACERAYSINDIRECT2KHR);
        writeToConn(json);
    }

    void handle_vkGetDeviceAccelerationStructureCompatibilityKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureVersionInfoKHR* pVersionInfo;
[&](){
            if (json["pVersionInfo"].as_vector().size()==0){
                pVersionInfo=NULL;
            return; }pVersionInfo=(VkAccelerationStructureVersionInfoKHR*)malloc(1*sizeof(VkAccelerationStructureVersionInfoKHR));auto& arr_aFpiHMk=json["pVersionInfo"].as_vector();
        for(int hlcodPX=0; hlcodPX < 1; hlcodPX++){
            [&](){
            deserialize_struct(arr_aFpiHMk[hlcodPX].as_map(),pVersionInfo[hlcodPX]);
            }();
        }
        }();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].as_vector().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));auto& arr_dBMhFMX=json["pCompatibility"].as_vector();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_uint64_t());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_int64_t());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_instance_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_device_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=json::vector();
            return; }auto arr_wbhdpeb=json::vector(1);
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVersionInfo[vhWWlwM]);
            arr_wbhdpeb[vhWWlwM]=temp_map;
            return;
            }();
        }
        json["pVersionInfo"]=arr_wbhdpeb;}();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=json::vector();
            return; }auto arr_dBMhFMX=json::vector(1);
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=static_cast<int>(pCompatibility[nzOFTGF]);}();}();}();
        }
        json["pCompatibility"]=arr_dBMhFMX;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR);
        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupStackSizeKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t group;
[&](){
            if (json["group"].is_uint64_t()){
                group=static_cast<uint32_t>(json["group"].as_uint64_t());
            }else if (json["group"].is_int64_t()){
                group=static_cast<uint32_t>(json["group"].as_int64_t());
            }else{
                group=static_cast<uint32_t>(json["group"].as_double());
            }
            }();
VkShaderGroupShaderKHR groupShader;
[&](){[&](){int temp_EOWKSMj;[&](){
            if (json["groupShader"].is_uint64_t()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_uint64_t());
            }else if (json["groupShader"].is_int64_t()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_int64_t());
            }else{
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_double());
            }
            }();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();

    PFN_vkGetRayTracingShaderGroupStackSizeKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }  
    
VkDeviceSize  result;
{
result=call_function(device, pipeline, group, groupShader);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=static_cast<uint>(group);}();
[&](){[&](){[&](){json["groupShader"]=static_cast<int>(groupShader);}();}();}();


        json["stream_type"]=static_cast<int>(VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR);
        writeToConn(json);
    }

    void handle_vkCmdSetRayTracingPipelineStackSizeKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t pipelineStackSize;
[&](){
            if (json["pipelineStackSize"].is_uint64_t()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_uint64_t());
            }else if (json["pipelineStackSize"].is_int64_t()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_int64_t());
            }else{
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_double());
            }
            }();

    PFN_vkCmdSetRayTracingPipelineStackSizeKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_instance_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_device_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }  
    
{
call_function(commandBuffer, pipelineStackSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=static_cast<uint>(pipelineStackSize);}();


        json["stream_type"]=static_cast<int>(VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR);
        writeToConn(json);
    }

    void handle_vkGetImageViewHandleNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewHandleInfoNVX* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageViewHandleInfoNVX*)malloc(1*sizeof(VkImageViewHandleInfoNVX));auto& arr_WPyvhGm=json["pInfo"].as_vector();
        for(int WwmPLiZ=0; WwmPLiZ < 1; WwmPLiZ++){
            [&](){
            deserialize_struct(arr_WPyvhGm[WwmPLiZ].as_map(),pInfo[WwmPLiZ]);
            }();
        }
        }();

    PFN_vkGetImageViewHandleNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageViewHandleNVX)get_instance_proc_addr(parent,"vkGetImageViewHandleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageViewHandleNVX)get_device_proc_addr(parent,"vkGetImageViewHandleNVX");
    }  
    
uint32_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=static_cast<uint>(result);}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mfMZJfb=json::vector(1);
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dQabsff]);
            arr_mfMZJfb[dQabsff]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mfMZJfb;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWHANDLENVX);
        writeToConn(json);
    }

    void handle_vkGetImageViewAddressNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageViewAddressPropertiesNVX* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageViewAddressPropertiesNVX*)malloc(1*sizeof(VkImageViewAddressPropertiesNVX));auto& arr_hveoAIn=json["pProperties"].as_vector();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            deserialize_struct(arr_hveoAIn[FiVrJfn].as_map(),pProperties[FiVrJfn]);
            }();
        }
        }();

    PFN_vkGetImageViewAddressNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageViewAddressNVX)get_instance_proc_addr(parent,"vkGetImageViewAddressNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageViewAddressNVX)get_device_proc_addr(parent,"vkGetImageViewAddressNVX");
    }  
    
VkResult  result;
{
result=call_function(device, imageView, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hveoAIn=json::vector(1);
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[FiVrJfn]);
            arr_hveoAIn[FiVrJfn]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hveoAIn;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWADDRESSNVX);
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
uint32_t* pCounterCount;
[&](){
            if (json["pCounterCount"].as_vector().size()==0){
                pCounterCount=NULL;
            return; }pCounterCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_QuwxWHd=json["pCounterCount"].as_vector();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){
            if (arr_QuwxWHd[HDbVSFc].is_uint64_t()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_uint64_t());
            }else if (arr_QuwxWHd[HDbVSFc].is_int64_t()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_int64_t());
            }else{
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_double());
            }
            }();
        }
        }();
VkPerformanceCounterKHR* pCounters;
[&](){
            if (json["pCounters"].as_vector().size()==0){
                pCounters=NULL;
            return; }pCounters=(VkPerformanceCounterKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterKHR));auto& arr_vEVlsJt=json["pCounters"].as_vector();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            deserialize_struct(arr_vEVlsJt[WmftXku].as_map(),pCounters[WmftXku]);
            }();
        }
        }();
VkPerformanceCounterDescriptionKHR* pCounterDescriptions;
[&](){
            if (json["pCounterDescriptions"].as_vector().size()==0){
                pCounterDescriptions=NULL;
            return; }pCounterDescriptions=(VkPerformanceCounterDescriptionKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterDescriptionKHR));auto& arr_znRZkzO=json["pCounterDescriptions"].as_vector();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            deserialize_struct(arr_znRZkzO[GjxogPx].as_map(),pCounterDescriptions[GjxogPx]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=json::vector();
            return; }auto arr_QuwxWHd=json::vector(1);
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=static_cast<uint>(pCounterCount[HDbVSFc]);}();
        }
        json["pCounterCount"]=arr_QuwxWHd;}();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=json::vector();
            return; }auto arr_vEVlsJt=json::vector(*pCounterCount);
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCounters[WmftXku]);
            arr_vEVlsJt[WmftXku]=temp_map;
            return;
            }();
        }
        json["pCounters"]=arr_vEVlsJt;}();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=json::vector();
            return; }auto arr_znRZkzO=json::vector(*pCounterCount);
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCounterDescriptions[GjxogPx]);
            arr_znRZkzO[GjxogPx]=temp_map;
            return;
            }();
        }
        json["pCounterDescriptions"]=arr_znRZkzO;}();


        json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo;
[&](){
            if (json["pPerformanceQueryCreateInfo"].as_vector().size()==0){
                pPerformanceQueryCreateInfo=NULL;
            return; }pPerformanceQueryCreateInfo=(VkQueryPoolPerformanceCreateInfoKHR*)malloc(1*sizeof(VkQueryPoolPerformanceCreateInfoKHR));auto& arr_WMdwLVX=json["pPerformanceQueryCreateInfo"].as_vector();
        for(int wpxitrA=0; wpxitrA < 1; wpxitrA++){
            [&](){
            deserialize_struct(arr_WMdwLVX[wpxitrA].as_map(),pPerformanceQueryCreateInfo[wpxitrA]);
            }();
        }
        }();
uint32_t* pNumPasses;
[&](){
            if (json["pNumPasses"].as_vector().size()==0){
                pNumPasses=NULL;
            return; }pNumPasses=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_QgclfwI=json["pNumPasses"].as_vector();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){
            if (arr_QgclfwI[vyixxEg].is_uint64_t()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_uint64_t());
            }else if (arr_QgclfwI[vyixxEg].is_int64_t()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_int64_t());
            }else{
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_double());
            }
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }  
    
{
call_function(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=json::vector();
            return; }auto arr_HfbrSJi=json::vector(1);
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPerformanceQueryCreateInfo[aEYwfht]);
            arr_HfbrSJi[aEYwfht]=temp_map;
            return;
            }();
        }
        json["pPerformanceQueryCreateInfo"]=arr_HfbrSJi;}();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=json::vector();
            return; }auto arr_QgclfwI=json::vector(1);
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=static_cast<uint>(pNumPasses[vyixxEg]);}();
        }
        json["pNumPasses"]=arr_QgclfwI;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR);
        writeToConn(json);
    }

    void handle_vkAcquireProfilingLockKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAcquireProfilingLockInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAcquireProfilingLockInfoKHR*)malloc(1*sizeof(VkAcquireProfilingLockInfoKHR));auto& arr_cbbacNs=json["pInfo"].as_vector();
        for(int ykaKCfg=0; ykaKCfg < 1; ykaKCfg++){
            [&](){
            deserialize_struct(arr_cbbacNs[ykaKCfg].as_map(),pInfo[ykaKCfg]);
            }();
        }
        }();

    PFN_vkAcquireProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAcquireProfilingLockKHR)get_instance_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAcquireProfilingLockKHR)get_device_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_BslWEPE=json::vector(1);
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ZgSmBLm]);
            arr_BslWEPE[ZgSmBLm]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_BslWEPE;}();


        json["stream_type"]=static_cast<int>(VKACQUIREPROFILINGLOCKKHR);
        writeToConn(json);
    }

    void handle_vkReleaseProfilingLockKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkReleaseProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkReleaseProfilingLockKHR)get_instance_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkReleaseProfilingLockKHR)get_device_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=static_cast<int>(VKRELEASEPROFILINGLOCKKHR);
        writeToConn(json);
    }

    void handle_vkGetImageDrmFormatModifierPropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageDrmFormatModifierPropertiesEXT* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageDrmFormatModifierPropertiesEXT*)malloc(1*sizeof(VkImageDrmFormatModifierPropertiesEXT));auto& arr_oxSUmzu=json["pProperties"].as_vector();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            deserialize_struct(arr_oxSUmzu[JPWNMan].as_map(),pProperties[JPWNMan]);
            }();
        }
        }();

    PFN_vkGetImageDrmFormatModifierPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_instance_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_device_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, image, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oxSUmzu=json::vector(1);
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[JPWNMan]);
            arr_oxSUmzu[JPWNMan]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oxSUmzu;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureAddress(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferDeviceAddressInfo* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));auto& arr_Dpwjlow=json["pInfo"].as_vector();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            deserialize_struct(arr_Dpwjlow[htSgjqN].as_map(),pInfo[htSgjqN]);
            }();
        }
        }();

    PFN_vkGetBufferOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }  
    
uint64_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=static_cast<uint>(result);}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LRSftdl=json::vector(1);
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[CPHfQOs]);
            arr_LRSftdl[CPHfQOs]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LRSftdl;}();


        json["stream_type"]=static_cast<int>(VKGETBUFFEROPAQUECAPTUREADDRESS);
        writeToConn(json);
    }

    void handle_vkGetBufferDeviceAddress(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferDeviceAddressInfo* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));auto& arr_Dpwjlow=json["pInfo"].as_vector();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            deserialize_struct(arr_Dpwjlow[htSgjqN].as_map(),pInfo[htSgjqN]);
            }();
        }
        }();

    PFN_vkGetBufferDeviceAddress call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetBufferDeviceAddress)get_instance_proc_addr(parent,"vkGetBufferDeviceAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetBufferDeviceAddress)get_device_proc_addr(parent,"vkGetBufferDeviceAddress");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LRSftdl=json::vector(1);
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[CPHfQOs]);
            arr_LRSftdl[CPHfQOs]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LRSftdl;}();


        json["stream_type"]=static_cast<int>(VKGETBUFFERDEVICEADDRESS);
        writeToConn(json);
    }

    void handle_vkCreateHeadlessSurfaceEXT(json::map& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkHeadlessSurfaceCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkHeadlessSurfaceCreateInfoEXT*)malloc(1*sizeof(VkHeadlessSurfaceCreateInfoEXT));auto& arr_ZPTPwbX=json["pCreateInfo"].as_vector();
        for(int zfADAts=0; zfADAts < 1; zfADAts++){
            [&](){
            deserialize_struct(arr_ZPTPwbX[zfADAts].as_map(),pCreateInfo[zfADAts]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateHeadlessSurfaceEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_instance_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_device_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_yHbnuDf=json::vector(1);
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[CyHXDmy]);
            arr_yHbnuDf[CyHXDmy]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_yHbnuDf;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();


        json["stream_type"]=static_cast<int>(VKCREATEHEADLESSSURFACEEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pCombinationCount;
[&](){
            if (json["pCombinationCount"].as_vector().size()==0){
                pCombinationCount=NULL;
            return; }pCombinationCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_VrJxAqY=json["pCombinationCount"].as_vector();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){
            if (arr_VrJxAqY[jKkiHUO].is_uint64_t()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_uint64_t());
            }else if (arr_VrJxAqY[jKkiHUO].is_int64_t()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_int64_t());
            }else{
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_double());
            }
            }();
        }
        }();
VkFramebufferMixedSamplesCombinationNV* pCombinations;
[&](){
            if (json["pCombinations"].as_vector().size()==0){
                pCombinations=NULL;
            return; }pCombinations=(VkFramebufferMixedSamplesCombinationNV*)malloc(*pCombinationCount*sizeof(VkFramebufferMixedSamplesCombinationNV));auto& arr_aOIaDFM=json["pCombinations"].as_vector();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            deserialize_struct(arr_aOIaDFM[oxJqbjP].as_map(),pCombinations[oxJqbjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pCombinationCount, pCombinations);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=json::vector();
            return; }auto arr_VrJxAqY=json::vector(1);
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=static_cast<uint>(pCombinationCount[jKkiHUO]);}();
        }
        json["pCombinationCount"]=arr_VrJxAqY;}();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=json::vector();
            return; }auto arr_aOIaDFM=json::vector(*pCombinationCount);
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCombinations[oxJqbjP]);
            arr_aOIaDFM[oxJqbjP]=temp_map;
            return;
            }();
        }
        json["pCombinations"]=arr_aOIaDFM;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV);
        writeToConn(json);
    }

    void handle_vkInitializePerformanceApiINTEL(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkInitializePerformanceApiInfoINTEL* pInitializeInfo;
[&](){
            if (json["pInitializeInfo"].as_vector().size()==0){
                pInitializeInfo=NULL;
            return; }pInitializeInfo=(VkInitializePerformanceApiInfoINTEL*)malloc(1*sizeof(VkInitializePerformanceApiInfoINTEL));auto& arr_cpZIIic=json["pInitializeInfo"].as_vector();
        for(int BZrUSpL=0; BZrUSpL < 1; BZrUSpL++){
            [&](){
            deserialize_struct(arr_cpZIIic[BZrUSpL].as_map(),pInitializeInfo[BZrUSpL]);
            }();
        }
        }();

    PFN_vkInitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, pInitializeInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=json::vector();
            return; }auto arr_BGIuPda=json::vector(1);
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInitializeInfo[pMSNyrD]);
            arr_BGIuPda[pMSNyrD]=temp_map;
            return;
            }();
        }
        json["pInitializeInfo"]=arr_BGIuPda;}();


        json["stream_type"]=static_cast<int>(VKINITIALIZEPERFORMANCEAPIINTEL);
        writeToConn(json);
    }

    void handle_vkUninitializePerformanceApiINTEL(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkUninitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=static_cast<int>(VKUNINITIALIZEPERFORMANCEAPIINTEL);
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceMarkerINTEL(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceMarkerInfoINTEL* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].as_vector().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkPerformanceMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceMarkerInfoINTEL));auto& arr_mjbTuwx=json["pMarkerInfo"].as_vector();
        for(int aadJAzE=0; aadJAzE < 1; aadJAzE++){
            [&](){
            deserialize_struct(arr_mjbTuwx[aadJAzE].as_map(),pMarkerInfo[aadJAzE]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceMarkerINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_jnuNlGq=json::vector(1);
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[zTzAESc]);
            arr_jnuNlGq[zTzAESc]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_jnuNlGq;}();


        json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCEMARKERINTEL);
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceStreamMarkerINTEL(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].as_vector().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkPerformanceStreamMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceStreamMarkerInfoINTEL));auto& arr_QvDzNEm=json["pMarkerInfo"].as_vector();
        for(int ylzDRXy=0; ylzDRXy < 1; ylzDRXy++){
            [&](){
            deserialize_struct(arr_QvDzNEm[ylzDRXy].as_map(),pMarkerInfo[ylzDRXy]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceStreamMarkerINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_MVQnSpz=json::vector(1);
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[xfSMHfo]);
            arr_MVQnSpz[xfSMHfo]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_MVQnSpz;}();


        json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCESTREAMMARKERINTEL);
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceOverrideINTEL(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceOverrideInfoINTEL* pOverrideInfo;
[&](){
            if (json["pOverrideInfo"].as_vector().size()==0){
                pOverrideInfo=NULL;
            return; }pOverrideInfo=(VkPerformanceOverrideInfoINTEL*)malloc(1*sizeof(VkPerformanceOverrideInfoINTEL));auto& arr_ZThQunI=json["pOverrideInfo"].as_vector();
        for(int VQeLutW=0; VQeLutW < 1; VQeLutW++){
            [&](){
            deserialize_struct(arr_ZThQunI[VQeLutW].as_map(),pOverrideInfo[VQeLutW]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceOverrideINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pOverrideInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=json::vector();
            return; }auto arr_LHSFuEM=json::vector(1);
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pOverrideInfo[KZSCUHM]);
            arr_LHSFuEM[KZSCUHM]=temp_map;
            return;
            }();
        }
        json["pOverrideInfo"]=arr_LHSFuEM;}();


        json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCEOVERRIDEINTEL);
        writeToConn(json);
    }

    void handle_vkAcquirePerformanceConfigurationINTEL(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo;
[&](){
            if (json["pAcquireInfo"].as_vector().size()==0){
                pAcquireInfo=NULL;
            return; }pAcquireInfo=(VkPerformanceConfigurationAcquireInfoINTEL*)malloc(1*sizeof(VkPerformanceConfigurationAcquireInfoINTEL));auto& arr_vfPlthd=json["pAcquireInfo"].as_vector();
        for(int IYVMDgx=0; IYVMDgx < 1; IYVMDgx++){
            [&](){
            deserialize_struct(arr_vfPlthd[IYVMDgx].as_map(),pAcquireInfo[IYVMDgx]);
            }();
        }
        }();
VkPerformanceConfigurationINTEL* pConfiguration;
[&](){
            if (json["pConfiguration"].as_vector().size()==0){
                pConfiguration=NULL;
            return; }pConfiguration=(VkPerformanceConfigurationINTEL*)malloc(1*sizeof(VkPerformanceConfigurationINTEL));auto& arr_zSRZrDS=json["pConfiguration"].as_vector();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();

    PFN_vkAcquirePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, pAcquireInfo, pConfiguration);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=json::vector();
            return; }auto arr_ZyqvvlF=json::vector(1);
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAcquireInfo[RYEcOAO]);
            arr_ZyqvvlF[RYEcOAO]=temp_map;
            return;
            }();
        }
        json["pAcquireInfo"]=arr_ZyqvvlF;}();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=json::vector();
            return; }auto arr_zSRZrDS=json::vector(1);
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        json["pConfiguration"]=arr_zSRZrDS;}();


        json["stream_type"]=static_cast<int>(VKACQUIREPERFORMANCECONFIGURATIONINTEL);
        writeToConn(json);
    }

    void handle_vkReleasePerformanceConfigurationINTEL(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkReleasePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        json["stream_type"]=static_cast<int>(VKRELEASEPERFORMANCECONFIGURATIONINTEL);
        writeToConn(json);
    }

    void handle_vkQueueSetPerformanceConfigurationINTEL(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkQueueSetPerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(queue, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        json["stream_type"]=static_cast<int>(VKQUEUESETPERFORMANCECONFIGURATIONINTEL);
        writeToConn(json);
    }

    void handle_vkGetPerformanceParameterINTEL(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceParameterTypeINTEL parameter;
[&](){[&](){int temp_TQususa;[&](){
            if (json["parameter"].is_uint64_t()){
                temp_TQususa=static_cast<int>(json["parameter"].as_uint64_t());
            }else if (json["parameter"].is_int64_t()){
                temp_TQususa=static_cast<int>(json["parameter"].as_int64_t());
            }else{
                temp_TQususa=static_cast<int>(json["parameter"].as_double());
            }
            }();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
VkPerformanceValueINTEL* pValue;
[&](){
            if (json["pValue"].as_vector().size()==0){
                pValue=NULL;
            return; }pValue=(VkPerformanceValueINTEL*)malloc(1*sizeof(VkPerformanceValueINTEL));auto& arr_hOmaGpc=json["pValue"].as_vector();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            deserialize_struct(arr_hOmaGpc[lyxuUNd].as_map(),pValue[lyxuUNd]);
            }();
        }
        }();

    PFN_vkGetPerformanceParameterINTEL call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_instance_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_device_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, parameter, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=static_cast<int>(parameter);}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=json::vector();
            return; }auto arr_hOmaGpc=json::vector(1);
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pValue[lyxuUNd]);
            arr_hOmaGpc[lyxuUNd]=temp_map;
            return;
            }();
        }
        json["pValue"]=arr_hOmaGpc;}();


        json["stream_type"]=static_cast<int>(VKGETPERFORMANCEPARAMETERINTEL);
        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryOpaqueCaptureAddress(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceMemoryOpaqueCaptureAddressInfo*)malloc(1*sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo));auto& arr_AaiLWsP=json["pInfo"].as_vector();
        for(int PJKtAPm=0; PJKtAPm < 1; PJKtAPm++){
            [&](){
            deserialize_struct(arr_AaiLWsP[PJKtAPm].as_map(),pInfo[PJKtAPm]);
            }();
        }
        }();

    PFN_vkGetDeviceMemoryOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }  
    
uint64_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=static_cast<uint>(result);}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_hjweGct=json::vector(1);
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vcZpbuB]);
            arr_hjweGct[vcZpbuB]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_hjweGct;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS);
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutablePropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineInfoKHR* pPipelineInfo;
[&](){
            if (json["pPipelineInfo"].as_vector().size()==0){
                pPipelineInfo=NULL;
            return; }pPipelineInfo=(VkPipelineInfoKHR*)malloc(1*sizeof(VkPipelineInfoKHR));auto& arr_TqFxxbV=json["pPipelineInfo"].as_vector();
        for(int yiBzToE=0; yiBzToE < 1; yiBzToE++){
            [&](){
            deserialize_struct(arr_TqFxxbV[yiBzToE].as_map(),pPipelineInfo[yiBzToE]);
            }();
        }
        }();
uint32_t* pExecutableCount;
[&](){
            if (json["pExecutableCount"].as_vector().size()==0){
                pExecutableCount=NULL;
            return; }pExecutableCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_tlXPSPh=json["pExecutableCount"].as_vector();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){
            if (arr_tlXPSPh[ZFmbkCm].is_uint64_t()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_uint64_t());
            }else if (arr_tlXPSPh[ZFmbkCm].is_int64_t()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_int64_t());
            }else{
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_double());
            }
            }();
        }
        }();
VkPipelineExecutablePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPipelineExecutablePropertiesKHR*)malloc(*pExecutableCount*sizeof(VkPipelineExecutablePropertiesKHR));auto& arr_vtfdUfF=json["pProperties"].as_vector();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            deserialize_struct(arr_vtfdUfF[uPFqrVz].as_map(),pProperties[uPFqrVz]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutablePropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_device_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pPipelineInfo, pExecutableCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=json::vector();
            return; }auto arr_SxuxUqw=json::vector(1);
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineInfo[mwoMxRp]);
            arr_SxuxUqw[mwoMxRp]=temp_map;
            return;
            }();
        }
        json["pPipelineInfo"]=arr_SxuxUqw;}();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=json::vector();
            return; }auto arr_tlXPSPh=json::vector(1);
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=static_cast<uint>(pExecutableCount[ZFmbkCm]);}();
        }
        json["pExecutableCount"]=arr_tlXPSPh;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_vtfdUfF=json::vector(*pExecutableCount);
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[uPFqrVz]);
            arr_vtfdUfF[uPFqrVz]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_vtfdUfF;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLEPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableStatisticsKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){
            if (json["pExecutableInfo"].as_vector().size()==0){
                pExecutableInfo=NULL;
            return; }pExecutableInfo=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));auto& arr_NilRUQP=json["pExecutableInfo"].as_vector();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            deserialize_struct(arr_NilRUQP[bxhNcYs].as_map(),pExecutableInfo[bxhNcYs]);
            }();
        }
        }();
uint32_t* pStatisticCount;
[&](){
            if (json["pStatisticCount"].as_vector().size()==0){
                pStatisticCount=NULL;
            return; }pStatisticCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_BIkbvee=json["pStatisticCount"].as_vector();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){
            if (arr_BIkbvee[MiieuSo].is_uint64_t()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_uint64_t());
            }else if (arr_BIkbvee[MiieuSo].is_int64_t()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_int64_t());
            }else{
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_double());
            }
            }();
        }
        }();
VkPipelineExecutableStatisticKHR* pStatistics;
[&](){
            if (json["pStatistics"].as_vector().size()==0){
                pStatistics=NULL;
            return; }pStatistics=(VkPipelineExecutableStatisticKHR*)malloc(*pStatisticCount*sizeof(VkPipelineExecutableStatisticKHR));auto& arr_cGybyJf=json["pStatistics"].as_vector();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            deserialize_struct(arr_cGybyJf[ktSOZGx].as_map(),pStatistics[ktSOZGx]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableStatisticsKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pExecutableInfo, pStatisticCount, pStatistics);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=json::vector();
            return; }auto arr_xbHlsCc=json::vector(1);
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecutableInfo[JTDfcCv]);
            arr_xbHlsCc[JTDfcCv]=temp_map;
            return;
            }();
        }
        json["pExecutableInfo"]=arr_xbHlsCc;}();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=json::vector();
            return; }auto arr_BIkbvee=json::vector(1);
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=static_cast<uint>(pStatisticCount[MiieuSo]);}();
        }
        json["pStatisticCount"]=arr_BIkbvee;}();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=json::vector();
            return; }auto arr_cGybyJf=json::vector(*pStatisticCount);
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pStatistics[ktSOZGx]);
            arr_cGybyJf[ktSOZGx]=temp_map;
            return;
            }();
        }
        json["pStatistics"]=arr_cGybyJf;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLESTATISTICSKHR);
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableInternalRepresentationsKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){
            if (json["pExecutableInfo"].as_vector().size()==0){
                pExecutableInfo=NULL;
            return; }pExecutableInfo=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));auto& arr_NilRUQP=json["pExecutableInfo"].as_vector();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            deserialize_struct(arr_NilRUQP[bxhNcYs].as_map(),pExecutableInfo[bxhNcYs]);
            }();
        }
        }();
uint32_t* pInternalRepresentationCount;
[&](){
            if (json["pInternalRepresentationCount"].as_vector().size()==0){
                pInternalRepresentationCount=NULL;
            return; }pInternalRepresentationCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_bVgggzH=json["pInternalRepresentationCount"].as_vector();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){
            if (arr_bVgggzH[urjNjhc].is_uint64_t()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_uint64_t());
            }else if (arr_bVgggzH[urjNjhc].is_int64_t()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_int64_t());
            }else{
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_double());
            }
            }();
        }
        }();
VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations;
[&](){
            if (json["pInternalRepresentations"].as_vector().size()==0){
                pInternalRepresentations=NULL;
            return; }pInternalRepresentations=(VkPipelineExecutableInternalRepresentationKHR*)malloc(*pInternalRepresentationCount*sizeof(VkPipelineExecutableInternalRepresentationKHR));auto& arr_yqajgdo=json["pInternalRepresentations"].as_vector();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            deserialize_struct(arr_yqajgdo[OdpgULc].as_map(),pInternalRepresentations[OdpgULc]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableInternalRepresentationsKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=json::vector();
            return; }auto arr_xbHlsCc=json::vector(1);
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecutableInfo[JTDfcCv]);
            arr_xbHlsCc[JTDfcCv]=temp_map;
            return;
            }();
        }
        json["pExecutableInfo"]=arr_xbHlsCc;}();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=json::vector();
            return; }auto arr_bVgggzH=json::vector(1);
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=static_cast<uint>(pInternalRepresentationCount[urjNjhc]);}();
        }
        json["pInternalRepresentationCount"]=arr_bVgggzH;}();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=json::vector();
            return; }auto arr_yqajgdo=json::vector(*pInternalRepresentationCount);
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInternalRepresentations[OdpgULc]);
            arr_yqajgdo[OdpgULc]=temp_map;
            return;
            }();
        }
        json["pInternalRepresentations"]=arr_yqajgdo;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR);
        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t lineStippleFactor;
[&](){
            if (json["lineStippleFactor"].is_uint64_t()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_uint64_t());
            }else if (json["lineStippleFactor"].is_int64_t()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_int64_t());
            }else{
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_double());
            }
            }();
uint16_t lineStipplePattern;
[&](){
            if (json["lineStipplePattern"].is_uint64_t()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_uint64_t());
            }else if (json["lineStipplePattern"].is_int64_t()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_int64_t());
            }else{
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_double());
            }
            }();

    PFN_vkCmdSetLineStippleEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLineStippleEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLineStippleEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }  
    
{
call_function(commandBuffer, lineStippleFactor, lineStipplePattern);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=static_cast<uint>(lineStippleFactor);}();
[&](){json["lineStipplePattern"]=static_cast<uint>(lineStipplePattern);}();


        json["stream_type"]=static_cast<int>(VKCMDSETLINESTIPPLEEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceToolProperties(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pToolCount;
[&](){
            if (json["pToolCount"].as_vector().size()==0){
                pToolCount=NULL;
            return; }pToolCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_PNAKwfC=json["pToolCount"].as_vector();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){
            if (arr_PNAKwfC[iRGIIgT].is_uint64_t()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_uint64_t());
            }else if (arr_PNAKwfC[iRGIIgT].is_int64_t()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_int64_t());
            }else{
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_double());
            }
            }();
        }
        }();
VkPhysicalDeviceToolProperties* pToolProperties;
[&](){
            if (json["pToolProperties"].as_vector().size()==0){
                pToolProperties=NULL;
            return; }pToolProperties=(VkPhysicalDeviceToolProperties*)malloc(*pToolCount*sizeof(VkPhysicalDeviceToolProperties));auto& arr_OYowiCQ=json["pToolProperties"].as_vector();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            deserialize_struct(arr_OYowiCQ[dlPXJcQ].as_map(),pToolProperties[dlPXJcQ]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceToolProperties call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pToolCount, pToolProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=json::vector();
            return; }auto arr_PNAKwfC=json::vector(1);
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=static_cast<uint>(pToolCount[iRGIIgT]);}();
        }
        json["pToolCount"]=arr_PNAKwfC;}();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=json::vector();
            return; }auto arr_OYowiCQ=json::vector(*pToolCount);
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pToolProperties[dlPXJcQ]);
            arr_OYowiCQ[dlPXJcQ]=temp_map;
            return;
            }();
        }
        json["pToolProperties"]=arr_OYowiCQ;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICETOOLPROPERTIES);
        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkAccelerationStructureCreateInfoKHR*)malloc(1*sizeof(VkAccelerationStructureCreateInfoKHR));auto& arr_rLnSCOE=json["pCreateInfo"].as_vector();
        for(int tKisKdf=0; tKisKdf < 1; tKisKdf++){
            [&](){
            deserialize_struct(arr_rLnSCOE[tKisKdf].as_map(),pCreateInfo[tKisKdf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkAccelerationStructureKHR* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].as_vector().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureKHR*)malloc(1*sizeof(VkAccelerationStructureKHR));auto& arr_vKbZGTA=json["pAccelerationStructure"].as_vector();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_device_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XoURuCS=json::vector(1);
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[bGUDBRC]);
            arr_XoURuCS[bGUDBRC]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XoURuCS;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=json::vector();
            return; }auto arr_vKbZGTA=json::vector(1);
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        json["pAccelerationStructure"]=arr_vKbZGTA;}();


        json["stream_type"]=static_cast<int>(VKCREATEACCELERATIONSTRUCTUREKHR);
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].as_vector().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));auto& arr_pLxHocT=json["pInfos"].as_vector();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            deserialize_struct(arr_pLxHocT[iIAEWFy].as_map(),pInfos[iIAEWFy]);
            }();
        }
        }();
 VkAccelerationStructureBuildRangeInfoKHR* * ppBuildRangeInfos;
[&](){
            if (json["ppBuildRangeInfos"].as_vector().size()==0){
                ppBuildRangeInfos=NULL;
            return; }ppBuildRangeInfos=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));auto& arr_LOFGJKx=json["ppBuildRangeInfos"].as_vector();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].as_vector().size()==0){
                ppBuildRangeInfos[gLEYTdh]=NULL;
            return; }ppBuildRangeInfos[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].as_vector();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            deserialize_struct(arr_HqQzokg[TwVqYHk].as_map(),ppBuildRangeInfos[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();

    PFN_vkCmdBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=json::vector();
            return; }auto arr_FMxYLmq=json::vector(1);
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=json::vector();
            return; }auto arr_PKxEvVS=json::vector(infoCount);
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            arr_PKxEvVS[IUJrDJF]=temp_map;
            return;
            }();
        }
        arr_FMxYLmq[CRaOjpb]=arr_PKxEvVS;}();
        }
        json["ppBuildRangeInfos"]=arr_FMxYLmq;}();


        json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURESKHR);
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresIndirectKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].as_vector().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));auto& arr_pLxHocT=json["pInfos"].as_vector();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            deserialize_struct(arr_pLxHocT[iIAEWFy].as_map(),pInfos[iIAEWFy]);
            }();
        }
        }();
 VkDeviceAddress* pIndirectDeviceAddresses;
[&](){
            if (json["pIndirectDeviceAddresses"].as_vector().size()==0){
                pIndirectDeviceAddresses=NULL;
            return; }pIndirectDeviceAddresses=(VkDeviceAddress*)malloc(infoCount*sizeof(VkDeviceAddress));auto& arr_qqxgmPw=json["pIndirectDeviceAddresses"].as_vector();
        for(int mphFFLu=0; mphFFLu < infoCount; mphFFLu++){
            [&](){uint64_t temp_qqxgmPw;[&](){
            if (arr_qqxgmPw[mphFFLu].is_uint64_t()){
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].as_uint64_t());
            }else if (arr_qqxgmPw[mphFFLu].is_int64_t()){
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].as_int64_t());
            }else{
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].as_double());
            }
            }();pIndirectDeviceAddresses[mphFFLu]=(VkDeviceAddress)temp_qqxgmPw;}();
        }
        }();
 uint32_t* pIndirectStrides;
[&](){
            if (json["pIndirectStrides"].as_vector().size()==0){
                pIndirectStrides=NULL;
            return; }pIndirectStrides=(uint32_t*)malloc(infoCount*sizeof(uint32_t));auto& arr_JoqNqic=json["pIndirectStrides"].as_vector();
        for(int TCKTxsQ=0; TCKTxsQ < infoCount; TCKTxsQ++){
            [&](){
            if (arr_JoqNqic[TCKTxsQ].is_uint64_t()){
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].as_uint64_t());
            }else if (arr_JoqNqic[TCKTxsQ].is_int64_t()){
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].as_int64_t());
            }else{
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].as_double());
            }
            }();
        }
        }();
 uint32_t* * ppMaxPrimitiveCounts;
[&](){
            if (json["ppMaxPrimitiveCounts"].as_vector().size()==0){
                ppMaxPrimitiveCounts=NULL;
            return; }ppMaxPrimitiveCounts=(uint32_t**)malloc(1*sizeof(uint32_t*));auto& arr_lnbIzaN=json["ppMaxPrimitiveCounts"].as_vector();
        for(int DtQfWPT=0; DtQfWPT < 1; DtQfWPT++){
            [&](){
            if (arr_lnbIzaN[DtQfWPT].as_vector().size()==0){
                ppMaxPrimitiveCounts[DtQfWPT]=NULL;
            return; }ppMaxPrimitiveCounts[DtQfWPT]=(uint32_t*)malloc(infoCount*sizeof(uint32_t));auto& arr_RluStPH=arr_lnbIzaN[DtQfWPT].as_vector();
        for(int SaLgIYu=0; SaLgIYu < infoCount; SaLgIYu++){
            [&](){
            if (arr_RluStPH[SaLgIYu].is_uint64_t()){
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].as_uint64_t());
            }else if (arr_RluStPH[SaLgIYu].is_int64_t()){
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].as_int64_t());
            }else{
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].as_double());
            }
            }();
        }
        }();
        }
        }();

    PFN_vkCmdBuildAccelerationStructuresIndirectKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=json::vector();
            return; }auto arr_YkBEqzj=json::vector(infoCount);
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=static_cast<uint>(pIndirectDeviceAddresses[tMAuxlx]);}();}();
        }
        json["pIndirectDeviceAddresses"]=arr_YkBEqzj;}();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=json::vector();
            return; }auto arr_Helprzq=json::vector(infoCount);
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=static_cast<uint>(pIndirectStrides[IXUUYlr]);}();
        }
        json["pIndirectStrides"]=arr_Helprzq;}();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=json::vector();
            return; }auto arr_DfsqJWs=json::vector(1);
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=json::vector();
            return; }auto arr_kfQrDXL=json::vector(infoCount);
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=static_cast<uint>(ppMaxPrimitiveCounts[TyNkaSn][SABezVP]);}();
        }
        arr_DfsqJWs[TyNkaSn]=arr_kfQrDXL;}();
        }
        json["ppMaxPrimitiveCounts"]=arr_DfsqJWs;}();


        json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR);
        writeToConn(json);
    }

    void handle_vkBuildAccelerationStructuresKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].as_vector().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));auto& arr_pLxHocT=json["pInfos"].as_vector();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            deserialize_struct(arr_pLxHocT[iIAEWFy].as_map(),pInfos[iIAEWFy]);
            }();
        }
        }();
 VkAccelerationStructureBuildRangeInfoKHR* * ppBuildRangeInfos;
[&](){
            if (json["ppBuildRangeInfos"].as_vector().size()==0){
                ppBuildRangeInfos=NULL;
            return; }ppBuildRangeInfos=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));auto& arr_LOFGJKx=json["ppBuildRangeInfos"].as_vector();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].as_vector().size()==0){
                ppBuildRangeInfos[gLEYTdh]=NULL;
            return; }ppBuildRangeInfos[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].as_vector();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            deserialize_struct(arr_HqQzokg[TwVqYHk].as_map(),ppBuildRangeInfos[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();

    PFN_vkBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=json::vector();
            return; }auto arr_FMxYLmq=json::vector(1);
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=json::vector();
            return; }auto arr_PKxEvVS=json::vector(infoCount);
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            arr_PKxEvVS[IUJrDJF]=temp_map;
            return;
            }();
        }
        arr_FMxYLmq[CRaOjpb]=arr_PKxEvVS;}();
        }
        json["ppBuildRangeInfos"]=arr_FMxYLmq;}();


        json["stream_type"]=static_cast<int>(VKBUILDACCELERATIONSTRUCTURESKHR);
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureDeviceAddressKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureDeviceAddressInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureDeviceAddressInfoKHR*)malloc(1*sizeof(VkAccelerationStructureDeviceAddressInfoKHR));auto& arr_hewpWGr=json["pInfo"].as_vector();
        for(int XQgcVWG=0; XQgcVWG < 1; XQgcVWG++){
            [&](){
            deserialize_struct(arr_hewpWGr[XQgcVWG].as_map(),pInfo[XQgcVWG]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureDeviceAddressKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_CAfLmMn=json::vector(1);
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[DozYfEa]);
            arr_CAfLmMn[DozYfEa]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_CAfLmMn;}();


        json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR);
        writeToConn(json);
    }

    void handle_vkCreateDeferredOperationKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkDeferredOperationKHR* pDeferredOperation;
[&](){
            if (json["pDeferredOperation"].as_vector().size()==0){
                pDeferredOperation=NULL;
            return; }pDeferredOperation=(VkDeferredOperationKHR*)malloc(1*sizeof(VkDeferredOperationKHR));auto& arr_fPVilHH=json["pDeferredOperation"].as_vector();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();

    PFN_vkCreateDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateDeferredOperationKHR)get_instance_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateDeferredOperationKHR)get_device_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocator, pDeferredOperation);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=json::vector();
            return; }auto arr_fPVilHH=json::vector(1);
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        json["pDeferredOperation"]=arr_fPVilHH;}();


        json["stream_type"]=static_cast<int>(VKCREATEDEFERREDOPERATIONKHR);
        writeToConn(json);
    }

    void handle_vkDestroyDeferredOperationKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_instance_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_device_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }  
    
{
call_function(device, operation, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYDEFERREDOPERATIONKHR);
        writeToConn(json);
    }

    void handle_vkGetDeferredOperationMaxConcurrencyKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationMaxConcurrencyKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_device_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }  
    
uint32_t  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){json["result"]=static_cast<uint>(result);}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=static_cast<int>(VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR);
        writeToConn(json);
    }

    void handle_vkGetDeferredOperationResultKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationResultKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_device_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }  
    
VkResult  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=static_cast<int>(VKGETDEFERREDOPERATIONRESULTKHR);
        writeToConn(json);
    }

    void handle_vkDeferredOperationJoinKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkDeferredOperationJoinKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDeferredOperationJoinKHR)get_instance_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDeferredOperationJoinKHR)get_device_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }  
    
VkResult  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=static_cast<int>(VKDEFERREDOPERATIONJOINKHR);
        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectMemoryRequirementsNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkComputePipelineCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkComputePipelineCreateInfo*)malloc(1*sizeof(VkComputePipelineCreateInfo));auto& arr_IIYnuXe=json["pCreateInfo"].as_vector();
        for(int LOABkrY=0; LOABkrY < 1; LOABkrY++){
            [&](){
            deserialize_struct(arr_IIYnuXe[LOABkrY].as_map(),pCreateInfo[LOABkrY]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetPipelineIndirectMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }  
    
{
call_function(device, pCreateInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XLStDVY=json::vector(1);
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[FoBxBjF]);
            arr_XLStDVY[FoBxBjF]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XLStDVY;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV);
        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectDeviceAddressNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineIndirectDeviceAddressInfoNV* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkPipelineIndirectDeviceAddressInfoNV*)malloc(1*sizeof(VkPipelineIndirectDeviceAddressInfoNV));auto& arr_nyTOzHx=json["pInfo"].as_vector();
        for(int fovHdtg=0; fovHdtg < 1; fovHdtg++){
            [&](){
            deserialize_struct(arr_nyTOzHx[fovHdtg].as_map(),pInfo[fovHdtg]);
            }();
        }
        }();

    PFN_vkGetPipelineIndirectDeviceAddressNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_device_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=static_cast<uint>(result);}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_iNXSdlN=json::vector(1);
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[EeNdDDD]);
            arr_iNXSdlN[EeNdDDD]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_iNXSdlN;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEINDIRECTDEVICEADDRESSNV);
        writeToConn(json);
    }

    void handle_vkCmdSetCullMode(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCullModeFlags cullMode;
[&](){[&](){int temp_JocwJIC;[&](){
            if (json["cullMode"].is_uint64_t()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_uint64_t());
            }else if (json["cullMode"].is_int64_t()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_int64_t());
            }else{
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_double());
            }
            }();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

    PFN_vkCmdSetCullMode call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCullMode)get_instance_proc_addr(parent,"vkCmdSetCullMode");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCullMode)get_device_proc_addr(parent,"vkCmdSetCullMode");
    }  
    
{
call_function(commandBuffer, cullMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=static_cast<int>(cullMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCULLMODE);
        writeToConn(json);
    }

    void handle_vkCmdSetFrontFace(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFrontFace frontFace;
[&](){[&](){int temp_ZBubEzp;[&](){
            if (json["frontFace"].is_uint64_t()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_uint64_t());
            }else if (json["frontFace"].is_int64_t()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_int64_t());
            }else{
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_double());
            }
            }();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

    PFN_vkCmdSetFrontFace call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetFrontFace)get_instance_proc_addr(parent,"vkCmdSetFrontFace");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetFrontFace)get_device_proc_addr(parent,"vkCmdSetFrontFace");
    }  
    
{
call_function(commandBuffer, frontFace);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=static_cast<int>(frontFace);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETFRONTFACE);
        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveTopology(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPrimitiveTopology primitiveTopology;
[&](){[&](){int temp_jzAnfAA;[&](){
            if (json["primitiveTopology"].is_uint64_t()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_uint64_t());
            }else if (json["primitiveTopology"].is_int64_t()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_int64_t());
            }else{
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_double());
            }
            }();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

    PFN_vkCmdSetPrimitiveTopology call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_instance_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_device_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }  
    
{
call_function(commandBuffer, primitiveTopology);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=static_cast<int>(primitiveTopology);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETPRIMITIVETOPOLOGY);
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWithCount(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();
 VkViewport* pViewports;
[&](){
            if (json["pViewports"].as_vector().size()==0){
                pViewports=NULL;
            return; }pViewports=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));auto& arr_NYoDqxX=json["pViewports"].as_vector();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            deserialize_struct(arr_NYoDqxX[SjlAQpy].as_map(),pViewports[SjlAQpy]);
            }();
        }
        }();

    PFN_vkCmdSetViewportWithCount call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewportWithCount)get_instance_proc_addr(parent,"vkCmdSetViewportWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewportWithCount)get_device_proc_addr(parent,"vkCmdSetViewportWithCount");
    }  
    
{
call_function(commandBuffer, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=json::vector();
            return; }auto arr_SyYryUE=json::vector(viewportCount);
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewports[HAuJlzw]);
            arr_SyYryUE[HAuJlzw]=temp_map;
            return;
            }();
        }
        json["pViewports"]=arr_SyYryUE;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWITHCOUNT);
        writeToConn(json);
    }

    void handle_vkCmdSetScissorWithCount(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t scissorCount;
[&](){
            if (json["scissorCount"].is_uint64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_uint64_t());
            }else if (json["scissorCount"].is_int64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_int64_t());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_double());
            }
            }();
 VkRect2D* pScissors;
[&](){
            if (json["pScissors"].as_vector().size()==0){
                pScissors=NULL;
            return; }pScissors=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));auto& arr_bIRAuhj=json["pScissors"].as_vector();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            deserialize_struct(arr_bIRAuhj[QukNmCZ].as_map(),pScissors[QukNmCZ]);
            }();
        }
        }();

    PFN_vkCmdSetScissorWithCount call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetScissorWithCount)get_instance_proc_addr(parent,"vkCmdSetScissorWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetScissorWithCount)get_device_proc_addr(parent,"vkCmdSetScissorWithCount");
    }  
    
{
call_function(commandBuffer, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=static_cast<uint>(scissorCount);}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=json::vector();
            return; }auto arr_RpUaBcS=json::vector(scissorCount);
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pScissors[XBYGvVT]);
            arr_RpUaBcS[XBYGvVT]=temp_map;
            return;
            }();
        }
        json["pScissors"]=arr_RpUaBcS;}();


        json["stream_type"]=static_cast<int>(VKCMDSETSCISSORWITHCOUNT);
        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer2KHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_uint64_t());
            }else if (json["indexType"].is_int64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_int64_t());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_device_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }  
    
{
call_function(commandBuffer, buffer, offset, size, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){[&](){[&](){json["indexType"]=static_cast<int>(indexType);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDBINDINDEXBUFFER2KHR);
        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].as_vector().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));auto& arr_ShVTBbp=json["pBuffers"].as_vector();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].as_vector().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_uWdiGtF=json["pOffsets"].as_vector();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_uint64_t());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_int64_t());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();
 VkDeviceSize* pSizes;
[&](){
            if (json["pSizes"].as_vector().size()==0){
                pSizes=NULL;
            return; }pSizes=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_cHIDMyb=json["pSizes"].as_vector();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){
            if (arr_cHIDMyb[yLUmhkZ].is_uint64_t()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_uint64_t());
            }else if (arr_cHIDMyb[yLUmhkZ].is_int64_t()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_int64_t());
            }else{
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].as_double());
            }
            }();pSizes[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();
 VkDeviceSize* pStrides;
[&](){
            if (json["pStrides"].as_vector().size()==0){
                pStrides=NULL;
            return; }pStrides=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));auto& arr_FOKmrCn=json["pStrides"].as_vector();
        for(int ByEZqEy=0; ByEZqEy < bindingCount; ByEZqEy++){
            [&](){uint64_t temp_FOKmrCn;[&](){
            if (arr_FOKmrCn[ByEZqEy].is_uint64_t()){
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].as_uint64_t());
            }else if (arr_FOKmrCn[ByEZqEy].is_int64_t()){
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].as_int64_t());
            }else{
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].as_double());
            }
            }();pStrides[ByEZqEy]=(VkDeviceSize)temp_FOKmrCn;}();
        }
        }();

    PFN_vkCmdBindVertexBuffers2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers2)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindVertexBuffers2)get_device_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=json::vector();
            return; }auto arr_OwyEmcF=json::vector(bindingCount);
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=static_cast<uint>(pSizes[YFhxzVl]);}();}();
        }
        json["pSizes"]=arr_OwyEmcF;}();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=json::vector();
            return; }auto arr_YFLMtWg=json::vector(bindingCount);
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=static_cast<uint>(pStrides[qlkJtZj]);}();}();
        }
        json["pStrides"]=arr_YFLMtWg;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDVERTEXBUFFERS2);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthTestEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthTestEnable;
[&](){uint32_t temp_WLSKeYp;[&](){
            if (json["depthTestEnable"].is_uint64_t()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_uint64_t());
            }else if (json["depthTestEnable"].is_int64_t()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_int64_t());
            }else{
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_double());
            }
            }();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

    PFN_vkCmdSetDepthTestEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }  
    
{
call_function(commandBuffer, depthTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=static_cast<uint>(depthTestEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHTESTENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthWriteEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthWriteEnable;
[&](){uint32_t temp_qztdWhG;[&](){
            if (json["depthWriteEnable"].is_uint64_t()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_uint64_t());
            }else if (json["depthWriteEnable"].is_int64_t()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_int64_t());
            }else{
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_double());
            }
            }();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

    PFN_vkCmdSetDepthWriteEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_instance_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_device_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }  
    
{
call_function(commandBuffer, depthWriteEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=static_cast<uint>(depthWriteEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHWRITEENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthCompareOp(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCompareOp depthCompareOp;
[&](){[&](){int temp_GommENv;[&](){
            if (json["depthCompareOp"].is_uint64_t()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_uint64_t());
            }else if (json["depthCompareOp"].is_int64_t()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_int64_t());
            }else{
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_double());
            }
            }();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

    PFN_vkCmdSetDepthCompareOp call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthCompareOp)get_instance_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthCompareOp)get_device_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }  
    
{
call_function(commandBuffer, depthCompareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=static_cast<int>(depthCompareOp);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCOMPAREOP);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBoundsTestEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBoundsTestEnable;
[&](){uint32_t temp_qmudcyJ;[&](){
            if (json["depthBoundsTestEnable"].is_uint64_t()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_uint64_t());
            }else if (json["depthBoundsTestEnable"].is_int64_t()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_int64_t());
            }else{
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_double());
            }
            }();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

    PFN_vkCmdSetDepthBoundsTestEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }  
    
{
call_function(commandBuffer, depthBoundsTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=static_cast<uint>(depthBoundsTestEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBOUNDSTESTENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetStencilTestEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stencilTestEnable;
[&](){uint32_t temp_qPvOEDS;[&](){
            if (json["stencilTestEnable"].is_uint64_t()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_uint64_t());
            }else if (json["stencilTestEnable"].is_int64_t()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_int64_t());
            }else{
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_double());
            }
            }();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

    PFN_vkCmdSetStencilTestEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetStencilTestEnable)get_instance_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetStencilTestEnable)get_device_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }  
    
{
call_function(commandBuffer, stencilTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=static_cast<uint>(stencilTestEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETSTENCILTESTENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetStencilOp(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
VkStencilOp failOp;
[&](){[&](){int temp_lKXncFy;[&](){
            if (json["failOp"].is_uint64_t()){
                temp_lKXncFy=static_cast<int>(json["failOp"].as_uint64_t());
            }else if (json["failOp"].is_int64_t()){
                temp_lKXncFy=static_cast<int>(json["failOp"].as_int64_t());
            }else{
                temp_lKXncFy=static_cast<int>(json["failOp"].as_double());
            }
            }();failOp=(VkStencilOp)temp_lKXncFy;}();}();
VkStencilOp passOp;
[&](){[&](){int temp_SPMLjKg;[&](){
            if (json["passOp"].is_uint64_t()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_uint64_t());
            }else if (json["passOp"].is_int64_t()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_int64_t());
            }else{
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_double());
            }
            }();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
VkStencilOp depthFailOp;
[&](){[&](){int temp_TdIKNtG;[&](){
            if (json["depthFailOp"].is_uint64_t()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_uint64_t());
            }else if (json["depthFailOp"].is_int64_t()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_int64_t());
            }else{
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_double());
            }
            }();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
VkCompareOp compareOp;
[&](){[&](){int temp_NLoCySV;[&](){
            if (json["compareOp"].is_uint64_t()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_uint64_t());
            }else if (json["compareOp"].is_int64_t()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_int64_t());
            }else{
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_double());
            }
            }();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

    PFN_vkCmdSetStencilOp call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetStencilOp)get_instance_proc_addr(parent,"vkCmdSetStencilOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetStencilOp)get_device_proc_addr(parent,"vkCmdSetStencilOp");
    }  
    
{
call_function(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){[&](){[&](){json["failOp"]=static_cast<int>(failOp);}();}();}();
[&](){[&](){[&](){json["passOp"]=static_cast<int>(passOp);}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=static_cast<int>(depthFailOp);}();}();}();
[&](){[&](){[&](){json["compareOp"]=static_cast<int>(compareOp);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETSTENCILOP);
        writeToConn(json);
    }

    void handle_vkCmdSetPatchControlPointsEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t patchControlPoints;
[&](){
            if (json["patchControlPoints"].is_uint64_t()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_uint64_t());
            }else if (json["patchControlPoints"].is_int64_t()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_int64_t());
            }else{
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_double());
            }
            }();

    PFN_vkCmdSetPatchControlPointsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_instance_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_device_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }  
    
{
call_function(commandBuffer, patchControlPoints);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=static_cast<uint>(patchControlPoints);}();


        json["stream_type"]=static_cast<int>(VKCMDSETPATCHCONTROLPOINTSEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizerDiscardEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 rasterizerDiscardEnable;
[&](){uint32_t temp_bdbWnok;[&](){
            if (json["rasterizerDiscardEnable"].is_uint64_t()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_uint64_t());
            }else if (json["rasterizerDiscardEnable"].is_int64_t()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_int64_t());
            }else{
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_double());
            }
            }();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

    PFN_vkCmdSetRasterizerDiscardEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_instance_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_device_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }  
    
{
call_function(commandBuffer, rasterizerDiscardEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=static_cast<uint>(rasterizerDiscardEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZERDISCARDENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBiasEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBiasEnable;
[&](){uint32_t temp_ewcVkBi;[&](){
            if (json["depthBiasEnable"].is_uint64_t()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_uint64_t());
            }else if (json["depthBiasEnable"].is_int64_t()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_int64_t());
            }else{
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_double());
            }
            }();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

    PFN_vkCmdSetDepthBiasEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_device_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }  
    
{
call_function(commandBuffer, depthBiasEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=static_cast<uint>(depthBiasEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIASENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLogicOp logicOp;
[&](){[&](){int temp_KRaggtp;[&](){
            if (json["logicOp"].is_uint64_t()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_uint64_t());
            }else if (json["logicOp"].is_int64_t()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_int64_t());
            }else{
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_double());
            }
            }();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

    PFN_vkCmdSetLogicOpEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLogicOpEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLogicOpEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }  
    
{
call_function(commandBuffer, logicOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=static_cast<int>(logicOp);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETLOGICOPEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveRestartEnable(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 primitiveRestartEnable;
[&](){uint32_t temp_mDszbuh;[&](){
            if (json["primitiveRestartEnable"].is_uint64_t()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_uint64_t());
            }else if (json["primitiveRestartEnable"].is_int64_t()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_int64_t());
            }else{
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_double());
            }
            }();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

    PFN_vkCmdSetPrimitiveRestartEnable call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_instance_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_device_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }  
    
{
call_function(commandBuffer, primitiveRestartEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=static_cast<uint>(primitiveRestartEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETPRIMITIVERESTARTENABLE);
        writeToConn(json);
    }

    void handle_vkCmdSetTessellationDomainOriginEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkTessellationDomainOrigin domainOrigin;
[&](){[&](){int temp_MhaRSZf;[&](){
            if (json["domainOrigin"].is_uint64_t()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_uint64_t());
            }else if (json["domainOrigin"].is_int64_t()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_int64_t());
            }else{
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_double());
            }
            }();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

    PFN_vkCmdSetTessellationDomainOriginEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_instance_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_device_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }  
    
{
call_function(commandBuffer, domainOrigin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=static_cast<int>(domainOrigin);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETTESSELLATIONDOMAINORIGINEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClampEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClampEnable;
[&](){uint32_t temp_DzsSqgr;[&](){
            if (json["depthClampEnable"].is_uint64_t()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_uint64_t());
            }else if (json["depthClampEnable"].is_int64_t()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_int64_t());
            }else{
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_double());
            }
            }();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

    PFN_vkCmdSetDepthClampEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClampEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=static_cast<uint>(depthClampEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLAMPENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetPolygonModeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPolygonMode polygonMode;
[&](){[&](){int temp_XzCpfxJ;[&](){
            if (json["polygonMode"].is_uint64_t()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_uint64_t());
            }else if (json["polygonMode"].is_int64_t()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_int64_t());
            }else{
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_double());
            }
            }();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

    PFN_vkCmdSetPolygonModeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_instance_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_device_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }  
    
{
call_function(commandBuffer, polygonMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=static_cast<int>(polygonMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETPOLYGONMODEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationSamplesEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits rasterizationSamples;
[&](){[&](){int temp_YCyLybT;[&](){
            if (json["rasterizationSamples"].is_uint64_t()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_uint64_t());
            }else if (json["rasterizationSamples"].is_int64_t()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_int64_t());
            }else{
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_double());
            }
            }();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

    PFN_vkCmdSetRasterizationSamplesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }  
    
{
call_function(commandBuffer, rasterizationSamples);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=static_cast<int>(rasterizationSamples);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZATIONSAMPLESEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetSampleMaskEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
 VkSampleMask* pSampleMask;
[&](){
            if (json["pSampleMask"].as_vector().size()==0){
                pSampleMask=NULL;
            return; }pSampleMask=(VkSampleMask*)malloc((samples + 31) / 32*sizeof(VkSampleMask));auto& arr_FGuLlff=json["pSampleMask"].as_vector();
        for(int BCMPGHn=0; BCMPGHn < (samples + 31) / 32; BCMPGHn++){
            [&](){uint32_t temp_FGuLlff;[&](){
            if (arr_FGuLlff[BCMPGHn].is_uint64_t()){
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].as_uint64_t());
            }else if (arr_FGuLlff[BCMPGHn].is_int64_t()){
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].as_int64_t());
            }else{
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].as_double());
            }
            }();pSampleMask[BCMPGHn]=(VkSampleMask)temp_FGuLlff;}();
        }
        }();

    PFN_vkCmdSetSampleMaskEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_instance_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_device_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }  
    
{
call_function(commandBuffer, samples, pSampleMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=json::vector();
            return; }auto arr_nepOVVF=json::vector((samples + 31) / 32);
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=static_cast<uint>(pSampleMask[ASCUBEW]);}();}();
        }
        json["pSampleMask"]=arr_nepOVVF;}();


        json["stream_type"]=static_cast<int>(VKCMDSETSAMPLEMASKEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToCoverageEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToCoverageEnable;
[&](){uint32_t temp_GXlPpxl;[&](){
            if (json["alphaToCoverageEnable"].is_uint64_t()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_uint64_t());
            }else if (json["alphaToCoverageEnable"].is_int64_t()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_int64_t());
            }else{
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_double());
            }
            }();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

    PFN_vkCmdSetAlphaToCoverageEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToCoverageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=static_cast<uint>(alphaToCoverageEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETALPHATOCOVERAGEENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToOneEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToOneEnable;
[&](){uint32_t temp_vIViDmy;[&](){
            if (json["alphaToOneEnable"].is_uint64_t()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_uint64_t());
            }else if (json["alphaToOneEnable"].is_int64_t()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_int64_t());
            }else{
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_double());
            }
            }();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

    PFN_vkCmdSetAlphaToOneEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToOneEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=static_cast<uint>(alphaToOneEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETALPHATOONEENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 logicOpEnable;
[&](){uint32_t temp_efIIzNf;[&](){
            if (json["logicOpEnable"].is_uint64_t()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_uint64_t());
            }else if (json["logicOpEnable"].is_int64_t()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_int64_t());
            }else{
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_double());
            }
            }();logicOpEnable=(VkBool32)temp_efIIzNf;}();

    PFN_vkCmdSetLogicOpEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }  
    
{
call_function(commandBuffer, logicOpEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=static_cast<uint>(logicOpEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETLOGICOPENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkBool32* pColorBlendEnables;
[&](){
            if (json["pColorBlendEnables"].as_vector().size()==0){
                pColorBlendEnables=NULL;
            return; }pColorBlendEnables=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));auto& arr_lHzNiUd=json["pColorBlendEnables"].as_vector();
        for(int wbANAKE=0; wbANAKE < attachmentCount; wbANAKE++){
            [&](){uint32_t temp_lHzNiUd;[&](){
            if (arr_lHzNiUd[wbANAKE].is_uint64_t()){
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].as_uint64_t());
            }else if (arr_lHzNiUd[wbANAKE].is_int64_t()){
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].as_int64_t());
            }else{
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].as_double());
            }
            }();pColorBlendEnables[wbANAKE]=(VkBool32)temp_lHzNiUd;}();
        }
        }();

    PFN_vkCmdSetColorBlendEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=json::vector();
            return; }auto arr_saqDhTV=json::vector(attachmentCount);
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=static_cast<uint>(pColorBlendEnables[VGuJXMd]);}();}();
        }
        json["pColorBlendEnables"]=arr_saqDhTV;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEquationEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkColorBlendEquationEXT* pColorBlendEquations;
[&](){
            if (json["pColorBlendEquations"].as_vector().size()==0){
                pColorBlendEquations=NULL;
            return; }pColorBlendEquations=(VkColorBlendEquationEXT*)malloc(attachmentCount*sizeof(VkColorBlendEquationEXT));auto& arr_EqkVhnu=json["pColorBlendEquations"].as_vector();
        for(int fbdCMaT=0; fbdCMaT < attachmentCount; fbdCMaT++){
            [&](){
            deserialize_struct(arr_EqkVhnu[fbdCMaT].as_map(),pColorBlendEquations[fbdCMaT]);
            }();
        }
        }();

    PFN_vkCmdSetColorBlendEquationEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=json::vector();
            return; }auto arr_hKUQljx=json::vector(attachmentCount);
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColorBlendEquations[EHggOtN]);
            arr_hKUQljx[EHggOtN]=temp_map;
            return;
            }();
        }
        json["pColorBlendEquations"]=arr_hKUQljx;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDEQUATIONEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteMaskEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkColorComponentFlags* pColorWriteMasks;
[&](){
            if (json["pColorWriteMasks"].as_vector().size()==0){
                pColorWriteMasks=NULL;
            return; }pColorWriteMasks=(VkColorComponentFlags*)malloc(attachmentCount*sizeof(VkColorComponentFlags));auto& arr_EqZFwIM=json["pColorWriteMasks"].as_vector();
        for(int ieFAddx=0; ieFAddx < attachmentCount; ieFAddx++){
            [&](){[&](){int temp_eGfaWyY;[&](){
            if (arr_EqZFwIM[ieFAddx].is_uint64_t()){
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].as_uint64_t());
            }else if (arr_EqZFwIM[ieFAddx].is_int64_t()){
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].as_int64_t());
            }else{
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].as_double());
            }
            }();pColorWriteMasks[ieFAddx]=(VkColorComponentFlags)temp_eGfaWyY;}();}();
        }
        }();

    PFN_vkCmdSetColorWriteMaskEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=json::vector();
            return; }auto arr_VFhepws=json::vector(attachmentCount);
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=static_cast<int>(pColorWriteMasks[PbQLtdZ]);}();}();}();
        }
        json["pColorWriteMasks"]=arr_VFhepws;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOLORWRITEMASKEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationStreamEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t rasterizationStream;
[&](){
            if (json["rasterizationStream"].is_uint64_t()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_uint64_t());
            }else if (json["rasterizationStream"].is_int64_t()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_int64_t());
            }else{
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_double());
            }
            }();

    PFN_vkCmdSetRasterizationStreamEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }  
    
{
call_function(commandBuffer, rasterizationStream);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=static_cast<uint>(rasterizationStream);}();


        json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZATIONSTREAMEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetConservativeRasterizationModeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkConservativeRasterizationModeEXT conservativeRasterizationMode;
[&](){[&](){int temp_foXltQC;[&](){
            if (json["conservativeRasterizationMode"].is_uint64_t()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_uint64_t());
            }else if (json["conservativeRasterizationMode"].is_int64_t()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_int64_t());
            }else{
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_double());
            }
            }();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

    PFN_vkCmdSetConservativeRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, conservativeRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=static_cast<int>(conservativeRasterizationMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetExtraPrimitiveOverestimationSizeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float extraPrimitiveOverestimationSize;
[&](){
            if (json["extraPrimitiveOverestimationSize"].is_uint64_t()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_uint64_t());
            }else if (json["extraPrimitiveOverestimationSize"].is_int64_t()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_int64_t());
            }else{
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_double());
            }
            }();

    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_instance_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_device_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }  
    
{
call_function(commandBuffer, extraPrimitiveOverestimationSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=static_cast<float>(extraPrimitiveOverestimationSize);}();


        json["stream_type"]=static_cast<int>(VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClipEnable;
[&](){uint32_t temp_xexuvpr;[&](){
            if (json["depthClipEnable"].is_uint64_t()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_uint64_t());
            }else if (json["depthClipEnable"].is_int64_t()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_int64_t());
            }else{
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_double());
            }
            }();depthClipEnable=(VkBool32)temp_xexuvpr;}();

    PFN_vkCmdSetDepthClipEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClipEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=static_cast<uint>(depthClipEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLIPENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 sampleLocationsEnable;
[&](){uint32_t temp_dFVPXvO;[&](){
            if (json["sampleLocationsEnable"].is_uint64_t()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_uint64_t());
            }else if (json["sampleLocationsEnable"].is_int64_t()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_int64_t());
            }else{
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_double());
            }
            }();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

    PFN_vkCmdSetSampleLocationsEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }  
    
{
call_function(commandBuffer, sampleLocationsEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=static_cast<uint>(sampleLocationsEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETSAMPLELOCATIONSENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendAdvancedEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkColorBlendAdvancedEXT* pColorBlendAdvanced;
[&](){
            if (json["pColorBlendAdvanced"].as_vector().size()==0){
                pColorBlendAdvanced=NULL;
            return; }pColorBlendAdvanced=(VkColorBlendAdvancedEXT*)malloc(attachmentCount*sizeof(VkColorBlendAdvancedEXT));auto& arr_CGYbnEQ=json["pColorBlendAdvanced"].as_vector();
        for(int apDMrcx=0; apDMrcx < attachmentCount; apDMrcx++){
            [&](){
            deserialize_struct(arr_CGYbnEQ[apDMrcx].as_map(),pColorBlendAdvanced[apDMrcx]);
            }();
        }
        }();

    PFN_vkCmdSetColorBlendAdvancedEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=json::vector();
            return; }auto arr_VhJvkCW=json::vector(attachmentCount);
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColorBlendAdvanced[rBcMzuv]);
            arr_VhJvkCW[rBcMzuv]=temp_map;
            return;
            }();
        }
        json["pColorBlendAdvanced"]=arr_VhJvkCW;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDADVANCEDEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetProvokingVertexModeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkProvokingVertexModeEXT provokingVertexMode;
[&](){[&](){int temp_unvGJcm;[&](){
            if (json["provokingVertexMode"].is_uint64_t()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_uint64_t());
            }else if (json["provokingVertexMode"].is_int64_t()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_int64_t());
            }else{
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_double());
            }
            }();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

    PFN_vkCmdSetProvokingVertexModeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_instance_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_device_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }  
    
{
call_function(commandBuffer, provokingVertexMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=static_cast<int>(provokingVertexMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETPROVOKINGVERTEXMODEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetLineRasterizationModeEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLineRasterizationModeEXT lineRasterizationMode;
[&](){[&](){int temp_TzHFAEB;[&](){
            if (json["lineRasterizationMode"].is_uint64_t()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_uint64_t());
            }else if (json["lineRasterizationMode"].is_int64_t()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_int64_t());
            }else{
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_double());
            }
            }();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

    PFN_vkCmdSetLineRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, lineRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=static_cast<int>(lineRasterizationMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETLINERASTERIZATIONMODEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stippledLineEnable;
[&](){uint32_t temp_lOgURYj;[&](){
            if (json["stippledLineEnable"].is_uint64_t()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_uint64_t());
            }else if (json["stippledLineEnable"].is_int64_t()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_int64_t());
            }else{
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_double());
            }
            }();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

    PFN_vkCmdSetLineStippleEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }  
    
{
call_function(commandBuffer, stippledLineEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=static_cast<uint>(stippledLineEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETLINESTIPPLEENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipNegativeOneToOneEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 negativeOneToOne;
[&](){uint32_t temp_KbgfkEI;[&](){
            if (json["negativeOneToOne"].is_uint64_t()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_uint64_t());
            }else if (json["negativeOneToOne"].is_int64_t()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_int64_t());
            }else{
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_double());
            }
            }();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

    PFN_vkCmdSetDepthClipNegativeOneToOneEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }  
    
{
call_function(commandBuffer, negativeOneToOne);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=static_cast<uint>(negativeOneToOne);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 viewportWScalingEnable;
[&](){uint32_t temp_FBvKoOa;[&](){
            if (json["viewportWScalingEnable"].is_uint64_t()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_uint64_t());
            }else if (json["viewportWScalingEnable"].is_int64_t()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_int64_t());
            }else{
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_double());
            }
            }();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

    PFN_vkCmdSetViewportWScalingEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }  
    
{
call_function(commandBuffer, viewportWScalingEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=static_cast<uint>(viewportWScalingEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWSCALINGENABLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetViewportSwizzleNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();
 VkViewportSwizzleNV* pViewportSwizzles;
[&](){
            if (json["pViewportSwizzles"].as_vector().size()==0){
                pViewportSwizzles=NULL;
            return; }pViewportSwizzles=(VkViewportSwizzleNV*)malloc(viewportCount*sizeof(VkViewportSwizzleNV));auto& arr_ZPCbbeZ=json["pViewportSwizzles"].as_vector();
        for(int dONOTlj=0; dONOTlj < viewportCount; dONOTlj++){
            [&](){
            deserialize_struct(arr_ZPCbbeZ[dONOTlj].as_map(),pViewportSwizzles[dONOTlj]);
            }();
        }
        }();

    PFN_vkCmdSetViewportSwizzleNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_instance_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_device_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=json::vector();
            return; }auto arr_mlTjeMw=json::vector(viewportCount);
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewportSwizzles[jvBpVNx]);
            arr_mlTjeMw[jvBpVNx]=temp_map;
            return;
            }();
        }
        json["pViewportSwizzles"]=arr_mlTjeMw;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTSWIZZLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageToColorEnable;
[&](){uint32_t temp_StrBHxz;[&](){
            if (json["coverageToColorEnable"].is_uint64_t()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_uint64_t());
            }else if (json["coverageToColorEnable"].is_int64_t()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_int64_t());
            }else{
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_double());
            }
            }();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

    PFN_vkCmdSetCoverageToColorEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }  
    
{
call_function(commandBuffer, coverageToColorEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=static_cast<uint>(coverageToColorEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGETOCOLORENABLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorLocationNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageToColorLocation;
[&](){
            if (json["coverageToColorLocation"].is_uint64_t()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_uint64_t());
            }else if (json["coverageToColorLocation"].is_int64_t()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_int64_t());
            }else{
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_double());
            }
            }();

    PFN_vkCmdSetCoverageToColorLocationNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }  
    
{
call_function(commandBuffer, coverageToColorLocation);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=static_cast<uint>(coverageToColorLocation);}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGETOCOLORLOCATIONNV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationModeNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageModulationModeNV coverageModulationMode;
[&](){[&](){int temp_BTSRuJL;[&](){
            if (json["coverageModulationMode"].is_uint64_t()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_uint64_t());
            }else if (json["coverageModulationMode"].is_int64_t()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_int64_t());
            }else{
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_double());
            }
            }();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

    PFN_vkCmdSetCoverageModulationModeNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }  
    
{
call_function(commandBuffer, coverageModulationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=static_cast<int>(coverageModulationMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONMODENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageModulationTableEnable;
[&](){uint32_t temp_lmSvUmH;[&](){
            if (json["coverageModulationTableEnable"].is_uint64_t()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_uint64_t());
            }else if (json["coverageModulationTableEnable"].is_int64_t()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_int64_t());
            }else{
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_double());
            }
            }();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

    PFN_vkCmdSetCoverageModulationTableEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=static_cast<uint>(coverageModulationTableEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONTABLEENABLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageModulationTableCount;
[&](){
            if (json["coverageModulationTableCount"].is_uint64_t()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_uint64_t());
            }else if (json["coverageModulationTableCount"].is_int64_t()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_int64_t());
            }else{
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_double());
            }
            }();
 float* pCoverageModulationTable;
[&](){
            if (json["pCoverageModulationTable"].as_vector().size()==0){
                pCoverageModulationTable=NULL;
            return; }pCoverageModulationTable=(float*)malloc(coverageModulationTableCount*sizeof(float));auto& arr_PUYynJq=json["pCoverageModulationTable"].as_vector();
        for(int uNkPtIy=0; uNkPtIy < coverageModulationTableCount; uNkPtIy++){
            [&](){
            if (arr_PUYynJq[uNkPtIy].is_uint64_t()){
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].as_uint64_t());
            }else if (arr_PUYynJq[uNkPtIy].is_int64_t()){
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].as_int64_t());
            }else{
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].as_double());
            }
            }();
        }
        }();

    PFN_vkCmdSetCoverageModulationTableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=static_cast<uint>(coverageModulationTableCount);}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=json::vector();
            return; }auto arr_FKEHfYD=json::vector(coverageModulationTableCount);
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=static_cast<float>(pCoverageModulationTable[pMqhQqL]);}();
        }
        json["pCoverageModulationTable"]=arr_FKEHfYD;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONTABLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetShadingRateImageEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 shadingRateImageEnable;
[&](){uint32_t temp_BQfvSQF;[&](){
            if (json["shadingRateImageEnable"].is_uint64_t()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_uint64_t());
            }else if (json["shadingRateImageEnable"].is_int64_t()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_int64_t());
            }else{
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_double());
            }
            }();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

    PFN_vkCmdSetShadingRateImageEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_instance_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_device_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }  
    
{
call_function(commandBuffer, shadingRateImageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=static_cast<uint>(shadingRateImageEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETSHADINGRATEIMAGEENABLENV);
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageReductionModeNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageReductionModeNV coverageReductionMode;
[&](){[&](){int temp_MbjGgOv;[&](){
            if (json["coverageReductionMode"].is_uint64_t()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_uint64_t());
            }else if (json["coverageReductionMode"].is_int64_t()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_int64_t());
            }else{
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_double());
            }
            }();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

    PFN_vkCmdSetCoverageReductionModeNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }  
    
{
call_function(commandBuffer, coverageReductionMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=static_cast<int>(coverageReductionMode);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEREDUCTIONMODENV);
        writeToConn(json);
    }

    void handle_vkCmdSetRepresentativeFragmentTestEnableNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 representativeFragmentTestEnable;
[&](){uint32_t temp_VmtUEuY;[&](){
            if (json["representativeFragmentTestEnable"].is_uint64_t()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_uint64_t());
            }else if (json["representativeFragmentTestEnable"].is_int64_t()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_int64_t());
            }else{
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_double());
            }
            }();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

    PFN_vkCmdSetRepresentativeFragmentTestEnableNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_instance_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_device_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }  
    
{
call_function(commandBuffer, representativeFragmentTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=static_cast<uint>(representativeFragmentTestEnable);}();}();


        json["stream_type"]=static_cast<int>(VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV);
        writeToConn(json);
    }

    void handle_vkCreatePrivateDataSlot(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPrivateDataSlotCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPrivateDataSlotCreateInfo*)malloc(1*sizeof(VkPrivateDataSlotCreateInfo));auto& arr_NidbGih=json["pCreateInfo"].as_vector();
        for(int ZNynneh=0; ZNynneh < 1; ZNynneh++){
            [&](){
            deserialize_struct(arr_NidbGih[ZNynneh].as_map(),pCreateInfo[ZNynneh]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkPrivateDataSlot* pPrivateDataSlot;
[&](){
            if (json["pPrivateDataSlot"].as_vector().size()==0){
                pPrivateDataSlot=NULL;
            return; }pPrivateDataSlot=(VkPrivateDataSlot*)malloc(1*sizeof(VkPrivateDataSlot));auto& arr_EOSkjPn=json["pPrivateDataSlot"].as_vector();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();

    PFN_vkCreatePrivateDataSlot call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreatePrivateDataSlot)get_instance_proc_addr(parent,"vkCreatePrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreatePrivateDataSlot)get_device_proc_addr(parent,"vkCreatePrivateDataSlot");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_OhzuPlW=json::vector(1);
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[KUjUcQv]);
            arr_OhzuPlW[KUjUcQv]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_OhzuPlW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=json::vector();
            return; }auto arr_EOSkjPn=json::vector(1);
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        json["pPrivateDataSlot"]=arr_EOSkjPn;}();


        json["stream_type"]=static_cast<int>(VKCREATEPRIVATEDATASLOT);
        writeToConn(json);
    }

    void handle_vkDestroyPrivateDataSlot(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPrivateDataSlot call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyPrivateDataSlot)get_instance_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyPrivateDataSlot)get_device_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }  
    
{
call_function(device, privateDataSlot, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYPRIVATEDATASLOT);
        writeToConn(json);
    }

    void handle_vkSetPrivateData(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){
            if (json["objectHandle"].is_uint64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_uint64_t());
            }else if (json["objectHandle"].is_int64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_int64_t());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_double());
            }
            }();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t data;
[&](){
            if (json["data"].is_uint64_t()){
                data=static_cast<uint64_t>(json["data"].as_uint64_t());
            }else if (json["data"].is_int64_t()){
                data=static_cast<uint64_t>(json["data"].as_int64_t());
            }else{
                data=static_cast<uint64_t>(json["data"].as_double());
            }
            }();

    PFN_vkSetPrivateData call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetPrivateData)get_instance_proc_addr(parent,"vkSetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetPrivateData)get_device_proc_addr(parent,"vkSetPrivateData");
    }  
    
VkResult  result;
{
result=call_function(device, objectType, objectHandle, privateDataSlot, data);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["objectHandle"]=static_cast<uint>(objectHandle);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=static_cast<uint>(data);}();


        json["stream_type"]=static_cast<int>(VKSETPRIVATEDATA);
        writeToConn(json);
    }

    void handle_vkGetPrivateData(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){
            if (json["objectHandle"].is_uint64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_uint64_t());
            }else if (json["objectHandle"].is_int64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_int64_t());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_double());
            }
            }();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }pData=(uint64_t*)malloc(1*sizeof(uint64_t));auto& arr_niIcbqy=json["pData"].as_vector();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){
            if (arr_niIcbqy[rXHtNoy].is_uint64_t()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_uint64_t());
            }else if (arr_niIcbqy[rXHtNoy].is_int64_t()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_int64_t());
            }else{
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_double());
            }
            }();
        }
        }();

    PFN_vkGetPrivateData call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPrivateData)get_instance_proc_addr(parent,"vkGetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPrivateData)get_device_proc_addr(parent,"vkGetPrivateData");
    }  
    
{
call_function(device, objectType, objectHandle, privateDataSlot, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["objectHandle"]=static_cast<uint>(objectHandle);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }auto arr_niIcbqy=json::vector(1);
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=static_cast<uint>(pData[rXHtNoy]);}();
        }
        json["pData"]=arr_niIcbqy;}();


        json["stream_type"]=static_cast<int>(VKGETPRIVATEDATA);
        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyBufferInfo2* pCopyBufferInfo;
[&](){
            if (json["pCopyBufferInfo"].as_vector().size()==0){
                pCopyBufferInfo=NULL;
            return; }pCopyBufferInfo=(VkCopyBufferInfo2*)malloc(1*sizeof(VkCopyBufferInfo2));auto& arr_zibazFk=json["pCopyBufferInfo"].as_vector();
        for(int BLWMzyy=0; BLWMzyy < 1; BLWMzyy++){
            [&](){
            deserialize_struct(arr_zibazFk[BLWMzyy].as_map(),pCopyBufferInfo[BLWMzyy]);
            }();
        }
        }();

    PFN_vkCmdCopyBuffer2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyBuffer2)get_instance_proc_addr(parent,"vkCmdCopyBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyBuffer2)get_device_proc_addr(parent,"vkCmdCopyBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=json::vector();
            return; }auto arr_RrXlJAO=json::vector(1);
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyBufferInfo[tCibIjb]);
            arr_RrXlJAO[tCibIjb]=temp_map;
            return;
            }();
        }
        json["pCopyBufferInfo"]=arr_RrXlJAO;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFER2);
        writeToConn(json);
    }

    void handle_vkCmdCopyImage2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyImageInfo2* pCopyImageInfo;
[&](){
            if (json["pCopyImageInfo"].as_vector().size()==0){
                pCopyImageInfo=NULL;
            return; }pCopyImageInfo=(VkCopyImageInfo2*)malloc(1*sizeof(VkCopyImageInfo2));auto& arr_QunWVoT=json["pCopyImageInfo"].as_vector();
        for(int aRJdnXE=0; aRJdnXE < 1; aRJdnXE++){
            [&](){
            deserialize_struct(arr_QunWVoT[aRJdnXE].as_map(),pCopyImageInfo[aRJdnXE]);
            }();
        }
        }();

    PFN_vkCmdCopyImage2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyImage2)get_instance_proc_addr(parent,"vkCmdCopyImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyImage2)get_device_proc_addr(parent,"vkCmdCopyImage2");
    }  
    
{
call_function(commandBuffer, pCopyImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=json::vector();
            return; }auto arr_fhmwDMM=json::vector(1);
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageInfo[vtScDqF]);
            arr_fhmwDMM[vtScDqF]=temp_map;
            return;
            }();
        }
        json["pCopyImageInfo"]=arr_fhmwDMM;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGE2);
        writeToConn(json);
    }

    void handle_vkCmdBlitImage2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkBlitImageInfo2* pBlitImageInfo;
[&](){
            if (json["pBlitImageInfo"].as_vector().size()==0){
                pBlitImageInfo=NULL;
            return; }pBlitImageInfo=(VkBlitImageInfo2*)malloc(1*sizeof(VkBlitImageInfo2));auto& arr_WcZAFFY=json["pBlitImageInfo"].as_vector();
        for(int ippZCip=0; ippZCip < 1; ippZCip++){
            [&](){
            deserialize_struct(arr_WcZAFFY[ippZCip].as_map(),pBlitImageInfo[ippZCip]);
            }();
        }
        }();

    PFN_vkCmdBlitImage2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBlitImage2)get_instance_proc_addr(parent,"vkCmdBlitImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBlitImage2)get_device_proc_addr(parent,"vkCmdBlitImage2");
    }  
    
{
call_function(commandBuffer, pBlitImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=json::vector();
            return; }auto arr_uMZBSOh=json::vector(1);
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBlitImageInfo[mMDYqpe]);
            arr_uMZBSOh[mMDYqpe]=temp_map;
            return;
            }();
        }
        json["pBlitImageInfo"]=arr_uMZBSOh;}();


        json["stream_type"]=static_cast<int>(VKCMDBLITIMAGE2);
        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyBufferToImageInfo2* pCopyBufferToImageInfo;
[&](){
            if (json["pCopyBufferToImageInfo"].as_vector().size()==0){
                pCopyBufferToImageInfo=NULL;
            return; }pCopyBufferToImageInfo=(VkCopyBufferToImageInfo2*)malloc(1*sizeof(VkCopyBufferToImageInfo2));auto& arr_HtvMvbo=json["pCopyBufferToImageInfo"].as_vector();
        for(int tWBWvbF=0; tWBWvbF < 1; tWBWvbF++){
            [&](){
            deserialize_struct(arr_HtvMvbo[tWBWvbF].as_map(),pCopyBufferToImageInfo[tWBWvbF]);
            }();
        }
        }();

    PFN_vkCmdCopyBufferToImage2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage2)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyBufferToImage2)get_device_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }  
    
{
call_function(commandBuffer, pCopyBufferToImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=json::vector();
            return; }auto arr_GgxIzVF=json::vector(1);
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyBufferToImageInfo[kZlUXOa]);
            arr_GgxIzVF[kZlUXOa]=temp_map;
            return;
            }();
        }
        json["pCopyBufferToImageInfo"]=arr_GgxIzVF;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFERTOIMAGE2);
        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyImageToBufferInfo2* pCopyImageToBufferInfo;
[&](){
            if (json["pCopyImageToBufferInfo"].as_vector().size()==0){
                pCopyImageToBufferInfo=NULL;
            return; }pCopyImageToBufferInfo=(VkCopyImageToBufferInfo2*)malloc(1*sizeof(VkCopyImageToBufferInfo2));auto& arr_NyCJVfx=json["pCopyImageToBufferInfo"].as_vector();
        for(int NLyWULP=0; NLyWULP < 1; NLyWULP++){
            [&](){
            deserialize_struct(arr_NyCJVfx[NLyWULP].as_map(),pCopyImageToBufferInfo[NLyWULP]);
            }();
        }
        }();

    PFN_vkCmdCopyImageToBuffer2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyImageToBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=json::vector();
            return; }auto arr_dKwPEQq=json::vector(1);
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToBufferInfo[SXwhnUi]);
            arr_dKwPEQq[SXwhnUi]=temp_map;
            return;
            }();
        }
        json["pCopyImageToBufferInfo"]=arr_dKwPEQq;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGETOBUFFER2);
        writeToConn(json);
    }

    void handle_vkCmdResolveImage2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkResolveImageInfo2* pResolveImageInfo;
[&](){
            if (json["pResolveImageInfo"].as_vector().size()==0){
                pResolveImageInfo=NULL;
            return; }pResolveImageInfo=(VkResolveImageInfo2*)malloc(1*sizeof(VkResolveImageInfo2));auto& arr_IZrxKgk=json["pResolveImageInfo"].as_vector();
        for(int LpoaGzd=0; LpoaGzd < 1; LpoaGzd++){
            [&](){
            deserialize_struct(arr_IZrxKgk[LpoaGzd].as_map(),pResolveImageInfo[LpoaGzd]);
            }();
        }
        }();

    PFN_vkCmdResolveImage2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdResolveImage2)get_instance_proc_addr(parent,"vkCmdResolveImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdResolveImage2)get_device_proc_addr(parent,"vkCmdResolveImage2");
    }  
    
{
call_function(commandBuffer, pResolveImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=json::vector();
            return; }auto arr_WXEMxut=json::vector(1);
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pResolveImageInfo[oSccZaz]);
            arr_WXEMxut[oSccZaz]=temp_map;
            return;
            }();
        }
        json["pResolveImageInfo"]=arr_WXEMxut;}();


        json["stream_type"]=static_cast<int>(VKCMDRESOLVEIMAGE2);
        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkExtent2D* pFragmentSize;
[&](){
            if (json["pFragmentSize"].as_vector().size()==0){
                pFragmentSize=NULL;
            return; }pFragmentSize=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));auto& arr_eIGxtNV=json["pFragmentSize"].as_vector();
        for(int eByenzl=0; eByenzl < 1; eByenzl++){
            [&](){
            deserialize_struct(arr_eIGxtNV[eByenzl].as_map(),pFragmentSize[eByenzl]);
            }();
        }
        }();
 VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){auto& arr_ogoToWI=json["combinerOps"].as_vector();
        for(int uWKWXJp=0; uWKWXJp < 2; uWKWXJp++){
            [&](){[&](){int temp_rKrWEKx;[&](){
            if (arr_ogoToWI[uWKWXJp].is_uint64_t()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_uint64_t());
            }else if (arr_ogoToWI[uWKWXJp].is_int64_t()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_int64_t());
            }else{
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_double());
            }
            }();combinerOps[uWKWXJp]=(VkFragmentShadingRateCombinerOpKHR)temp_rKrWEKx;}();}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }  
    
{
call_function(commandBuffer, pFragmentSize, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=json::vector();
            return; }auto arr_RBQYqfx=json::vector(1);
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFragmentSize[rHAqvQQ]);
            arr_RBQYqfx[rHAqvQQ]=temp_map;
            return;
            }();
        }
        json["pFragmentSize"]=arr_RBQYqfx;}();
[&](){auto arr_foscmwP=json::vector(2);
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=static_cast<int>(combinerOps[uBsarms]);}();}();}();
        }
        json["combinerOps"]=arr_foscmwP;}();


        json["stream_type"]=static_cast<int>(VKCMDSETFRAGMENTSHADINGRATEKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFragmentShadingRatesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pFragmentShadingRateCount;
[&](){
            if (json["pFragmentShadingRateCount"].as_vector().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }pFragmentShadingRateCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_CjAZByp=json["pFragmentShadingRateCount"].as_vector();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){
            if (arr_CjAZByp[vQwTqIV].is_uint64_t()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_uint64_t());
            }else if (arr_CjAZByp[vQwTqIV].is_int64_t()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_int64_t());
            }else{
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_double());
            }
            }();
        }
        }();
VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates;
[&](){
            if (json["pFragmentShadingRates"].as_vector().size()==0){
                pFragmentShadingRates=NULL;
            return; }pFragmentShadingRates=(VkPhysicalDeviceFragmentShadingRateKHR*)malloc(*pFragmentShadingRateCount*sizeof(VkPhysicalDeviceFragmentShadingRateKHR));auto& arr_UdwJpYv=json["pFragmentShadingRates"].as_vector();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            deserialize_struct(arr_UdwJpYv[bVRSXYW].as_map(),pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=json::vector();
            return; }auto arr_CjAZByp=json::vector(1);
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=static_cast<uint>(pFragmentShadingRateCount[vQwTqIV]);}();
        }
        json["pFragmentShadingRateCount"]=arr_CjAZByp;}();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=json::vector();
            return; }auto arr_UdwJpYv=json::vector(*pFragmentShadingRateCount);
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFragmentShadingRates[bVRSXYW]);
            arr_UdwJpYv[bVRSXYW]=temp_map;
            return;
            }();
        }
        json["pFragmentShadingRates"]=arr_UdwJpYv;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR);
        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateEnumNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFragmentShadingRateNV shadingRate;
[&](){[&](){int temp_CqLMxeN;[&](){
            if (json["shadingRate"].is_uint64_t()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_uint64_t());
            }else if (json["shadingRate"].is_int64_t()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_int64_t());
            }else{
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_double());
            }
            }();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
 VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){auto& arr_ogoToWI=json["combinerOps"].as_vector();
        for(int uWKWXJp=0; uWKWXJp < 2; uWKWXJp++){
            [&](){[&](){int temp_rKrWEKx;[&](){
            if (arr_ogoToWI[uWKWXJp].is_uint64_t()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_uint64_t());
            }else if (arr_ogoToWI[uWKWXJp].is_int64_t()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_int64_t());
            }else{
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].as_double());
            }
            }();combinerOps[uWKWXJp]=(VkFragmentShadingRateCombinerOpKHR)temp_rKrWEKx;}();}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateEnumNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }  
    
{
call_function(commandBuffer, shadingRate, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=static_cast<int>(shadingRate);}();}();}();
[&](){auto arr_foscmwP=json::vector(2);
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=static_cast<int>(combinerOps[uBsarms]);}();}();}();
        }
        json["combinerOps"]=arr_foscmwP;}();


        json["stream_type"]=static_cast<int>(VKCMDSETFRAGMENTSHADINGRATEENUMNV);
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureBuildSizesKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_uint64_t());
            }else if (json["buildType"].is_int64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_int64_t());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].as_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
 VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo;
[&](){
            if (json["pBuildInfo"].as_vector().size()==0){
                pBuildInfo=NULL;
            return; }pBuildInfo=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));auto& arr_plZlnwA=json["pBuildInfo"].as_vector();
        for(int PtWSBOy=0; PtWSBOy < 1; PtWSBOy++){
            [&](){
            deserialize_struct(arr_plZlnwA[PtWSBOy].as_map(),pBuildInfo[PtWSBOy]);
            }();
        }
        }();
 uint32_t* pMaxPrimitiveCounts;
[&](){
            if (json["pMaxPrimitiveCounts"].as_vector().size()==0){
                pMaxPrimitiveCounts=NULL;
            return; }pMaxPrimitiveCounts=(uint32_t*)malloc(pBuildInfo->geometryCount*sizeof(uint32_t));auto& arr_crHuORX=json["pMaxPrimitiveCounts"].as_vector();
        for(int JfSxsJb=0; JfSxsJb < pBuildInfo->geometryCount; JfSxsJb++){
            [&](){
            if (arr_crHuORX[JfSxsJb].is_uint64_t()){
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].as_uint64_t());
            }else if (arr_crHuORX[JfSxsJb].is_int64_t()){
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].as_int64_t());
            }else{
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].as_double());
            }
            }();
        }
        }();
VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo;
[&](){
            if (json["pSizeInfo"].as_vector().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkAccelerationStructureBuildSizesInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildSizesInfoKHR));auto& arr_aJATMZS=json["pSizeInfo"].as_vector();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            deserialize_struct(arr_aJATMZS[pwtSWhd].as_map(),pSizeInfo[pwtSWhd]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureBuildSizesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }  
    
{
call_function(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=static_cast<int>(buildType);}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=json::vector();
            return; }auto arr_rNWxDog=json::vector(1);
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBuildInfo[DpqeGQs]);
            arr_rNWxDog[DpqeGQs]=temp_map;
            return;
            }();
        }
        json["pBuildInfo"]=arr_rNWxDog;}();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=json::vector();
            return; }auto arr_vNFCnZs=json::vector(pBuildInfo->geometryCount);
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=static_cast<uint>(pMaxPrimitiveCounts[KHWuVmo]);}();
        }
        json["pMaxPrimitiveCounts"]=arr_vNFCnZs;}();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=json::vector();
            return; }auto arr_aJATMZS=json::vector(1);
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSizeInfo[pwtSWhd]);
            arr_aJATMZS[pwtSWhd]=temp_map;
            return;
            }();
        }
        json["pSizeInfo"]=arr_aJATMZS;}();


        json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR);
        writeToConn(json);
    }

    void handle_vkCmdSetVertexInputEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexBindingDescriptionCount;
[&](){
            if (json["vertexBindingDescriptionCount"].is_uint64_t()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_uint64_t());
            }else if (json["vertexBindingDescriptionCount"].is_int64_t()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_int64_t());
            }else{
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_double());
            }
            }();
 VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions;
[&](){
            if (json["pVertexBindingDescriptions"].as_vector().size()==0){
                pVertexBindingDescriptions=NULL;
            return; }pVertexBindingDescriptions=(VkVertexInputBindingDescription2EXT*)malloc(vertexBindingDescriptionCount*sizeof(VkVertexInputBindingDescription2EXT));auto& arr_ZGQrPce=json["pVertexBindingDescriptions"].as_vector();
        for(int RbuAKHw=0; RbuAKHw < vertexBindingDescriptionCount; RbuAKHw++){
            [&](){
            deserialize_struct(arr_ZGQrPce[RbuAKHw].as_map(),pVertexBindingDescriptions[RbuAKHw]);
            }();
        }
        }();
uint32_t vertexAttributeDescriptionCount;
[&](){
            if (json["vertexAttributeDescriptionCount"].is_uint64_t()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_uint64_t());
            }else if (json["vertexAttributeDescriptionCount"].is_int64_t()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_int64_t());
            }else{
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_double());
            }
            }();
 VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions;
[&](){
            if (json["pVertexAttributeDescriptions"].as_vector().size()==0){
                pVertexAttributeDescriptions=NULL;
            return; }pVertexAttributeDescriptions=(VkVertexInputAttributeDescription2EXT*)malloc(vertexAttributeDescriptionCount*sizeof(VkVertexInputAttributeDescription2EXT));auto& arr_CiNLRoW=json["pVertexAttributeDescriptions"].as_vector();
        for(int OKcAyyi=0; OKcAyyi < vertexAttributeDescriptionCount; OKcAyyi++){
            [&](){
            deserialize_struct(arr_CiNLRoW[OKcAyyi].as_map(),pVertexAttributeDescriptions[OKcAyyi]);
            }();
        }
        }();

    PFN_vkCmdSetVertexInputEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetVertexInputEXT)get_instance_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetVertexInputEXT)get_device_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }  
    
{
call_function(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=static_cast<uint>(vertexBindingDescriptionCount);}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=json::vector();
            return; }auto arr_CLcpEBv=json::vector(vertexBindingDescriptionCount);
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexBindingDescriptions[BlSYyCp]);
            arr_CLcpEBv[BlSYyCp]=temp_map;
            return;
            }();
        }
        json["pVertexBindingDescriptions"]=arr_CLcpEBv;}();
[&](){json["vertexAttributeDescriptionCount"]=static_cast<uint>(vertexAttributeDescriptionCount);}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=json::vector();
            return; }auto arr_nigNRkL=json::vector(vertexAttributeDescriptionCount);
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexAttributeDescriptions[UWEyBUU]);
            arr_nigNRkL[UWEyBUU]=temp_map;
            return;
            }();
        }
        json["pVertexAttributeDescriptions"]=arr_nigNRkL;}();


        json["stream_type"]=static_cast<int>(VKCMDSETVERTEXINPUTEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteEnableEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();
 VkBool32* pColorWriteEnables;
[&](){
            if (json["pColorWriteEnables"].as_vector().size()==0){
                pColorWriteEnables=NULL;
            return; }pColorWriteEnables=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));auto& arr_KEXhgIr=json["pColorWriteEnables"].as_vector();
        for(int vEjtLXo=0; vEjtLXo < attachmentCount; vEjtLXo++){
            [&](){uint32_t temp_KEXhgIr;[&](){
            if (arr_KEXhgIr[vEjtLXo].is_uint64_t()){
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].as_uint64_t());
            }else if (arr_KEXhgIr[vEjtLXo].is_int64_t()){
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].as_int64_t());
            }else{
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].as_double());
            }
            }();pColorWriteEnables[vEjtLXo]=(VkBool32)temp_KEXhgIr;}();
        }
        }();

    PFN_vkCmdSetColorWriteEnableEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }  
    
{
call_function(commandBuffer, attachmentCount, pColorWriteEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=json::vector();
            return; }auto arr_jmtmyTP=json::vector(attachmentCount);
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=static_cast<uint>(pColorWriteEnables[yHXwpvy]);}();}();
        }
        json["pColorWriteEnables"]=arr_jmtmyTP;}();


        json["stream_type"]=static_cast<int>(VKCMDSETCOLORWRITEENABLEEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetEvent2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
 VkDependencyInfo* pDependencyInfo;
[&](){
            if (json["pDependencyInfo"].as_vector().size()==0){
                pDependencyInfo=NULL;
            return; }pDependencyInfo=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));auto& arr_rdDuAVo=json["pDependencyInfo"].as_vector();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            deserialize_struct(arr_rdDuAVo[WSueWEw].as_map(),pDependencyInfo[WSueWEw]);
            }();
        }
        }();

    PFN_vkCmdSetEvent2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetEvent2)get_instance_proc_addr(parent,"vkCmdSetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetEvent2)get_device_proc_addr(parent,"vkCmdSetEvent2");
    }  
    
{
call_function(commandBuffer, event, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=json::vector();
            return; }auto arr_RUiZhht=json::vector(1);
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfo[rtSvYgr]);
            arr_RUiZhht[rtSvYgr]=temp_map;
            return;
            }();
        }
        json["pDependencyInfo"]=arr_RUiZhht;}();


        json["stream_type"]=static_cast<int>(VKCMDSETEVENT2);
        writeToConn(json);
    }

    void handle_vkCmdResetEvent2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags2 stageMask;
[&](){[&](){int temp_bRKcCBq;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

    PFN_vkCmdResetEvent2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdResetEvent2)get_instance_proc_addr(parent,"vkCmdResetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdResetEvent2)get_device_proc_addr(parent,"vkCmdResetEvent2");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();


        json["stream_type"]=static_cast<int>(VKCMDRESETEVENT2);
        writeToConn(json);
    }

    void handle_vkCmdWaitEvents2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){
            if (json["eventCount"].is_uint64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_uint64_t());
            }else if (json["eventCount"].is_int64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_int64_t());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].as_double());
            }
            }();
 VkEvent* pEvents;
[&](){
            if (json["pEvents"].as_vector().size()==0){
                pEvents=NULL;
            return; }pEvents=(VkEvent*)malloc(eventCount*sizeof(VkEvent));auto& arr_QYtHNne=json["pEvents"].as_vector();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], pEvents[RuhNVwi]);}();
        }
        }();
 VkDependencyInfo* pDependencyInfos;
[&](){
            if (json["pDependencyInfos"].as_vector().size()==0){
                pDependencyInfos=NULL;
            return; }pDependencyInfos=(VkDependencyInfo*)malloc(eventCount*sizeof(VkDependencyInfo));auto& arr_ldOSlic=json["pDependencyInfos"].as_vector();
        for(int aTqXMab=0; aTqXMab < eventCount; aTqXMab++){
            [&](){
            deserialize_struct(arr_ldOSlic[aTqXMab].as_map(),pDependencyInfos[aTqXMab]);
            }();
        }
        }();

    PFN_vkCmdWaitEvents2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWaitEvents2)get_instance_proc_addr(parent,"vkCmdWaitEvents2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWaitEvents2)get_device_proc_addr(parent,"vkCmdWaitEvents2");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=static_cast<uint>(eventCount);}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=json::vector();
            return; }auto arr_tUuyOPJ=json::vector(eventCount);
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        json["pEvents"]=arr_tUuyOPJ;}();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=json::vector();
            return; }auto arr_ZVkfhDe=json::vector(eventCount);
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfos[jvYalYw]);
            arr_ZVkfhDe[jvYalYw]=temp_map;
            return;
            }();
        }
        json["pDependencyInfos"]=arr_ZVkfhDe;}();


        json["stream_type"]=static_cast<int>(VKCMDWAITEVENTS2);
        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDependencyInfo* pDependencyInfo;
[&](){
            if (json["pDependencyInfo"].as_vector().size()==0){
                pDependencyInfo=NULL;
            return; }pDependencyInfo=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));auto& arr_rdDuAVo=json["pDependencyInfo"].as_vector();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            deserialize_struct(arr_rdDuAVo[WSueWEw].as_map(),pDependencyInfo[WSueWEw]);
            }();
        }
        }();

    PFN_vkCmdPipelineBarrier2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdPipelineBarrier2)get_instance_proc_addr(parent,"vkCmdPipelineBarrier2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdPipelineBarrier2)get_device_proc_addr(parent,"vkCmdPipelineBarrier2");
    }  
    
{
call_function(commandBuffer, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=json::vector();
            return; }auto arr_RUiZhht=json::vector(1);
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfo[rtSvYgr]);
            arr_RUiZhht[rtSvYgr]=temp_map;
            return;
            }();
        }
        json["pDependencyInfo"]=arr_RUiZhht;}();


        json["stream_type"]=static_cast<int>(VKCMDPIPELINEBARRIER2);
        writeToConn(json);
    }

    void handle_vkQueueSubmit2(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){
            if (json["submitCount"].is_uint64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_uint64_t());
            }else if (json["submitCount"].is_int64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_int64_t());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].as_double());
            }
            }();
 VkSubmitInfo2* pSubmits;
[&](){
            if (json["pSubmits"].as_vector().size()==0){
                pSubmits=NULL;
            return; }pSubmits=(VkSubmitInfo2*)malloc(submitCount*sizeof(VkSubmitInfo2));auto& arr_mzfyWou=json["pSubmits"].as_vector();
        for(int ozkbIJW=0; ozkbIJW < submitCount; ozkbIJW++){
            [&](){
            deserialize_struct(arr_mzfyWou[ozkbIJW].as_map(),pSubmits[ozkbIJW]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkQueueSubmit2)get_instance_proc_addr(parent,"vkQueueSubmit2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkQueueSubmit2)get_device_proc_addr(parent,"vkQueueSubmit2");
    }  
    
VkResult  result;
{
result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=static_cast<uint>(submitCount);}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=json::vector();
            return; }auto arr_shQKWeV=json::vector(submitCount);
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubmits[uwYUklT]);
            arr_shQKWeV[uwYUklT]=temp_map;
            return;
            }();
        }
        json["pSubmits"]=arr_shQKWeV;}();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=static_cast<int>(VKQUEUESUBMIT2);
        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp2(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_uint64_t());
            }else if (json["stage"].is_int64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_int64_t());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

    PFN_vkCmdWriteTimestamp2 call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteTimestamp2)get_instance_proc_addr(parent,"vkCmdWriteTimestamp2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteTimestamp2)get_device_proc_addr(parent,"vkCmdWriteTimestamp2");
    }  
    
{
call_function(commandBuffer, stage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=static_cast<int>(stage);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITETIMESTAMP2);
        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarker2AMD(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_uint64_t());
            }else if (json["stage"].is_int64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_int64_t());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){
            if (json["marker"].is_uint64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_uint64_t());
            }else if (json["marker"].is_int64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_int64_t());
            }else{
                marker=static_cast<uint32_t>(json["marker"].as_double());
            }
            }();

    PFN_vkCmdWriteBufferMarker2AMD call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }  
    
{
call_function(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=static_cast<int>(stage);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){json["marker"]=static_cast<uint>(marker);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITEBUFFERMARKER2AMD);
        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointData2NV(json::map& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].as_vector().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_vector();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_uint64_t());
            }else if (arr_LsYqVIK[lgasnOP].is_int64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_int64_t());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_double());
            }
            }();
        }
        }();
VkCheckpointData2NV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].as_vector().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointData2NV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointData2NV));auto& arr_jIvYyZg=json["pCheckpointData"].as_vector();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            deserialize_struct(arr_jIvYyZg[yGwfptp].as_map(),pCheckpointData[yGwfptp]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointData2NV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_instance_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_device_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=json::vector();
            return; }auto arr_LsYqVIK=json::vector(1);
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=static_cast<uint>(pCheckpointDataCount[lgasnOP]);}();
        }
        json["pCheckpointDataCount"]=arr_LsYqVIK;}();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=json::vector();
            return; }auto arr_jIvYyZg=json::vector(*pCheckpointDataCount);
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCheckpointData[yGwfptp]);
            arr_jIvYyZg[yGwfptp]=temp_map;
            return;
            }();
        }
        json["pCheckpointData"]=arr_jIvYyZg;}();


        json["stream_type"]=static_cast<int>(VKGETQUEUECHECKPOINTDATA2NV);
        writeToConn(json);
    }

    void handle_vkCopyMemoryToImageEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo;
[&](){
            if (json["pCopyMemoryToImageInfo"].as_vector().size()==0){
                pCopyMemoryToImageInfo=NULL;
            return; }pCopyMemoryToImageInfo=(VkCopyMemoryToImageInfoEXT*)malloc(1*sizeof(VkCopyMemoryToImageInfoEXT));auto& arr_uGpCetH=json["pCopyMemoryToImageInfo"].as_vector();
        for(int LeBHPTF=0; LeBHPTF < 1; LeBHPTF++){
            [&](){
            deserialize_struct(arr_uGpCetH[LeBHPTF].as_map(),pCopyMemoryToImageInfo[LeBHPTF]);
            }();
        }
        }();

    PFN_vkCopyMemoryToImageEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyMemoryToImageEXT)get_instance_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyMemoryToImageEXT)get_device_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyMemoryToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=json::vector();
            return; }auto arr_VVrQQGW=json::vector(1);
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyMemoryToImageInfo[pVINPWa]);
            arr_VVrQQGW[pVINPWa]=temp_map;
            return;
            }();
        }
        json["pCopyMemoryToImageInfo"]=arr_VVrQQGW;}();


        json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOIMAGEEXT);
        writeToConn(json);
    }

    void handle_vkCopyImageToMemoryEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo;
[&](){
            if (json["pCopyImageToMemoryInfo"].as_vector().size()==0){
                pCopyImageToMemoryInfo=NULL;
            return; }pCopyImageToMemoryInfo=(VkCopyImageToMemoryInfoEXT*)malloc(1*sizeof(VkCopyImageToMemoryInfoEXT));auto& arr_JjXseiq=json["pCopyImageToMemoryInfo"].as_vector();
        for(int zMfiotL=0; zMfiotL < 1; zMfiotL++){
            [&](){
            deserialize_struct(arr_JjXseiq[zMfiotL].as_map(),pCopyImageToMemoryInfo[zMfiotL]);
            }();
        }
        }();

    PFN_vkCopyImageToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyImageToMemoryEXT)get_instance_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyImageToMemoryEXT)get_device_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyImageToMemoryInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=json::vector();
            return; }auto arr_uAVSOVI=json::vector(1);
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToMemoryInfo[vveMAPG]);
            arr_uAVSOVI[vveMAPG]=temp_map;
            return;
            }();
        }
        json["pCopyImageToMemoryInfo"]=arr_uAVSOVI;}();


        json["stream_type"]=static_cast<int>(VKCOPYIMAGETOMEMORYEXT);
        writeToConn(json);
    }

    void handle_vkCopyImageToImageEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyImageToImageInfoEXT* pCopyImageToImageInfo;
[&](){
            if (json["pCopyImageToImageInfo"].as_vector().size()==0){
                pCopyImageToImageInfo=NULL;
            return; }pCopyImageToImageInfo=(VkCopyImageToImageInfoEXT*)malloc(1*sizeof(VkCopyImageToImageInfoEXT));auto& arr_WKQiAFF=json["pCopyImageToImageInfo"].as_vector();
        for(int kaVefuU=0; kaVefuU < 1; kaVefuU++){
            [&](){
            deserialize_struct(arr_WKQiAFF[kaVefuU].as_map(),pCopyImageToImageInfo[kaVefuU]);
            }();
        }
        }();

    PFN_vkCopyImageToImageEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyImageToImageEXT)get_instance_proc_addr(parent,"vkCopyImageToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyImageToImageEXT)get_device_proc_addr(parent,"vkCopyImageToImageEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyImageToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=json::vector();
            return; }auto arr_mMvIKFh=json::vector(1);
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToImageInfo[vOMFrGb]);
            arr_mMvIKFh[vOMFrGb]=temp_map;
            return;
            }();
        }
        json["pCopyImageToImageInfo"]=arr_mMvIKFh;}();


        json["stream_type"]=static_cast<int>(VKCOPYIMAGETOIMAGEEXT);
        writeToConn(json);
    }

    void handle_vkTransitionImageLayoutEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t transitionCount;
[&](){
            if (json["transitionCount"].is_uint64_t()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_uint64_t());
            }else if (json["transitionCount"].is_int64_t()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_int64_t());
            }else{
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_double());
            }
            }();
 VkHostImageLayoutTransitionInfoEXT* pTransitions;
[&](){
            if (json["pTransitions"].as_vector().size()==0){
                pTransitions=NULL;
            return; }pTransitions=(VkHostImageLayoutTransitionInfoEXT*)malloc(transitionCount*sizeof(VkHostImageLayoutTransitionInfoEXT));auto& arr_kGKdcAG=json["pTransitions"].as_vector();
        for(int mCqQGEL=0; mCqQGEL < transitionCount; mCqQGEL++){
            [&](){
            deserialize_struct(arr_kGKdcAG[mCqQGEL].as_map(),pTransitions[mCqQGEL]);
            }();
        }
        }();

    PFN_vkTransitionImageLayoutEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkTransitionImageLayoutEXT)get_instance_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkTransitionImageLayoutEXT)get_device_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }  
    
VkResult  result;
{
result=call_function(device, transitionCount, pTransitions);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=static_cast<uint>(transitionCount);}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=json::vector();
            return; }auto arr_KQaENWu=json::vector(transitionCount);
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTransitions[EeppCgm]);
            arr_KQaENWu[EeppCgm]=temp_map;
            return;
            }();
        }
        json["pTransitions"]=arr_KQaENWu;}();


        json["stream_type"]=static_cast<int>(VKTRANSITIONIMAGELAYOUTEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoCapabilitiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkVideoProfileInfoKHR* pVideoProfile;
[&](){
            if (json["pVideoProfile"].as_vector().size()==0){
                pVideoProfile=NULL;
            return; }pVideoProfile=(VkVideoProfileInfoKHR*)malloc(1*sizeof(VkVideoProfileInfoKHR));auto& arr_LQJyXAW=json["pVideoProfile"].as_vector();
        for(int AyTOixj=0; AyTOixj < 1; AyTOixj++){
            [&](){
            deserialize_struct(arr_LQJyXAW[AyTOixj].as_map(),pVideoProfile[AyTOixj]);
            }();
        }
        }();
VkVideoCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkVideoCapabilitiesKHR*)malloc(1*sizeof(VkVideoCapabilitiesKHR));auto& arr_rprZzlH=json["pCapabilities"].as_vector();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            deserialize_struct(arr_rprZzlH[NPLkdlm].as_map(),pCapabilities[NPLkdlm]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pVideoProfile, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=json::vector();
            return; }auto arr_eFObkVe=json::vector(1);
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoProfile[YJbJtas]);
            arr_eFObkVe[YJbJtas]=temp_map;
            return;
            }();
        }
        json["pVideoProfile"]=arr_eFObkVe;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_rprZzlH=json::vector(1);
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[NPLkdlm]);
            arr_rprZzlH[NPLkdlm]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_rprZzlH;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoFormatPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo;
[&](){
            if (json["pVideoFormatInfo"].as_vector().size()==0){
                pVideoFormatInfo=NULL;
            return; }pVideoFormatInfo=(VkPhysicalDeviceVideoFormatInfoKHR*)malloc(1*sizeof(VkPhysicalDeviceVideoFormatInfoKHR));auto& arr_JCeubLO=json["pVideoFormatInfo"].as_vector();
        for(int aVxBrFp=0; aVxBrFp < 1; aVxBrFp++){
            [&](){
            deserialize_struct(arr_JCeubLO[aVxBrFp].as_map(),pVideoFormatInfo[aVxBrFp]);
            }();
        }
        }();
uint32_t* pVideoFormatPropertyCount;
[&](){
            if (json["pVideoFormatPropertyCount"].as_vector().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }pVideoFormatPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].as_vector();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){
            if (arr_kJoqfTP[hCeCDXk].is_uint64_t()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_uint64_t());
            }else if (arr_kJoqfTP[hCeCDXk].is_int64_t()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_int64_t());
            }else{
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_double());
            }
            }();
        }
        }();
VkVideoFormatPropertiesKHR* pVideoFormatProperties;
[&](){
            if (json["pVideoFormatProperties"].as_vector().size()==0){
                pVideoFormatProperties=NULL;
            return; }pVideoFormatProperties=(VkVideoFormatPropertiesKHR*)malloc(*pVideoFormatPropertyCount*sizeof(VkVideoFormatPropertiesKHR));auto& arr_GhjQGHj=json["pVideoFormatProperties"].as_vector();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            deserialize_struct(arr_GhjQGHj[mUXWOpX].as_map(),pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=json::vector();
            return; }auto arr_JJWKnHz=json::vector(1);
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoFormatInfo[FIocPZR]);
            arr_JJWKnHz[FIocPZR]=temp_map;
            return;
            }();
        }
        json["pVideoFormatInfo"]=arr_JJWKnHz;}();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=json::vector();
            return; }auto arr_kJoqfTP=json::vector(1);
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=static_cast<uint>(pVideoFormatPropertyCount[hCeCDXk]);}();
        }
        json["pVideoFormatPropertyCount"]=arr_kJoqfTP;}();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=json::vector();
            return; }auto arr_GhjQGHj=json::vector(*pVideoFormatPropertyCount);
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoFormatProperties[mUXWOpX]);
            arr_GhjQGHj[mUXWOpX]=temp_map;
            return;
            }();
        }
        json["pVideoFormatProperties"]=arr_GhjQGHj;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR);
        writeToConn(json);
    }

    void handle_vkCreateVideoSessionKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkVideoSessionCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkVideoSessionCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionCreateInfoKHR));auto& arr_wPbwQCK=json["pCreateInfo"].as_vector();
        for(int YSXcLgo=0; YSXcLgo < 1; YSXcLgo++){
            [&](){
            deserialize_struct(arr_wPbwQCK[YSXcLgo].as_map(),pCreateInfo[YSXcLgo]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkVideoSessionKHR* pVideoSession;
[&](){
            if (json["pVideoSession"].as_vector().size()==0){
                pVideoSession=NULL;
            return; }pVideoSession=(VkVideoSessionKHR*)malloc(1*sizeof(VkVideoSessionKHR));auto& arr_YUuHYdT=json["pVideoSession"].as_vector();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();

    PFN_vkCreateVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateVideoSessionKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateVideoSessionKHR)get_device_proc_addr(parent,"vkCreateVideoSessionKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pVideoSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_mCuZMrp=json::vector(1);
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tsYbFnY]);
            arr_mCuZMrp[tsYbFnY]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_mCuZMrp;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=json::vector();
            return; }auto arr_YUuHYdT=json::vector(1);
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        json["pVideoSession"]=arr_YUuHYdT;}();


        json["stream_type"]=static_cast<int>(VKCREATEVIDEOSESSIONKHR);
        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyVideoSessionKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyVideoSessionKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }  
    
{
call_function(device, videoSession, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYVIDEOSESSIONKHR);
        writeToConn(json);
    }

    void handle_vkCreateVideoSessionParametersKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkVideoSessionParametersCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkVideoSessionParametersCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersCreateInfoKHR));auto& arr_orBbBzS=json["pCreateInfo"].as_vector();
        for(int BFSvJhy=0; BFSvJhy < 1; BFSvJhy++){
            [&](){
            deserialize_struct(arr_orBbBzS[BFSvJhy].as_map(),pCreateInfo[BFSvJhy]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkVideoSessionParametersKHR* pVideoSessionParameters;
[&](){
            if (json["pVideoSessionParameters"].as_vector().size()==0){
                pVideoSessionParameters=NULL;
            return; }pVideoSessionParameters=(VkVideoSessionParametersKHR*)malloc(1*sizeof(VkVideoSessionParametersKHR));auto& arr_drxJQhO=json["pVideoSessionParameters"].as_vector();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();

    PFN_vkCreateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_PbbIaMM=json::vector(1);
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[uFIOrHK]);
            arr_PbbIaMM[uFIOrHK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_PbbIaMM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=json::vector();
            return; }auto arr_drxJQhO=json::vector(1);
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        json["pVideoSessionParameters"]=arr_drxJQhO;}();


        json["stream_type"]=static_cast<int>(VKCREATEVIDEOSESSIONPARAMETERSKHR);
        writeToConn(json);
    }

    void handle_vkUpdateVideoSessionParametersKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
 VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo;
[&](){
            if (json["pUpdateInfo"].as_vector().size()==0){
                pUpdateInfo=NULL;
            return; }pUpdateInfo=(VkVideoSessionParametersUpdateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersUpdateInfoKHR));auto& arr_ErkRXpw=json["pUpdateInfo"].as_vector();
        for(int wrcSXFx=0; wrcSXFx < 1; wrcSXFx++){
            [&](){
            deserialize_struct(arr_ErkRXpw[wrcSXFx].as_map(),pUpdateInfo[wrcSXFx]);
            }();
        }
        }();

    PFN_vkUpdateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSessionParameters, pUpdateInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=json::vector();
            return; }auto arr_miOYaCQ=json::vector(1);
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pUpdateInfo[gnypMkA]);
            arr_miOYaCQ[gnypMkA]=temp_map;
            return;
            }();
        }
        json["pUpdateInfo"]=arr_miOYaCQ;}();


        json["stream_type"]=static_cast<int>(VKUPDATEVIDEOSESSIONPARAMETERSKHR);
        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionParametersKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }  
    
{
call_function(device, videoSessionParameters, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYVIDEOSESSIONPARAMETERSKHR);
        writeToConn(json);
    }

    void handle_vkGetVideoSessionMemoryRequirementsKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t* pMemoryRequirementsCount;
[&](){
            if (json["pMemoryRequirementsCount"].as_vector().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }pMemoryRequirementsCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_pJPineF=json["pMemoryRequirementsCount"].as_vector();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){
            if (arr_pJPineF[NMpDmPR].is_uint64_t()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_uint64_t());
            }else if (arr_pJPineF[NMpDmPR].is_int64_t()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_int64_t());
            }else{
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_double());
            }
            }();
        }
        }();
VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkVideoSessionMemoryRequirementsKHR*)malloc(*pMemoryRequirementsCount*sizeof(VkVideoSessionMemoryRequirementsKHR));auto& arr_UuJQZUu=json["pMemoryRequirements"].as_vector();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            deserialize_struct(arr_UuJQZUu[FfNBlzG].as_map(),pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();

    PFN_vkGetVideoSessionMemoryRequirementsKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_instance_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_device_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=json::vector();
            return; }auto arr_pJPineF=json::vector(1);
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=static_cast<uint>(pMemoryRequirementsCount[NMpDmPR]);}();
        }
        json["pMemoryRequirementsCount"]=arr_pJPineF;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_UuJQZUu=json::vector(*pMemoryRequirementsCount);
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[FfNBlzG]);
            arr_UuJQZUu[FfNBlzG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_UuJQZUu;}();


        json["stream_type"]=static_cast<int>(VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR);
        writeToConn(json);
    }

    void handle_vkBindVideoSessionMemoryKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t bindSessionMemoryInfoCount;
[&](){
            if (json["bindSessionMemoryInfoCount"].is_uint64_t()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_uint64_t());
            }else if (json["bindSessionMemoryInfoCount"].is_int64_t()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_int64_t());
            }else{
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_double());
            }
            }();
 VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos;
[&](){
            if (json["pBindSessionMemoryInfos"].as_vector().size()==0){
                pBindSessionMemoryInfos=NULL;
            return; }pBindSessionMemoryInfos=(VkBindVideoSessionMemoryInfoKHR*)malloc(bindSessionMemoryInfoCount*sizeof(VkBindVideoSessionMemoryInfoKHR));auto& arr_TbzDfjI=json["pBindSessionMemoryInfos"].as_vector();
        for(int XHgqGRS=0; XHgqGRS < bindSessionMemoryInfoCount; XHgqGRS++){
            [&](){
            deserialize_struct(arr_TbzDfjI[XHgqGRS].as_map(),pBindSessionMemoryInfos[XHgqGRS]);
            }();
        }
        }();

    PFN_vkBindVideoSessionMemoryKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_instance_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_device_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=static_cast<uint>(bindSessionMemoryInfoCount);}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=json::vector();
            return; }auto arr_XamFtca=json::vector(bindSessionMemoryInfoCount);
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindSessionMemoryInfos[bWiRCGV]);
            arr_XamFtca[bWiRCGV]=temp_map;
            return;
            }();
        }
        json["pBindSessionMemoryInfos"]=arr_XamFtca;}();


        json["stream_type"]=static_cast<int>(VKBINDVIDEOSESSIONMEMORYKHR);
        writeToConn(json);
    }

    void handle_vkCmdDecodeVideoKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoDecodeInfoKHR* pDecodeInfo;
[&](){
            if (json["pDecodeInfo"].as_vector().size()==0){
                pDecodeInfo=NULL;
            return; }pDecodeInfo=(VkVideoDecodeInfoKHR*)malloc(1*sizeof(VkVideoDecodeInfoKHR));auto& arr_ewdOprb=json["pDecodeInfo"].as_vector();
        for(int PPOqwvx=0; PPOqwvx < 1; PPOqwvx++){
            [&](){
            deserialize_struct(arr_ewdOprb[PPOqwvx].as_map(),pDecodeInfo[PPOqwvx]);
            }();
        }
        }();

    PFN_vkCmdDecodeVideoKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDecodeVideoKHR)get_instance_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDecodeVideoKHR)get_device_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }  
    
{
call_function(commandBuffer, pDecodeInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=json::vector();
            return; }auto arr_FUuNCSo=json::vector(1);
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDecodeInfo[jmrOltD]);
            arr_FUuNCSo[jmrOltD]=temp_map;
            return;
            }();
        }
        json["pDecodeInfo"]=arr_FUuNCSo;}();


        json["stream_type"]=static_cast<int>(VKCMDDECODEVIDEOKHR);
        writeToConn(json);
    }

    void handle_vkCmdBeginVideoCodingKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoBeginCodingInfoKHR* pBeginInfo;
[&](){
            if (json["pBeginInfo"].as_vector().size()==0){
                pBeginInfo=NULL;
            return; }pBeginInfo=(VkVideoBeginCodingInfoKHR*)malloc(1*sizeof(VkVideoBeginCodingInfoKHR));auto& arr_YgojtMV=json["pBeginInfo"].as_vector();
        for(int gEGjmEh=0; gEGjmEh < 1; gEGjmEh++){
            [&](){
            deserialize_struct(arr_YgojtMV[gEGjmEh].as_map(),pBeginInfo[gEGjmEh]);
            }();
        }
        }();

    PFN_vkCmdBeginVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_device_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=json::vector();
            return; }auto arr_pSWbqZw=json::vector(1);
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBeginInfo[tVSxYNW]);
            arr_pSWbqZw[tVSxYNW]=temp_map;
            return;
            }();
        }
        json["pBeginInfo"]=arr_pSWbqZw;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINVIDEOCODINGKHR);
        writeToConn(json);
    }

    void handle_vkCmdControlVideoCodingKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoCodingControlInfoKHR* pCodingControlInfo;
[&](){
            if (json["pCodingControlInfo"].as_vector().size()==0){
                pCodingControlInfo=NULL;
            return; }pCodingControlInfo=(VkVideoCodingControlInfoKHR*)malloc(1*sizeof(VkVideoCodingControlInfoKHR));auto& arr_QVObPIP=json["pCodingControlInfo"].as_vector();
        for(int LMgTacT=0; LMgTacT < 1; LMgTacT++){
            [&](){
            deserialize_struct(arr_QVObPIP[LMgTacT].as_map(),pCodingControlInfo[LMgTacT]);
            }();
        }
        }();

    PFN_vkCmdControlVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_device_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pCodingControlInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=json::vector();
            return; }auto arr_vJmaWsp=json::vector(1);
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCodingControlInfo[MLwaMsn]);
            arr_vJmaWsp[MLwaMsn]=temp_map;
            return;
            }();
        }
        json["pCodingControlInfo"]=arr_vJmaWsp;}();


        json["stream_type"]=static_cast<int>(VKCMDCONTROLVIDEOCODINGKHR);
        writeToConn(json);
    }

    void handle_vkCmdEndVideoCodingKHR(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoEndCodingInfoKHR* pEndCodingInfo;
[&](){
            if (json["pEndCodingInfo"].as_vector().size()==0){
                pEndCodingInfo=NULL;
            return; }pEndCodingInfo=(VkVideoEndCodingInfoKHR*)malloc(1*sizeof(VkVideoEndCodingInfoKHR));auto& arr_ErbGsyK=json["pEndCodingInfo"].as_vector();
        for(int QjqRiFV=0; QjqRiFV < 1; QjqRiFV++){
            [&](){
            deserialize_struct(arr_ErbGsyK[QjqRiFV].as_map(),pEndCodingInfo[QjqRiFV]);
            }();
        }
        }();

    PFN_vkCmdEndVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_device_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pEndCodingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=json::vector();
            return; }auto arr_OpexQSo=json::vector(1);
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pEndCodingInfo[KxwYkSG]);
            arr_OpexQSo[KxwYkSG]=temp_map;
            return;
            }();
        }
        json["pEndCodingInfo"]=arr_OpexQSo;}();


        json["stream_type"]=static_cast<int>(VKCMDENDVIDEOCODINGKHR);
        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t decompressRegionCount;
[&](){
            if (json["decompressRegionCount"].is_uint64_t()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_uint64_t());
            }else if (json["decompressRegionCount"].is_int64_t()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_int64_t());
            }else{
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_double());
            }
            }();
 VkDecompressMemoryRegionNV* pDecompressMemoryRegions;
[&](){
            if (json["pDecompressMemoryRegions"].as_vector().size()==0){
                pDecompressMemoryRegions=NULL;
            return; }pDecompressMemoryRegions=(VkDecompressMemoryRegionNV*)malloc(decompressRegionCount*sizeof(VkDecompressMemoryRegionNV));auto& arr_VAyqSbG=json["pDecompressMemoryRegions"].as_vector();
        for(int EZVrxlF=0; EZVrxlF < decompressRegionCount; EZVrxlF++){
            [&](){
            deserialize_struct(arr_VAyqSbG[EZVrxlF].as_map(),pDecompressMemoryRegions[EZVrxlF]);
            }();
        }
        }();

    PFN_vkCmdDecompressMemoryNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDecompressMemoryNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDecompressMemoryNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }  
    
{
call_function(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=static_cast<uint>(decompressRegionCount);}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=json::vector();
            return; }auto arr_oMszjDS=json::vector(decompressRegionCount);
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDecompressMemoryRegions[PnFzdhd]);
            arr_oMszjDS[PnFzdhd]=temp_map;
            return;
            }();
        }
        json["pDecompressMemoryRegions"]=arr_oMszjDS;}();


        json["stream_type"]=static_cast<int>(VKCMDDECOMPRESSMEMORYNV);
        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryIndirectCountNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectCommandsAddress;
[&](){uint64_t temp_nwmsRdL;[&](){
            if (json["indirectCommandsAddress"].is_uint64_t()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_uint64_t());
            }else if (json["indirectCommandsAddress"].is_int64_t()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_int64_t());
            }else{
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_double());
            }
            }();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
VkDeviceAddress indirectCommandsCountAddress;
[&](){uint64_t temp_TcxQHrV;[&](){
            if (json["indirectCommandsCountAddress"].is_uint64_t()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_uint64_t());
            }else if (json["indirectCommandsCountAddress"].is_int64_t()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_int64_t());
            }else{
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_double());
            }
            }();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

    PFN_vkCmdDecompressMemoryIndirectCountNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }  
    
{
call_function(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=static_cast<uint>(indirectCommandsAddress);}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=static_cast<uint>(indirectCommandsCountAddress);}();}();
[&](){json["stride"]=static_cast<uint>(stride);}();


        json["stream_type"]=static_cast<int>(VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV);
        writeToConn(json);
    }

    void handle_vkCreateCuModuleNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCuModuleCreateInfoNVX* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCuModuleCreateInfoNVX*)malloc(1*sizeof(VkCuModuleCreateInfoNVX));auto& arr_hMoVXkn=json["pCreateInfo"].as_vector();
        for(int cihZnwL=0; cihZnwL < 1; cihZnwL++){
            [&](){
            deserialize_struct(arr_hMoVXkn[cihZnwL].as_map(),pCreateInfo[cihZnwL]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkCuModuleNVX* pModule;
[&](){
            if (json["pModule"].as_vector().size()==0){
                pModule=NULL;
            return; }pModule=(VkCuModuleNVX*)malloc(1*sizeof(VkCuModuleNVX));auto& arr_FnQIexZ=json["pModule"].as_vector();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();

    PFN_vkCreateCuModuleNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateCuModuleNVX)get_instance_proc_addr(parent,"vkCreateCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateCuModuleNVX)get_device_proc_addr(parent,"vkCreateCuModuleNVX");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_FjdqPXh=json::vector(1);
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TUVhIjf]);
            arr_FjdqPXh[TUVhIjf]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_FjdqPXh;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pModule==NULL){
                json["pModule"]=json::vector();
            return; }auto arr_FnQIexZ=json::vector(1);
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        json["pModule"]=arr_FnQIexZ;}();


        json["stream_type"]=static_cast<int>(VKCREATECUMODULENVX);
        writeToConn(json);
    }

    void handle_vkCreateCuFunctionNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCuFunctionCreateInfoNVX* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCuFunctionCreateInfoNVX*)malloc(1*sizeof(VkCuFunctionCreateInfoNVX));auto& arr_gHmsOsA=json["pCreateInfo"].as_vector();
        for(int EbWStVn=0; EbWStVn < 1; EbWStVn++){
            [&](){
            deserialize_struct(arr_gHmsOsA[EbWStVn].as_map(),pCreateInfo[EbWStVn]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkCuFunctionNVX* pFunction;
[&](){
            if (json["pFunction"].as_vector().size()==0){
                pFunction=NULL;
            return; }pFunction=(VkCuFunctionNVX*)malloc(1*sizeof(VkCuFunctionNVX));auto& arr_TrIYEcP=json["pFunction"].as_vector();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();

    PFN_vkCreateCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateCuFunctionNVX)get_instance_proc_addr(parent,"vkCreateCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateCuFunctionNVX)get_device_proc_addr(parent,"vkCreateCuFunctionNVX");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFunction);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XkBojZi=json::vector(1);
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[twsSgji]);
            arr_XkBojZi[twsSgji]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XkBojZi;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=json::vector();
            return; }auto arr_TrIYEcP=json::vector(1);
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        json["pFunction"]=arr_TrIYEcP;}();


        json["stream_type"]=static_cast<int>(VKCREATECUFUNCTIONNVX);
        writeToConn(json);
    }

    void handle_vkDestroyCuModuleNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuModuleNVX module;
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCuModuleNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyCuModuleNVX)get_instance_proc_addr(parent,"vkDestroyCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyCuModuleNVX)get_device_proc_addr(parent,"vkDestroyCuModuleNVX");
    }  
    
{
call_function(device, module, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYCUMODULENVX);
        writeToConn(json);
    }

    void handle_vkDestroyCuFunctionNVX(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuFunctionNVX function;
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyCuFunctionNVX)get_instance_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyCuFunctionNVX)get_device_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }  
    
{
call_function(device, function, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYCUFUNCTIONNVX);
        writeToConn(json);
    }

    void handle_vkCmdCuLaunchKernelNVX(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCuLaunchInfoNVX* pLaunchInfo;
[&](){
            if (json["pLaunchInfo"].as_vector().size()==0){
                pLaunchInfo=NULL;
            return; }pLaunchInfo=(VkCuLaunchInfoNVX*)malloc(1*sizeof(VkCuLaunchInfoNVX));auto& arr_KytmXlj=json["pLaunchInfo"].as_vector();
        for(int TnDRcbg=0; TnDRcbg < 1; TnDRcbg++){
            [&](){
            deserialize_struct(arr_KytmXlj[TnDRcbg].as_map(),pLaunchInfo[TnDRcbg]);
            }();
        }
        }();

    PFN_vkCmdCuLaunchKernelNVX call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_instance_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_device_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }  
    
{
call_function(commandBuffer, pLaunchInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=json::vector();
            return; }auto arr_UKYVund=json::vector(1);
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLaunchInfo[eUSpbRB]);
            arr_UKYVund[eUSpbRB]=temp_map;
            return;
            }();
        }
        json["pLaunchInfo"]=arr_UKYVund;}();


        json["stream_type"]=static_cast<int>(VKCMDCULAUNCHKERNELNVX);
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSizeEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
VkDeviceSize* pLayoutSizeInBytes;
[&](){
            if (json["pLayoutSizeInBytes"].as_vector().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }pLayoutSizeInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].as_vector();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){
            if (arr_xOYiCiO[QcQjmSi].is_uint64_t()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_uint64_t());
            }else if (arr_xOYiCiO[QcQjmSi].is_int64_t()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_int64_t());
            }else{
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_double());
            }
            }();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSizeEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }  
    
{
call_function(device, layout, pLayoutSizeInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=json::vector();
            return; }auto arr_xOYiCiO=json::vector(1);
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=static_cast<uint>(pLayoutSizeInBytes[QcQjmSi]);}();}();
        }
        json["pLayoutSizeInBytes"]=arr_xOYiCiO;}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTSIZEEXT);
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutBindingOffsetEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
uint32_t binding;
[&](){
            if (json["binding"].is_uint64_t()){
                binding=static_cast<uint32_t>(json["binding"].as_uint64_t());
            }else if (json["binding"].is_int64_t()){
                binding=static_cast<uint32_t>(json["binding"].as_int64_t());
            }else{
                binding=static_cast<uint32_t>(json["binding"].as_double());
            }
            }();
VkDeviceSize* pOffset;
[&](){
            if (json["pOffset"].as_vector().size()==0){
                pOffset=NULL;
            return; }pOffset=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));auto& arr_dquZgZN=json["pOffset"].as_vector();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){
            if (arr_dquZgZN[LNetLnu].is_uint64_t()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_uint64_t());
            }else if (arr_dquZgZN[LNetLnu].is_int64_t()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_int64_t());
            }else{
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_double());
            }
            }();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }  
    
{
call_function(device, layout, binding, pOffset);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=static_cast<uint>(binding);}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=json::vector();
            return; }auto arr_dquZgZN=json::vector(1);
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=static_cast<uint>(pOffset[LNetLnu]);}();}();
        }
        json["pOffset"]=arr_dquZgZN;}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT);
        writeToConn(json);
    }

    void handle_vkGetDescriptorEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorGetInfoEXT* pDescriptorInfo;
[&](){
            if (json["pDescriptorInfo"].as_vector().size()==0){
                pDescriptorInfo=NULL;
            return; }pDescriptorInfo=(VkDescriptorGetInfoEXT*)malloc(1*sizeof(VkDescriptorGetInfoEXT));auto& arr_PhsrvQH=json["pDescriptorInfo"].as_vector();
        for(int HBOsibB=0; HBOsibB < 1; HBOsibB++){
            [&](){
            deserialize_struct(arr_PhsrvQH[HBOsibB].as_map(),pDescriptorInfo[HBOsibB]);
            }();
        }
        }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pDescriptor;
[&](){
            if (json["pDescriptor"].as_vector().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].as_vector().size()==0){
                temp_mEHYUhJ=NULL;
            return; }temp_mEHYUhJ=(char*)malloc(dataSize*sizeof(char));auto& arr_NUAdiYW=json["pDescriptor"].as_vector();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){
            if (arr_NUAdiYW[skXTLXg].is_uint64_t()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_uint64_t());
            }else if (arr_NUAdiYW[skXTLXg].is_int64_t()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_int64_t());
            }else{
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_double());
            }
            }();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

    PFN_vkGetDescriptorEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorEXT)get_instance_proc_addr(parent,"vkGetDescriptorEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorEXT)get_device_proc_addr(parent,"vkGetDescriptorEXT");
    }  
    
{
call_function(device, pDescriptorInfo, dataSize, pDescriptor);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=json::vector();
            return; }auto arr_RGgHhwd=json::vector(1);
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorInfo[cdcTeyn]);
            arr_RGgHhwd[cdcTeyn]=temp_map;
            return;
            }();
        }
        json["pDescriptorInfo"]=arr_RGgHhwd;}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=json::vector();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=json::vector();
            return; }auto arr_NUAdiYW=json::vector(dataSize);
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){arr_NUAdiYW[skXTLXg]=static_cast<uint>(((char*)(pDescriptor))[skXTLXg]);}();
        }
        json["pDescriptor"]=arr_NUAdiYW;}();}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTOREXT);
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBuffersEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t bufferCount;
[&](){
            if (json["bufferCount"].is_uint64_t()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_uint64_t());
            }else if (json["bufferCount"].is_int64_t()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_int64_t());
            }else{
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_double());
            }
            }();
 VkDescriptorBufferBindingInfoEXT* pBindingInfos;
[&](){
            if (json["pBindingInfos"].as_vector().size()==0){
                pBindingInfos=NULL;
            return; }pBindingInfos=(VkDescriptorBufferBindingInfoEXT*)malloc(bufferCount*sizeof(VkDescriptorBufferBindingInfoEXT));auto& arr_xBOCrqU=json["pBindingInfos"].as_vector();
        for(int VnwAoIb=0; VnwAoIb < bufferCount; VnwAoIb++){
            [&](){
            deserialize_struct(arr_xBOCrqU[VnwAoIb].as_map(),pBindingInfos[VnwAoIb]);
            }();
        }
        }();

    PFN_vkCmdBindDescriptorBuffersEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }  
    
{
call_function(commandBuffer, bufferCount, pBindingInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=static_cast<uint>(bufferCount);}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=json::vector();
            return; }auto arr_guwgqGC=json::vector(bufferCount);
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindingInfos[btgeqwi]);
            arr_guwgqGC[btgeqwi]=temp_map;
            return;
            }();
        }
        json["pBindingInfos"]=arr_guwgqGC;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORBUFFERSEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDescriptorBufferOffsetsEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){
            if (json["firstSet"].is_uint64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_uint64_t());
            }else if (json["firstSet"].is_int64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_int64_t());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].as_double());
            }
            }();
uint32_t setCount;
[&](){
            if (json["setCount"].is_uint64_t()){
                setCount=static_cast<uint32_t>(json["setCount"].as_uint64_t());
            }else if (json["setCount"].is_int64_t()){
                setCount=static_cast<uint32_t>(json["setCount"].as_int64_t());
            }else{
                setCount=static_cast<uint32_t>(json["setCount"].as_double());
            }
            }();
 uint32_t* pBufferIndices;
[&](){
            if (json["pBufferIndices"].as_vector().size()==0){
                pBufferIndices=NULL;
            return; }pBufferIndices=(uint32_t*)malloc(setCount*sizeof(uint32_t));auto& arr_PTuYzHc=json["pBufferIndices"].as_vector();
        for(int sDNFOkx=0; sDNFOkx < setCount; sDNFOkx++){
            [&](){
            if (arr_PTuYzHc[sDNFOkx].is_uint64_t()){
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].as_uint64_t());
            }else if (arr_PTuYzHc[sDNFOkx].is_int64_t()){
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].as_int64_t());
            }else{
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].as_double());
            }
            }();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].as_vector().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(setCount*sizeof(VkDeviceSize));auto& arr_uWdiGtF=json["pOffsets"].as_vector();
        for(int ELYQTNF=0; ELYQTNF < setCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_uint64_t());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64_t()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_int64_t());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].as_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();

    PFN_vkCmdSetDescriptorBufferOffsetsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_instance_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_device_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=static_cast<uint>(firstSet);}();
[&](){json["setCount"]=static_cast<uint>(setCount);}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=json::vector();
            return; }auto arr_zejaAgt=json::vector(setCount);
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=static_cast<uint>(pBufferIndices[tuuKbsL]);}();
        }
        json["pBufferIndices"]=arr_zejaAgt;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(setCount);
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();


        json["stream_type"]=static_cast<int>(VKCMDSETDESCRIPTORBUFFEROFFSETSEXT);
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();

    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();


        json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT);
        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureDescriptorDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkBufferCaptureDescriptorDataInfoEXT));auto& arr_VqsZREG=json["pInfo"].as_vector();
        for(int dxQHpNQ=0; dxQHpNQ < 1; dxQHpNQ++){
            [&](){
            deserialize_struct(arr_VqsZREG[dxQHpNQ].as_map(),pInfo[dxQHpNQ]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_Hxvezrr=json::vector(1);
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[VgzeNwX]);
            arr_Hxvezrr[VgzeNwX]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_Hxvezrr;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT);
        writeToConn(json);
    }

    void handle_vkGetImageOpaqueCaptureDescriptorDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageCaptureDescriptorDataInfoEXT));auto& arr_YRCGcVr=json["pInfo"].as_vector();
        for(int VOFqAJf=0; VOFqAJf < 1; VOFqAJf++){
            [&](){
            deserialize_struct(arr_YRCGcVr[VOFqAJf].as_map(),pInfo[VOFqAJf]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_vrxBIsi=json::vector(1);
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[swRpuDc]);
            arr_vrxBIsi[swRpuDc]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_vrxBIsi;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT);
        writeToConn(json);
    }

    void handle_vkGetImageViewOpaqueCaptureDescriptorDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageViewCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageViewCaptureDescriptorDataInfoEXT));auto& arr_eRxFxUj=json["pInfo"].as_vector();
        for(int QcuObSb=0; QcuObSb < 1; QcuObSb++){
            [&](){
            deserialize_struct(arr_eRxFxUj[QcuObSb].as_map(),pInfo[QcuObSb]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_CYlSaQv=json::vector(1);
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[pmdADqD]);
            arr_CYlSaQv[pmdADqD]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_CYlSaQv;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT);
        writeToConn(json);
    }

    void handle_vkGetSamplerOpaqueCaptureDescriptorDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkSamplerCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkSamplerCaptureDescriptorDataInfoEXT));auto& arr_MRsSLnb=json["pInfo"].as_vector();
        for(int VTYniUZ=0; VTYniUZ < 1; VTYniUZ++){
            [&](){
            deserialize_struct(arr_MRsSLnb[VTYniUZ].as_map(),pInfo[VTYniUZ]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_RMPxsVS=json::vector(1);
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[SScNLQN]);
            arr_RMPxsVS[SScNLQN]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_RMPxsVS;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT);
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT));auto& arr_IpvCogf=json["pInfo"].as_vector();
        for(int rufTsHO=0; rufTsHO < 1; rufTsHO++){
            [&](){
            deserialize_struct(arr_IpvCogf[rufTsHO].as_map(),pInfo[rufTsHO]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_iLnHGmk=json::vector(1);
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[kbTuVMH]);
            arr_iLnHGmk[kbTuVMH]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_iLnHGmk;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT);
        writeToConn(json);
    }

    void handle_vkSetDeviceMemoryPriorityEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
float priority;
[&](){
            if (json["priority"].is_uint64_t()){
                priority=static_cast<float>(json["priority"].as_uint64_t());
            }else if (json["priority"].is_int64_t()){
                priority=static_cast<float>(json["priority"].as_int64_t());
            }else{
                priority=static_cast<float>(json["priority"].as_double());
            }
            }();

    PFN_vkSetDeviceMemoryPriorityEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_instance_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_device_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }  
    
{
call_function(device, memory, priority);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=static_cast<float>(priority);}();


        json["stream_type"]=static_cast<int>(VKSETDEVICEMEMORYPRIORITYEXT);
        writeToConn(json);
    }

    void handle_vkAcquireDrmDisplayEXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){
            if (json["drmFd"].is_uint64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_uint64_t());
            }else if (json["drmFd"].is_int64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_int64_t());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].as_double());
            }
            }();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkAcquireDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_instance_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_device_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, drmFd, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=static_cast<int>(drmFd);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        json["stream_type"]=static_cast<int>(VKACQUIREDRMDISPLAYEXT);
        writeToConn(json);
    }

    void handle_vkGetDrmDisplayEXT(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){
            if (json["drmFd"].is_uint64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_uint64_t());
            }else if (json["drmFd"].is_int64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_int64_t());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].as_double());
            }
            }();
uint32_t connectorId;
[&](){
            if (json["connectorId"].is_uint64_t()){
                connectorId=static_cast<uint32_t>(json["connectorId"].as_uint64_t());
            }else if (json["connectorId"].is_int64_t()){
                connectorId=static_cast<uint32_t>(json["connectorId"].as_int64_t());
            }else{
                connectorId=static_cast<uint32_t>(json["connectorId"].as_double());
            }
            }();
VkDisplayKHR* display;
[&](){
            if (json["display"].as_vector().size()==0){
                display=NULL;
            return; }display=(VkDisplayKHR*)malloc(1*sizeof(VkDisplayKHR));auto& arr_DpFHFgI=json["display"].as_vector();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();

    PFN_vkGetDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDrmDisplayEXT)get_instance_proc_addr(parent,"vkGetDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDrmDisplayEXT)get_device_proc_addr(parent,"vkGetDrmDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, drmFd, connectorId, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=static_cast<int>(drmFd);}();
[&](){json["connectorId"]=static_cast<uint>(connectorId);}();
[&](){
            if (display==NULL){
                json["display"]=json::vector();
            return; }auto arr_DpFHFgI=json::vector(1);
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        json["display"]=arr_DpFHFgI;}();


        json["stream_type"]=static_cast<int>(VKGETDRMDISPLAYEXT);
        writeToConn(json);
    }

    void handle_vkWaitForPresentKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t presentId;
[&](){
            if (json["presentId"].is_uint64_t()){
                presentId=static_cast<uint64_t>(json["presentId"].as_uint64_t());
            }else if (json["presentId"].is_int64_t()){
                presentId=static_cast<uint64_t>(json["presentId"].as_int64_t());
            }else{
                presentId=static_cast<uint64_t>(json["presentId"].as_double());
            }
            }();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();

    PFN_vkWaitForPresentKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkWaitForPresentKHR)get_instance_proc_addr(parent,"vkWaitForPresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkWaitForPresentKHR)get_device_proc_addr(parent,"vkWaitForPresentKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, presentId, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=static_cast<uint>(presentId);}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();


        json["stream_type"]=static_cast<int>(VKWAITFORPRESENTKHR);
        writeToConn(json);
    }

    void handle_vkCmdBeginRendering(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderingInfo* pRenderingInfo;
[&](){
            if (json["pRenderingInfo"].as_vector().size()==0){
                pRenderingInfo=NULL;
            return; }pRenderingInfo=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));auto& arr_IEHUXzQ=json["pRenderingInfo"].as_vector();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            deserialize_struct(arr_IEHUXzQ[oIBIqTv].as_map(),pRenderingInfo[oIBIqTv]);
            }();
        }
        }();

    PFN_vkCmdBeginRendering call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBeginRendering)get_instance_proc_addr(parent,"vkCmdBeginRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBeginRendering)get_device_proc_addr(parent,"vkCmdBeginRendering");
    }  
    
{
call_function(commandBuffer, pRenderingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=json::vector();
            return; }auto arr_DOEgrev=json::vector(1);
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingInfo[dAqQfxy]);
            arr_DOEgrev[dAqQfxy]=temp_map;
            return;
            }();
        }
        json["pRenderingInfo"]=arr_DOEgrev;}();


        json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERING);
        writeToConn(json);
    }

    void handle_vkCmdEndRendering(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRendering call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdEndRendering)get_instance_proc_addr(parent,"vkCmdEndRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdEndRendering)get_device_proc_addr(parent,"vkCmdEndRendering");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=static_cast<int>(VKCMDENDRENDERING);
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutHostMappingInfoVALVE(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetBindingReferenceVALVE* pBindingReference;
[&](){
            if (json["pBindingReference"].as_vector().size()==0){
                pBindingReference=NULL;
            return; }pBindingReference=(VkDescriptorSetBindingReferenceVALVE*)malloc(1*sizeof(VkDescriptorSetBindingReferenceVALVE));auto& arr_swAzjIz=json["pBindingReference"].as_vector();
        for(int dYYQsmf=0; dYYQsmf < 1; dYYQsmf++){
            [&](){
            deserialize_struct(arr_swAzjIz[dYYQsmf].as_map(),pBindingReference[dYYQsmf]);
            }();
        }
        }();
VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping;
[&](){
            if (json["pHostMapping"].as_vector().size()==0){
                pHostMapping=NULL;
            return; }pHostMapping=(VkDescriptorSetLayoutHostMappingInfoVALVE*)malloc(1*sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE));auto& arr_zODJzpL=json["pHostMapping"].as_vector();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            deserialize_struct(arr_zODJzpL[jHGvhna].as_map(),pHostMapping[jHGvhna]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }  
    
{
call_function(device, pBindingReference, pHostMapping);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=json::vector();
            return; }auto arr_JTmPGZt=json::vector(1);
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindingReference[OEumPxJ]);
            arr_JTmPGZt[OEumPxJ]=temp_map;
            return;
            }();
        }
        json["pBindingReference"]=arr_JTmPGZt;}();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=json::vector();
            return; }auto arr_zODJzpL=json::vector(1);
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHostMapping[jHGvhna]);
            arr_zODJzpL[jHGvhna]=temp_map;
            return;
            }();
        }
        json["pHostMapping"]=arr_zODJzpL;}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE);
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetHostMappingVALVE(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
void** ppData;
[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));auto& arr_JgRLJSK=json["ppData"].as_vector();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_vector().size()*sizeof(char));auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].as_vector();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].as_vector().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkGetDescriptorSetHostMappingVALVE call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }  
    
{
call_function(device, descriptorSet, ppData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_JgRLJSK=json::vector(1);
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(strlen(((char*)(ppData[NsRFkBj])))+1);
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[NsRFkBj]))[jYdchEs]);}();
        }
        arr_JgRLJSK[NsRFkBj]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_JgRLJSK;}();


        json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETHOSTMAPPINGVALVE);
        writeToConn(json);
    }

    void handle_vkCreateMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMicromapCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkMicromapCreateInfoEXT*)malloc(1*sizeof(VkMicromapCreateInfoEXT));auto& arr_XnWTHFD=json["pCreateInfo"].as_vector();
        for(int SlvdLyP=0; SlvdLyP < 1; SlvdLyP++){
            [&](){
            deserialize_struct(arr_XnWTHFD[SlvdLyP].as_map(),pCreateInfo[SlvdLyP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkMicromapEXT* pMicromap;
[&](){
            if (json["pMicromap"].as_vector().size()==0){
                pMicromap=NULL;
            return; }pMicromap=(VkMicromapEXT*)malloc(1*sizeof(VkMicromapEXT));auto& arr_mHmzwPX=json["pMicromap"].as_vector();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();

    PFN_vkCreateMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateMicromapEXT)get_instance_proc_addr(parent,"vkCreateMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateMicromapEXT)get_device_proc_addr(parent,"vkCreateMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pMicromap);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_vrQtrYo=json::vector(1);
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[cfhYIUK]);
            arr_vrQtrYo[cfhYIUK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_vrQtrYo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=json::vector();
            return; }auto arr_mHmzwPX=json::vector(1);
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        json["pMicromap"]=arr_mHmzwPX;}();


        json["stream_type"]=static_cast<int>(VKCREATEMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCmdBuildMicromapsEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();
 VkMicromapBuildInfoEXT* pInfos;
[&](){
            if (json["pInfos"].as_vector().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));auto& arr_pOhxygW=json["pInfos"].as_vector();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            deserialize_struct(arr_pOhxygW[UnBcPOz].as_map(),pInfos[UnBcPOz]);
            }();
        }
        }();

    PFN_vkCmdBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_instance_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_device_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_KdoluBZ=json::vector(infoCount);
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[bfMWBOA]);
            arr_KdoluBZ[bfMWBOA]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_KdoluBZ;}();


        json["stream_type"]=static_cast<int>(VKCMDBUILDMICROMAPSEXT);
        writeToConn(json);
    }

    void handle_vkBuildMicromapsEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();
 VkMicromapBuildInfoEXT* pInfos;
[&](){
            if (json["pInfos"].as_vector().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));auto& arr_pOhxygW=json["pInfos"].as_vector();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            deserialize_struct(arr_pOhxygW[UnBcPOz].as_map(),pInfos[UnBcPOz]);
            }();
        }
        }();

    PFN_vkBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBuildMicromapsEXT)get_instance_proc_addr(parent,"vkBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBuildMicromapsEXT)get_device_proc_addr(parent,"vkBuildMicromapsEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, infoCount, pInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_KdoluBZ=json::vector(infoCount);
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[bfMWBOA]);
            arr_KdoluBZ[bfMWBOA]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_KdoluBZ;}();


        json["stream_type"]=static_cast<int>(VKBUILDMICROMAPSEXT);
        writeToConn(json);
    }

    void handle_vkDestroyMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMicromapEXT micromap;
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyMicromapEXT)get_instance_proc_addr(parent,"vkDestroyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyMicromapEXT)get_device_proc_addr(parent,"vkDestroyMicromapEXT");
    }  
    
{
call_function(device, micromap, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));auto& arr_JTPzqPn=json["pInfo"].as_vector();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            deserialize_struct(arr_JTPzqPn[rzDjQUu].as_map(),pInfo[rzDjQUu]);
            }();
        }
        }();

    PFN_vkCmdCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UIlbXxp=json::vector(1);
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vDMleIo]);
            arr_UIlbXxp[vDMleIo]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_UIlbXxp;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCopyMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));auto& arr_JTPzqPn=json["pInfo"].as_vector();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            deserialize_struct(arr_JTPzqPn[rzDjQUu].as_map(),pInfo[rzDjQUu]);
            }();
        }
        }();

    PFN_vkCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyMicromapEXT)get_instance_proc_addr(parent,"vkCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyMicromapEXT)get_device_proc_addr(parent,"vkCopyMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UIlbXxp=json::vector(1);
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vDMleIo]);
            arr_UIlbXxp[vDMleIo]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_UIlbXxp;}();


        json["stream_type"]=static_cast<int>(VKCOPYMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapToMemoryEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));auto& arr_yvWkCxr=json["pInfo"].as_vector();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            deserialize_struct(arr_yvWkCxr[LolGOkG].as_map(),pInfo[LolGOkG]);
            }();
        }
        }();

    PFN_vkCmdCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_EiLirbT=json::vector(1);
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dzsAOWF]);
            arr_EiLirbT[dzsAOWF]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_EiLirbT;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMICROMAPTOMEMORYEXT);
        writeToConn(json);
    }

    void handle_vkCopyMicromapToMemoryEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));auto& arr_yvWkCxr=json["pInfo"].as_vector();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            deserialize_struct(arr_yvWkCxr[LolGOkG].as_map(),pInfo[LolGOkG]);
            }();
        }
        }();

    PFN_vkCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_EiLirbT=json::vector(1);
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dzsAOWF]);
            arr_EiLirbT[dzsAOWF]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_EiLirbT;}();


        json["stream_type"]=static_cast<int>(VKCOPYMICROMAPTOMEMORYEXT);
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));auto& arr_JkoWJSQ=json["pInfo"].as_vector();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            deserialize_struct(arr_JkoWJSQ[HyJmoQR].as_map(),pInfo[HyJmoQR]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QufOGLT=json::vector(1);
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[semZpgt]);
            arr_QufOGLT[semZpgt]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QufOGLT;}();


        json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCopyMemoryToMicromapEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));auto& arr_JkoWJSQ=json["pInfo"].as_vector();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            deserialize_struct(arr_JkoWJSQ[HyJmoQR].as_map(),pInfo[HyJmoQR]);
            }();
        }
        }();

    PFN_vkCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QufOGLT=json::vector(1);
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[semZpgt]);
            arr_QufOGLT[semZpgt]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QufOGLT;}();


        json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOMICROMAPEXT);
        writeToConn(json);
    }

    void handle_vkCmdWriteMicromapsPropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t micromapCount;
[&](){
            if (json["micromapCount"].is_uint64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_uint64_t());
            }else if (json["micromapCount"].is_int64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_int64_t());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_double());
            }
            }();
 VkMicromapEXT* pMicromaps;
[&](){
            if (json["pMicromaps"].as_vector().size()==0){
                pMicromaps=NULL;
            return; }pMicromaps=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));auto& arr_gjzjRBu=json["pMicromaps"].as_vector();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], pMicromaps[XuxNkjt]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

    PFN_vkCmdWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }  
    
{
call_function(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=static_cast<uint>(micromapCount);}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=json::vector();
            return; }auto arr_NriAFXg=json::vector(micromapCount);
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        json["pMicromaps"]=arr_NriAFXg;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();


        json["stream_type"]=static_cast<int>(VKCMDWRITEMICROMAPSPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkWriteMicromapsPropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t micromapCount;
[&](){
            if (json["micromapCount"].is_uint64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_uint64_t());
            }else if (json["micromapCount"].is_int64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_int64_t());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_double());
            }
            }();
 VkMicromapEXT* pMicromaps;
[&](){
            if (json["pMicromaps"].as_vector().size()==0){
                pMicromaps=NULL;
            return; }pMicromaps=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));auto& arr_gjzjRBu=json["pMicromaps"].as_vector();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], pMicromaps[XuxNkjt]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<size_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<size_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<size_t>(json["stride"].as_double());
            }
            }();

    PFN_vkWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=static_cast<uint>(micromapCount);}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=json::vector();
            return; }auto arr_NriAFXg=json::vector(micromapCount);
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        json["pMicromaps"]=arr_NriAFXg;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){json["stride"]=static_cast<int>(stride);}();


        json["stream_type"]=static_cast<int>(VKWRITEMICROMAPSPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkGetDeviceMicromapCompatibilityEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMicromapVersionInfoEXT* pVersionInfo;
[&](){
            if (json["pVersionInfo"].as_vector().size()==0){
                pVersionInfo=NULL;
            return; }pVersionInfo=(VkMicromapVersionInfoEXT*)malloc(1*sizeof(VkMicromapVersionInfoEXT));auto& arr_FlJdkUQ=json["pVersionInfo"].as_vector();
        for(int GMLSjyq=0; GMLSjyq < 1; GMLSjyq++){
            [&](){
            deserialize_struct(arr_FlJdkUQ[GMLSjyq].as_map(),pVersionInfo[GMLSjyq]);
            }();
        }
        }();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].as_vector().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));auto& arr_dBMhFMX=json["pCompatibility"].as_vector();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_uint64_t());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_int64_t());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceMicromapCompatibilityEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_instance_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_device_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=json::vector();
            return; }auto arr_PYqUGEM=json::vector(1);
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVersionInfo[odfXDEI]);
            arr_PYqUGEM[odfXDEI]=temp_map;
            return;
            }();
        }
        json["pVersionInfo"]=arr_PYqUGEM;}();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=json::vector();
            return; }auto arr_dBMhFMX=json::vector(1);
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=static_cast<int>(pCompatibility[nzOFTGF]);}();}();}();
        }
        json["pCompatibility"]=arr_dBMhFMX;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEMICROMAPCOMPATIBILITYEXT);
        writeToConn(json);
    }

    void handle_vkGetMicromapBuildSizesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_uint64_t());
            }else if (json["buildType"].is_int64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_int64_t());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].as_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
 VkMicromapBuildInfoEXT* pBuildInfo;
[&](){
            if (json["pBuildInfo"].as_vector().size()==0){
                pBuildInfo=NULL;
            return; }pBuildInfo=(VkMicromapBuildInfoEXT*)malloc(1*sizeof(VkMicromapBuildInfoEXT));auto& arr_oNQjwLj=json["pBuildInfo"].as_vector();
        for(int ALWsyDT=0; ALWsyDT < 1; ALWsyDT++){
            [&](){
            deserialize_struct(arr_oNQjwLj[ALWsyDT].as_map(),pBuildInfo[ALWsyDT]);
            }();
        }
        }();
VkMicromapBuildSizesInfoEXT* pSizeInfo;
[&](){
            if (json["pSizeInfo"].as_vector().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkMicromapBuildSizesInfoEXT*)malloc(1*sizeof(VkMicromapBuildSizesInfoEXT));auto& arr_fJKSsZw=json["pSizeInfo"].as_vector();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            deserialize_struct(arr_fJKSsZw[XgjgtXU].as_map(),pSizeInfo[XgjgtXU]);
            }();
        }
        }();

    PFN_vkGetMicromapBuildSizesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_instance_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_device_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }  
    
{
call_function(device, buildType, pBuildInfo, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=static_cast<int>(buildType);}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=json::vector();
            return; }auto arr_lREHNwp=json::vector(1);
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBuildInfo[nPItxru]);
            arr_lREHNwp[nPItxru]=temp_map;
            return;
            }();
        }
        json["pBuildInfo"]=arr_lREHNwp;}();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=json::vector();
            return; }auto arr_fJKSsZw=json::vector(1);
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSizeInfo[XgjgtXU]);
            arr_fJKSsZw[XgjgtXU]=temp_map;
            return;
            }();
        }
        json["pSizeInfo"]=arr_fJKSsZw;}();


        json["stream_type"]=static_cast<int>(VKGETMICROMAPBUILDSIZESEXT);
        writeToConn(json);
    }

    void handle_vkGetShaderModuleIdentifierEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].as_vector().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));auto& arr_ICaFqGG=json["pIdentifier"].as_vector();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            deserialize_struct(arr_ICaFqGG[DSBkSwY].as_map(),pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleIdentifierEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }  
    
{
call_function(device, shaderModule, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=json::vector();
            return; }auto arr_ICaFqGG=json::vector(1);
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIdentifier[DSBkSwY]);
            arr_ICaFqGG[DSBkSwY]=temp_map;
            return;
            }();
        }
        json["pIdentifier"]=arr_ICaFqGG;}();


        json["stream_type"]=static_cast<int>(VKGETSHADERMODULEIDENTIFIEREXT);
        writeToConn(json);
    }

    void handle_vkGetShaderModuleCreateInfoIdentifierEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkShaderModuleCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));auto& arr_GtIQgds=json["pCreateInfo"].as_vector();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            deserialize_struct(arr_GtIQgds[PbmosKP].as_map(),pCreateInfo[PbmosKP]);
            }();
        }
        }();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].as_vector().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));auto& arr_ICaFqGG=json["pIdentifier"].as_vector();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            deserialize_struct(arr_ICaFqGG[DSBkSwY].as_map(),pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleCreateInfoIdentifierEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }  
    
{
call_function(device, pCreateInfo, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iSZUILM=json::vector(1);
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[dKxemXH]);
            arr_iSZUILM[dKxemXH]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iSZUILM;}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=json::vector();
            return; }auto arr_ICaFqGG=json::vector(1);
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIdentifier[DSBkSwY]);
            arr_ICaFqGG[DSBkSwY]=temp_map;
            return;
            }();
        }
        json["pIdentifier"]=arr_ICaFqGG;}();


        json["stream_type"]=static_cast<int>(VKGETSHADERMODULECREATEINFOIDENTIFIEREXT);
        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout2KHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkImageSubresource2KHR* pSubresource;
[&](){
            if (json["pSubresource"].as_vector().size()==0){
                pSubresource=NULL;
            return; }pSubresource=(VkImageSubresource2KHR*)malloc(1*sizeof(VkImageSubresource2KHR));auto& arr_oUQSxrb=json["pSubresource"].as_vector();
        for(int HhQHZaA=0; HhQHZaA < 1; HhQHZaA++){
            [&](){
            deserialize_struct(arr_oUQSxrb[HhQHZaA].as_map(),pSubresource[HhQHZaA]);
            }();
        }
        }();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));auto& arr_JxnVeqW=json["pLayout"].as_vector();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            deserialize_struct(arr_JxnVeqW[jEkaLQP].as_map(),pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_device_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=json::vector();
            return; }auto arr_xtdYssI=json::vector(1);
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubresource[HvvKvoL]);
            arr_xtdYssI[HvvKvoL]=temp_map;
            return;
            }();
        }
        json["pSubresource"]=arr_xtdYssI;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JxnVeqW=json::vector(1);
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jEkaLQP]);
            arr_JxnVeqW[jEkaLQP]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JxnVeqW;}();


        json["stream_type"]=static_cast<int>(VKGETIMAGESUBRESOURCELAYOUT2KHR);
        writeToConn(json);
    }

    void handle_vkGetPipelinePropertiesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineInfoEXT* pPipelineInfo;
[&](){
            if (json["pPipelineInfo"].as_vector().size()==0){
                pPipelineInfo=NULL;
            return; }pPipelineInfo=(VkPipelineInfoEXT*)malloc(1*sizeof(VkPipelineInfoEXT));auto& arr_PhjfoeL=json["pPipelineInfo"].as_vector();
        for(int tiAojvv=0; tiAojvv < 1; tiAojvv++){
            [&](){
            deserialize_struct(arr_PhjfoeL[tiAojvv].as_map(),pPipelineInfo[tiAojvv]);
            }();
        }
        }();
VkBaseOutStructure* pPipelineProperties;
[&](){
            if (json["pPipelineProperties"].as_vector().size()==0){
                pPipelineProperties=NULL;
            return; }pPipelineProperties=(VkBaseOutStructure*)malloc(1*sizeof(VkBaseOutStructure));auto& arr_eMgMlNc=json["pPipelineProperties"].as_vector();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            deserialize_struct(arr_eMgMlNc[cJpCXwz].as_map(),pPipelineProperties[cJpCXwz]);
            }();
        }
        }();

    PFN_vkGetPipelinePropertiesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_instance_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_device_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pPipelineInfo, pPipelineProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=json::vector();
            return; }auto arr_eGbOPJq=json::vector(1);
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineInfo[iUjmOrp]);
            arr_eGbOPJq[iUjmOrp]=temp_map;
            return;
            }();
        }
        json["pPipelineInfo"]=arr_eGbOPJq;}();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=json::vector();
            return; }auto arr_eMgMlNc=json::vector(1);
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineProperties[cJpCXwz]);
            arr_eMgMlNc[cJpCXwz]=temp_map;
            return;
            }();
        }
        json["pPipelineProperties"]=arr_eMgMlNc;}();


        json["stream_type"]=static_cast<int>(VKGETPIPELINEPROPERTIESEXT);
        writeToConn(json);
    }

    void handle_vkGetFramebufferTilePropertiesQCOM(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
uint32_t* pPropertiesCount;
[&](){
            if (json["pPropertiesCount"].as_vector().size()==0){
                pPropertiesCount=NULL;
            return; }pPropertiesCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_vUkyKfO=json["pPropertiesCount"].as_vector();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){
            if (arr_vUkyKfO[YhfeqPW].is_uint64_t()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_uint64_t());
            }else if (arr_vUkyKfO[YhfeqPW].is_int64_t()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_int64_t());
            }else{
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_double());
            }
            }();
        }
        }();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(*pPropertiesCount*sizeof(VkTilePropertiesQCOM));auto& arr_hYNBodF=json["pProperties"].as_vector();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            deserialize_struct(arr_hYNBodF[oGElcJh].as_map(),pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetFramebufferTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }  
    
VkResult  result;
{
result=call_function(device, framebuffer, pPropertiesCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=json::vector();
            return; }auto arr_vUkyKfO=json::vector(1);
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=static_cast<uint>(pPropertiesCount[YhfeqPW]);}();
        }
        json["pPropertiesCount"]=arr_vUkyKfO;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hYNBodF=json::vector(*pPropertiesCount);
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oGElcJh]);
            arr_hYNBodF[oGElcJh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hYNBodF;}();


        json["stream_type"]=static_cast<int>(VKGETFRAMEBUFFERTILEPROPERTIESQCOM);
        writeToConn(json);
    }

    void handle_vkGetDynamicRenderingTilePropertiesQCOM(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderingInfo* pRenderingInfo;
[&](){
            if (json["pRenderingInfo"].as_vector().size()==0){
                pRenderingInfo=NULL;
            return; }pRenderingInfo=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));auto& arr_IEHUXzQ=json["pRenderingInfo"].as_vector();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            deserialize_struct(arr_IEHUXzQ[oIBIqTv].as_map(),pRenderingInfo[oIBIqTv]);
            }();
        }
        }();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(1*sizeof(VkTilePropertiesQCOM));auto& arr_hYNBodF=json["pProperties"].as_vector();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            deserialize_struct(arr_hYNBodF[oGElcJh].as_map(),pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetDynamicRenderingTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }  
    
VkResult  result;
{
result=call_function(device, pRenderingInfo, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=json::vector();
            return; }auto arr_DOEgrev=json::vector(1);
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingInfo[dAqQfxy]);
            arr_DOEgrev[dAqQfxy]=temp_map;
            return;
            }();
        }
        json["pRenderingInfo"]=arr_DOEgrev;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hYNBodF=json::vector(1);
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oGElcJh]);
            arr_hYNBodF[oGElcJh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hYNBodF;}();


        json["stream_type"]=static_cast<int>(VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo;
[&](){
            if (json["pOpticalFlowImageFormatInfo"].as_vector().size()==0){
                pOpticalFlowImageFormatInfo=NULL;
            return; }pOpticalFlowImageFormatInfo=(VkOpticalFlowImageFormatInfoNV*)malloc(1*sizeof(VkOpticalFlowImageFormatInfoNV));auto& arr_bHRLrfx=json["pOpticalFlowImageFormatInfo"].as_vector();
        for(int oBdVYyf=0; oBdVYyf < 1; oBdVYyf++){
            [&](){
            deserialize_struct(arr_bHRLrfx[oBdVYyf].as_map(),pOpticalFlowImageFormatInfo[oBdVYyf]);
            }();
        }
        }();
uint32_t* pFormatCount;
[&](){
            if (json["pFormatCount"].as_vector().size()==0){
                pFormatCount=NULL;
            return; }pFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_OWVxAsX=json["pFormatCount"].as_vector();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){
            if (arr_OWVxAsX[AvMKjKj].is_uint64_t()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_uint64_t());
            }else if (arr_OWVxAsX[AvMKjKj].is_int64_t()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_int64_t());
            }else{
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_double());
            }
            }();
        }
        }();
VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkOpticalFlowImageFormatPropertiesNV*)malloc(*pFormatCount*sizeof(VkOpticalFlowImageFormatPropertiesNV));auto& arr_oZncgpa=json["pImageFormatProperties"].as_vector();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            deserialize_struct(arr_oZncgpa[gkJgIzP].as_map(),pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=json::vector();
            return; }auto arr_oyPfnWV=json::vector(1);
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pOpticalFlowImageFormatInfo[HqzITOl]);
            arr_oyPfnWV[HqzITOl]=temp_map;
            return;
            }();
        }
        json["pOpticalFlowImageFormatInfo"]=arr_oyPfnWV;}();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=json::vector();
            return; }auto arr_OWVxAsX=json::vector(1);
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=static_cast<uint>(pFormatCount[AvMKjKj]);}();
        }
        json["pFormatCount"]=arr_OWVxAsX;}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_oZncgpa=json::vector(*pFormatCount);
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[gkJgIzP]);
            arr_oZncgpa[gkJgIzP]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_oZncgpa;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV);
        writeToConn(json);
    }

    void handle_vkCreateOpticalFlowSessionNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkOpticalFlowSessionCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].as_vector().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkOpticalFlowSessionCreateInfoNV*)malloc(1*sizeof(VkOpticalFlowSessionCreateInfoNV));auto& arr_sIplIPh=json["pCreateInfo"].as_vector();
        for(int OLjhukd=0; OLjhukd < 1; OLjhukd++){
            [&](){
            deserialize_struct(arr_sIplIPh[OLjhukd].as_map(),pCreateInfo[OLjhukd]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkOpticalFlowSessionNV* pSession;
[&](){
            if (json["pSession"].as_vector().size()==0){
                pSession=NULL;
            return; }pSession=(VkOpticalFlowSessionNV*)malloc(1*sizeof(VkOpticalFlowSessionNV));auto& arr_PyNQerY=json["pSession"].as_vector();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();

    PFN_vkCreateOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_device_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dKVOiZE=json::vector(1);
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[LaeeodD]);
            arr_dKVOiZE[LaeeodD]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dKVOiZE;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSession==NULL){
                json["pSession"]=json::vector();
            return; }auto arr_PyNQerY=json::vector(1);
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        json["pSession"]=arr_PyNQerY;}();


        json["stream_type"]=static_cast<int>(VKCREATEOPTICALFLOWSESSIONNV);
        writeToConn(json);
    }

    void handle_vkDestroyOpticalFlowSessionNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_device_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }  
    
{
call_function(device, session, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYOPTICALFLOWSESSIONNV);
        writeToConn(json);
    }

    void handle_vkBindOpticalFlowSessionImageNV(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
VkOpticalFlowSessionBindingPointNV bindingPoint;
[&](){[&](){int temp_dqYOkbF;[&](){
            if (json["bindingPoint"].is_uint64_t()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_uint64_t());
            }else if (json["bindingPoint"].is_int64_t()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_int64_t());
            }else{
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_double());
            }
            }();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
VkImageView view;
[&](){deserialize_VkImageView(json["view"], view);}();
VkImageLayout layout;
[&](){[&](){int temp_IaQZtFR;[&](){
            if (json["layout"].is_uint64_t()){
                temp_IaQZtFR=static_cast<int>(json["layout"].as_uint64_t());
            }else if (json["layout"].is_int64_t()){
                temp_IaQZtFR=static_cast<int>(json["layout"].as_int64_t());
            }else{
                temp_IaQZtFR=static_cast<int>(json["layout"].as_double());
            }
            }();layout=(VkImageLayout)temp_IaQZtFR;}();}();

    PFN_vkBindOpticalFlowSessionImageNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_instance_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_device_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }  
    
VkResult  result;
{
result=call_function(device, session, bindingPoint, view, layout);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=static_cast<int>(bindingPoint);}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=static_cast<int>(layout);}();}();}();


        json["stream_type"]=static_cast<int>(VKBINDOPTICALFLOWSESSIONIMAGENV);
        writeToConn(json);
    }

    void handle_vkCmdOpticalFlowExecuteNV(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
 VkOpticalFlowExecuteInfoNV* pExecuteInfo;
[&](){
            if (json["pExecuteInfo"].as_vector().size()==0){
                pExecuteInfo=NULL;
            return; }pExecuteInfo=(VkOpticalFlowExecuteInfoNV*)malloc(1*sizeof(VkOpticalFlowExecuteInfoNV));auto& arr_tbUOmHi=json["pExecuteInfo"].as_vector();
        for(int HcarBbt=0; HcarBbt < 1; HcarBbt++){
            [&](){
            deserialize_struct(arr_tbUOmHi[HcarBbt].as_map(),pExecuteInfo[HcarBbt]);
            }();
        }
        }();

    PFN_vkCmdOpticalFlowExecuteNV call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_instance_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_device_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }  
    
{
call_function(commandBuffer, session, pExecuteInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=json::vector();
            return; }auto arr_CyySpro=json::vector(1);
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecuteInfo[XLHKKBA]);
            arr_CyySpro[XLHKKBA]=temp_map;
            return;
            }();
        }
        json["pExecuteInfo"]=arr_CyySpro;}();


        json["stream_type"]=static_cast<int>(VKCMDOPTICALFLOWEXECUTENV);
        writeToConn(json);
    }

    void handle_vkGetDeviceFaultInfoEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceFaultCountsEXT* pFaultCounts;
[&](){
            if (json["pFaultCounts"].as_vector().size()==0){
                pFaultCounts=NULL;
            return; }pFaultCounts=(VkDeviceFaultCountsEXT*)malloc(1*sizeof(VkDeviceFaultCountsEXT));auto& arr_LWLqmdd=json["pFaultCounts"].as_vector();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            deserialize_struct(arr_LWLqmdd[RexMRxZ].as_map(),pFaultCounts[RexMRxZ]);
            }();
        }
        }();
VkDeviceFaultInfoEXT* pFaultInfo;
[&](){
            if (json["pFaultInfo"].as_vector().size()==0){
                pFaultInfo=NULL;
            return; }pFaultInfo=(VkDeviceFaultInfoEXT*)malloc(1*sizeof(VkDeviceFaultInfoEXT));auto& arr_CRNBZxs=json["pFaultInfo"].as_vector();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            deserialize_struct(arr_CRNBZxs[AHHHhvb].as_map(),pFaultInfo[AHHHhvb]);
            }();
        }
        }();

    PFN_vkGetDeviceFaultInfoEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_instance_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_device_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pFaultCounts, pFaultInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=json::vector();
            return; }auto arr_LWLqmdd=json::vector(1);
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFaultCounts[RexMRxZ]);
            arr_LWLqmdd[RexMRxZ]=temp_map;
            return;
            }();
        }
        json["pFaultCounts"]=arr_LWLqmdd;}();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=json::vector();
            return; }auto arr_CRNBZxs=json::vector(1);
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFaultInfo[AHHHhvb]);
            arr_CRNBZxs[AHHHhvb]=temp_map;
            return;
            }();
        }
        json["pFaultInfo"]=arr_CRNBZxs;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEFAULTINFOEXT);
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias2EXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDepthBiasInfoEXT* pDepthBiasInfo;
[&](){
            if (json["pDepthBiasInfo"].as_vector().size()==0){
                pDepthBiasInfo=NULL;
            return; }pDepthBiasInfo=(VkDepthBiasInfoEXT*)malloc(1*sizeof(VkDepthBiasInfoEXT));auto& arr_DfdCGqY=json["pDepthBiasInfo"].as_vector();
        for(int xSRWdSz=0; xSRWdSz < 1; xSRWdSz++){
            [&](){
            deserialize_struct(arr_DfdCGqY[xSRWdSz].as_map(),pDepthBiasInfo[xSRWdSz]);
            }();
        }
        }();

    PFN_vkCmdSetDepthBias2EXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_instance_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_device_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }  
    
{
call_function(commandBuffer, pDepthBiasInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=json::vector();
            return; }auto arr_AKZgFGf=json::vector(1);
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDepthBiasInfo[kGsXYsB]);
            arr_AKZgFGf[kGsXYsB]=temp_map;
            return;
            }();
        }
        json["pDepthBiasInfo"]=arr_AKZgFGf;}();


        json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIAS2EXT);
        writeToConn(json);
    }

    void handle_vkReleaseSwapchainImagesEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkReleaseSwapchainImagesInfoEXT* pReleaseInfo;
[&](){
            if (json["pReleaseInfo"].as_vector().size()==0){
                pReleaseInfo=NULL;
            return; }pReleaseInfo=(VkReleaseSwapchainImagesInfoEXT*)malloc(1*sizeof(VkReleaseSwapchainImagesInfoEXT));auto& arr_jqKJdwU=json["pReleaseInfo"].as_vector();
        for(int fqZXHcz=0; fqZXHcz < 1; fqZXHcz++){
            [&](){
            deserialize_struct(arr_jqKJdwU[fqZXHcz].as_map(),pReleaseInfo[fqZXHcz]);
            }();
        }
        }();

    PFN_vkReleaseSwapchainImagesEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_instance_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_device_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pReleaseInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=json::vector();
            return; }auto arr_jcnZDBn=json::vector(1);
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pReleaseInfo[dRtPqPF]);
            arr_jcnZDBn[dRtPqPF]=temp_map;
            return;
            }();
        }
        json["pReleaseInfo"]=arr_jcnZDBn;}();


        json["stream_type"]=static_cast<int>(VKRELEASESWAPCHAINIMAGESEXT);
        writeToConn(json);
    }

    void handle_vkGetDeviceImageSubresourceLayoutKHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageSubresourceInfoKHR* pInfo;
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageSubresourceInfoKHR*)malloc(1*sizeof(VkDeviceImageSubresourceInfoKHR));auto& arr_TDGjppd=json["pInfo"].as_vector();
        for(int irOmazS=0; irOmazS < 1; irOmazS++){
            [&](){
            deserialize_struct(arr_TDGjppd[irOmazS].as_map(),pInfo[irOmazS]);
            }();
        }
        }();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));auto& arr_JxnVeqW=json["pLayout"].as_vector();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            deserialize_struct(arr_JxnVeqW[jEkaLQP].as_map(),pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSubresourceLayoutKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_instance_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_device_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }  
    
{
call_function(device, pInfo, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_SwRDgPP=json::vector(1);
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[wxoktPv]);
            arr_SwRDgPP[wxoktPv]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_SwRDgPP;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JxnVeqW=json::vector(1);
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jEkaLQP]);
            arr_JxnVeqW[jEkaLQP]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JxnVeqW;}();


        json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR);
        writeToConn(json);
    }

    void handle_vkMapMemory2KHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryMapInfoKHR* pMemoryMapInfo;
[&](){
            if (json["pMemoryMapInfo"].as_vector().size()==0){
                pMemoryMapInfo=NULL;
            return; }pMemoryMapInfo=(VkMemoryMapInfoKHR*)malloc(1*sizeof(VkMemoryMapInfoKHR));auto& arr_RTzyDuY=json["pMemoryMapInfo"].as_vector();
        for(int cnbdFzc=0; cnbdFzc < 1; cnbdFzc++){
            [&](){
            deserialize_struct(arr_RTzyDuY[cnbdFzc].as_map(),pMemoryMapInfo[cnbdFzc]);
            }();
        }
        }();
void** ppData;
[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));auto& arr_JgRLJSK=json["ppData"].as_vector();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_vector().size()*sizeof(char));auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].as_vector();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].as_vector().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkMapMemory2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkMapMemory2KHR)get_instance_proc_addr(parent,"vkMapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkMapMemory2KHR)get_device_proc_addr(parent,"vkMapMemory2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryMapInfo, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=json::vector();
            return; }auto arr_udcndbe=json::vector(1);
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryMapInfo[iwSaLAe]);
            arr_udcndbe[iwSaLAe]=temp_map;
            return;
            }();
        }
        json["pMemoryMapInfo"]=arr_udcndbe;}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_JgRLJSK=json::vector(1);
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(strlen(((char*)(ppData[NsRFkBj])))+1);
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[NsRFkBj]))[jYdchEs]);}();
        }
        arr_JgRLJSK[NsRFkBj]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_JgRLJSK;}();

        json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=server_memory_json.as_uint64_t(); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        json["stream_type"]=static_cast<int>(VKMAPMEMORY2KHR);
        writeToConn(json);
    }

    void handle_vkUnmapMemory2KHR(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryUnmapInfoKHR* pMemoryUnmapInfo;
[&](){
            if (json["pMemoryUnmapInfo"].as_vector().size()==0){
                pMemoryUnmapInfo=NULL;
            return; }pMemoryUnmapInfo=(VkMemoryUnmapInfoKHR*)malloc(1*sizeof(VkMemoryUnmapInfoKHR));auto& arr_bpXegaD=json["pMemoryUnmapInfo"].as_vector();
        for(int cntXsPf=0; cntXsPf < 1; cntXsPf++){
            [&](){
            deserialize_struct(arr_bpXegaD[cntXsPf].as_map(),pMemoryUnmapInfo[cntXsPf]);
            }();
        }
        }();

    PFN_vkUnmapMemory2KHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkUnmapMemory2KHR)get_instance_proc_addr(parent,"vkUnmapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkUnmapMemory2KHR)get_device_proc_addr(parent,"vkUnmapMemory2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryUnmapInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=json::vector();
            return; }auto arr_hZlnXPf=json::vector(1);
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryUnmapInfo[caczdhq]);
            arr_hZlnXPf[caczdhq]=temp_map;
            return;
            }();
        }
        json["pMemoryUnmapInfo"]=arr_hZlnXPf;}();


        json["stream_type"]=static_cast<int>(VKUNMAPMEMORY2KHR);
        writeToConn(json);
    }

    void handle_vkCreateShadersEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();
 VkShaderCreateInfoEXT* pCreateInfos;
[&](){
            if (json["pCreateInfos"].as_vector().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkShaderCreateInfoEXT*)malloc(createInfoCount*sizeof(VkShaderCreateInfoEXT));auto& arr_aNFxtFM=json["pCreateInfos"].as_vector();
        for(int IEFkbzS=0; IEFkbzS < createInfoCount; IEFkbzS++){
            [&](){
            deserialize_struct(arr_aNFxtFM[IEFkbzS].as_map(),pCreateInfos[IEFkbzS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();
VkShaderEXT* pShaders;
[&](){
            if (json["pShaders"].as_vector().size()==0){
                pShaders=NULL;
            return; }pShaders=(VkShaderEXT*)malloc(createInfoCount*sizeof(VkShaderEXT));auto& arr_ndnxxFm=json["pShaders"].as_vector();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();

    PFN_vkCreateShadersEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCreateShadersEXT)get_instance_proc_addr(parent,"vkCreateShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCreateShadersEXT)get_device_proc_addr(parent,"vkCreateShadersEXT");
    }  
    
VkResult  result;
{
result=call_function(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_mOfZnnW=json::vector(createInfoCount);
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[bOiKywR]);
            arr_mOfZnnW[bOiKywR]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_mOfZnnW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=json::vector();
            return; }auto arr_ndnxxFm=json::vector(createInfoCount);
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        json["pShaders"]=arr_ndnxxFm;}();


        json["stream_type"]=static_cast<int>(VKCREATESHADERSEXT);
        writeToConn(json);
    }

    void handle_vkDestroyShaderEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].as_vector().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));auto& arr_Zyucmmb=json["pAllocator"].as_vector();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            deserialize_struct(arr_Zyucmmb[YRPmyai].as_map(),pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyShaderEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkDestroyShaderEXT)get_instance_proc_addr(parent,"vkDestroyShaderEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkDestroyShaderEXT)get_device_proc_addr(parent,"vkDestroyShaderEXT");
    }  
    
{
call_function(device, shader, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();


        json["stream_type"]=static_cast<int>(VKDESTROYSHADEREXT);
        writeToConn(json);
    }

    void handle_vkGetShaderBinaryDataEXT(json::map& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetShaderBinaryDataEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_instance_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_device_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, shader, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();


        json["stream_type"]=static_cast<int>(VKGETSHADERBINARYDATAEXT);
        writeToConn(json);
    }

    void handle_vkCmdBindShadersEXT(json::map& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t stageCount;
[&](){
            if (json["stageCount"].is_uint64_t()){
                stageCount=static_cast<uint32_t>(json["stageCount"].as_uint64_t());
            }else if (json["stageCount"].is_int64_t()){
                stageCount=static_cast<uint32_t>(json["stageCount"].as_int64_t());
            }else{
                stageCount=static_cast<uint32_t>(json["stageCount"].as_double());
            }
            }();
 VkShaderStageFlagBits* pStages;
[&](){
            if (json["pStages"].as_vector().size()==0){
                pStages=NULL;
            return; }pStages=(VkShaderStageFlagBits*)malloc(stageCount*sizeof(VkShaderStageFlagBits));auto& arr_qbDLWnb=json["pStages"].as_vector();
        for(int FzJYCiP=0; FzJYCiP < stageCount; FzJYCiP++){
            [&](){[&](){int temp_IwfnGxi;[&](){
            if (arr_qbDLWnb[FzJYCiP].is_uint64_t()){
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].as_uint64_t());
            }else if (arr_qbDLWnb[FzJYCiP].is_int64_t()){
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].as_int64_t());
            }else{
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].as_double());
            }
            }();pStages[FzJYCiP]=(VkShaderStageFlagBits)temp_IwfnGxi;}();}();
        }
        }();
 VkShaderEXT* pShaders;
[&](){
            if (json["pShaders"].as_vector().size()==0){
                pShaders=NULL;
            return; }pShaders=(VkShaderEXT*)malloc(stageCount*sizeof(VkShaderEXT));auto& arr_lXkCGqI=json["pShaders"].as_vector();
        for(int DXMUrFp=0; DXMUrFp < stageCount; DXMUrFp++){
            [&](){deserialize_VkShaderEXT(arr_lXkCGqI[DXMUrFp], pShaders[DXMUrFp]);}();
        }
        }();

    PFN_vkCmdBindShadersEXT call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkCmdBindShadersEXT)get_instance_proc_addr(parent,"vkCmdBindShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkCmdBindShadersEXT)get_device_proc_addr(parent,"vkCmdBindShadersEXT");
    }  
    
{
call_function(commandBuffer, stageCount, pStages, pShaders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=static_cast<uint>(stageCount);}();
[&](){
            if (pStages==NULL){
                json["pStages"]=json::vector();
            return; }auto arr_phXrzxO=json::vector(stageCount);
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=static_cast<int>(pStages[uFucfxh]);}();}();}();
        }
        json["pStages"]=arr_phXrzxO;}();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=json::vector();
            return; }auto arr_ZjERyql=json::vector(stageCount);
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        json["pShaders"]=arr_ZjERyql;}();


        json["stream_type"]=static_cast<int>(VKCMDBINDSHADERSEXT);
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(json::map& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
VkCooperativeMatrixPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesKHR));auto& arr_PEzgESc=json["pProperties"].as_vector();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            deserialize_struct(arr_PEzgESc[iTGjLCh].as_map(),pProperties[iTGjLCh]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR call_function;
    
    auto parent_json=json["parent"].as_map();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json.at("instance"),parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json.at("device"),parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=static_cast<int>(result);}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_PEzgESc=json::vector(*pPropertyCount);
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[iTGjLCh]);
            arr_PEzgESc[iTGjLCh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_PEzgESc;}();


        json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR);
        writeToConn(json);
    }

void handle_command(json::map json){
//Will only be called by the server

switch (static_cast<StreamType>(json["stream_type"].as_uint64_t())){


        case (VKCREATEINSTANCE):
            handle_vkCreateInstance(json);
            return;
    

        case (VKDESTROYINSTANCE):
            handle_vkDestroyInstance(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICES):
            handle_vkEnumeratePhysicalDevices(json);
            return;
    

        case (VKGETDEVICEPROCADDR):
            handle_vkGetDeviceProcAddr(json);
            return;
    

        case (VKGETINSTANCEPROCADDR):
            handle_vkGetInstanceProcAddr(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES):
            handle_vkGetPhysicalDeviceProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
            handle_vkGetPhysicalDeviceQueueFamilyProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
            handle_vkGetPhysicalDeviceMemoryProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES):
            handle_vkGetPhysicalDeviceFeatures(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceFormatProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceImageFormatProperties(json);
            return;
    

        case (VKCREATEDEVICE):
            handle_vkCreateDevice(json);
            return;
    

        case (VKDESTROYDEVICE):
            handle_vkDestroyDevice(json);
            return;
    

        case (VKENUMERATEINSTANCEVERSION):
            handle_vkEnumerateInstanceVersion(json);
            return;
    

        case (VKENUMERATEINSTANCELAYERPROPERTIES):
            handle_vkEnumerateInstanceLayerProperties(json);
            return;
    

        case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
            handle_vkEnumerateInstanceExtensionProperties(json);
            return;
    

        case (VKENUMERATEDEVICELAYERPROPERTIES):
            handle_vkEnumerateDeviceLayerProperties(json);
            return;
    

        case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
            handle_vkEnumerateDeviceExtensionProperties(json);
            return;
    

        case (VKGETDEVICEQUEUE):
            handle_vkGetDeviceQueue(json);
            return;
    

        case (VKQUEUESUBMIT):
            handle_vkQueueSubmit(json);
            return;
    

        case (VKQUEUEWAITIDLE):
            handle_vkQueueWaitIdle(json);
            return;
    

        case (VKDEVICEWAITIDLE):
            handle_vkDeviceWaitIdle(json);
            return;
    

        case (VKALLOCATEMEMORY):
            handle_vkAllocateMemory(json);
            return;
    

        case (VKFREEMEMORY):
            handle_vkFreeMemory(json);
            return;
    

        case (VKMAPMEMORY):
            handle_vkMapMemory(json);
            return;
    

        case (VKUNMAPMEMORY):
            handle_vkUnmapMemory(json);
            return;
    

        case (VKFLUSHMAPPEDMEMORYRANGES):
            handle_vkFlushMappedMemoryRanges(json);
            return;
    

        case (VKINVALIDATEMAPPEDMEMORYRANGES):
            handle_vkInvalidateMappedMemoryRanges(json);
            return;
    

        case (VKGETDEVICEMEMORYCOMMITMENT):
            handle_vkGetDeviceMemoryCommitment(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS):
            handle_vkGetBufferMemoryRequirements(json);
            return;
    

        case (VKBINDBUFFERMEMORY):
            handle_vkBindBufferMemory(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS):
            handle_vkGetImageMemoryRequirements(json);
            return;
    

        case (VKBINDIMAGEMEMORY):
            handle_vkBindImageMemory(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
            handle_vkGetImageSparseMemoryRequirements(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceSparseImageFormatProperties(json);
            return;
    

        case (VKQUEUEBINDSPARSE):
            handle_vkQueueBindSparse(json);
            return;
    

        case (VKCREATEFENCE):
            handle_vkCreateFence(json);
            return;
    

        case (VKDESTROYFENCE):
            handle_vkDestroyFence(json);
            return;
    

        case (VKRESETFENCES):
            handle_vkResetFences(json);
            return;
    

        case (VKGETFENCESTATUS):
            handle_vkGetFenceStatus(json);
            return;
    

        case (VKWAITFORFENCES):
            handle_vkWaitForFences(json);
            return;
    

        case (VKCREATESEMAPHORE):
            handle_vkCreateSemaphore(json);
            return;
    

        case (VKDESTROYSEMAPHORE):
            handle_vkDestroySemaphore(json);
            return;
    

        case (VKCREATEEVENT):
            handle_vkCreateEvent(json);
            return;
    

        case (VKDESTROYEVENT):
            handle_vkDestroyEvent(json);
            return;
    

        case (VKGETEVENTSTATUS):
            handle_vkGetEventStatus(json);
            return;
    

        case (VKSETEVENT):
            handle_vkSetEvent(json);
            return;
    

        case (VKRESETEVENT):
            handle_vkResetEvent(json);
            return;
    

        case (VKCREATEQUERYPOOL):
            handle_vkCreateQueryPool(json);
            return;
    

        case (VKDESTROYQUERYPOOL):
            handle_vkDestroyQueryPool(json);
            return;
    

        case (VKGETQUERYPOOLRESULTS):
            handle_vkGetQueryPoolResults(json);
            return;
    

        case (VKRESETQUERYPOOL):
            handle_vkResetQueryPool(json);
            return;
    

        case (VKCREATEBUFFER):
            handle_vkCreateBuffer(json);
            return;
    

        case (VKDESTROYBUFFER):
            handle_vkDestroyBuffer(json);
            return;
    

        case (VKCREATEBUFFERVIEW):
            handle_vkCreateBufferView(json);
            return;
    

        case (VKDESTROYBUFFERVIEW):
            handle_vkDestroyBufferView(json);
            return;
    

        case (VKCREATEIMAGE):
            handle_vkCreateImage(json);
            return;
    

        case (VKDESTROYIMAGE):
            handle_vkDestroyImage(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT):
            handle_vkGetImageSubresourceLayout(json);
            return;
    

        case (VKCREATEIMAGEVIEW):
            handle_vkCreateImageView(json);
            return;
    

        case (VKDESTROYIMAGEVIEW):
            handle_vkDestroyImageView(json);
            return;
    

        case (VKCREATESHADERMODULE):
            handle_vkCreateShaderModule(json);
            return;
    

        case (VKDESTROYSHADERMODULE):
            handle_vkDestroyShaderModule(json);
            return;
    

        case (VKCREATEPIPELINECACHE):
            handle_vkCreatePipelineCache(json);
            return;
    

        case (VKDESTROYPIPELINECACHE):
            handle_vkDestroyPipelineCache(json);
            return;
    

        case (VKGETPIPELINECACHEDATA):
            handle_vkGetPipelineCacheData(json);
            return;
    

        case (VKMERGEPIPELINECACHES):
            handle_vkMergePipelineCaches(json);
            return;
    

        case (VKCREATEGRAPHICSPIPELINES):
            handle_vkCreateGraphicsPipelines(json);
            return;
    

        case (VKCREATECOMPUTEPIPELINES):
            handle_vkCreateComputePipelines(json);
            return;
    

        case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
            handle_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(json);
            return;
    

        case (VKDESTROYPIPELINE):
            handle_vkDestroyPipeline(json);
            return;
    

        case (VKCREATEPIPELINELAYOUT):
            handle_vkCreatePipelineLayout(json);
            return;
    

        case (VKDESTROYPIPELINELAYOUT):
            handle_vkDestroyPipelineLayout(json);
            return;
    

        case (VKCREATESAMPLER):
            handle_vkCreateSampler(json);
            return;
    

        case (VKDESTROYSAMPLER):
            handle_vkDestroySampler(json);
            return;
    

        case (VKCREATEDESCRIPTORSETLAYOUT):
            handle_vkCreateDescriptorSetLayout(json);
            return;
    

        case (VKDESTROYDESCRIPTORSETLAYOUT):
            handle_vkDestroyDescriptorSetLayout(json);
            return;
    

        case (VKCREATEDESCRIPTORPOOL):
            handle_vkCreateDescriptorPool(json);
            return;
    

        case (VKDESTROYDESCRIPTORPOOL):
            handle_vkDestroyDescriptorPool(json);
            return;
    

        case (VKRESETDESCRIPTORPOOL):
            handle_vkResetDescriptorPool(json);
            return;
    

        case (VKALLOCATEDESCRIPTORSETS):
            handle_vkAllocateDescriptorSets(json);
            return;
    

        case (VKFREEDESCRIPTORSETS):
            handle_vkFreeDescriptorSets(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETS):
            handle_vkUpdateDescriptorSets(json);
            return;
    

        case (VKCREATEFRAMEBUFFER):
            handle_vkCreateFramebuffer(json);
            return;
    

        case (VKDESTROYFRAMEBUFFER):
            handle_vkDestroyFramebuffer(json);
            return;
    

        case (VKCREATERENDERPASS):
            handle_vkCreateRenderPass(json);
            return;
    

        case (VKDESTROYRENDERPASS):
            handle_vkDestroyRenderPass(json);
            return;
    

        case (VKGETRENDERAREAGRANULARITY):
            handle_vkGetRenderAreaGranularity(json);
            return;
    

        case (VKGETRENDERINGAREAGRANULARITYKHR):
            handle_vkGetRenderingAreaGranularityKHR(json);
            return;
    

        case (VKCREATECOMMANDPOOL):
            handle_vkCreateCommandPool(json);
            return;
    

        case (VKDESTROYCOMMANDPOOL):
            handle_vkDestroyCommandPool(json);
            return;
    

        case (VKRESETCOMMANDPOOL):
            handle_vkResetCommandPool(json);
            return;
    

        case (VKALLOCATECOMMANDBUFFERS):
            handle_vkAllocateCommandBuffers(json);
            return;
    

        case (VKFREECOMMANDBUFFERS):
            handle_vkFreeCommandBuffers(json);
            return;
    

        case (VKBEGINCOMMANDBUFFER):
            handle_vkBeginCommandBuffer(json);
            return;
    

        case (VKENDCOMMANDBUFFER):
            handle_vkEndCommandBuffer(json);
            return;
    

        case (VKRESETCOMMANDBUFFER):
            handle_vkResetCommandBuffer(json);
            return;
    

        case (VKCMDBINDPIPELINE):
            handle_vkCmdBindPipeline(json);
            return;
    

        case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
            handle_vkCmdSetAttachmentFeedbackLoopEnableEXT(json);
            return;
    

        case (VKCMDSETVIEWPORT):
            handle_vkCmdSetViewport(json);
            return;
    

        case (VKCMDSETSCISSOR):
            handle_vkCmdSetScissor(json);
            return;
    

        case (VKCMDSETLINEWIDTH):
            handle_vkCmdSetLineWidth(json);
            return;
    

        case (VKCMDSETDEPTHBIAS):
            handle_vkCmdSetDepthBias(json);
            return;
    

        case (VKCMDSETBLENDCONSTANTS):
            handle_vkCmdSetBlendConstants(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDS):
            handle_vkCmdSetDepthBounds(json);
            return;
    

        case (VKCMDSETSTENCILCOMPAREMASK):
            handle_vkCmdSetStencilCompareMask(json);
            return;
    

        case (VKCMDSETSTENCILWRITEMASK):
            handle_vkCmdSetStencilWriteMask(json);
            return;
    

        case (VKCMDSETSTENCILREFERENCE):
            handle_vkCmdSetStencilReference(json);
            return;
    

        case (VKCMDBINDDESCRIPTORSETS):
            handle_vkCmdBindDescriptorSets(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER):
            handle_vkCmdBindIndexBuffer(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS):
            handle_vkCmdBindVertexBuffers(json);
            return;
    

        case (VKCMDDRAW):
            handle_vkCmdDraw(json);
            return;
    

        case (VKCMDDRAWINDEXED):
            handle_vkCmdDrawIndexed(json);
            return;
    

        case (VKCMDDRAWMULTIEXT):
            handle_vkCmdDrawMultiEXT(json);
            return;
    

        case (VKCMDDRAWMULTIINDEXEDEXT):
            handle_vkCmdDrawMultiIndexedEXT(json);
            return;
    

        case (VKCMDDRAWINDIRECT):
            handle_vkCmdDrawIndirect(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECT):
            handle_vkCmdDrawIndexedIndirect(json);
            return;
    

        case (VKCMDDISPATCH):
            handle_vkCmdDispatch(json);
            return;
    

        case (VKCMDDISPATCHINDIRECT):
            handle_vkCmdDispatchIndirect(json);
            return;
    

        case (VKCMDSUBPASSSHADINGHUAWEI):
            handle_vkCmdSubpassShadingHUAWEI(json);
            return;
    

        case (VKCMDDRAWCLUSTERHUAWEI):
            handle_vkCmdDrawClusterHUAWEI(json);
            return;
    

        case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
            handle_vkCmdDrawClusterIndirectHUAWEI(json);
            return;
    

        case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
            handle_vkCmdUpdatePipelineIndirectBufferNV(json);
            return;
    

        case (VKCMDCOPYBUFFER):
            handle_vkCmdCopyBuffer(json);
            return;
    

        case (VKCMDCOPYIMAGE):
            handle_vkCmdCopyImage(json);
            return;
    

        case (VKCMDBLITIMAGE):
            handle_vkCmdBlitImage(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE):
            handle_vkCmdCopyBufferToImage(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER):
            handle_vkCmdCopyImageToBuffer(json);
            return;
    

        case (VKCMDCOPYMEMORYINDIRECTNV):
            handle_vkCmdCopyMemoryIndirectNV(json);
            return;
    

        case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
            handle_vkCmdCopyMemoryToImageIndirectNV(json);
            return;
    

        case (VKCMDUPDATEBUFFER):
            handle_vkCmdUpdateBuffer(json);
            return;
    

        case (VKCMDFILLBUFFER):
            handle_vkCmdFillBuffer(json);
            return;
    

        case (VKCMDCLEARCOLORIMAGE):
            handle_vkCmdClearColorImage(json);
            return;
    

        case (VKCMDCLEARDEPTHSTENCILIMAGE):
            handle_vkCmdClearDepthStencilImage(json);
            return;
    

        case (VKCMDCLEARATTACHMENTS):
            handle_vkCmdClearAttachments(json);
            return;
    

        case (VKCMDRESOLVEIMAGE):
            handle_vkCmdResolveImage(json);
            return;
    

        case (VKCMDSETEVENT):
            handle_vkCmdSetEvent(json);
            return;
    

        case (VKCMDRESETEVENT):
            handle_vkCmdResetEvent(json);
            return;
    

        case (VKCMDWAITEVENTS):
            handle_vkCmdWaitEvents(json);
            return;
    

        case (VKCMDPIPELINEBARRIER):
            handle_vkCmdPipelineBarrier(json);
            return;
    

        case (VKCMDBEGINQUERY):
            handle_vkCmdBeginQuery(json);
            return;
    

        case (VKCMDENDQUERY):
            handle_vkCmdEndQuery(json);
            return;
    

        case (VKCMDBEGINCONDITIONALRENDERINGEXT):
            handle_vkCmdBeginConditionalRenderingEXT(json);
            return;
    

        case (VKCMDENDCONDITIONALRENDERINGEXT):
            handle_vkCmdEndConditionalRenderingEXT(json);
            return;
    

        case (VKCMDRESETQUERYPOOL):
            handle_vkCmdResetQueryPool(json);
            return;
    

        case (VKCMDWRITETIMESTAMP):
            handle_vkCmdWriteTimestamp(json);
            return;
    

        case (VKCMDCOPYQUERYPOOLRESULTS):
            handle_vkCmdCopyQueryPoolResults(json);
            return;
    

        case (VKCMDPUSHCONSTANTS):
            handle_vkCmdPushConstants(json);
            return;
    

        case (VKCMDBEGINRENDERPASS):
            handle_vkCmdBeginRenderPass(json);
            return;
    

        case (VKCMDNEXTSUBPASS):
            handle_vkCmdNextSubpass(json);
            return;
    

        case (VKCMDENDRENDERPASS):
            handle_vkCmdEndRenderPass(json);
            return;
    

        case (VKCMDEXECUTECOMMANDS):
            handle_vkCmdExecuteCommands(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
            handle_vkGetPhysicalDeviceDisplayPropertiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
            handle_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(json);
            return;
    

        case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
            handle_vkGetDisplayPlaneSupportedDisplaysKHR(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIESKHR):
            handle_vkGetDisplayModePropertiesKHR(json);
            return;
    

        case (VKCREATEDISPLAYMODEKHR):
            handle_vkCreateDisplayModeKHR(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIESKHR):
            handle_vkGetDisplayPlaneCapabilitiesKHR(json);
            return;
    

        case (VKCREATEDISPLAYPLANESURFACEKHR):
            handle_vkCreateDisplayPlaneSurfaceKHR(json);
            return;
    

        case (VKCREATESHAREDSWAPCHAINSKHR):
            handle_vkCreateSharedSwapchainsKHR(json);
            return;
    

        case (VKDESTROYSURFACEKHR):
            handle_vkDestroySurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
            handle_vkGetPhysicalDeviceSurfaceSupportKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
            handle_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
            handle_vkGetPhysicalDeviceSurfaceFormatsKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
            handle_vkGetPhysicalDeviceSurfacePresentModesKHR(json);
            return;
    

        case (VKCREATESWAPCHAINKHR):
            handle_vkCreateSwapchainKHR(json);
            return;
    

        case (VKDESTROYSWAPCHAINKHR):
            handle_vkDestroySwapchainKHR(json);
            return;
    

        case (VKGETSWAPCHAINIMAGESKHR):
            handle_vkGetSwapchainImagesKHR(json);
            return;
    

        case (VKACQUIRENEXTIMAGEKHR):
            handle_vkAcquireNextImageKHR(json);
            return;
    

        case (VKQUEUEPRESENTKHR):
            handle_vkQueuePresentKHR(json);
            return;
    

        case (VKCREATEXLIBSURFACEKHR):
            handle_vkCreateXlibSurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
            handle_vkGetPhysicalDeviceXlibPresentationSupportKHR(json);
            return;
    

        case (VKCREATEXCBSURFACEKHR):
            handle_vkCreateXcbSurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
            handle_vkGetPhysicalDeviceXcbPresentationSupportKHR(json);
            return;
    

        case (VKCREATEDEBUGREPORTCALLBACKEXT):
            handle_vkCreateDebugReportCallbackEXT(json);
            return;
    

        case (VKDESTROYDEBUGREPORTCALLBACKEXT):
            handle_vkDestroyDebugReportCallbackEXT(json);
            return;
    

        case (VKDEBUGREPORTMESSAGEEXT):
            handle_vkDebugReportMessageEXT(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTNAMEEXT):
            handle_vkDebugMarkerSetObjectNameEXT(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTTAGEXT):
            handle_vkDebugMarkerSetObjectTagEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERBEGINEXT):
            handle_vkCmdDebugMarkerBeginEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERENDEXT):
            handle_vkCmdDebugMarkerEndEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERINSERTEXT):
            handle_vkCmdDebugMarkerInsertEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
            handle_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(json);
            return;
    

        case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
            handle_vkCmdExecuteGeneratedCommandsNV(json);
            return;
    

        case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
            handle_vkCmdPreprocessGeneratedCommandsNV(json);
            return;
    

        case (VKCMDBINDPIPELINESHADERGROUPNV):
            handle_vkCmdBindPipelineShaderGroupNV(json);
            return;
    

        case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
            handle_vkGetGeneratedCommandsMemoryRequirementsNV(json);
            return;
    

        case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
            handle_vkCreateIndirectCommandsLayoutNV(json);
            return;
    

        case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
            handle_vkDestroyIndirectCommandsLayoutNV(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES2):
            handle_vkGetPhysicalDeviceFeatures2(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES2):
            handle_vkGetPhysicalDeviceProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceFormatProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceImageFormatProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
            handle_vkGetPhysicalDeviceQueueFamilyProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
            handle_vkGetPhysicalDeviceMemoryProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceSparseImageFormatProperties2(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETKHR):
            handle_vkCmdPushDescriptorSetKHR(json);
            return;
    

        case (VKTRIMCOMMANDPOOL):
            handle_vkTrimCommandPool(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
            handle_vkGetPhysicalDeviceExternalBufferProperties(json);
            return;
    

        case (VKGETMEMORYFDKHR):
            handle_vkGetMemoryFdKHR(json);
            return;
    

        case (VKGETMEMORYFDPROPERTIESKHR):
            handle_vkGetMemoryFdPropertiesKHR(json);
            return;
    

        case (VKGETMEMORYREMOTEADDRESSNV):
            handle_vkGetMemoryRemoteAddressNV(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
            handle_vkGetPhysicalDeviceExternalSemaphoreProperties(json);
            return;
    

        case (VKGETSEMAPHOREFDKHR):
            handle_vkGetSemaphoreFdKHR(json);
            return;
    

        case (VKIMPORTSEMAPHOREFDKHR):
            handle_vkImportSemaphoreFdKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
            handle_vkGetPhysicalDeviceExternalFenceProperties(json);
            return;
    

        case (VKGETFENCEFDKHR):
            handle_vkGetFenceFdKHR(json);
            return;
    

        case (VKIMPORTFENCEFDKHR):
            handle_vkImportFenceFdKHR(json);
            return;
    

        case (VKRELEASEDISPLAYEXT):
            handle_vkReleaseDisplayEXT(json);
            return;
    

        case (VKDISPLAYPOWERCONTROLEXT):
            handle_vkDisplayPowerControlEXT(json);
            return;
    

        case (VKREGISTERDEVICEEVENTEXT):
            handle_vkRegisterDeviceEventEXT(json);
            return;
    

        case (VKREGISTERDISPLAYEVENTEXT):
            handle_vkRegisterDisplayEventEXT(json);
            return;
    

        case (VKGETSWAPCHAINCOUNTEREXT):
            handle_vkGetSwapchainCounterEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
            handle_vkGetPhysicalDeviceSurfaceCapabilities2EXT(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEGROUPS):
            handle_vkEnumeratePhysicalDeviceGroups(json);
            return;
    

        case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
            handle_vkGetDeviceGroupPeerMemoryFeatures(json);
            return;
    

        case (VKBINDBUFFERMEMORY2):
            handle_vkBindBufferMemory2(json);
            return;
    

        case (VKBINDIMAGEMEMORY2):
            handle_vkBindImageMemory2(json);
            return;
    

        case (VKCMDSETDEVICEMASK):
            handle_vkCmdSetDeviceMask(json);
            return;
    

        case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
            handle_vkGetDeviceGroupPresentCapabilitiesKHR(json);
            return;
    

        case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
            handle_vkGetDeviceGroupSurfacePresentModesKHR(json);
            return;
    

        case (VKACQUIRENEXTIMAGE2KHR):
            handle_vkAcquireNextImage2KHR(json);
            return;
    

        case (VKCMDDISPATCHBASE):
            handle_vkCmdDispatchBase(json);
            return;
    

        case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
            handle_vkGetPhysicalDevicePresentRectanglesKHR(json);
            return;
    

        case (VKCREATEDESCRIPTORUPDATETEMPLATE):
            handle_vkCreateDescriptorUpdateTemplate(json);
            return;
    

        case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
            handle_vkDestroyDescriptorUpdateTemplate(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
            handle_vkUpdateDescriptorSetWithTemplate(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
            handle_vkCmdPushDescriptorSetWithTemplateKHR(json);
            return;
    

        case (VKSETHDRMETADATAEXT):
            handle_vkSetHdrMetadataEXT(json);
            return;
    

        case (VKGETSWAPCHAINSTATUSKHR):
            handle_vkGetSwapchainStatusKHR(json);
            return;
    

        case (VKGETREFRESHCYCLEDURATIONGOOGLE):
            handle_vkGetRefreshCycleDurationGOOGLE(json);
            return;
    

        case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
            handle_vkGetPastPresentationTimingGOOGLE(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGNV):
            handle_vkCmdSetViewportWScalingNV(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEEXT):
            handle_vkCmdSetDiscardRectangleEXT(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
            handle_vkCmdSetDiscardRectangleEnableEXT(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEMODEEXT):
            handle_vkCmdSetDiscardRectangleModeEXT(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSEXT):
            handle_vkCmdSetSampleLocationsEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
            handle_vkGetPhysicalDeviceMultisamplePropertiesEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
            handle_vkGetPhysicalDeviceSurfaceCapabilities2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
            handle_vkGetPhysicalDeviceSurfaceFormats2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
            handle_vkGetPhysicalDeviceDisplayProperties2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
            handle_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIES2KHR):
            handle_vkGetDisplayModeProperties2KHR(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIES2KHR):
            handle_vkGetDisplayPlaneCapabilities2KHR(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS2):
            handle_vkGetBufferMemoryRequirements2(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS2):
            handle_vkGetImageMemoryRequirements2(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
            handle_vkGetImageSparseMemoryRequirements2(json);
            return;
    

        case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
            handle_vkGetDeviceBufferMemoryRequirements(json);
            return;
    

        case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
            handle_vkGetDeviceImageMemoryRequirements(json);
            return;
    

        case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
            handle_vkGetDeviceImageSparseMemoryRequirements(json);
            return;
    

        case (VKCREATESAMPLERYCBCRCONVERSION):
            handle_vkCreateSamplerYcbcrConversion(json);
            return;
    

        case (VKDESTROYSAMPLERYCBCRCONVERSION):
            handle_vkDestroySamplerYcbcrConversion(json);
            return;
    

        case (VKGETDEVICEQUEUE2):
            handle_vkGetDeviceQueue2(json);
            return;
    

        case (VKCREATEVALIDATIONCACHEEXT):
            handle_vkCreateValidationCacheEXT(json);
            return;
    

        case (VKDESTROYVALIDATIONCACHEEXT):
            handle_vkDestroyValidationCacheEXT(json);
            return;
    

        case (VKGETVALIDATIONCACHEDATAEXT):
            handle_vkGetValidationCacheDataEXT(json);
            return;
    

        case (VKMERGEVALIDATIONCACHESEXT):
            handle_vkMergeValidationCachesEXT(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
            handle_vkGetDescriptorSetLayoutSupport(json);
            return;
    

        case (VKGETSHADERINFOAMD):
            handle_vkGetShaderInfoAMD(json);
            return;
    

        case (VKSETLOCALDIMMINGAMD):
            handle_vkSetLocalDimmingAMD(json);
            return;
    

        case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
            handle_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(json);
            return;
    

        case (VKGETCALIBRATEDTIMESTAMPSEXT):
            handle_vkGetCalibratedTimestampsEXT(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTNAMEEXT):
            handle_vkSetDebugUtilsObjectNameEXT(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTTAGEXT):
            handle_vkSetDebugUtilsObjectTagEXT(json);
            return;
    

        case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
            handle_vkQueueBeginDebugUtilsLabelEXT(json);
            return;
    

        case (VKQUEUEENDDEBUGUTILSLABELEXT):
            handle_vkQueueEndDebugUtilsLabelEXT(json);
            return;
    

        case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
            handle_vkQueueInsertDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDBEGINDEBUGUTILSLABELEXT):
            handle_vkCmdBeginDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDENDDEBUGUTILSLABELEXT):
            handle_vkCmdEndDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDINSERTDEBUGUTILSLABELEXT):
            handle_vkCmdInsertDebugUtilsLabelEXT(json);
            return;
    

        case (VKCREATEDEBUGUTILSMESSENGEREXT):
            handle_vkCreateDebugUtilsMessengerEXT(json);
            return;
    

        case (VKDESTROYDEBUGUTILSMESSENGEREXT):
            handle_vkDestroyDebugUtilsMessengerEXT(json);
            return;
    

        case (VKSUBMITDEBUGUTILSMESSAGEEXT):
            handle_vkSubmitDebugUtilsMessageEXT(json);
            return;
    

        case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
            handle_vkGetMemoryHostPointerPropertiesEXT(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKERAMD):
            handle_vkCmdWriteBufferMarkerAMD(json);
            return;
    

        case (VKCREATERENDERPASS2):
            handle_vkCreateRenderPass2(json);
            return;
    

        case (VKCMDBEGINRENDERPASS2):
            handle_vkCmdBeginRenderPass2(json);
            return;
    

        case (VKCMDNEXTSUBPASS2):
            handle_vkCmdNextSubpass2(json);
            return;
    

        case (VKCMDENDRENDERPASS2):
            handle_vkCmdEndRenderPass2(json);
            return;
    

        case (VKGETSEMAPHORECOUNTERVALUE):
            handle_vkGetSemaphoreCounterValue(json);
            return;
    

        case (VKWAITSEMAPHORES):
            handle_vkWaitSemaphores(json);
            return;
    

        case (VKSIGNALSEMAPHORE):
            handle_vkSignalSemaphore(json);
            return;
    

        case (VKCMDDRAWINDIRECTCOUNT):
            handle_vkCmdDrawIndirectCount(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
            handle_vkCmdDrawIndexedIndirectCount(json);
            return;
    

        case (VKCMDSETCHECKPOINTNV):
            handle_vkCmdSetCheckpointNV(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATANV):
            handle_vkGetQueueCheckpointDataNV(json);
            return;
    

        case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
            handle_vkCmdBindTransformFeedbackBuffersEXT(json);
            return;
    

        case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
            handle_vkCmdBeginTransformFeedbackEXT(json);
            return;
    

        case (VKCMDENDTRANSFORMFEEDBACKEXT):
            handle_vkCmdEndTransformFeedbackEXT(json);
            return;
    

        case (VKCMDBEGINQUERYINDEXEDEXT):
            handle_vkCmdBeginQueryIndexedEXT(json);
            return;
    

        case (VKCMDENDQUERYINDEXEDEXT):
            handle_vkCmdEndQueryIndexedEXT(json);
            return;
    

        case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
            handle_vkCmdDrawIndirectByteCountEXT(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORNV):
            handle_vkCmdSetExclusiveScissorNV(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORENABLENV):
            handle_vkCmdSetExclusiveScissorEnableNV(json);
            return;
    

        case (VKCMDBINDSHADINGRATEIMAGENV):
            handle_vkCmdBindShadingRateImageNV(json);
            return;
    

        case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
            handle_vkCmdSetViewportShadingRatePaletteNV(json);
            return;
    

        case (VKCMDSETCOARSESAMPLEORDERNV):
            handle_vkCmdSetCoarseSampleOrderNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSNV):
            handle_vkCmdDrawMeshTasksNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTNV):
            handle_vkCmdDrawMeshTasksIndirectNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
            handle_vkCmdDrawMeshTasksIndirectCountNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSEXT):
            handle_vkCmdDrawMeshTasksEXT(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTEXT):
            handle_vkCmdDrawMeshTasksIndirectEXT(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
            handle_vkCmdDrawMeshTasksIndirectCountEXT(json);
            return;
    

        case (VKCOMPILEDEFERREDNV):
            handle_vkCompileDeferredNV(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTURENV):
            handle_vkCreateAccelerationStructureNV(json);
            return;
    

        case (VKCMDBINDINVOCATIONMASKHUAWEI):
            handle_vkCmdBindInvocationMaskHUAWEI(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTUREKHR):
            handle_vkDestroyAccelerationStructureKHR(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTURENV):
            handle_vkDestroyAccelerationStructureNV(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
            handle_vkGetAccelerationStructureMemoryRequirementsNV(json);
            return;
    

        case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
            handle_vkBindAccelerationStructureMemoryNV(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURENV):
            handle_vkCmdCopyAccelerationStructureNV(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
            handle_vkCmdCopyAccelerationStructureKHR(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTUREKHR):
            handle_vkCopyAccelerationStructureKHR(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_vkCmdCopyAccelerationStructureToMemoryKHR(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_vkCopyAccelerationStructureToMemoryKHR(json);
            return;
    

        case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_vkCmdCopyMemoryToAccelerationStructureKHR(json);
            return;
    

        case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_vkCopyMemoryToAccelerationStructureKHR(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_vkCmdWriteAccelerationStructuresPropertiesKHR(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
            handle_vkCmdWriteAccelerationStructuresPropertiesNV(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURENV):
            handle_vkCmdBuildAccelerationStructureNV(json);
            return;
    

        case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_vkWriteAccelerationStructuresPropertiesKHR(json);
            return;
    

        case (VKCMDTRACERAYSKHR):
            handle_vkCmdTraceRaysKHR(json);
            return;
    

        case (VKCMDTRACERAYSNV):
            handle_vkCmdTraceRaysNV(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
            handle_vkGetRayTracingShaderGroupHandlesKHR(json);
            return;
    

        case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
            handle_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREHANDLENV):
            handle_vkGetAccelerationStructureHandleNV(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESNV):
            handle_vkCreateRayTracingPipelinesNV(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESKHR):
            handle_vkCreateRayTracingPipelinesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
            handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECTKHR):
            handle_vkCmdTraceRaysIndirectKHR(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECT2KHR):
            handle_vkCmdTraceRaysIndirect2KHR(json);
            return;
    

        case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
            handle_vkGetDeviceAccelerationStructureCompatibilityKHR(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
            handle_vkGetRayTracingShaderGroupStackSizeKHR(json);
            return;
    

        case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
            handle_vkCmdSetRayTracingPipelineStackSizeKHR(json);
            return;
    

        case (VKGETIMAGEVIEWHANDLENVX):
            handle_vkGetImageViewHandleNVX(json);
            return;
    

        case (VKGETIMAGEVIEWADDRESSNVX):
            handle_vkGetImageViewAddressNVX(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
            handle_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
            handle_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(json);
            return;
    

        case (VKACQUIREPROFILINGLOCKKHR):
            handle_vkAcquireProfilingLockKHR(json);
            return;
    

        case (VKRELEASEPROFILINGLOCKKHR):
            handle_vkReleaseProfilingLockKHR(json);
            return;
    

        case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
            handle_vkGetImageDrmFormatModifierPropertiesEXT(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREADDRESS):
            handle_vkGetBufferOpaqueCaptureAddress(json);
            return;
    

        case (VKGETBUFFERDEVICEADDRESS):
            handle_vkGetBufferDeviceAddress(json);
            return;
    

        case (VKCREATEHEADLESSSURFACEEXT):
            handle_vkCreateHeadlessSurfaceEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
            handle_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(json);
            return;
    

        case (VKINITIALIZEPERFORMANCEAPIINTEL):
            handle_vkInitializePerformanceApiINTEL(json);
            return;
    

        case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
            handle_vkUninitializePerformanceApiINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCEMARKERINTEL):
            handle_vkCmdSetPerformanceMarkerINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
            handle_vkCmdSetPerformanceStreamMarkerINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
            handle_vkCmdSetPerformanceOverrideINTEL(json);
            return;
    

        case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
            handle_vkAcquirePerformanceConfigurationINTEL(json);
            return;
    

        case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
            handle_vkReleasePerformanceConfigurationINTEL(json);
            return;
    

        case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
            handle_vkQueueSetPerformanceConfigurationINTEL(json);
            return;
    

        case (VKGETPERFORMANCEPARAMETERINTEL):
            handle_vkGetPerformanceParameterINTEL(json);
            return;
    

        case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
            handle_vkGetDeviceMemoryOpaqueCaptureAddress(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
            handle_vkGetPipelineExecutablePropertiesKHR(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
            handle_vkGetPipelineExecutableStatisticsKHR(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
            handle_vkGetPipelineExecutableInternalRepresentationsKHR(json);
            return;
    

        case (VKCMDSETLINESTIPPLEEXT):
            handle_vkCmdSetLineStippleEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICETOOLPROPERTIES):
            handle_vkGetPhysicalDeviceToolProperties(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTUREKHR):
            handle_vkCreateAccelerationStructureKHR(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
            handle_vkCmdBuildAccelerationStructuresKHR(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
            handle_vkCmdBuildAccelerationStructuresIndirectKHR(json);
            return;
    

        case (VKBUILDACCELERATIONSTRUCTURESKHR):
            handle_vkBuildAccelerationStructuresKHR(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
            handle_vkGetAccelerationStructureDeviceAddressKHR(json);
            return;
    

        case (VKCREATEDEFERREDOPERATIONKHR):
            handle_vkCreateDeferredOperationKHR(json);
            return;
    

        case (VKDESTROYDEFERREDOPERATIONKHR):
            handle_vkDestroyDeferredOperationKHR(json);
            return;
    

        case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
            handle_vkGetDeferredOperationMaxConcurrencyKHR(json);
            return;
    

        case (VKGETDEFERREDOPERATIONRESULTKHR):
            handle_vkGetDeferredOperationResultKHR(json);
            return;
    

        case (VKDEFERREDOPERATIONJOINKHR):
            handle_vkDeferredOperationJoinKHR(json);
            return;
    

        case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
            handle_vkGetPipelineIndirectMemoryRequirementsNV(json);
            return;
    

        case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
            handle_vkGetPipelineIndirectDeviceAddressNV(json);
            return;
    

        case (VKCMDSETCULLMODE):
            handle_vkCmdSetCullMode(json);
            return;
    

        case (VKCMDSETFRONTFACE):
            handle_vkCmdSetFrontFace(json);
            return;
    

        case (VKCMDSETPRIMITIVETOPOLOGY):
            handle_vkCmdSetPrimitiveTopology(json);
            return;
    

        case (VKCMDSETVIEWPORTWITHCOUNT):
            handle_vkCmdSetViewportWithCount(json);
            return;
    

        case (VKCMDSETSCISSORWITHCOUNT):
            handle_vkCmdSetScissorWithCount(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER2KHR):
            handle_vkCmdBindIndexBuffer2KHR(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS2):
            handle_vkCmdBindVertexBuffers2(json);
            return;
    

        case (VKCMDSETDEPTHTESTENABLE):
            handle_vkCmdSetDepthTestEnable(json);
            return;
    

        case (VKCMDSETDEPTHWRITEENABLE):
            handle_vkCmdSetDepthWriteEnable(json);
            return;
    

        case (VKCMDSETDEPTHCOMPAREOP):
            handle_vkCmdSetDepthCompareOp(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDSTESTENABLE):
            handle_vkCmdSetDepthBoundsTestEnable(json);
            return;
    

        case (VKCMDSETSTENCILTESTENABLE):
            handle_vkCmdSetStencilTestEnable(json);
            return;
    

        case (VKCMDSETSTENCILOP):
            handle_vkCmdSetStencilOp(json);
            return;
    

        case (VKCMDSETPATCHCONTROLPOINTSEXT):
            handle_vkCmdSetPatchControlPointsEXT(json);
            return;
    

        case (VKCMDSETRASTERIZERDISCARDENABLE):
            handle_vkCmdSetRasterizerDiscardEnable(json);
            return;
    

        case (VKCMDSETDEPTHBIASENABLE):
            handle_vkCmdSetDepthBiasEnable(json);
            return;
    

        case (VKCMDSETLOGICOPEXT):
            handle_vkCmdSetLogicOpEXT(json);
            return;
    

        case (VKCMDSETPRIMITIVERESTARTENABLE):
            handle_vkCmdSetPrimitiveRestartEnable(json);
            return;
    

        case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
            handle_vkCmdSetTessellationDomainOriginEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLAMPENABLEEXT):
            handle_vkCmdSetDepthClampEnableEXT(json);
            return;
    

        case (VKCMDSETPOLYGONMODEEXT):
            handle_vkCmdSetPolygonModeEXT(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSAMPLESEXT):
            handle_vkCmdSetRasterizationSamplesEXT(json);
            return;
    

        case (VKCMDSETSAMPLEMASKEXT):
            handle_vkCmdSetSampleMaskEXT(json);
            return;
    

        case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
            handle_vkCmdSetAlphaToCoverageEnableEXT(json);
            return;
    

        case (VKCMDSETALPHATOONEENABLEEXT):
            handle_vkCmdSetAlphaToOneEnableEXT(json);
            return;
    

        case (VKCMDSETLOGICOPENABLEEXT):
            handle_vkCmdSetLogicOpEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDENABLEEXT):
            handle_vkCmdSetColorBlendEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDEQUATIONEXT):
            handle_vkCmdSetColorBlendEquationEXT(json);
            return;
    

        case (VKCMDSETCOLORWRITEMASKEXT):
            handle_vkCmdSetColorWriteMaskEXT(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSTREAMEXT):
            handle_vkCmdSetRasterizationStreamEXT(json);
            return;
    

        case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
            handle_vkCmdSetConservativeRasterizationModeEXT(json);
            return;
    

        case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
            handle_vkCmdSetExtraPrimitiveOverestimationSizeEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLIPENABLEEXT):
            handle_vkCmdSetDepthClipEnableEXT(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
            handle_vkCmdSetSampleLocationsEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDADVANCEDEXT):
            handle_vkCmdSetColorBlendAdvancedEXT(json);
            return;
    

        case (VKCMDSETPROVOKINGVERTEXMODEEXT):
            handle_vkCmdSetProvokingVertexModeEXT(json);
            return;
    

        case (VKCMDSETLINERASTERIZATIONMODEEXT):
            handle_vkCmdSetLineRasterizationModeEXT(json);
            return;
    

        case (VKCMDSETLINESTIPPLEENABLEEXT):
            handle_vkCmdSetLineStippleEnableEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
            handle_vkCmdSetDepthClipNegativeOneToOneEXT(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGENABLENV):
            handle_vkCmdSetViewportWScalingEnableNV(json);
            return;
    

        case (VKCMDSETVIEWPORTSWIZZLENV):
            handle_vkCmdSetViewportSwizzleNV(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORENABLENV):
            handle_vkCmdSetCoverageToColorEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
            handle_vkCmdSetCoverageToColorLocationNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONMODENV):
            handle_vkCmdSetCoverageModulationModeNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
            handle_vkCmdSetCoverageModulationTableEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLENV):
            handle_vkCmdSetCoverageModulationTableNV(json);
            return;
    

        case (VKCMDSETSHADINGRATEIMAGEENABLENV):
            handle_vkCmdSetShadingRateImageEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGEREDUCTIONMODENV):
            handle_vkCmdSetCoverageReductionModeNV(json);
            return;
    

        case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
            handle_vkCmdSetRepresentativeFragmentTestEnableNV(json);
            return;
    

        case (VKCREATEPRIVATEDATASLOT):
            handle_vkCreatePrivateDataSlot(json);
            return;
    

        case (VKDESTROYPRIVATEDATASLOT):
            handle_vkDestroyPrivateDataSlot(json);
            return;
    

        case (VKSETPRIVATEDATA):
            handle_vkSetPrivateData(json);
            return;
    

        case (VKGETPRIVATEDATA):
            handle_vkGetPrivateData(json);
            return;
    

        case (VKCMDCOPYBUFFER2):
            handle_vkCmdCopyBuffer2(json);
            return;
    

        case (VKCMDCOPYIMAGE2):
            handle_vkCmdCopyImage2(json);
            return;
    

        case (VKCMDBLITIMAGE2):
            handle_vkCmdBlitImage2(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE2):
            handle_vkCmdCopyBufferToImage2(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER2):
            handle_vkCmdCopyImageToBuffer2(json);
            return;
    

        case (VKCMDRESOLVEIMAGE2):
            handle_vkCmdResolveImage2(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEKHR):
            handle_vkCmdSetFragmentShadingRateKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
            handle_vkGetPhysicalDeviceFragmentShadingRatesKHR(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
            handle_vkCmdSetFragmentShadingRateEnumNV(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
            handle_vkGetAccelerationStructureBuildSizesKHR(json);
            return;
    

        case (VKCMDSETVERTEXINPUTEXT):
            handle_vkCmdSetVertexInputEXT(json);
            return;
    

        case (VKCMDSETCOLORWRITEENABLEEXT):
            handle_vkCmdSetColorWriteEnableEXT(json);
            return;
    

        case (VKCMDSETEVENT2):
            handle_vkCmdSetEvent2(json);
            return;
    

        case (VKCMDRESETEVENT2):
            handle_vkCmdResetEvent2(json);
            return;
    

        case (VKCMDWAITEVENTS2):
            handle_vkCmdWaitEvents2(json);
            return;
    

        case (VKCMDPIPELINEBARRIER2):
            handle_vkCmdPipelineBarrier2(json);
            return;
    

        case (VKQUEUESUBMIT2):
            handle_vkQueueSubmit2(json);
            return;
    

        case (VKCMDWRITETIMESTAMP2):
            handle_vkCmdWriteTimestamp2(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKER2AMD):
            handle_vkCmdWriteBufferMarker2AMD(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATA2NV):
            handle_vkGetQueueCheckpointData2NV(json);
            return;
    

        case (VKCOPYMEMORYTOIMAGEEXT):
            handle_vkCopyMemoryToImageEXT(json);
            return;
    

        case (VKCOPYIMAGETOMEMORYEXT):
            handle_vkCopyImageToMemoryEXT(json);
            return;
    

        case (VKCOPYIMAGETOIMAGEEXT):
            handle_vkCopyImageToImageEXT(json);
            return;
    

        case (VKTRANSITIONIMAGELAYOUTEXT):
            handle_vkTransitionImageLayoutEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
            handle_vkGetPhysicalDeviceVideoCapabilitiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
            handle_vkGetPhysicalDeviceVideoFormatPropertiesKHR(json);
            return;
    

        case (VKCREATEVIDEOSESSIONKHR):
            handle_vkCreateVideoSessionKHR(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONKHR):
            handle_vkDestroyVideoSessionKHR(json);
            return;
    

        case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
            handle_vkCreateVideoSessionParametersKHR(json);
            return;
    

        case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
            handle_vkUpdateVideoSessionParametersKHR(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
            handle_vkDestroyVideoSessionParametersKHR(json);
            return;
    

        case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
            handle_vkGetVideoSessionMemoryRequirementsKHR(json);
            return;
    

        case (VKBINDVIDEOSESSIONMEMORYKHR):
            handle_vkBindVideoSessionMemoryKHR(json);
            return;
    

        case (VKCMDDECODEVIDEOKHR):
            handle_vkCmdDecodeVideoKHR(json);
            return;
    

        case (VKCMDBEGINVIDEOCODINGKHR):
            handle_vkCmdBeginVideoCodingKHR(json);
            return;
    

        case (VKCMDCONTROLVIDEOCODINGKHR):
            handle_vkCmdControlVideoCodingKHR(json);
            return;
    

        case (VKCMDENDVIDEOCODINGKHR):
            handle_vkCmdEndVideoCodingKHR(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYNV):
            handle_vkCmdDecompressMemoryNV(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
            handle_vkCmdDecompressMemoryIndirectCountNV(json);
            return;
    

        case (VKCREATECUMODULENVX):
            handle_vkCreateCuModuleNVX(json);
            return;
    

        case (VKCREATECUFUNCTIONNVX):
            handle_vkCreateCuFunctionNVX(json);
            return;
    

        case (VKDESTROYCUMODULENVX):
            handle_vkDestroyCuModuleNVX(json);
            return;
    

        case (VKDESTROYCUFUNCTIONNVX):
            handle_vkDestroyCuFunctionNVX(json);
            return;
    

        case (VKCMDCULAUNCHKERNELNVX):
            handle_vkCmdCuLaunchKernelNVX(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
            handle_vkGetDescriptorSetLayoutSizeEXT(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
            handle_vkGetDescriptorSetLayoutBindingOffsetEXT(json);
            return;
    

        case (VKGETDESCRIPTOREXT):
            handle_vkGetDescriptorEXT(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFERSEXT):
            handle_vkCmdBindDescriptorBuffersEXT(json);
            return;
    

        case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
            handle_vkCmdSetDescriptorBufferOffsetsEXT(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
            handle_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetBufferOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetImageOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetImageViewOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetSamplerOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKSETDEVICEMEMORYPRIORITYEXT):
            handle_vkSetDeviceMemoryPriorityEXT(json);
            return;
    

        case (VKACQUIREDRMDISPLAYEXT):
            handle_vkAcquireDrmDisplayEXT(json);
            return;
    

        case (VKGETDRMDISPLAYEXT):
            handle_vkGetDrmDisplayEXT(json);
            return;
    

        case (VKWAITFORPRESENTKHR):
            handle_vkWaitForPresentKHR(json);
            return;
    

        case (VKCMDBEGINRENDERING):
            handle_vkCmdBeginRendering(json);
            return;
    

        case (VKCMDENDRENDERING):
            handle_vkCmdEndRendering(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
            handle_vkGetDescriptorSetLayoutHostMappingInfoVALVE(json);
            return;
    

        case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
            handle_vkGetDescriptorSetHostMappingVALVE(json);
            return;
    

        case (VKCREATEMICROMAPEXT):
            handle_vkCreateMicromapEXT(json);
            return;
    

        case (VKCMDBUILDMICROMAPSEXT):
            handle_vkCmdBuildMicromapsEXT(json);
            return;
    

        case (VKBUILDMICROMAPSEXT):
            handle_vkBuildMicromapsEXT(json);
            return;
    

        case (VKDESTROYMICROMAPEXT):
            handle_vkDestroyMicromapEXT(json);
            return;
    

        case (VKCMDCOPYMICROMAPEXT):
            handle_vkCmdCopyMicromapEXT(json);
            return;
    

        case (VKCOPYMICROMAPEXT):
            handle_vkCopyMicromapEXT(json);
            return;
    

        case (VKCMDCOPYMICROMAPTOMEMORYEXT):
            handle_vkCmdCopyMicromapToMemoryEXT(json);
            return;
    

        case (VKCOPYMICROMAPTOMEMORYEXT):
            handle_vkCopyMicromapToMemoryEXT(json);
            return;
    

        case (VKCMDCOPYMEMORYTOMICROMAPEXT):
            handle_vkCmdCopyMemoryToMicromapEXT(json);
            return;
    

        case (VKCOPYMEMORYTOMICROMAPEXT):
            handle_vkCopyMemoryToMicromapEXT(json);
            return;
    

        case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
            handle_vkCmdWriteMicromapsPropertiesEXT(json);
            return;
    

        case (VKWRITEMICROMAPSPROPERTIESEXT):
            handle_vkWriteMicromapsPropertiesEXT(json);
            return;
    

        case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
            handle_vkGetDeviceMicromapCompatibilityEXT(json);
            return;
    

        case (VKGETMICROMAPBUILDSIZESEXT):
            handle_vkGetMicromapBuildSizesEXT(json);
            return;
    

        case (VKGETSHADERMODULEIDENTIFIEREXT):
            handle_vkGetShaderModuleIdentifierEXT(json);
            return;
    

        case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
            handle_vkGetShaderModuleCreateInfoIdentifierEXT(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
            handle_vkGetImageSubresourceLayout2KHR(json);
            return;
    

        case (VKGETPIPELINEPROPERTIESEXT):
            handle_vkGetPipelinePropertiesEXT(json);
            return;
    

        case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
            handle_vkGetFramebufferTilePropertiesQCOM(json);
            return;
    

        case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
            handle_vkGetDynamicRenderingTilePropertiesQCOM(json);
            return;
    

        case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
            handle_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(json);
            return;
    

        case (VKCREATEOPTICALFLOWSESSIONNV):
            handle_vkCreateOpticalFlowSessionNV(json);
            return;
    

        case (VKDESTROYOPTICALFLOWSESSIONNV):
            handle_vkDestroyOpticalFlowSessionNV(json);
            return;
    

        case (VKBINDOPTICALFLOWSESSIONIMAGENV):
            handle_vkBindOpticalFlowSessionImageNV(json);
            return;
    

        case (VKCMDOPTICALFLOWEXECUTENV):
            handle_vkCmdOpticalFlowExecuteNV(json);
            return;
    

        case (VKGETDEVICEFAULTINFOEXT):
            handle_vkGetDeviceFaultInfoEXT(json);
            return;
    

        case (VKCMDSETDEPTHBIAS2EXT):
            handle_vkCmdSetDepthBias2EXT(json);
            return;
    

        case (VKRELEASESWAPCHAINIMAGESEXT):
            handle_vkReleaseSwapchainImagesEXT(json);
            return;
    

        case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
            handle_vkGetDeviceImageSubresourceLayoutKHR(json);
            return;
    

        case (VKMAPMEMORY2KHR):
            handle_vkMapMemory2KHR(json);
            return;
    

        case (VKUNMAPMEMORY2KHR):
            handle_vkUnmapMemory2KHR(json);
            return;
    

        case (VKCREATESHADERSEXT):
            handle_vkCreateShadersEXT(json);
            return;
    

        case (VKDESTROYSHADEREXT):
            handle_vkDestroyShaderEXT(json);
            return;
    

        case (VKGETSHADERBINARYDATAEXT):
            handle_vkGetShaderBinaryDataEXT(json);
            return;
    

        case (VKCMDBINDSHADERSEXT):
            handle_vkCmdBindShadersEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
            handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(json);
            return;
    
}}
#else

typedef struct {
VkInstance instance;
VkDevice device;
} parent_handle_struct;

std::map<uintptr_t,parent_handle_struct> handle_to_parent_handle_struct;


extern "C" {

VKAPI_ATTR VkResult VKAPI_CALL vk_icdNegotiateLoaderICDInterfaceVersion (uint32_t* pSupportedVersion){
    *pSupportedVersion=3;
    return VK_SUCCESS;
}

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vk_icdGetInstanceProcAddr(VkInstance instance, const char* pName){
        return vkGetInstanceProcAddr(instance,pName);
    }

__attribute__((visibility ("hidden"))) VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance ){
//Will only be called by the client
debug_printf("Executing vkCreateInstance\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEINSTANCE);
    
    auto parent_json=json::map();
    
parent_json["instance"]=(uintptr_t)NULL;
json["parent"]=parent_json;
{
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_yCteunD=json::vector(1);
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[pSiEPar]);
            arr_yCteunD[pSiEPar]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_yCteunD;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=json::vector();
            return; }auto arr_GanofFb=json::vector(1);
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        json["pInstance"]=arr_GanofFb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}


[&](){
            if (json["pInstance"].as_vector().size()==0){
                pInstance=NULL;
            return; }auto& arr_GanofFb=json["pInstance"].as_vector();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_enXIhAI;[&](){
            if (json["result"].is_uint64_t()){
                temp_enXIhAI=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_enXIhAI=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_enXIhAI=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_enXIhAI;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pInstance)]={.instance=(*pInstance),.device=NULL};

debug_printf("Ending vkCreateInstance...\n");
debug_printf("Return value of vkCreateInstance is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyInstance( VkInstance instance, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyInstance\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYINSTANCE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


debug_printf("Ending vkDestroyInstance...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDevices( VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDevices\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=json::vector();
            return; }auto arr_ngpFKeB=json::vector(1);
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=static_cast<uint>(pPhysicalDeviceCount[TRqNryD]);}();
        }
        json["pPhysicalDeviceCount"]=arr_ngpFKeB;}();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=json::vector();
            return; }auto arr_ZSQNUNc=json::vector(*pPhysicalDeviceCount);
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        json["pPhysicalDevices"]=arr_ZSQNUNc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceCount"].as_vector().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].as_vector();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){
            if (arr_ngpFKeB[TRqNryD].is_uint64_t()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_uint64_t());
            }else if (arr_ngpFKeB[TRqNryD].is_int64_t()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_int64_t());
            }else{
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPhysicalDevices"].as_vector().size()==0){
                pPhysicalDevices=NULL;
            return; }auto& arr_ZSQNUNc=json["pPhysicalDevices"].as_vector();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lSnbIbV;[&](){
            if (json["result"].is_uint64_t()){
                temp_lSnbIbV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_lSnbIbV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_lSnbIbV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_lSnbIbV;}();}();

                if (pPhysicalDevices!=NULL){
                    for (int i=0; i<*pPhysicalDeviceCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPhysicalDevices[i])]=parent;
                    }
                }
                

debug_printf("Ending vkEnumeratePhysicalDevices...\n");
debug_printf("Return value of vkEnumeratePhysicalDevices is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetDeviceProcAddr( VkDevice device, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceProcAddr\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEPROCADDR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=json::vector();
            return; }auto arr_XCtfitt=json::vector(strlen(pName)+1);
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=static_cast<uint>(pName[EZmXTUp]);}();
        }
        json["pName"]=arr_XCtfitt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetDeviceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetInstanceProcAddr( VkInstance instance, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetInstanceProcAddr\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETINSTANCEPROCADDR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=json::vector();
            return; }auto arr_XCtfitt=json::vector(strlen(pName)+1);
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=static_cast<uint>(pName[EZmXTUp]);}();
        }
        json["pName"]=arr_XCtfitt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETINSTANCEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (json["result"].as_uint64_t()!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetInstanceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_rSttUuQ=json::vector(1);
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[RBAofpr]);
            arr_rSttUuQ[RBAofpr]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_rSttUuQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_rSttUuQ=json["pProperties"].as_vector();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            deserialize_struct(arr_rSttUuQ[RBAofpr].as_map(),pProperties[RBAofpr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=json::vector();
            return; }auto arr_tzRlmPf=json::vector(1);
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=static_cast<uint>(pQueueFamilyPropertyCount[cPKCUxv]);}();
        }
        json["pQueueFamilyPropertyCount"]=arr_tzRlmPf;}();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=json::vector();
            return; }auto arr_ixxluvk=json::vector(*pQueueFamilyPropertyCount);
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueFamilyProperties[WYdxXmB]);
            arr_ixxluvk[WYdxXmB]=temp_map;
            return;
            }();
        }
        json["pQueueFamilyProperties"]=arr_ixxluvk;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].as_vector().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_vector();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_uint64_t());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_int64_t());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].as_vector().size()==0){
                pQueueFamilyProperties=NULL;
            return; }auto& arr_ixxluvk=json["pQueueFamilyProperties"].as_vector();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            deserialize_struct(arr_ixxluvk[WYdxXmB].as_map(),pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMEMORYPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=json::vector();
            return; }auto arr_cVJWqPt=json::vector(1);
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryProperties[iqfYjRc]);
            arr_cVJWqPt[iqfYjRc]=temp_map;
            return;
            }();
        }
        json["pMemoryProperties"]=arr_cVJWqPt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].as_vector().size()==0){
                pMemoryProperties=NULL;
            return; }auto& arr_cVJWqPt=json["pMemoryProperties"].as_vector();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            deserialize_struct(arr_cVJWqPt[iqfYjRc].as_map(),pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFEATURES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=json::vector();
            return; }auto arr_MNJcbZO=json::vector(1);
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFeatures[IqPoadP]);
            arr_MNJcbZO[IqPoadP]=temp_map;
            return;
            }();
        }
        json["pFeatures"]=arr_MNJcbZO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].as_vector().size()==0){
                pFeatures=NULL;
            return; }auto& arr_MNJcbZO=json["pFeatures"].as_vector();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            deserialize_struct(arr_MNJcbZO[IqPoadP].as_map(),pFeatures[IqPoadP]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFORMATPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=json::vector();
            return; }auto arr_ktGodop=json::vector(1);
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatProperties[CLkwuSw]);
            arr_ktGodop[CLkwuSw]=temp_map;
            return;
            }();
        }
        json["pFormatProperties"]=arr_ktGodop;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].as_vector().size()==0){
                pFormatProperties=NULL;
            return; }auto& arr_ktGodop=json["pFormatProperties"].as_vector();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            deserialize_struct(arr_ktGodop[CLkwuSw].as_map(),pFormatProperties[CLkwuSw]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_sBgMBXU=json::vector(1);
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[hhYjZOs]);
            arr_sBgMBXU[hhYjZOs]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_sBgMBXU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }auto& arr_sBgMBXU=json["pImageFormatProperties"].as_vector();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            deserialize_struct(arr_sBgMBXU[hhYjZOs].as_map(),pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_Fblblty;[&](){
            if (json["result"].is_uint64_t()){
                temp_Fblblty=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_Fblblty=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_Fblblty=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_Fblblty;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDevice( VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice ){
//Will only be called by the client
debug_printf("Executing vkCreateDevice\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDEVICE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TuuJAwt=json::vector(1);
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[Ktbkccz]);
            arr_TuuJAwt[Ktbkccz]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TuuJAwt;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=json::vector();
            return; }auto arr_WTIobJE=json::vector(1);
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        json["pDevice"]=arr_WTIobJE;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();


[&](){
            if (json["pDevice"].as_vector().size()==0){
                pDevice=NULL;
            return; }auto& arr_WTIobJE=json["pDevice"].as_vector();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_arnVPXd;[&](){
            if (json["result"].is_uint64_t()){
                temp_arnVPXd=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_arnVPXd=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_arnVPXd=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_arnVPXd;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pDevice)]={.instance=NULL,.device=(*pDevice) };
registerDevice(*pDevice,physicalDevice);

debug_printf("Ending vkCreateDevice...\n");
debug_printf("Return value of vkCreateDevice is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDevice( VkDevice device, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDevice\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDEVICE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


debug_printf("Ending vkDestroyDevice...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceVersion( uint32_t* pApiVersion ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceVersion\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCEVERSION);
    
    auto parent_json=json::map();
    
parent_json["instance"]=(uintptr_t)NULL;
json["parent"]=parent_json;
{
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=json::vector();
            return; }auto arr_qBCKjKo=json::vector(1);
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=static_cast<uint>(pApiVersion[KJjQFCs]);}();
        }
        json["pApiVersion"]=arr_qBCKjKo;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){
            if (json["pApiVersion"].as_vector().size()==0){
                pApiVersion=NULL;
            return; }auto& arr_qBCKjKo=json["pApiVersion"].as_vector();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){
            if (arr_qBCKjKo[KJjQFCs].is_uint64_t()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_uint64_t());
            }else if (arr_qBCKjKo[KJjQFCs].is_int64_t()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_int64_t());
            }else{
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YOjYIAv;[&](){
            if (json["result"].is_uint64_t()){
                temp_YOjYIAv=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_YOjYIAv=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_YOjYIAv=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_YOjYIAv;}();}();

debug_printf("Ending vkEnumerateInstanceVersion...\n");
debug_printf("Return value of vkEnumerateInstanceVersion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceLayerProperties( uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceLayerProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCELAYERPROPERTIES);
    
    auto parent_json=json::map();
    
parent_json["instance"]=(uintptr_t)NULL;
json["parent"]=parent_json;
{
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_AKGITwD=json::vector(*pPropertyCount);
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[AVcpYdO]);
            arr_AKGITwD[AVcpYdO]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_AKGITwD;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_AKGITwD=json["pProperties"].as_vector();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            deserialize_struct(arr_AKGITwD[AVcpYdO].as_map(),pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_npLpYVw;[&](){
            if (json["result"].is_uint64_t()){
                temp_npLpYVw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_npLpYVw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_npLpYVw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_npLpYVw;}();}();

debug_printf("Ending vkEnumerateInstanceLayerProperties...\n");
debug_printf("Return value of vkEnumerateInstanceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceExtensionProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEINSTANCEEXTENSIONPROPERTIES);
    
    auto parent_json=json::map();
    
parent_json["instance"]=(uintptr_t)NULL;
json["parent"]=parent_json;

        if(pProperties==NULL){
            const uint32_t DEFAULT_PROPERTIES_LENGTH=100;
            pProperties=(VkExtensionProperties*)malloc(DEFAULT_PROPERTIES_LENGTH*sizeof(VkExtensionProperties));
            *pPropertyCount=DEFAULT_PROPERTIES_LENGTH;
            
            for (uint32_t i=0; i<*pPropertyCount; i++){
                pProperties[i]=VkExtensionProperties();
            }
        }
        
        uint32_t len_of_properties_array=*pPropertyCount;
        
{
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=json::vector();
            return; }auto arr_xWfwWBl=json::vector(strlen(pLayerName)+1);
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=static_cast<uint>(pLayerName[EYxuOlw]);}();
        }
        json["pLayerName"]=arr_xWfwWBl;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_yJzeHZb=json::vector(*pPropertyCount);
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oiKhvHw]);
            arr_yJzeHZb[oiKhvHw]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_yJzeHZb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}

[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_yJzeHZb=json["pProperties"].as_vector();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            deserialize_struct(arr_yJzeHZb[oiKhvHw].as_map(),pProperties[oiKhvHw]);
            }();
        }
        }();

        std::set<std::string> propertiesSet;
        for(uint32_t i=0; i<*pPropertyCount; i++){
            propertiesSet.insert(std::string(pProperties[i].extensionName));
        }
        

            #ifdef VK_USE_PLATFORM_XLIB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XLIB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XLIB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XLIB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            

            #ifdef VK_USE_PLATFORM_XCB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XCB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XCB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XCB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            
VkResult result;
[&](){[&](){int temp_niAjHXZ;[&](){
            if (json["result"].is_uint64_t()){
                temp_niAjHXZ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_niAjHXZ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_niAjHXZ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_niAjHXZ;}();}();

debug_printf("Ending vkEnumerateInstanceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateInstanceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceLayerProperties( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceLayerProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEDEVICELAYERPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_AKGITwD=json::vector(*pPropertyCount);
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[AVcpYdO]);
            arr_AKGITwD[AVcpYdO]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_AKGITwD;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_AKGITwD=json["pProperties"].as_vector();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            deserialize_struct(arr_AKGITwD[AVcpYdO].as_map(),pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_GURLKJj;[&](){
            if (json["result"].is_uint64_t()){
                temp_GURLKJj=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_GURLKJj=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_GURLKJj=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_GURLKJj;}();}();

debug_printf("Ending vkEnumerateDeviceLayerProperties...\n");
debug_printf("Return value of vkEnumerateDeviceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceExtensionProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEDEVICEEXTENSIONPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=json::vector();
            return; }auto arr_xWfwWBl=json::vector(strlen(pLayerName)+1);
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=static_cast<uint>(pLayerName[EYxuOlw]);}();
        }
        json["pLayerName"]=arr_xWfwWBl;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_yJzeHZb=json::vector(*pPropertyCount);
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oiKhvHw]);
            arr_yJzeHZb[oiKhvHw]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_yJzeHZb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_yJzeHZb=json["pProperties"].as_vector();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            deserialize_struct(arr_yJzeHZb[oiKhvHw].as_map(),pProperties[oiKhvHw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_VtyFKEt;[&](){
            if (json["result"].is_uint64_t()){
                temp_VtyFKEt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VtyFKEt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VtyFKEt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VtyFKEt;}();}();

debug_printf("Ending vkEnumerateDeviceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateDeviceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue( VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEQUEUE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){json["queueIndex"]=static_cast<uint>(queueIndex);}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=json::vector();
            return; }auto arr_rYZbcEA=json::vector(1);
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        json["pQueue"]=arr_rYZbcEA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
[&](){
            if (json["queueIndex"].is_uint64_t()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_uint64_t());
            }else if (json["queueIndex"].is_int64_t()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_int64_t());
            }else{
                queueIndex=static_cast<uint32_t>(json["queueIndex"].as_double());
            }
            }();
[&](){
            if (json["pQueue"].as_vector().size()==0){
                pQueue=NULL;
            return; }auto& arr_rYZbcEA=json["pQueue"].as_vector();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

                if (pQueue!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueue[i])]=parent;
                    }
                }
                

debug_printf("Ending vkGetDeviceQueue...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit( VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit\n");
MemoryMapLock.lock_shared();

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUESUBMIT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=static_cast<uint>(submitCount);}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=json::vector();
            return; }auto arr_kYcwgKD=json::vector(submitCount);
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubmits[FrUhwZA]);
            arr_kYcwgKD[FrUhwZA]=temp_map;
            return;
            }();
        }
        json["pSubmits"]=arr_kYcwgKD;}();
[&](){serialize_VkFence(json["fence"],fence);}();
}
SyncAll();


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["submitCount"].is_uint64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_uint64_t());
            }else if (json["submitCount"].is_int64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_int64_t());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].as_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_xDkRYSw;[&](){
            if (json["result"].is_uint64_t()){
                temp_xDkRYSw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_xDkRYSw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_xDkRYSw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_xDkRYSw;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkQueueSubmit...\n");
debug_printf("Return value of vkQueueSubmit is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueWaitIdle( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueWaitIdle\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEWAITIDLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkResult result;
[&](){[&](){int temp_tolQiBl;[&](){
            if (json["result"].is_uint64_t()){
                temp_tolQiBl=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_tolQiBl=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_tolQiBl=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_tolQiBl;}();}();

debug_printf("Ending vkQueueWaitIdle...\n");
debug_printf("Return value of vkQueueWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeviceWaitIdle( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkDeviceWaitIdle\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDEVICEWAITIDLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEVICEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
VkResult result;
[&](){[&](){int temp_acLKDuP;[&](){
            if (json["result"].is_uint64_t()){
                temp_acLKDuP=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_acLKDuP=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_acLKDuP=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_acLKDuP;}();}();

waitForCounterIdle(device);
debug_printf("Ending vkDeviceWaitIdle...\n");
debug_printf("Return value of vkDeviceWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateMemory( VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory ){
//Will only be called by the client
debug_printf("Executing vkAllocateMemory\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKALLOCATEMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_NGCHnPz=json::vector(1);
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[MAXIAGO]);
            arr_NGCHnPz[MAXIAGO]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_NGCHnPz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=json::vector();
            return; }auto arr_JqUSUSb=json::vector(1);
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        json["pMemory"]=arr_JqUSUSb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMemory"].as_vector().size()==0){
                pMemory=NULL;
            return; }auto& arr_JqUSUSb=json["pMemory"].as_vector();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_PToClmy;[&](){
            if (json["result"].is_uint64_t()){
                temp_PToClmy=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_PToClmy=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_PToClmy=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_PToClmy;}();}();
registerDeviceMemory(*pMemory, pAllocateInfo->allocationSize);

debug_printf("Ending vkAllocateMemory...\n");
debug_printf("Return value of vkAllocateMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeMemory( VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkFreeMemory\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKFREEMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}
vkUnmapMemory(device,memory);


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();


debug_printf("Ending vkFreeMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory( VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory\n");
MemoryMapLock.lock();

    json::map json;
    json["stream_type"]=static_cast<int>(VKMAPMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;

        if (size==VK_WHOLE_SIZE){
            size=devicememory_to_size[(uintptr_t)memory]-offset;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_syvZTtN=json::vector(1);
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=json::vector();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(size);
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[weOJAdg]))[jYdchEs]);}();
        }
        arr_syvZTtN[weOJAdg]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_syvZTtN;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_UEEqVUK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_UEEqVUK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_UEEqVUK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_UEEqVUK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }auto& arr_syvZTtN=json["ppData"].as_vector();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].as_vector().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].as_vector().size()==0){
                temp_syvZTtN=NULL;
            return; }temp_syvZTtN=(char*)malloc(size*sizeof(char));auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].as_vector();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_wvjjzvw;[&](){
            if (json["result"].is_uint64_t()){
                temp_wvjjzvw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_wvjjzvw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_wvjjzvw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_wvjjzvw;}();}();

        json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=server_memory_json.as_uint64_t(); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,json["mem"].as_uint64_t());
        
        #ifndef CLIENT
            json["mem"]=json["mem"].as_uint64_t();
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory...\n");
debug_printf("Return value of vkMapMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUnmapMemory( VkDevice device, VkDeviceMemory memory ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory\n");
MemoryMapLock.lock();

    json::map json;
    json["stream_type"]=static_cast<int>(VKUNMAPMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
}
deregisterDeviceMemoryMap(memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkFlushMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkFlushMappedMemoryRanges\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKFLUSHMAPPEDMEMORYRANGES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=static_cast<uint>(memoryRangeCount);}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=json::vector();
            return; }auto arr_sKDZFVw=json::vector(memoryRangeCount);
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRanges[GdhGpVL]);
            arr_sKDZFVw[GdhGpVL]=temp_map;
            return;
            }();
        }
        json["pMemoryRanges"]=arr_sKDZFVw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFLUSHMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["memoryRangeCount"].is_uint64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_uint64_t());
            }else if (json["memoryRangeCount"].is_int64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_int64_t());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_trVQekJ;[&](){
            if (json["result"].is_uint64_t()){
                temp_trVQekJ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_trVQekJ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_trVQekJ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_trVQekJ;}();}();

debug_printf("Ending vkFlushMappedMemoryRanges...\n");
debug_printf("Return value of vkFlushMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInvalidateMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkInvalidateMappedMemoryRanges\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKINVALIDATEMAPPEDMEMORYRANGES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=static_cast<uint>(memoryRangeCount);}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=json::vector();
            return; }auto arr_sKDZFVw=json::vector(memoryRangeCount);
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRanges[GdhGpVL]);
            arr_sKDZFVw[GdhGpVL]=temp_map;
            return;
            }();
        }
        json["pMemoryRanges"]=arr_sKDZFVw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINVALIDATEMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["memoryRangeCount"].is_uint64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_uint64_t());
            }else if (json["memoryRangeCount"].is_int64_t()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_int64_t());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_jVSAMPV;[&](){
            if (json["result"].is_uint64_t()){
                temp_jVSAMPV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_jVSAMPV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_jVSAMPV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_jVSAMPV;}();}();

debug_printf("Ending vkInvalidateMappedMemoryRanges...\n");
debug_printf("Return value of vkInvalidateMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMemoryCommitment( VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryCommitment\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEMEMORYCOMMITMENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=json::vector();
            return; }auto arr_BkHcKeY=json::vector(1);
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=static_cast<uint>(pCommittedMemoryInBytes[iEYXrVv]);}();}();
        }
        json["pCommittedMemoryInBytes"]=arr_BkHcKeY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYCOMMITMENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){
            if (json["pCommittedMemoryInBytes"].as_vector().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].as_vector();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){
            if (arr_BkHcKeY[iEYXrVv].is_uint64_t()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_uint64_t());
            }else if (arr_BkHcKeY[iEYXrVv].is_int64_t()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_int64_t());
            }else{
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].as_double());
            }
            }();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

debug_printf("Ending vkGetDeviceMemoryCommitment...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements( VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETBUFFERMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_qQjUyYD=json::vector(1);
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[VeirrNu]);
            arr_qQjUyYD[VeirrNu]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_qQjUyYD;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_qQjUyYD=json["pMemoryRequirements"].as_vector();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            deserialize_struct(arr_qQjUyYD[VeirrNu].as_map(),pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory( VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDBUFFERMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=static_cast<uint>(memoryOffset);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_uint64_t());
            }else if (json["memoryOffset"].is_int64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_int64_t());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_vWIXPNS;[&](){
            if (json["result"].is_uint64_t()){
                temp_vWIXPNS=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vWIXPNS=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vWIXPNS=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vWIXPNS;}();}();

debug_printf("Ending vkBindBufferMemory...\n");
debug_printf("Return value of vkBindBufferMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements( VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_qQjUyYD=json::vector(1);
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[VeirrNu]);
            arr_qQjUyYD[VeirrNu]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_qQjUyYD;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_qQjUyYD=json["pMemoryRequirements"].as_vector();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            deserialize_struct(arr_qQjUyYD[VeirrNu].as_map(),pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory( VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDIMAGEMEMORY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=static_cast<uint>(memoryOffset);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_uint64_t());
            }else if (json["memoryOffset"].is_int64_t()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_int64_t());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].as_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_DPbOQkR;[&](){
            if (json["result"].is_uint64_t()){
                temp_DPbOQkR=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_DPbOQkR=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_DPbOQkR=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_DPbOQkR;}();}();

debug_printf("Ending vkBindImageMemory...\n");
debug_printf("Return value of vkBindImageMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements( VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGESPARSEMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_gCgbiZM=json::vector(*pSparseMemoryRequirementCount);
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[HKRWUBR]);
            arr_gCgbiZM[HKRWUBR]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_gCgbiZM;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].as_vector();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            deserialize_struct(arr_gCgbiZM[HKRWUBR].as_map(),pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_jINYdYP=json::vector(*pPropertyCount);
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[BOLcXca]);
            arr_jINYdYP[BOLcXca]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_jINYdYP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_jINYdYP=json["pProperties"].as_vector();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            deserialize_struct(arr_jINYdYP[BOLcXca].as_map(),pProperties[BOLcXca]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueBindSparse( VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueBindSparse\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEBINDSPARSE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=json::vector();
            return; }auto arr_eUGJCxJ=json::vector(bindInfoCount);
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfo[ujBkVap]);
            arr_eUGJCxJ[ujBkVap]=temp_map;
            return;
            }();
        }
        json["pBindInfo"]=arr_eUGJCxJ;}();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBINDSPARSE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_PpQvdMQ;[&](){
            if (json["result"].is_uint64_t()){
                temp_PpQvdMQ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_PpQvdMQ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_PpQvdMQ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_PpQvdMQ;}();}();

debug_printf("Ending vkQueueBindSparse...\n");
debug_printf("Return value of vkQueueBindSparse is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFence( VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkCreateFence\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEFENCE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_qbBwXza=json::vector(1);
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[kPSKeJY]);
            arr_qbBwXza[kPSKeJY]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_qbBwXza;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GExdWhT;[&](){
            if (json["result"].is_uint64_t()){
                temp_GExdWhT=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_GExdWhT=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_GExdWhT=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_GExdWhT;}();}();

                if (pFence!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFence[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFence...\n");
debug_printf("Return value of vkCreateFence is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFence( VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFence\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYFENCE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();


debug_printf("Ending vkDestroyFence...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences ){
//Will only be called by the client
debug_printf("Executing vkResetFences\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETFENCES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=static_cast<uint>(fenceCount);}();
[&](){
            if (pFences==NULL){
                json["pFences"]=json::vector();
            return; }auto arr_UUllwqV=json::vector(fenceCount);
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        json["pFences"]=arr_UUllwqV;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["fenceCount"].is_uint64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_uint64_t());
            }else if (json["fenceCount"].is_int64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_int64_t());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_vPmZsFt;[&](){
            if (json["result"].is_uint64_t()){
                temp_vPmZsFt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vPmZsFt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vPmZsFt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vPmZsFt;}();}();

debug_printf("Ending vkResetFences...\n");
debug_printf("Return value of vkResetFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceStatus( VkDevice device, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkGetFenceStatus\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETFENCESTATUS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCESTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_kFznveb;[&](){
            if (json["result"].is_uint64_t()){
                temp_kFznveb=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_kFznveb=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_kFznveb=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_kFznveb;}();}();

debug_printf("Ending vkGetFenceStatus...\n");
debug_printf("Return value of vkGetFenceStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForFences\n");
MemoryMapLock.lock_shared();

    json::map json;
    json["stream_type"]=static_cast<int>(VKWAITFORFENCES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=static_cast<uint>(fenceCount);}();
[&](){
            if (pFences==NULL){
                json["pFences"]=json::vector();
            return; }auto arr_UUllwqV=json::vector(fenceCount);
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        json["pFences"]=arr_UUllwqV;}();
[&](){[&](){json["waitAll"]=static_cast<uint>(waitAll);}();}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["fenceCount"].is_uint64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_uint64_t());
            }else if (json["fenceCount"].is_int64_t()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_int64_t());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].as_double());
            }
            }();

[&](){uint32_t temp_pqKsrTL;[&](){
            if (json["waitAll"].is_uint64_t()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_uint64_t());
            }else if (json["waitAll"].is_int64_t()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_int64_t());
            }else{
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].as_double());
            }
            }();waitAll=(VkBool32)temp_pqKsrTL;}();
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_iXmjtzl;[&](){
            if (json["result"].is_uint64_t()){
                temp_iXmjtzl=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_iXmjtzl=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_iXmjtzl=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_iXmjtzl;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkWaitForFences...\n");
debug_printf("Return value of vkWaitForFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSemaphore( VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore ){
//Will only be called by the client
debug_printf("Executing vkCreateSemaphore\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESEMAPHORE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_hQVwpIP=json::vector(1);
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TzTYDbe]);
            arr_hQVwpIP[TzTYDbe]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_hQVwpIP;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=json::vector();
            return; }auto arr_rvNHvxY=json::vector(1);
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        json["pSemaphore"]=arr_rvNHvxY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSemaphore"].as_vector().size()==0){
                pSemaphore=NULL;
            return; }auto& arr_rvNHvxY=json["pSemaphore"].as_vector();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_oYhdFMQ;[&](){
            if (json["result"].is_uint64_t()){
                temp_oYhdFMQ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_oYhdFMQ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_oYhdFMQ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_oYhdFMQ;}();}();

                if (pSemaphore!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSemaphore[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSemaphore...\n");
debug_printf("Return value of vkCreateSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySemaphore( VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySemaphore\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSEMAPHORE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();


debug_printf("Ending vkDestroySemaphore...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateEvent( VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent ){
//Will only be called by the client
debug_printf("Executing vkCreateEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_wqWioqo=json::vector(1);
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[ThfQKZW]);
            arr_wqWioqo[ThfQKZW]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_wqWioqo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=json::vector();
            return; }auto arr_edObbrc=json::vector(1);
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        json["pEvent"]=arr_edObbrc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pEvent"].as_vector().size()==0){
                pEvent=NULL;
            return; }auto& arr_edObbrc=json["pEvent"].as_vector();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RhjukGg;[&](){
            if (json["result"].is_uint64_t()){
                temp_RhjukGg=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_RhjukGg=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_RhjukGg=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_RhjukGg;}();}();

                if (pEvent!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pEvent[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateEvent...\n");
debug_printf("Return value of vkCreateEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyEvent( VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkDestroyEvent...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetEventStatus( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkGetEventStatus\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETEVENTSTATUS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETEVENTSTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_LjAnXKd;[&](){
            if (json["result"].is_uint64_t()){
                temp_LjAnXKd=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LjAnXKd=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LjAnXKd=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LjAnXKd;}();}();

debug_printf("Ending vkGetEventStatus...\n");
debug_printf("Return value of vkGetEventStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkSetEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_LpIefps;[&](){
            if (json["result"].is_uint64_t()){
                temp_LpIefps=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LpIefps=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LpIefps=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LpIefps;}();}();

debug_printf("Ending vkSetEvent...\n");
debug_printf("Return value of vkSetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkResetEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_IJKFvzI;[&](){
            if (json["result"].is_uint64_t()){
                temp_IJKFvzI=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_IJKFvzI=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_IJKFvzI=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_IJKFvzI;}();}();

debug_printf("Ending vkResetEvent...\n");
debug_printf("Return value of vkResetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateQueryPool( VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool ){
//Will only be called by the client
debug_printf("Executing vkCreateQueryPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEQUERYPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_AOuTZQo=json::vector(1);
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[SvYxRUl]);
            arr_AOuTZQo[SvYxRUl]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_AOuTZQo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=json::vector();
            return; }auto arr_uEjfPmz=json::vector(1);
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        json["pQueryPool"]=arr_uEjfPmz;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pQueryPool"].as_vector().size()==0){
                pQueryPool=NULL;
            return; }auto& arr_uEjfPmz=json["pQueryPool"].as_vector();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_YCeirvy;[&](){
            if (json["result"].is_uint64_t()){
                temp_YCeirvy=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_YCeirvy=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_YCeirvy=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_YCeirvy;}();}();

                if (pQueryPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueryPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateQueryPool...\n");
debug_printf("Return value of vkCreateQueryPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyQueryPool( VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyQueryPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYQUERYPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();


debug_printf("Ending vkDestroyQueryPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetQueryPoolResults( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkGetQueryPoolResults\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETQUERYPOOLRESULTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){[&](){json["stride"]=static_cast<uint>(stride);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_int64_t());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();
VkResult result;
[&](){[&](){int temp_uWvdBKW;[&](){
            if (json["result"].is_uint64_t()){
                temp_uWvdBKW=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_uWvdBKW=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_uWvdBKW=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_uWvdBKW;}();}();

debug_printf("Ending vkGetQueryPoolResults...\n");
debug_printf("Return value of vkGetQueryPoolResults is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkResetQueryPool( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkResetQueryPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETQUERYPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();

debug_printf("Ending vkResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkResetQueryPoolEXT( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
return vkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBuffer( VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_YapwvbL=json::vector(1);
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XkzMxbI]);
            arr_YapwvbL[XkzMxbI]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_YapwvbL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=json::vector();
            return; }auto arr_cIWQmjJ=json::vector(1);
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        json["pBuffer"]=arr_cIWQmjJ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pBuffer"].as_vector().size()==0){
                pBuffer=NULL;
            return; }auto& arr_cIWQmjJ=json["pBuffer"].as_vector();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OnfWbtl;[&](){
            if (json["result"].is_uint64_t()){
                temp_OnfWbtl=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_OnfWbtl=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_OnfWbtl=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_OnfWbtl;}();}();

                if (pBuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pBuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBuffer...\n");
debug_printf("Return value of vkCreateBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBuffer( VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();


debug_printf("Ending vkDestroyBuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBufferView( VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateBufferView\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEBUFFERVIEW);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_SvrkcZl=json::vector(1);
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[cSdiRJj]);
            arr_SvrkcZl[cSdiRJj]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_SvrkcZl;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pView==NULL){
                json["pView"]=json::vector();
            return; }auto arr_FoBLnTF=json::vector(1);
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        json["pView"]=arr_FoBLnTF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].as_vector().size()==0){
                pView=NULL;
            return; }auto& arr_FoBLnTF=json["pView"].as_vector();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_wpZAeSe;[&](){
            if (json["result"].is_uint64_t()){
                temp_wpZAeSe=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_wpZAeSe=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_wpZAeSe=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_wpZAeSe;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBufferView...\n");
debug_printf("Return value of vkCreateBufferView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBufferView( VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBufferView\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYBUFFERVIEW);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();


debug_printf("Ending vkDestroyBufferView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImage( VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage ){
//Will only be called by the client
debug_printf("Executing vkCreateImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TpPCnAy=json::vector(1);
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[pRwmwcF]);
            arr_TpPCnAy[pRwmwcF]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TpPCnAy;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pImage==NULL){
                json["pImage"]=json::vector();
            return; }auto arr_YGmHGGw=json::vector(1);
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        json["pImage"]=arr_YGmHGGw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pImage"].as_vector().size()==0){
                pImage=NULL;
            return; }auto& arr_YGmHGGw=json["pImage"].as_vector();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZORigsY;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZORigsY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZORigsY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZORigsY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZORigsY;}();}();

                if (pImage!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pImage[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImage...\n");
debug_printf("Return value of vkCreateImage is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImage( VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();


debug_printf("Ending vkDestroyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout( VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGESUBRESOURCELAYOUT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=json::vector();
            return; }auto arr_bNRLlpX=json::vector(1);
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubresource[trrMzRH]);
            arr_bNRLlpX[trrMzRH]=temp_map;
            return;
            }();
        }
        json["pSubresource"]=arr_bNRLlpX;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JAFsVvP=json::vector(1);
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jGHmbXh]);
            arr_JAFsVvP[jGHmbXh]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JAFsVvP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }auto& arr_JAFsVvP=json["pLayout"].as_vector();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            deserialize_struct(arr_JAFsVvP[jGHmbXh].as_map(),pLayout[jGHmbXh]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImageView( VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateImageView\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEIMAGEVIEW);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_TYfFrkP=json::vector(1);
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[HNOogbj]);
            arr_TYfFrkP[HNOogbj]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_TYfFrkP;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pView==NULL){
                json["pView"]=json::vector();
            return; }auto arr_GCwrdnq=json::vector(1);
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        json["pView"]=arr_GCwrdnq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].as_vector().size()==0){
                pView=NULL;
            return; }auto& arr_GCwrdnq=json["pView"].as_vector();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZQdRwrg;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZQdRwrg=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZQdRwrg=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZQdRwrg=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZQdRwrg;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImageView...\n");
debug_printf("Return value of vkCreateImageView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImageView( VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImageView\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYIMAGEVIEW);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();


debug_printf("Ending vkDestroyImageView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShaderModule( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule ){
//Will only be called by the client
debug_printf("Executing vkCreateShaderModule\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESHADERMODULE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iSZUILM=json::vector(1);
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[dKxemXH]);
            arr_iSZUILM[dKxemXH]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iSZUILM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=json::vector();
            return; }auto arr_FaKUyxw=json::vector(1);
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        json["pShaderModule"]=arr_FaKUyxw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pShaderModule"].as_vector().size()==0){
                pShaderModule=NULL;
            return; }auto& arr_FaKUyxw=json["pShaderModule"].as_vector();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_iuLPIVs;[&](){
            if (json["result"].is_uint64_t()){
                temp_iuLPIVs=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_iuLPIVs=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_iuLPIVs=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_iuLPIVs;}();}();

                if (pShaderModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaderModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShaderModule...\n");
debug_printf("Return value of vkCreateShaderModule is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderModule( VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderModule\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSHADERMODULE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();


debug_printf("Ending vkDestroyShaderModule...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineCache( VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineCache\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEPIPELINECACHE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_wTXOYfz=json::vector(1);
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[iWdFkeP]);
            arr_wTXOYfz[iWdFkeP]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_wTXOYfz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=json::vector();
            return; }auto arr_mogHiwV=json::vector(1);
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        json["pPipelineCache"]=arr_mogHiwV;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineCache"].as_vector().size()==0){
                pPipelineCache=NULL;
            return; }auto& arr_mogHiwV=json["pPipelineCache"].as_vector();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yYSuCeV;[&](){
            if (json["result"].is_uint64_t()){
                temp_yYSuCeV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yYSuCeV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yYSuCeV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yYSuCeV;}();}();

                if (pPipelineCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineCache...\n");
debug_printf("Return value of vkCreatePipelineCache is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineCache( VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineCache\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYPIPELINECACHE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();


debug_printf("Ending vkDestroyPipelineCache...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineCacheData( VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineCacheData\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINECACHEDATA);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINECACHEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_jTTriaB;[&](){
            if (json["result"].is_uint64_t()){
                temp_jTTriaB=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_jTTriaB=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_jTTriaB=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_jTTriaB;}();}();

debug_printf("Ending vkGetPipelineCacheData...\n");
debug_printf("Return value of vkGetPipelineCacheData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergePipelineCaches( VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergePipelineCaches\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKMERGEPIPELINECACHES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=static_cast<uint>(srcCacheCount);}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=json::vector();
            return; }auto arr_DmqfOOL=json::vector(srcCacheCount);
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        json["pSrcCaches"]=arr_DmqfOOL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEPIPELINECACHES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
[&](){
            if (json["srcCacheCount"].is_uint64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_uint64_t());
            }else if (json["srcCacheCount"].is_int64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_int64_t());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_VCXflIX;[&](){
            if (json["result"].is_uint64_t()){
                temp_VCXflIX=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VCXflIX=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VCXflIX=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VCXflIX;}();}();

debug_printf("Ending vkMergePipelineCaches...\n");
debug_printf("Return value of vkMergePipelineCaches is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateGraphicsPipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateGraphicsPipelines\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEGRAPHICSPIPELINES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_juQDvLY=json::vector(createInfoCount);
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[wqGiARr]);
            arr_juQDvLY[wqGiARr]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_juQDvLY;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEGRAPHICSPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();


[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_fwluuIW;[&](){
            if (json["result"].is_uint64_t()){
                temp_fwluuIW=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_fwluuIW=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_fwluuIW=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_fwluuIW;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateGraphicsPipelines...\n");
debug_printf("Return value of vkCreateGraphicsPipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateComputePipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateComputePipelines\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATECOMPUTEPIPELINES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_eqiaDas=json::vector(createInfoCount);
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[NsFJrJk]);
            arr_eqiaDas[NsFJrJk]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_eqiaDas;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMPUTEPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();


[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_XaCpxZE;[&](){
            if (json["result"].is_uint64_t()){
                temp_XaCpxZE=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_XaCpxZE=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_XaCpxZE=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_XaCpxZE;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateComputePipelines...\n");
debug_printf("Return value of vkCreateComputePipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI( VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=json::vector();
            return; }auto arr_QJRQgTX=json::vector(1);
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMaxWorkgroupSize[WdbibPk]);
            arr_QJRQgTX[WdbibPk]=temp_map;
            return;
            }();
        }
        json["pMaxWorkgroupSize"]=arr_QJRQgTX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
[&](){
            if (json["pMaxWorkgroupSize"].as_vector().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].as_vector();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            deserialize_struct(arr_QJRQgTX[WdbibPk].as_map(),pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bKsxLVR;[&](){
            if (json["result"].is_uint64_t()){
                temp_bKsxLVR=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_bKsxLVR=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_bKsxLVR=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_bKsxLVR;}();}();

debug_printf("Ending vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
debug_printf("Return value of vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipeline( VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipeline\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYPIPELINE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();


debug_printf("Ending vkDestroyPipeline...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineLayout( VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineLayout\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEPIPELINELAYOUT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iyZpkhm=json::vector(1);
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[AdWYCmn]);
            arr_iyZpkhm[AdWYCmn]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iyZpkhm;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=json::vector();
            return; }auto arr_NheDZho=json::vector(1);
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        json["pPipelineLayout"]=arr_NheDZho;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineLayout"].as_vector().size()==0){
                pPipelineLayout=NULL;
            return; }auto& arr_NheDZho=json["pPipelineLayout"].as_vector();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_JaTGUJz;[&](){
            if (json["result"].is_uint64_t()){
                temp_JaTGUJz=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_JaTGUJz=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_JaTGUJz=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_JaTGUJz;}();}();

                if (pPipelineLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineLayout...\n");
debug_printf("Return value of vkCreatePipelineLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineLayout( VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineLayout\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYPIPELINELAYOUT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();


debug_printf("Ending vkDestroyPipelineLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSampler( VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler ){
//Will only be called by the client
debug_printf("Executing vkCreateSampler\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESAMPLER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_xWlqrLm=json::vector(1);
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[yMsdBPh]);
            arr_xWlqrLm[yMsdBPh]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_xWlqrLm;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=json::vector();
            return; }auto arr_nEROYrx=json::vector(1);
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        json["pSampler"]=arr_nEROYrx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSampler"].as_vector().size()==0){
                pSampler=NULL;
            return; }auto& arr_nEROYrx=json["pSampler"].as_vector();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yPETNHz;[&](){
            if (json["result"].is_uint64_t()){
                temp_yPETNHz=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yPETNHz=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yPETNHz=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yPETNHz;}();}();

                if (pSampler!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSampler[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSampler...\n");
debug_printf("Return value of vkCreateSampler is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySampler( VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySampler\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSAMPLER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSampler(json["sampler"], sampler);}();


debug_printf("Ending vkDestroySampler...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorSetLayout( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorSetLayout\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORSETLAYOUT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dFRsqIW=json::vector(1);
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tUGauKK]);
            arr_dFRsqIW[tUGauKK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dFRsqIW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=json::vector();
            return; }auto arr_iCAhOCt=json::vector(1);
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        json["pSetLayout"]=arr_iCAhOCt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSetLayout"].as_vector().size()==0){
                pSetLayout=NULL;
            return; }auto& arr_iCAhOCt=json["pSetLayout"].as_vector();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_QKciijQ;[&](){
            if (json["result"].is_uint64_t()){
                temp_QKciijQ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_QKciijQ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_QKciijQ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_QKciijQ;}();}();

                if (pSetLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSetLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorSetLayout...\n");
debug_printf("Return value of vkCreateDescriptorSetLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorSetLayout( VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorSetLayout\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORSETLAYOUT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();


debug_printf("Ending vkDestroyDescriptorSetLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorPool( VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_fChMCRL=json::vector(1);
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XgrRVVh]);
            arr_fChMCRL[XgrRVVh]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_fChMCRL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=json::vector();
            return; }auto arr_zvYCksx=json::vector(1);
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        json["pDescriptorPool"]=arr_zvYCksx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorPool"].as_vector().size()==0){
                pDescriptorPool=NULL;
            return; }auto& arr_zvYCksx=json["pDescriptorPool"].as_vector();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_POXquiI;[&](){
            if (json["result"].is_uint64_t()){
                temp_POXquiI=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_POXquiI=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_POXquiI=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_POXquiI;}();}();

                if (pDescriptorPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorPool...\n");
debug_printf("Return value of vkCreateDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();


debug_printf("Ending vkDestroyDescriptorPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetDescriptorPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETDESCRIPTORPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){[&](){int temp_zAsidUJ;[&](){
            if (json["flags"].is_uint64_t()){
                temp_zAsidUJ=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_zAsidUJ=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_zAsidUJ=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();
VkResult result;
[&](){[&](){int temp_IyIFPmQ;[&](){
            if (json["result"].is_uint64_t()){
                temp_IyIFPmQ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_IyIFPmQ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_IyIFPmQ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_IyIFPmQ;}();}();

debug_printf("Ending vkResetDescriptorPool...\n");
debug_printf("Return value of vkResetDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateDescriptorSets( VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkAllocateDescriptorSets\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKALLOCATEDESCRIPTORSETS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_yVqYJHW=json::vector(1);
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[jTINpTr]);
            arr_yVqYJHW[jTINpTr]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_yVqYJHW;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_hwQSDBT=json::vector(pAllocateInfo->descriptorSetCount);
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        json["pDescriptorSets"]=arr_hwQSDBT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDescriptorSets"].as_vector().size()==0){
                pDescriptorSets=NULL;
            return; }auto& arr_hwQSDBT=json["pDescriptorSets"].as_vector();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LQaOJmJ;[&](){
            if (json["result"].is_uint64_t()){
                temp_LQaOJmJ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LQaOJmJ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LQaOJmJ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LQaOJmJ;}();}();

                if (pDescriptorSets!=NULL){
                    for (int i=0; i<pAllocateInfo->descriptorSetCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorSets[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateDescriptorSets...\n");
debug_printf("Return value of vkAllocateDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkFreeDescriptorSets( VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkFreeDescriptorSets\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKFREEDESCRIPTORSETS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=static_cast<uint>(descriptorSetCount);}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_JZNsxgK=json::vector(descriptorSetCount);
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        json["pDescriptorSets"]=arr_JZNsxgK;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){
            if (json["descriptorSetCount"].is_uint64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_uint64_t());
            }else if (json["descriptorSetCount"].is_int64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_int64_t());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_YypqqnY;[&](){
            if (json["result"].is_uint64_t()){
                temp_YypqqnY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_YypqqnY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_YypqqnY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_YypqqnY;}();}();

debug_printf("Ending vkFreeDescriptorSets...\n");
debug_printf("Return value of vkFreeDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSets( VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSets\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKUPDATEDESCRIPTORSETS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=static_cast<uint>(descriptorWriteCount);}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=json::vector();
            return; }auto arr_AuOrFWk=json::vector(descriptorWriteCount);
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorWrites[qJACxKx]);
            arr_AuOrFWk[qJACxKx]=temp_map;
            return;
            }();
        }
        json["pDescriptorWrites"]=arr_AuOrFWk;}();
[&](){json["descriptorCopyCount"]=static_cast<uint>(descriptorCopyCount);}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=json::vector();
            return; }auto arr_WWZDhqd=json::vector(descriptorCopyCount);
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorCopies[ryeXdkw]);
            arr_WWZDhqd[ryeXdkw]=temp_map;
            return;
            }();
        }
        json["pDescriptorCopies"]=arr_WWZDhqd;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["descriptorWriteCount"].is_uint64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_uint64_t());
            }else if (json["descriptorWriteCount"].is_int64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_int64_t());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_double());
            }
            }();

[&](){
            if (json["descriptorCopyCount"].is_uint64_t()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_uint64_t());
            }else if (json["descriptorCopyCount"].is_int64_t()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_int64_t());
            }else{
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].as_double());
            }
            }();


debug_printf("Ending vkUpdateDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFramebuffer( VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateFramebuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEFRAMEBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_LBIrWmz=json::vector(1);
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[jMLqpUb]);
            arr_LBIrWmz[jMLqpUb]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_LBIrWmz;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=json::vector();
            return; }auto arr_xECXRAK=json::vector(1);
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        json["pFramebuffer"]=arr_xECXRAK;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFramebuffer"].as_vector().size()==0){
                pFramebuffer=NULL;
            return; }auto& arr_xECXRAK=json["pFramebuffer"].as_vector();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_AOWGmZj;[&](){
            if (json["result"].is_uint64_t()){
                temp_AOWGmZj=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_AOWGmZj=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_AOWGmZj=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_AOWGmZj;}();}();

                if (pFramebuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFramebuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFramebuffer...\n");
debug_printf("Return value of vkCreateFramebuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFramebuffer( VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFramebuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYFRAMEBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();


debug_printf("Ending vkDestroyFramebuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass( VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATERENDERPASS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_upxhtZe=json::vector(1);
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[oHJSJzU]);
            arr_upxhtZe[oHJSJzU]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_upxhtZe;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=json::vector();
            return; }auto arr_ZwdXTfx=json::vector(1);
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        json["pRenderPass"]=arr_ZwdXTfx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].as_vector().size()==0){
                pRenderPass=NULL;
            return; }auto& arr_ZwdXTfx=json["pRenderPass"].as_vector();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OCmIgFP;[&](){
            if (json["result"].is_uint64_t()){
                temp_OCmIgFP=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_OCmIgFP=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_OCmIgFP=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_OCmIgFP;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass...\n");
debug_printf("Return value of vkCreateRenderPass is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyRenderPass( VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyRenderPass\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYRENDERPASS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();


debug_printf("Ending vkDestroyRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderAreaGranularity( VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderAreaGranularity\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETRENDERAREAGRANULARITY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=json::vector();
            return; }auto arr_VvmWHYL=json::vector(1);
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGranularity[tgiNLQL]);
            arr_VvmWHYL[tgiNLQL]=temp_map;
            return;
            }();
        }
        json["pGranularity"]=arr_VvmWHYL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERAREAGRANULARITY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
[&](){
            if (json["pGranularity"].as_vector().size()==0){
                pGranularity=NULL;
            return; }auto& arr_VvmWHYL=json["pGranularity"].as_vector();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            deserialize_struct(arr_VvmWHYL[tgiNLQL].as_map(),pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderAreaGranularity...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderingAreaGranularityKHR( VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderingAreaGranularityKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETRENDERINGAREAGRANULARITYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=json::vector();
            return; }auto arr_QFvDqfG=json::vector(1);
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingAreaInfo[WRYBJDa]);
            arr_QFvDqfG[WRYBJDa]=temp_map;
            return;
            }();
        }
        json["pRenderingAreaInfo"]=arr_QFvDqfG;}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=json::vector();
            return; }auto arr_VvmWHYL=json::vector(1);
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGranularity[tgiNLQL]);
            arr_VvmWHYL[tgiNLQL]=temp_map;
            return;
            }();
        }
        json["pGranularity"]=arr_VvmWHYL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERINGAREAGRANULARITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pGranularity"].as_vector().size()==0){
                pGranularity=NULL;
            return; }auto& arr_VvmWHYL=json["pGranularity"].as_vector();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            deserialize_struct(arr_VvmWHYL[tgiNLQL].as_map(),pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderingAreaGranularityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCommandPool( VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool ){
//Will only be called by the client
debug_printf("Executing vkCreateCommandPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATECOMMANDPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_ISnaSOj=json::vector(1);
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[ubLLexW]);
            arr_ISnaSOj[ubLLexW]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_ISnaSOj;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=json::vector();
            return; }auto arr_ohCGecZ=json::vector(1);
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        json["pCommandPool"]=arr_ohCGecZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pCommandPool"].as_vector().size()==0){
                pCommandPool=NULL;
            return; }auto& arr_ohCGecZ=json["pCommandPool"].as_vector();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_TwnbacJ;[&](){
            if (json["result"].is_uint64_t()){
                temp_TwnbacJ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TwnbacJ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_TwnbacJ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_TwnbacJ;}();}();

                if (pCommandPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCommandPool...\n");
debug_printf("Return value of vkCreateCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCommandPool( VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCommandPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYCOMMANDPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();


debug_printf("Ending vkDestroyCommandPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETCOMMANDPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_ZfbLqrp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_ZfbLqrp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();
VkResult result;
[&](){[&](){int temp_ysibPDT;[&](){
            if (json["result"].is_uint64_t()){
                temp_ysibPDT=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ysibPDT=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ysibPDT=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ysibPDT;}();}();

debug_printf("Ending vkResetCommandPool...\n");
debug_printf("Return value of vkResetCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateCommandBuffers( VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkAllocateCommandBuffers\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKALLOCATECOMMANDBUFFERS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=json::vector();
            return; }auto arr_ZURucFE=json::vector(1);
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocateInfo[VMrKYrr]);
            arr_ZURucFE[VMrKYrr]=temp_map;
            return;
            }();
        }
        json["pAllocateInfo"]=arr_ZURucFE;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_WZYlBGU=json::vector(pAllocateInfo->commandBufferCount);
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        json["pCommandBuffers"]=arr_WZYlBGU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCommandBuffers"].as_vector().size()==0){
                pCommandBuffers=NULL;
            return; }auto& arr_WZYlBGU=json["pCommandBuffers"].as_vector();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KJhrnJP;[&](){
            if (json["result"].is_uint64_t()){
                temp_KJhrnJP=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_KJhrnJP=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_KJhrnJP=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_KJhrnJP;}();}();

                if (pCommandBuffers!=NULL){
                    for (int i=0; i<pAllocateInfo->commandBufferCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandBuffers[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateCommandBuffers...\n");
debug_printf("Return value of vkAllocateCommandBuffers is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeCommandBuffers( VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkFreeCommandBuffers\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKFREECOMMANDBUFFERS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=static_cast<uint>(commandBufferCount);}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_PdRlpEO=json::vector(commandBufferCount);
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        json["pCommandBuffers"]=arr_PdRlpEO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){
            if (json["commandBufferCount"].is_uint64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_uint64_t());
            }else if (json["commandBufferCount"].is_int64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_int64_t());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_double());
            }
            }();


debug_printf("Ending vkFreeCommandBuffers...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBeginCommandBuffer( VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkBeginCommandBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBEGINCOMMANDBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=json::vector();
            return; }auto arr_cULABHU=json::vector(1);
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBeginInfo[MlslWJM]);
            arr_cULABHU[MlslWJM]=temp_map;
            return;
            }();
        }
        json["pBeginInfo"]=arr_cULABHU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBEGINCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_mMeFygb;[&](){
            if (json["result"].is_uint64_t()){
                temp_mMeFygb=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_mMeFygb=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_mMeFygb=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_mMeFygb;}();}();

debug_printf("Ending vkBeginCommandBuffer...\n");
debug_printf("Return value of vkBeginCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEndCommandBuffer( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkEndCommandBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENDCOMMANDBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENDCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkResult result;
[&](){[&](){int temp_BVLpkXY;[&](){
            if (json["result"].is_uint64_t()){
                temp_BVLpkXY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_BVLpkXY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_BVLpkXY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_BVLpkXY;}();}();

debug_printf("Ending vkEndCommandBuffer...\n");
debug_printf("Return value of vkEndCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandBuffer( VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRESETCOMMANDBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lxCkbVG;[&](){
            if (json["flags"].is_uint64_t()){
                temp_lxCkbVG=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_lxCkbVG=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_lxCkbVG=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();
VkResult result;
[&](){[&](){int temp_RMtPwdq;[&](){
            if (json["result"].is_uint64_t()){
                temp_RMtPwdq=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_RMtPwdq=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_RMtPwdq=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_RMtPwdq;}();}();

debug_printf("Ending vkResetCommandBuffer...\n");
debug_printf("Return value of vkResetCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipeline( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipeline\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDPIPELINE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdBindPipeline...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAttachmentFeedbackLoopEnableEXT( VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAttachmentFeedbackLoopEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=static_cast<int>(aspectMask);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_LWxAVsj;[&](){
            if (json["aspectMask"].is_uint64_t()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_uint64_t());
            }else if (json["aspectMask"].is_int64_t()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_int64_t());
            }else{
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].as_double());
            }
            }();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

debug_printf("Ending vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewport( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewport\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=json::vector();
            return; }auto arr_SyYryUE=json::vector(viewportCount);
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewports[HAuJlzw]);
            arr_SyYryUE[HAuJlzw]=temp_map;
            return;
            }();
        }
        json["pViewports"]=arr_SyYryUE;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetViewport...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissor( VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissor\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSCISSOR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=static_cast<uint>(firstScissor);}();
[&](){json["scissorCount"]=static_cast<uint>(scissorCount);}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=json::vector();
            return; }auto arr_RpUaBcS=json::vector(scissorCount);
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pScissors[XBYGvVT]);
            arr_RpUaBcS[XBYGvVT]=temp_map;
            return;
            }();
        }
        json["pScissors"]=arr_RpUaBcS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSOR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstScissor"].is_uint64_t()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_uint64_t());
            }else if (json["firstScissor"].is_int64_t()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_int64_t());
            }else{
                firstScissor=static_cast<uint32_t>(json["firstScissor"].as_double());
            }
            }();
[&](){
            if (json["scissorCount"].is_uint64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_uint64_t());
            }else if (json["scissorCount"].is_int64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_int64_t());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetScissor...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineWidth( VkCommandBuffer commandBuffer, float lineWidth ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineWidth\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLINEWIDTH);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=static_cast<float>(lineWidth);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINEWIDTH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["lineWidth"].is_uint64_t()){
                lineWidth=static_cast<float>(json["lineWidth"].as_uint64_t());
            }else if (json["lineWidth"].is_int64_t()){
                lineWidth=static_cast<float>(json["lineWidth"].as_int64_t());
            }else{
                lineWidth=static_cast<float>(json["lineWidth"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetLineWidth...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias( VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIAS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=static_cast<float>(depthBiasConstantFactor);}();
[&](){json["depthBiasClamp"]=static_cast<float>(depthBiasClamp);}();
[&](){json["depthBiasSlopeFactor"]=static_cast<float>(depthBiasSlopeFactor);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["depthBiasConstantFactor"].is_uint64_t()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_uint64_t());
            }else if (json["depthBiasConstantFactor"].is_int64_t()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_int64_t());
            }else{
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].as_double());
            }
            }();
[&](){
            if (json["depthBiasClamp"].is_uint64_t()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_uint64_t());
            }else if (json["depthBiasClamp"].is_int64_t()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_int64_t());
            }else{
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].as_double());
            }
            }();
[&](){
            if (json["depthBiasSlopeFactor"].is_uint64_t()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_uint64_t());
            }else if (json["depthBiasSlopeFactor"].is_int64_t()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_int64_t());
            }else{
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetDepthBias...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetBlendConstants( VkCommandBuffer commandBuffer, const float blendConstants[4] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetBlendConstants\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETBLENDCONSTANTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){auto arr_HTjCZtj=json::vector(4);
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_HTjCZtj[lLRJClr]=static_cast<float>(blendConstants[lLRJClr]);}();
        }
        json["blendConstants"]=arr_HTjCZtj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETBLENDCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){auto& arr_HTjCZtj=json["blendConstants"].as_vector();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            
        }
        }();

debug_printf("Ending vkCmdSetBlendConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBounds( VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBounds\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBOUNDS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=static_cast<float>(minDepthBounds);}();
[&](){json["maxDepthBounds"]=static_cast<float>(maxDepthBounds);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["minDepthBounds"].is_uint64_t()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_uint64_t());
            }else if (json["minDepthBounds"].is_int64_t()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_int64_t());
            }else{
                minDepthBounds=static_cast<float>(json["minDepthBounds"].as_double());
            }
            }();
[&](){
            if (json["maxDepthBounds"].is_uint64_t()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_uint64_t());
            }else if (json["maxDepthBounds"].is_int64_t()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_int64_t());
            }else{
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetDepthBounds...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilCompareMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilCompareMask\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSTENCILCOMPAREMASK);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["compareMask"]=static_cast<uint>(compareMask);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILCOMPAREMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["compareMask"].is_uint64_t()){
                compareMask=static_cast<uint32_t>(json["compareMask"].as_uint64_t());
            }else if (json["compareMask"].is_int64_t()){
                compareMask=static_cast<uint32_t>(json["compareMask"].as_int64_t());
            }else{
                compareMask=static_cast<uint32_t>(json["compareMask"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilCompareMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilWriteMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilWriteMask\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSTENCILWRITEMASK);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["writeMask"]=static_cast<uint>(writeMask);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILWRITEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["writeMask"].is_uint64_t()){
                writeMask=static_cast<uint32_t>(json["writeMask"].as_uint64_t());
            }else if (json["writeMask"].is_int64_t()){
                writeMask=static_cast<uint32_t>(json["writeMask"].as_int64_t());
            }else{
                writeMask=static_cast<uint32_t>(json["writeMask"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilWriteMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilReference( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilReference\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSTENCILREFERENCE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){json["reference"]=static_cast<uint>(reference);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILREFERENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["reference"].is_uint64_t()){
                reference=static_cast<uint32_t>(json["reference"].as_uint64_t());
            }else if (json["reference"].is_int64_t()){
                reference=static_cast<uint32_t>(json["reference"].as_int64_t());
            }else{
                reference=static_cast<uint32_t>(json["reference"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilReference...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorSets( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorSets\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORSETS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=static_cast<uint>(firstSet);}();
[&](){json["descriptorSetCount"]=static_cast<uint>(descriptorSetCount);}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=json::vector();
            return; }auto arr_JZNsxgK=json::vector(descriptorSetCount);
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        json["pDescriptorSets"]=arr_JZNsxgK;}();
[&](){json["dynamicOffsetCount"]=static_cast<uint>(dynamicOffsetCount);}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=json::vector();
            return; }auto arr_Zetuxcc=json::vector(dynamicOffsetCount);
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=static_cast<uint>(pDynamicOffsets[nxuqgVF]);}();
        }
        json["pDynamicOffsets"]=arr_Zetuxcc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["firstSet"].is_uint64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_uint64_t());
            }else if (json["firstSet"].is_int64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_int64_t());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].as_double());
            }
            }();
[&](){
            if (json["descriptorSetCount"].is_uint64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_uint64_t());
            }else if (json["descriptorSetCount"].is_int64_t()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_int64_t());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].as_double());
            }
            }();

[&](){
            if (json["dynamicOffsetCount"].is_uint64_t()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_uint64_t());
            }else if (json["dynamicOffsetCount"].is_int64_t()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_int64_t());
            }else{
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdBindDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDINDEXBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){[&](){json["indexType"]=static_cast<int>(indexType);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_uint64_t());
            }else if (json["indexType"].is_int64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_int64_t());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDVERTEXBUFFERS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdBindVertexBuffers...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDraw\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAW);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=static_cast<uint>(vertexCount);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstVertex"]=static_cast<uint>(firstVertex);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["vertexCount"].is_uint64_t()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_uint64_t());
            }else if (json["vertexCount"].is_int64_t()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_int64_t());
            }else{
                vertexCount=static_cast<uint32_t>(json["vertexCount"].as_double());
            }
            }();
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
[&](){
            if (json["firstVertex"].is_uint64_t()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_uint64_t());
            }else if (json["firstVertex"].is_int64_t()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_int64_t());
            }else{
                firstVertex=static_cast<uint32_t>(json["firstVertex"].as_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();

debug_printf("Ending vkCmdDraw...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexed\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXED);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=static_cast<uint>(indexCount);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstIndex"]=static_cast<uint>(firstIndex);}();
[&](){json["vertexOffset"]=static_cast<int>(vertexOffset);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXED):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["indexCount"].is_uint64_t()){
                indexCount=static_cast<uint32_t>(json["indexCount"].as_uint64_t());
            }else if (json["indexCount"].is_int64_t()){
                indexCount=static_cast<uint32_t>(json["indexCount"].as_int64_t());
            }else{
                indexCount=static_cast<uint32_t>(json["indexCount"].as_double());
            }
            }();
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
[&](){
            if (json["firstIndex"].is_uint64_t()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_uint64_t());
            }else if (json["firstIndex"].is_int64_t()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_int64_t());
            }else{
                firstIndex=static_cast<uint32_t>(json["firstIndex"].as_double());
            }
            }();
[&](){
            if (json["vertexOffset"].is_uint64_t()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_uint64_t());
            }else if (json["vertexOffset"].is_int64_t()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_int64_t());
            }else{
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].as_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexed...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMULTIEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=json::vector();
            return; }auto arr_NmVssTF=json::vector(drawCount);
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexInfo[xJCsgzh]);
            arr_NmVssTF[xJCsgzh]=temp_map;
            return;
            }();
        }
        json["pVertexInfo"]=arr_NmVssTF;}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();

[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMultiEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiIndexedEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiIndexedEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMULTIINDEXEDEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=json::vector();
            return; }auto arr_OvAOCiL=json::vector(drawCount);
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIndexInfo[FmfkOAV]);
            arr_OvAOCiL[FmfkOAV]=temp_map;
            return;
            }();
        }
        json["pIndexInfo"]=arr_OvAOCiL;}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=json::vector();
            return; }auto arr_PavgIEG=json::vector(1);
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=static_cast<int>(pVertexOffset[PNvrUEs]);}();
        }
        json["pVertexOffset"]=arr_PavgIEG;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();

[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();


debug_printf("Ending vkCmdDrawMultiIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirect\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirect\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXEDINDIRECT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexedIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatch( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatch\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDISPATCH);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

debug_printf("Ending vkCmdDispatch...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchIndirect\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDISPATCHINDIRECT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDispatchIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSubpassShadingHUAWEI( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdSubpassShadingHUAWEI\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSUBPASSSHADINGHUAWEI);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSUBPASSSHADINGHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdSubpassShadingHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterHUAWEI( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterHUAWEI\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWCLUSTERHUAWEI);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawClusterHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterIndirectHUAWEI( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterIndirectHUAWEI\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWCLUSTERINDIRECTHUAWEI);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDrawClusterIndirectHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdatePipelineIndirectBufferNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdatePipelineIndirectBufferNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDUPDATEPIPELINEINDIRECTBUFFERNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdUpdatePipelineIndirectBufferNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_McSYWcQ=json::vector(regionCount);
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[IaMuFrO]);
            arr_McSYWcQ[IaMuFrO]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_McSYWcQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdCopyBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_HMPixWj=json::vector(regionCount);
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[TvxHvSV]);
            arr_HMPixWj[TvxHvSV]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_HMPixWj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdCopyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBLITIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_dQsoHhP=json::vector(regionCount);
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[YEXYPDJ]);
            arr_dQsoHhP[YEXYPDJ]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_dQsoHhP;}();
[&](){[&](){[&](){json["filter"]=static_cast<int>(filter);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();

[&](){[&](){int temp_DaCTyEq;[&](){
            if (json["filter"].is_uint64_t()){
                temp_DaCTyEq=static_cast<int>(json["filter"].as_uint64_t());
            }else if (json["filter"].is_int64_t()){
                temp_DaCTyEq=static_cast<int>(json["filter"].as_int64_t());
            }else{
                temp_DaCTyEq=static_cast<int>(json["filter"].as_double());
            }
            }();filter=(VkFilter)temp_DaCTyEq;}();}();

debug_printf("Ending vkCmdBlitImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFERTOIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_igZnVsu=json::vector(regionCount);
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[yuuZKOo]);
            arr_igZnVsu[yuuZKOo]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_igZnVsu;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdCopyBufferToImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGETOBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_igZnVsu=json::vector(regionCount);
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[yuuZKOo]);
            arr_igZnVsu[yuuZKOo]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_igZnVsu;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdCopyImageToBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryIndirectNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYINDIRECTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=static_cast<uint>(copyBufferAddress);}();}();
[&](){json["copyCount"]=static_cast<uint>(copyCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_uint64_t());
            }else if (json["copyBufferAddress"].is_int64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_int64_t());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){
            if (json["copyCount"].is_uint64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_uint64_t());
            }else if (json["copyCount"].is_int64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_int64_t());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdCopyMemoryIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToImageIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToImageIndirectNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOIMAGEINDIRECTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=static_cast<uint>(copyBufferAddress);}();}();
[&](){json["copyCount"]=static_cast<uint>(copyCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=json::vector();
            return; }auto arr_hVMAkcO=json::vector(copyCount);
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageSubresources[OfGHasS]);
            arr_hVMAkcO[OfGHasS]=temp_map;
            return;
            }();
        }
        json["pImageSubresources"]=arr_hVMAkcO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_uint64_t());
            }else if (json["copyBufferAddress"].is_int64_t()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_int64_t());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].as_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){
            if (json["copyCount"].is_uint64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_uint64_t());
            }else if (json["copyCount"].is_int64_t()){
                copyCount=static_cast<uint32_t>(json["copyCount"].as_int64_t());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();


debug_printf("Ending vkCmdCopyMemoryToImageIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdateBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdateBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDUPDATEBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["dataSize"]=static_cast<uint>(dataSize);}();}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(dataSize);
        for(int wgKJNeB=0; wgKJNeB < dataSize; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_SwYyzuh;[&](){
            if (json["dataSize"].is_uint64_t()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_int64_t());
            }else{
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].as_double());
            }
            }();dataSize=(VkDeviceSize)temp_SwYyzuh;}();


debug_printf("Ending vkCmdUpdateBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdFillBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data ){
//Will only be called by the client
debug_printf("Executing vkCmdFillBuffer\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDFILLBUFFER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){json["data"]=static_cast<uint>(data);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDFILLBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){
            if (json["data"].is_uint64_t()){
                data=static_cast<uint32_t>(json["data"].as_uint64_t());
            }else if (json["data"].is_int64_t()){
                data=static_cast<uint32_t>(json["data"].as_int64_t());
            }else{
                data=static_cast<uint32_t>(json["data"].as_double());
            }
            }();

debug_printf("Ending vkCmdFillBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearColorImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearColorImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCLEARCOLORIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=json::vector();
            return; }auto arr_SGRyjqE=json::vector(1);
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColor[ldPlUDi]);
            arr_SGRyjqE[ldPlUDi]=temp_map;
            return;
            }();
        }
        json["pColor"]=arr_SGRyjqE;}();
[&](){json["rangeCount"]=static_cast<uint>(rangeCount);}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=json::vector();
            return; }auto arr_BisbUqU=json::vector(rangeCount);
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRanges[IZgopUD]);
            arr_BisbUqU[IZgopUD]=temp_map;
            return;
            }();
        }
        json["pRanges"]=arr_BisbUqU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARCOLORIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){
            if (json["rangeCount"].is_uint64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_uint64_t());
            }else if (json["rangeCount"].is_int64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_int64_t());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdClearColorImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearDepthStencilImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearDepthStencilImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCLEARDEPTHSTENCILIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=json::vector();
            return; }auto arr_gYzlVps=json::vector(1);
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDepthStencil[jJUemfv]);
            arr_gYzlVps[jJUemfv]=temp_map;
            return;
            }();
        }
        json["pDepthStencil"]=arr_gYzlVps;}();
[&](){json["rangeCount"]=static_cast<uint>(rangeCount);}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=json::vector();
            return; }auto arr_BisbUqU=json::vector(rangeCount);
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRanges[IZgopUD]);
            arr_BisbUqU[IZgopUD]=temp_map;
            return;
            }();
        }
        json["pRanges"]=arr_BisbUqU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARDEPTHSTENCILIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){
            if (json["rangeCount"].is_uint64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_uint64_t());
            }else if (json["rangeCount"].is_int64_t()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_int64_t());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdClearDepthStencilImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearAttachments( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects ){
//Will only be called by the client
debug_printf("Executing vkCmdClearAttachments\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCLEARATTACHMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=json::vector();
            return; }auto arr_fOlilkR=json::vector(attachmentCount);
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAttachments[BsFiayf]);
            arr_fOlilkR[BsFiayf]=temp_map;
            return;
            }();
        }
        json["pAttachments"]=arr_fOlilkR;}();
[&](){json["rectCount"]=static_cast<uint>(rectCount);}();
[&](){
            if (pRects==NULL){
                json["pRects"]=json::vector();
            return; }auto arr_cgJwUFb=json::vector(rectCount);
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRects[HncrKEH]);
            arr_cgJwUFb[HncrKEH]=temp_map;
            return;
            }();
        }
        json["pRects"]=arr_cgJwUFb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARATTACHMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();

[&](){
            if (json["rectCount"].is_uint64_t()){
                rectCount=static_cast<uint32_t>(json["rectCount"].as_uint64_t());
            }else if (json["rectCount"].is_int64_t()){
                rectCount=static_cast<uint32_t>(json["rectCount"].as_int64_t());
            }else{
                rectCount=static_cast<uint32_t>(json["rectCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdClearAttachments...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDRESOLVEIMAGE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=static_cast<int>(srcImageLayout);}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=static_cast<int>(dstImageLayout);}();}();}();
[&](){json["regionCount"]=static_cast<uint>(regionCount);}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=json::vector();
            return; }auto arr_OGNZeww=json::vector(regionCount);
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRegions[UbqELUx]);
            arr_OGNZeww[UbqELUx]=temp_map;
            return;
            }();
        }
        json["pRegions"]=arr_OGNZeww;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_uint64_t());
            }else if (json["srcImageLayout"].is_int64_t()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_int64_t());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].as_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_uint64_t());
            }else if (json["dstImageLayout"].is_int64_t()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_int64_t());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].as_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_uint64_t());
            }else if (json["regionCount"].is_int64_t()){
                regionCount=static_cast<uint32_t>(json["regionCount"].as_int64_t());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdResolveImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdSetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDRESETEVENT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdResetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWAITEVENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=static_cast<uint>(eventCount);}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=json::vector();
            return; }auto arr_tUuyOPJ=json::vector(eventCount);
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        json["pEvents"]=arr_tUuyOPJ;}();
[&](){[&](){[&](){json["srcStageMask"]=static_cast<int>(srcStageMask);}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=static_cast<int>(dstStageMask);}();}();}();
[&](){json["memoryBarrierCount"]=static_cast<uint>(memoryBarrierCount);}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=json::vector();
            return; }auto arr_fXDYoDs=json::vector(memoryBarrierCount);
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryBarriers[JhnlCAW]);
            arr_fXDYoDs[JhnlCAW]=temp_map;
            return;
            }();
        }
        json["pMemoryBarriers"]=arr_fXDYoDs;}();
[&](){json["bufferMemoryBarrierCount"]=static_cast<uint>(bufferMemoryBarrierCount);}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=json::vector();
            return; }auto arr_FmJTDmX=json::vector(bufferMemoryBarrierCount);
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBufferMemoryBarriers[aFMQios]);
            arr_FmJTDmX[aFMQios]=temp_map;
            return;
            }();
        }
        json["pBufferMemoryBarriers"]=arr_FmJTDmX;}();
[&](){json["imageMemoryBarrierCount"]=static_cast<uint>(imageMemoryBarrierCount);}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=json::vector();
            return; }auto arr_nkkvvYR=json::vector(imageMemoryBarrierCount);
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageMemoryBarriers[trWYSmx]);
            arr_nkkvvYR[trWYSmx]=temp_map;
            return;
            }();
        }
        json["pImageMemoryBarriers"]=arr_nkkvvYR;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["eventCount"].is_uint64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_uint64_t());
            }else if (json["eventCount"].is_int64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_int64_t());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].as_double());
            }
            }();

[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_uint64_t());
            }else if (json["srcStageMask"].is_int64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_int64_t());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_uint64_t());
            }else if (json["dstStageMask"].is_int64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_int64_t());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){
            if (json["memoryBarrierCount"].is_uint64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_uint64_t());
            }else if (json["memoryBarrierCount"].is_int64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_int64_t());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_double());
            }
            }();

[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_uint64_t());
            }else if (json["bufferMemoryBarrierCount"].is_int64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_int64_t());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_double());
            }
            }();

[&](){
            if (json["imageMemoryBarrierCount"].is_uint64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_uint64_t());
            }else if (json["imageMemoryBarrierCount"].is_int64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_int64_t());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdWaitEvents...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier( VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPIPELINEBARRIER);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=static_cast<int>(srcStageMask);}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=static_cast<int>(dstStageMask);}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=static_cast<int>(dependencyFlags);}();}();}();
[&](){json["memoryBarrierCount"]=static_cast<uint>(memoryBarrierCount);}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=json::vector();
            return; }auto arr_fXDYoDs=json::vector(memoryBarrierCount);
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryBarriers[JhnlCAW]);
            arr_fXDYoDs[JhnlCAW]=temp_map;
            return;
            }();
        }
        json["pMemoryBarriers"]=arr_fXDYoDs;}();
[&](){json["bufferMemoryBarrierCount"]=static_cast<uint>(bufferMemoryBarrierCount);}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=json::vector();
            return; }auto arr_FmJTDmX=json::vector(bufferMemoryBarrierCount);
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBufferMemoryBarriers[aFMQios]);
            arr_FmJTDmX[aFMQios]=temp_map;
            return;
            }();
        }
        json["pBufferMemoryBarriers"]=arr_FmJTDmX;}();
[&](){json["imageMemoryBarrierCount"]=static_cast<uint>(imageMemoryBarrierCount);}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=json::vector();
            return; }auto arr_nkkvvYR=json::vector(imageMemoryBarrierCount);
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageMemoryBarriers[trWYSmx]);
            arr_nkkvvYR[trWYSmx]=temp_map;
            return;
            }();
        }
        json["pImageMemoryBarriers"]=arr_nkkvvYR;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_uint64_t());
            }else if (json["srcStageMask"].is_int64_t()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_int64_t());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].as_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_uint64_t());
            }else if (json["dstStageMask"].is_int64_t()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_int64_t());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].as_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){[&](){int temp_MJCELwI;[&](){
            if (json["dependencyFlags"].is_uint64_t()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_uint64_t());
            }else if (json["dependencyFlags"].is_int64_t()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_int64_t());
            }else{
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].as_double());
            }
            }();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
[&](){
            if (json["memoryBarrierCount"].is_uint64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_uint64_t());
            }else if (json["memoryBarrierCount"].is_int64_t()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_int64_t());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].as_double());
            }
            }();

[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_uint64_t());
            }else if (json["bufferMemoryBarrierCount"].is_int64_t()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_int64_t());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].as_double());
            }
            }();

[&](){
            if (json["imageMemoryBarrierCount"].is_uint64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_uint64_t());
            }else if (json["imageMemoryBarrierCount"].is_int64_t()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_int64_t());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdPipelineBarrier...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQuery\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINQUERY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

debug_printf("Ending vkCmdBeginQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQuery\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDQUERY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

debug_printf("Ending vkCmdEndQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginConditionalRenderingEXT( VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginConditionalRenderingEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINCONDITIONALRENDERINGEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=json::vector();
            return; }auto arr_guEoeuh=json::vector(1);
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pConditionalRenderingBegin[KETgcvj]);
            arr_guEoeuh[KETgcvj]=temp_map;
            return;
            }();
        }
        json["pConditionalRenderingBegin"]=arr_guEoeuh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndConditionalRenderingEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndConditionalRenderingEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDCONDITIONALRENDERINGEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetQueryPool( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkCmdResetQueryPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDRESETQUERYPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();

debug_printf("Ending vkCmdResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITETIMESTAMP);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=static_cast<int>(pipelineStage);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_uint64_t());
            }else if (json["pipelineStage"].is_int64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_int64_t());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteTimestamp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyQueryPoolResults( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyQueryPoolResults\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYQUERYPOOLRESULTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
[&](){json["queryCount"]=static_cast<uint>(queryCount);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){[&](){json["stride"]=static_cast<uint>(stride);}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_uint64_t());
            }else if (json["queryCount"].is_int64_t()){
                queryCount=static_cast<uint32_t>(json["queryCount"].as_int64_t());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].as_double());
            }
            }();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_int64_t());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].as_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_jzLjdpj=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

debug_printf("Ending vkCmdCopyQueryPoolResults...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPushConstants( VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues ){
//Will only be called by the client
debug_printf("Executing vkCmdPushConstants\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPUSHCONSTANTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=static_cast<int>(stageFlags);}();}();}();
[&](){json["offset"]=static_cast<uint>(offset);}();
[&](){json["size"]=static_cast<uint>(size);}();
[&](){
            if (pValues==NULL){
                json["pValues"]=json::vector();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=json::vector();
            return; }auto arr_xbuPmvw=json::vector(size);
        for(int vSvAlWQ=0; vSvAlWQ < size; vSvAlWQ++){
            [&](){arr_xbuPmvw[vSvAlWQ]=static_cast<uint>(((char*)(pValues))[vSvAlWQ]);}();
        }
        json["pValues"]=arr_xbuPmvw;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){[&](){int temp_oWGKgUV;[&](){
            if (json["stageFlags"].is_uint64_t()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_uint64_t());
            }else if (json["stageFlags"].is_int64_t()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_int64_t());
            }else{
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].as_double());
            }
            }();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
[&](){
            if (json["offset"].is_uint64_t()){
                offset=static_cast<uint32_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                offset=static_cast<uint32_t>(json["offset"].as_int64_t());
            }else{
                offset=static_cast<uint32_t>(json["offset"].as_double());
            }
            }();
[&](){
            if (json["size"].is_uint64_t()){
                size=static_cast<uint32_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                size=static_cast<uint32_t>(json["size"].as_int64_t());
            }else{
                size=static_cast<uint32_t>(json["size"].as_double());
            }
            }();


debug_printf("Ending vkCmdPushConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERPASS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=json::vector();
            return; }auto arr_XtnTubd=json::vector(1);
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderPassBegin[lCAvoJt]);
            arr_XtnTubd[lCAvoJt]=temp_map;
            return;
            }();
        }
        json["pRenderPassBegin"]=arr_XtnTubd;}();
[&](){[&](){[&](){json["contents"]=static_cast<int>(contents);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_uint64_t());
            }else if (json["contents"].is_int64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_int64_t());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].as_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdBeginRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass( VkCommandBuffer commandBuffer, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDNEXTSUBPASS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=static_cast<int>(contents);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_uint64_t());
            }else if (json["contents"].is_int64_t()){
                temp_pXPXcBB=static_cast<int>(json["contents"].as_int64_t());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].as_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdNextSubpass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDRENDERPASS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteCommands( VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteCommands\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDEXECUTECOMMANDS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=static_cast<uint>(commandBufferCount);}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=json::vector();
            return; }auto arr_PdRlpEO=json::vector(commandBufferCount);
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        json["pCommandBuffers"]=arr_PdRlpEO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTECOMMANDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["commandBufferCount"].is_uint64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_uint64_t());
            }else if (json["commandBufferCount"].is_int64_t()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_int64_t());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdExecuteCommands...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_jKVTjSh=json::vector(*pPropertyCount);
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[ULwTWiE]);
            arr_jKVTjSh[ULwTWiE]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_jKVTjSh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_jKVTjSh=json["pProperties"].as_vector();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            deserialize_struct(arr_jKVTjSh[ULwTWiE].as_map(),pProperties[ULwTWiE]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wMWMDOL;[&](){
            if (json["result"].is_uint64_t()){
                temp_wMWMDOL=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_wMWMDOL=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_wMWMDOL=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_wMWMDOL;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlanePropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_TBQSgXa=json::vector(*pPropertyCount);
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[yGKhOKS]);
            arr_TBQSgXa[yGKhOKS]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_TBQSgXa;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_TBQSgXa=json["pProperties"].as_vector();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            deserialize_struct(arr_TBQSgXa[yGKhOKS].as_map(),pProperties[yGKhOKS]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ltzLwWn;[&](){
            if (json["result"].is_uint64_t()){
                temp_ltzLwWn=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ltzLwWn=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ltzLwWn=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ltzLwWn;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlanePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneSupportedDisplaysKHR( VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneSupportedDisplaysKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=static_cast<uint>(planeIndex);}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=json::vector();
            return; }auto arr_HfQXIoE=json::vector(1);
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=static_cast<uint>(pDisplayCount[tJtenSc]);}();
        }
        json["pDisplayCount"]=arr_HfQXIoE;}();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=json::vector();
            return; }auto arr_zfKAWAH=json::vector(*pDisplayCount);
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        json["pDisplays"]=arr_zfKAWAH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["planeIndex"].is_uint64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_uint64_t());
            }else if (json["planeIndex"].is_int64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_int64_t());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_double());
            }
            }();
[&](){
            if (json["pDisplayCount"].as_vector().size()==0){
                pDisplayCount=NULL;
            return; }auto& arr_HfQXIoE=json["pDisplayCount"].as_vector();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){
            if (arr_HfQXIoE[tJtenSc].is_uint64_t()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_uint64_t());
            }else if (arr_HfQXIoE[tJtenSc].is_int64_t()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_int64_t());
            }else{
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pDisplays"].as_vector().size()==0){
                pDisplays=NULL;
            return; }auto& arr_zfKAWAH=json["pDisplays"].as_vector();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OikTSIm;[&](){
            if (json["result"].is_uint64_t()){
                temp_OikTSIm=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_OikTSIm=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_OikTSIm=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_OikTSIm;}();}();

debug_printf("Ending vkGetDisplayPlaneSupportedDisplaysKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneSupportedDisplaysKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModePropertiesKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModePropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDISPLAYMODEPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_kllbUBl=json::vector(*pPropertyCount);
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[MCBnXbq]);
            arr_kllbUBl[MCBnXbq]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_kllbUBl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_kllbUBl=json["pProperties"].as_vector();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            deserialize_struct(arr_kllbUBl[MCBnXbq].as_map(),pProperties[MCBnXbq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_LoZRfEp;[&](){
            if (json["result"].is_uint64_t()){
                temp_LoZRfEp=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LoZRfEp=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LoZRfEp=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LoZRfEp;}();}();

debug_printf("Ending vkGetDisplayModePropertiesKHR...\n");
debug_printf("Return value of vkGetDisplayModePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayModeKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayModeKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDISPLAYMODEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_mQflhNS=json::vector(1);
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[UOiSdEd]);
            arr_mQflhNS[UOiSdEd]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_mQflhNS;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMode==NULL){
                json["pMode"]=json::vector();
            return; }auto arr_CHqKWyT=json::vector(1);
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        json["pMode"]=arr_CHqKWyT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYMODEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pMode"].as_vector().size()==0){
                pMode=NULL;
            return; }auto& arr_CHqKWyT=json["pMode"].as_vector();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_kniGOao;[&](){
            if (json["result"].is_uint64_t()){
                temp_kniGOao=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_kniGOao=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_kniGOao=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_kniGOao;}();}();

                if (pMode!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMode[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayModeKHR...\n");
debug_printf("Return value of vkCreateDisplayModeKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilitiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANECAPABILITIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=static_cast<uint>(planeIndex);}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_HrzVMCr=json::vector(1);
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[aOxwnlc]);
            arr_HrzVMCr[aOxwnlc]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_HrzVMCr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
[&](){
            if (json["planeIndex"].is_uint64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_uint64_t());
            }else if (json["planeIndex"].is_int64_t()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_int64_t());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].as_double());
            }
            }();
[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }auto& arr_HrzVMCr=json["pCapabilities"].as_vector();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            deserialize_struct(arr_HrzVMCr[aOxwnlc].as_map(),pCapabilities[aOxwnlc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_zLZXATV;[&](){
            if (json["result"].is_uint64_t()){
                temp_zLZXATV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_zLZXATV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_zLZXATV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_zLZXATV;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayPlaneSurfaceKHR( VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayPlaneSurfaceKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDISPLAYPLANESURFACEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_pnrRUFC=json::vector(1);
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[KAVLDOd]);
            arr_pnrRUFC[KAVLDOd]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_pnrRUFC;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYPLANESURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_saNZXhN;[&](){
            if (json["result"].is_uint64_t()){
                temp_saNZXhN=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_saNZXhN=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_saNZXhN=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_saNZXhN;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayPlaneSurfaceKHR...\n");
debug_printf("Return value of vkCreateDisplayPlaneSurfaceKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSharedSwapchainsKHR( VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains ){
//Will only be called by the client
debug_printf("Executing vkCreateSharedSwapchainsKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESHAREDSWAPCHAINSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=static_cast<uint>(swapchainCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_GXhEUBn=json::vector(swapchainCount);
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[KSXdUUO]);
            arr_GXhEUBn[KSXdUUO]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_GXhEUBn;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=json::vector();
            return; }auto arr_UlEaWkU=json::vector(swapchainCount);
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        json["pSwapchains"]=arr_UlEaWkU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHAREDSWAPCHAINSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["swapchainCount"].is_uint64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_uint64_t());
            }else if (json["swapchainCount"].is_int64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_int64_t());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_double());
            }
            }();


[&](){
            if (json["pSwapchains"].as_vector().size()==0){
                pSwapchains=NULL;
            return; }auto& arr_UlEaWkU=json["pSwapchains"].as_vector();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_MTbyvky;[&](){
            if (json["result"].is_uint64_t()){
                temp_MTbyvky=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_MTbyvky=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_MTbyvky=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_MTbyvky;}();}();

                if (pSwapchains!=NULL){
                    for (int i=0; i<swapchainCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchains[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSharedSwapchainsKHR...\n");
debug_printf("Return value of vkCreateSharedSwapchainsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySurfaceKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSURFACEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();


debug_printf("Ending vkDestroySurfaceKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceSupportKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACESUPPORTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=json::vector();
            return; }auto arr_SEnYPHg=json::vector(1);
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=static_cast<uint>(pSupported[rAhuVoM]);}();}();
        }
        json["pSupported"]=arr_SEnYPHg;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSupported"].as_vector().size()==0){
                pSupported=NULL;
            return; }auto& arr_SEnYPHg=json["pSupported"].as_vector();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){
            if (arr_SEnYPHg[rAhuVoM].is_uint64_t()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_uint64_t());
            }else if (arr_SEnYPHg[rAhuVoM].is_int64_t()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_int64_t());
            }else{
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].as_double());
            }
            }();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LotRUeU;[&](){
            if (json["result"].is_uint64_t()){
                temp_LotRUeU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LotRUeU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LotRUeU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LotRUeU;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceSupportKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceSupportKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilitiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_mjTYhnS=json::vector(1);
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[MvYVwuP]);
            arr_mjTYhnS[MvYVwuP]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_mjTYhnS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }auto& arr_mjTYhnS=json["pSurfaceCapabilities"].as_vector();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            deserialize_struct(arr_mjTYhnS[MvYVwuP].as_map(),pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ItXtZre;[&](){
            if (json["result"].is_uint64_t()){
                temp_ItXtZre=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ItXtZre=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ItXtZre=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ItXtZre;}();}();
pSurfaceCapabilities->currentExtent=VkExtent2D{0xFFFFFFFF,0xFFFFFFFF};

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormatsKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormatsKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEFORMATSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=json::vector();
            return; }auto arr_mbQwRYl=json::vector(1);
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=static_cast<uint>(pSurfaceFormatCount[bFtFQKD]);}();
        }
        json["pSurfaceFormatCount"]=arr_mbQwRYl;}();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=json::vector();
            return; }auto arr_FttXsVA=json::vector(*pSurfaceFormatCount);
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceFormats[sioXabq]);
            arr_FttXsVA[sioXabq]=temp_map;
            return;
            }();
        }
        json["pSurfaceFormats"]=arr_FttXsVA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceFormatCount"].as_vector().size()==0){
                pSurfaceFormatCount=NULL;
            return; }auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_vector();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_uint64_t());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_int64_t());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].as_vector().size()==0){
                pSurfaceFormats=NULL;
            return; }auto& arr_FttXsVA=json["pSurfaceFormats"].as_vector();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            deserialize_struct(arr_FttXsVA[sioXabq].as_map(),pSurfaceFormats[sioXabq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_uuOhwVg;[&](){
            if (json["result"].is_uint64_t()){
                temp_uuOhwVg=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_uuOhwVg=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_uuOhwVg=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_uuOhwVg;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormatsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfacePresentModesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfacePresentModesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=json::vector();
            return; }auto arr_jrQQyxv=json::vector(1);
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=static_cast<uint>(pPresentModeCount[yThsxfd]);}();
        }
        json["pPresentModeCount"]=arr_jrQQyxv;}();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=json::vector();
            return; }auto arr_hrNyEFX=json::vector(*pPresentModeCount);
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=static_cast<int>(pPresentModes[ULOmMaK]);}();}();}();
        }
        json["pPresentModes"]=arr_hrNyEFX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pPresentModeCount"].as_vector().size()==0){
                pPresentModeCount=NULL;
            return; }auto& arr_jrQQyxv=json["pPresentModeCount"].as_vector();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){
            if (arr_jrQQyxv[yThsxfd].is_uint64_t()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_uint64_t());
            }else if (arr_jrQQyxv[yThsxfd].is_int64_t()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_int64_t());
            }else{
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPresentModes"].as_vector().size()==0){
                pPresentModes=NULL;
            return; }auto& arr_hrNyEFX=json["pPresentModes"].as_vector();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){
            if (arr_hrNyEFX[ULOmMaK].is_uint64_t()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_uint64_t());
            }else if (arr_hrNyEFX[ULOmMaK].is_int64_t()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_int64_t());
            }else{
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].as_double());
            }
            }();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vbOoAvY;[&](){
            if (json["result"].is_uint64_t()){
                temp_vbOoAvY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vbOoAvY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vbOoAvY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vbOoAvY;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSwapchainKHR( VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain ){
//Will only be called by the client
debug_printf("Executing vkCreateSwapchainKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESWAPCHAINKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{

        VkSwapchainCreateInfoKHR temp_info=*pCreateInfo;
        
        temp_info.imageUsage|=VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        
        auto pCreateInfo=&temp_info;
        
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_egkAfIq=json::vector(1);
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[RzLCOHt]);
            arr_egkAfIq[RzLCOHt]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_egkAfIq;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=json::vector();
            return; }auto arr_vaTnpgr=json::vector(1);
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        json["pSwapchain"]=arr_vaTnpgr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSwapchain"].as_vector().size()==0){
                pSwapchain=NULL;
            return; }auto& arr_vaTnpgr=json["pSwapchain"].as_vector();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zHrmoVe;[&](){
            if (json["result"].is_uint64_t()){
                temp_zHrmoVe=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_zHrmoVe=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_zHrmoVe=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_zHrmoVe;}();}();

        auto& imageExtent1=json["pCreateInfo"].as_vector()[0].as_map().at("imageExtent").as_map();
        debug_printf("Swapchain extent: %d, %d\n", static_cast<uint32_t>(imageExtent1.at("width").as_uint64_t()), imageExtent1.at("height").as_uint64_t());
        debug_printf("Swapchain extent: %d, %d\n", pCreateInfo->imageExtent.width, pCreateInfo->imageExtent.height);
        

                if (pSwapchain!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchain[i])]=parent;
                    }
                }
                
registerSwapchain(*pSwapchain,device, pCreateInfo);

debug_printf("Ending vkCreateSwapchainKHR...\n");
debug_printf("Return value of vkCreateSwapchainKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySwapchainKHR( VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySwapchainKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSWAPCHAINKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();


debug_printf("Ending vkDestroySwapchainKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainImagesKHR( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainImagesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSWAPCHAINIMAGESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=json::vector();
            return; }auto arr_fUdbkNA=json::vector(1);
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=static_cast<uint>(pSwapchainImageCount[YVmxCel]);}();
        }
        json["pSwapchainImageCount"]=arr_fUdbkNA;}();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=json::vector();
            return; }auto arr_KNYDiQo=json::vector(*pSwapchainImageCount);
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        json["pSwapchainImages"]=arr_KNYDiQo;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINIMAGESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pSwapchainImageCount"].as_vector().size()==0){
                pSwapchainImageCount=NULL;
            return; }auto& arr_fUdbkNA=json["pSwapchainImageCount"].as_vector();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){
            if (arr_fUdbkNA[YVmxCel].is_uint64_t()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_uint64_t());
            }else if (arr_fUdbkNA[YVmxCel].is_int64_t()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_int64_t());
            }else{
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSwapchainImages"].as_vector().size()==0){
                pSwapchainImages=NULL;
            return; }auto& arr_KNYDiQo=json["pSwapchainImages"].as_vector();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RTeqDCy;[&](){
            if (json["result"].is_uint64_t()){
                temp_RTeqDCy=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_RTeqDCy=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_RTeqDCy=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_RTeqDCy;}();}();

debug_printf("Ending vkGetSwapchainImagesKHR...\n");
debug_printf("Return value of vkGetSwapchainImagesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImageKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImageKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKACQUIRENEXTIMAGEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=json::vector();
            return; }auto arr_oSqpNfH=json::vector(1);
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=static_cast<uint>(pImageIndex[BEjuBtR]);}();
        }
        json["pImageIndex"]=arr_oSqpNfH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
[&](){
            if (json["pImageIndex"].as_vector().size()==0){
                pImageIndex=NULL;
            return; }auto& arr_oSqpNfH=json["pImageIndex"].as_vector();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_uint64_t());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_int64_t());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wzTITSb;[&](){
            if (json["result"].is_uint64_t()){
                temp_wzTITSb=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_wzTITSb=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_wzTITSb=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_wzTITSb;}();}();

debug_printf("Ending vkAcquireNextImageKHR...\n");
debug_printf("Return value of vkAcquireNextImageKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR* pPresentInfo ){
//Will only be called by the client
debug_printf("Executing vkQueuePresentKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEPRESENTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{

        auto new_info=(VkPresentInfoKHR*)copyVkStruct(pPresentInfo);
        
        auto parent_struct=(StreamStructure*)new_info;
        void* curr_struct=copyVkStruct(parent_struct->pNext);
        VkSwapchainPresentFenceInfoEXT* swapchain_fence_info=NULL;
        
        while(curr_struct!=NULL){
            parent_struct->pNext=curr_struct;
            if (((StreamStructure*)curr_struct)->sType==VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT){
                swapchain_fence_info=(VkSwapchainPresentFenceInfoEXT*)curr_struct;
            }
            parent_struct=(StreamStructure*)curr_struct;
            curr_struct=copyVkStruct(parent_struct->pNext);
        }
            
         if (swapchain_fence_info==NULL){
            swapchain_fence_info=new VkSwapchainPresentFenceInfoEXT;
            swapchain_fence_info->sType=VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT;
            swapchain_fence_info->pNext=NULL;
            swapchain_fence_info->swapchainCount=0;
            swapchain_fence_info->pFences=NULL;
            parent_struct->pNext=swapchain_fence_info;
         }
         
         auto old_count=swapchain_fence_info->swapchainCount;
         auto fences_list=(VkFence*)memdup(swapchain_fence_info->pFences,old_count*sizeof(VkFence));
         
         swapchain_fence_info->swapchainCount=new_info->swapchainCount;
         auto new_count=swapchain_fence_info->swapchainCount;
         fences_list=(VkFence*)realloc(fences_list,new_count*sizeof(VkFence));
         swapchain_fence_info->pFences=fences_list;
         
         auto fence_create_info=VkFenceCreateInfo{
         .sType=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
         .pNext=NULL,
         .flags=0
         };
         
         for (int i=0; i< new_count; i++){
            if ((i>= old_count) || (fences_list[i]==VK_NULL_HANDLE)){
                vkCreateFence(swapchain_to_device[(uintptr_t)(new_info->pSwapchains[i])],&fence_create_info, NULL, &(fences_list[i]));
            }
            
            pushToQueue(fences_list[i], pPresentInfo->pSwapchains[i], pPresentInfo->pImageIndices[i]);
         }
         
         VkPresentInfoKHR* pPresentInfo=new_info;
        
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=json::vector();
            return; }auto arr_EyhZHrS=json::vector(1);
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPresentInfo[EKHdNlu]);
            arr_EyhZHrS[EKHdNlu]=temp_map;
            return;
            }();
        }
        json["pPresentInfo"]=arr_EyhZHrS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();

VkResult result;
[&](){[&](){int temp_csTKlYw;[&](){
            if (json["result"].is_uint64_t()){
                temp_csTKlYw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_csTKlYw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_csTKlYw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_csTKlYw;}();}();

debug_printf("Ending vkQueuePresentKHR...\n");
debug_printf("Return value of vkQueuePresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXlibSurfaceKHR( VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXlibSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xlib);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXlibPresentationSupportKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (dpy==NULL){
                json["dpy"]=json::vector();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
[&](){
            if (json["dpy"].as_vector().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(json["dpy"].as_uint64_t());}();
[&](){visualID=(VisualID )(json["visualID"].as_uint64_t());}();
VkBool32 result;
[&](){uint32_t temp_hXhCCrN;[&](){
            if (json["result"].is_uint64_t()){
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].as_int64_t());
            }else{
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].as_double());
            }
            }();result=(VkBool32)temp_hXhCCrN;}();

debug_printf("Ending vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXcbSurfaceKHR( VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXcbSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xcb);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXcbPresentationSupportKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (connection==NULL){
                json["connection"]=json::vector();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
[&](){
            if (json["connection"].as_vector().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(json["connection"].as_uint64_t());}();
[&](){visual_id=(xcb_visualid_t )(json["visual_id"].as_uint64_t());}();
VkBool32 result;
[&](){uint32_t temp_TsntsfC;[&](){
            if (json["result"].is_uint64_t()){
                temp_TsntsfC=static_cast<uint32_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TsntsfC=static_cast<uint32_t>(json["result"].as_int64_t());
            }else{
                temp_TsntsfC=static_cast<uint32_t>(json["result"].as_double());
            }
            }();result=(VkBool32)temp_TsntsfC;}();

debug_printf("Ending vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugReportCallbackEXT( VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugReportCallbackEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDEBUGREPORTCALLBACKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_YvgjHhM=json::vector(1);
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[BsRBklZ]);
            arr_YvgjHhM[BsRBklZ]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_YvgjHhM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=json::vector();
            return; }auto arr_qwLilWz=json::vector(1);
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        json["pCallback"]=arr_qwLilWz;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pCallback"].as_vector().size()==0){
                pCallback=NULL;
            return; }auto& arr_qwLilWz=json["pCallback"].as_vector();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KbUnynS;[&](){
            if (json["result"].is_uint64_t()){
                temp_KbUnynS=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_KbUnynS=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_KbUnynS=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_KbUnynS;}();}();

                if (pCallback!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCallback[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugReportCallbackEXT...\n");
debug_printf("Return value of vkCreateDebugReportCallbackEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugReportCallbackEXT( VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugReportCallbackEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDEBUGREPORTCALLBACKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();


debug_printf("Ending vkDestroyDebugReportCallbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkDebugReportMessageEXT( VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage ){
//Will only be called by the client
debug_printf("Executing vkDebugReportMessageEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDEBUGREPORTMESSAGEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["object"]=static_cast<uint>(object);}();
[&](){json["location"]=static_cast<int>(location);}();
[&](){json["messageCode"]=static_cast<int>(messageCode);}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=json::vector();
            return; }auto arr_SZVAgkt=json::vector(strlen(pLayerPrefix)+1);
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=static_cast<uint>(pLayerPrefix[ESuRCqF]);}();
        }
        json["pLayerPrefix"]=arr_SZVAgkt;}();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=json::vector();
            return; }auto arr_rGBBIki=json::vector(strlen(pMessage)+1);
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=static_cast<uint>(pMessage[ZYKcZZQ]);}();
        }
        json["pMessage"]=arr_rGBBIki;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGREPORTMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_tiROuYA;[&](){
            if (json["flags"].is_uint64_t()){
                temp_tiROuYA=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_tiROuYA=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_tiROuYA=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
[&](){[&](){int temp_rGtGMFh;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_rGtGMFh=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
[&](){
            if (json["object"].is_uint64_t()){
                object=static_cast<uint64_t>(json["object"].as_uint64_t());
            }else if (json["object"].is_int64_t()){
                object=static_cast<uint64_t>(json["object"].as_int64_t());
            }else{
                object=static_cast<uint64_t>(json["object"].as_double());
            }
            }();
[&](){
            if (json["location"].is_uint64_t()){
                location=static_cast<size_t>(json["location"].as_uint64_t());
            }else if (json["location"].is_int64_t()){
                location=static_cast<size_t>(json["location"].as_int64_t());
            }else{
                location=static_cast<size_t>(json["location"].as_double());
            }
            }();
[&](){
            if (json["messageCode"].is_uint64_t()){
                messageCode=static_cast<int32_t>(json["messageCode"].as_uint64_t());
            }else if (json["messageCode"].is_int64_t()){
                messageCode=static_cast<int32_t>(json["messageCode"].as_int64_t());
            }else{
                messageCode=static_cast<int32_t>(json["messageCode"].as_double());
            }
            }();



debug_printf("Ending vkDebugReportMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectNameEXT( VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectNameEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDEBUGMARKERSETOBJECTNAMEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=json::vector();
            return; }auto arr_WQmILKl=json::vector(1);
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pNameInfo[VlhHang]);
            arr_WQmILKl[VlhHang]=temp_map;
            return;
            }();
        }
        json["pNameInfo"]=arr_WQmILKl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_VfBgOIt;[&](){
            if (json["result"].is_uint64_t()){
                temp_VfBgOIt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VfBgOIt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VfBgOIt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VfBgOIt;}();}();

debug_printf("Ending vkDebugMarkerSetObjectNameEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectTagEXT( VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectTagEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDEBUGMARKERSETOBJECTTAGEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=json::vector();
            return; }auto arr_uESKIxS=json::vector(1);
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTagInfo[fibGciH]);
            arr_uESKIxS[fibGciH]=temp_map;
            return;
            }();
        }
        json["pTagInfo"]=arr_uESKIxS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ZCuJyoB;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZCuJyoB=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZCuJyoB=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZCuJyoB=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZCuJyoB;}();}();

debug_printf("Ending vkDebugMarkerSetObjectTagEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerBeginEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerBeginEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERBEGINEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_sUKpmoY=json::vector(1);
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[MSMqdqs]);
            arr_sUKpmoY[MSMqdqs]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_sUKpmoY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERBEGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerBeginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerEndEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerEndEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERENDEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERENDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdDebugMarkerEndEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerInsertEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerInsertEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDEBUGMARKERINSERTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_sUKpmoY=json::vector(1);
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[MSMqdqs]);
            arr_sUKpmoY[MSMqdqs]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_sUKpmoY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERINSERTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerInsertEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalImageFormatPropertiesNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){[&](){[&](){json["type"]=static_cast<int>(type);}();}();}();
[&](){[&](){[&](){json["tiling"]=static_cast<int>(tiling);}();}();}();
[&](){[&](){[&](){json["usage"]=static_cast<int>(usage);}();}();}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=static_cast<int>(externalHandleType);}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=json::vector();
            return; }auto arr_gXHGwln=json::vector(1);
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalImageFormatProperties[CfNLqMF]);
            arr_gXHGwln[CfNLqMF]=temp_map;
            return;
            }();
        }
        json["pExternalImageFormatProperties"]=arr_gXHGwln;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_uint64_t());
            }else if (json["type"].is_int64_t()){
                temp_bMZuPlo=static_cast<int>(json["type"].as_int64_t());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].as_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_uint64_t());
            }else if (json["tiling"].is_int64_t()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_int64_t());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].as_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_uint64_t());
            }else if (json["usage"].is_int64_t()){
                temp_sXuQFYv=static_cast<int>(json["usage"].as_int64_t());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].as_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_LpOHWxp=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){[&](){int temp_DSfbDyM;[&](){
            if (json["externalHandleType"].is_uint64_t()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_uint64_t());
            }else if (json["externalHandleType"].is_int64_t()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_int64_t());
            }else{
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].as_double());
            }
            }();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
[&](){
            if (json["pExternalImageFormatProperties"].as_vector().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }auto& arr_gXHGwln=json["pExternalImageFormatProperties"].as_vector();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            deserialize_struct(arr_gXHGwln[CfNLqMF].as_map(),pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_vEkPnlL;[&](){
            if (json["result"].is_uint64_t()){
                temp_vEkPnlL=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vEkPnlL=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vEkPnlL=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vEkPnlL;}();}();

debug_printf("Ending vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceExternalImageFormatPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteGeneratedCommandsNV( VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteGeneratedCommandsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDEXECUTEGENERATEDCOMMANDSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=static_cast<uint>(isPreprocessed);}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=json::vector();
            return; }auto arr_mvZtJqS=json::vector(1);
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGeneratedCommandsInfo[breVZQP]);
            arr_mvZtJqS[breVZQP]=temp_map;
            return;
            }();
        }
        json["pGeneratedCommandsInfo"]=arr_mvZtJqS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_tPMaOPc;[&](){
            if (json["isPreprocessed"].is_uint64_t()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_uint64_t());
            }else if (json["isPreprocessed"].is_int64_t()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_int64_t());
            }else{
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].as_double());
            }
            }();isPreprocessed=(VkBool32)temp_tPMaOPc;}();


debug_printf("Ending vkCmdExecuteGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPreprocessGeneratedCommandsNV( VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPreprocessGeneratedCommandsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPREPROCESSGENERATEDCOMMANDSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=json::vector();
            return; }auto arr_mvZtJqS=json::vector(1);
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGeneratedCommandsInfo[breVZQP]);
            arr_mvZtJqS[breVZQP]=temp_map;
            return;
            }();
        }
        json["pGeneratedCommandsInfo"]=arr_mvZtJqS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPreprocessGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipelineShaderGroupNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipelineShaderGroupNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDPIPELINESHADERGROUPNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=static_cast<uint>(groupIndex);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINESHADERGROUPNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["groupIndex"].is_uint64_t()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_uint64_t());
            }else if (json["groupIndex"].is_int64_t()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_int64_t());
            }else{
                groupIndex=static_cast<uint32_t>(json["groupIndex"].as_double());
            }
            }();

debug_printf("Ending vkCmdBindPipelineShaderGroupNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetGeneratedCommandsMemoryRequirementsNV( VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetGeneratedCommandsMemoryRequirementsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_bVjZkmU=json::vector(1);
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[suoLDtj]);
            arr_bVjZkmU[suoLDtj]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_bVjZkmU;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetGeneratedCommandsMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateIndirectCommandsLayoutNV( VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateIndirectCommandsLayoutNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEINDIRECTCOMMANDSLAYOUTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_EQPGiEt=json::vector(1);
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TPVCKbG]);
            arr_EQPGiEt[TPVCKbG]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_EQPGiEt;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=json::vector();
            return; }auto arr_lGdEoyU=json::vector(1);
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        json["pIndirectCommandsLayout"]=arr_lGdEoyU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pIndirectCommandsLayout"].as_vector().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].as_vector();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pvQcinN;[&](){
            if (json["result"].is_uint64_t()){
                temp_pvQcinN=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_pvQcinN=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_pvQcinN=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_pvQcinN;}();}();

                if (pIndirectCommandsLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pIndirectCommandsLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateIndirectCommandsLayoutNV...\n");
debug_printf("Return value of vkCreateIndirectCommandsLayoutNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyIndirectCommandsLayoutNV( VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyIndirectCommandsLayoutNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYINDIRECTCOMMANDSLAYOUTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();


debug_printf("Ending vkDestroyIndirectCommandsLayoutNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFEATURES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=json::vector();
            return; }auto arr_QUwriqy=json::vector(1);
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFeatures[AlewVZE]);
            arr_QUwriqy[AlewVZE]=temp_map;
            return;
            }();
        }
        json["pFeatures"]=arr_QUwriqy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].as_vector().size()==0){
                pFeatures=NULL;
            return; }auto& arr_QUwriqy=json["pFeatures"].as_vector();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            deserialize_struct(arr_QUwriqy[AlewVZE].as_map(),pFeatures[AlewVZE]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
return vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oZVBLox=json::vector(1);
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[pxUpVYV]);
            arr_oZVBLox[pxUpVYV]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oZVBLox;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_oZVBLox=json["pProperties"].as_vector();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            deserialize_struct(arr_oZVBLox[pxUpVYV].as_map(),pProperties[pxUpVYV]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
return vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFORMATPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=static_cast<int>(format);}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=json::vector();
            return; }auto arr_RNYTnLU=json::vector(1);
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatProperties[VZFdkqX]);
            arr_RNYTnLU[VZFdkqX]=temp_map;
            return;
            }();
        }
        json["pFormatProperties"]=arr_RNYTnLU;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_uint64_t());
            }else if (json["format"].is_int64_t()){
                temp_MKJOJVI=static_cast<int>(json["format"].as_int64_t());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].as_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].as_vector().size()==0){
                pFormatProperties=NULL;
            return; }auto& arr_RNYTnLU=json["pFormatProperties"].as_vector();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            deserialize_struct(arr_RNYTnLU[VZFdkqX].as_map(),pFormatProperties[VZFdkqX]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2KHR( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
return vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=json::vector();
            return; }auto arr_MpVGyYe=json::vector(1);
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatInfo[YAeYFEt]);
            arr_MpVGyYe[YAeYFEt]=temp_map;
            return;
            }();
        }
        json["pImageFormatInfo"]=arr_MpVGyYe;}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_wmAZzRc=json::vector(1);
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[NQfBHSv]);
            arr_wmAZzRc[NQfBHSv]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_wmAZzRc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }auto& arr_wmAZzRc=json["pImageFormatProperties"].as_vector();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            deserialize_struct(arr_wmAZzRc[NQfBHSv].as_map(),pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_TYPijbq;[&](){
            if (json["result"].is_uint64_t()){
                temp_TYPijbq=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TYPijbq=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_TYPijbq=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_TYPijbq;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties2...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
return vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=json::vector();
            return; }auto arr_tzRlmPf=json::vector(1);
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=static_cast<uint>(pQueueFamilyPropertyCount[cPKCUxv]);}();
        }
        json["pQueueFamilyPropertyCount"]=arr_tzRlmPf;}();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=json::vector();
            return; }auto arr_NqmNsHw=json::vector(*pQueueFamilyPropertyCount);
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueFamilyProperties[UxEWlik]);
            arr_NqmNsHw[UxEWlik]=temp_map;
            return;
            }();
        }
        json["pQueueFamilyProperties"]=arr_NqmNsHw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].as_vector().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].as_vector();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_uint64_t());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64_t()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_int64_t());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].as_vector().size()==0){
                pQueueFamilyProperties=NULL;
            return; }auto& arr_NqmNsHw=json["pQueueFamilyProperties"].as_vector();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            deserialize_struct(arr_NqmNsHw[UxEWlik].as_map(),pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
return vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMEMORYPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=json::vector();
            return; }auto arr_nJXNYGt=json::vector(1);
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryProperties[tFDFCkf]);
            arr_nJXNYGt[tFDFCkf]=temp_map;
            return;
            }();
        }
        json["pMemoryProperties"]=arr_nJXNYGt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].as_vector().size()==0){
                pMemoryProperties=NULL;
            return; }auto& arr_nJXNYGt=json["pMemoryProperties"].as_vector();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            deserialize_struct(arr_nJXNYGt[tFDFCkf].as_map(),pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
return vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=json::vector();
            return; }auto arr_nZOUWlt=json::vector(1);
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFormatInfo[cvknnOe]);
            arr_nZOUWlt[cvknnOe]=temp_map;
            return;
            }();
        }
        json["pFormatInfo"]=arr_nZOUWlt;}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_YaLkATe=json::vector(*pPropertyCount);
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[lIrIGCv]);
            arr_YaLkATe[lIrIGCv]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_YaLkATe;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_YaLkATe=json["pProperties"].as_vector();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            deserialize_struct(arr_YaLkATe[lIrIGCv].as_map(),pProperties[lIrIGCv]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
return vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetKHR( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPUSHDESCRIPTORSETKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();
[&](){json["descriptorWriteCount"]=static_cast<uint>(descriptorWriteCount);}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=json::vector();
            return; }auto arr_AuOrFWk=json::vector(descriptorWriteCount);
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorWrites[qJACxKx]);
            arr_AuOrFWk[qJACxKx]=temp_map;
            return;
            }();
        }
        json["pDescriptorWrites"]=arr_AuOrFWk;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();
[&](){
            if (json["descriptorWriteCount"].is_uint64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_uint64_t());
            }else if (json["descriptorWriteCount"].is_int64_t()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_int64_t());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdPushDescriptorSetKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
//Will only be called by the client
debug_printf("Executing vkTrimCommandPool\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKTRIMCOMMANDPOOL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRIMCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_FGvozFl;[&](){
            if (json["flags"].is_uint64_t()){
                temp_FGvozFl=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_FGvozFl=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_FGvozFl=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

debug_printf("Ending vkTrimCommandPool...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPoolKHR( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
return vkTrimCommandPool(device, commandPool, flags);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalBufferProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=json::vector();
            return; }auto arr_VbIxQJg=json::vector(1);
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalBufferInfo[XeSwNaV]);
            arr_VbIxQJg[XeSwNaV]=temp_map;
            return;
            }();
        }
        json["pExternalBufferInfo"]=arr_VbIxQJg;}();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=json::vector();
            return; }auto arr_oXzExYk=json::vector(1);
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalBufferProperties[ufvutei]);
            arr_oXzExYk[ufvutei]=temp_map;
            return;
            }();
        }
        json["pExternalBufferProperties"]=arr_oXzExYk;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalBufferProperties"].as_vector().size()==0){
                pExternalBufferProperties=NULL;
            return; }auto& arr_oXzExYk=json["pExternalBufferProperties"].as_vector();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            deserialize_struct(arr_oXzExYk[ufvutei].as_map(),pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalBufferProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
return vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdKHR( VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETMEMORYFDKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_imCbcqk=json::vector(1);
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[oZoTEJx]);
            arr_imCbcqk[oZoTEJx]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_imCbcqk;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_koObBcU;[&](){
            if (json["result"].is_uint64_t()){
                temp_koObBcU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_koObBcU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_koObBcU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_koObBcU;}();}();

debug_printf("Ending vkGetMemoryFdKHR...\n");
debug_printf("Return value of vkGetMemoryFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdPropertiesKHR( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETMEMORYFDPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=static_cast<int>(handleType);}();}();}();
[&](){json["fd"]=static_cast<int>(fd);}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=json::vector();
            return; }auto arr_tzzZhYk=json::vector(1);
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryFdProperties[UpKTZRJ]);
            arr_tzzZhYk[UpKTZRJ]=temp_map;
            return;
            }();
        }
        json["pMemoryFdProperties"]=arr_tzzZhYk;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_uint64_t());
            }else if (json["handleType"].is_int64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_int64_t());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
[&](){
            if (json["fd"].is_uint64_t()){
                fd=static_cast<int>(json["fd"].as_uint64_t());
            }else if (json["fd"].is_int64_t()){
                fd=static_cast<int>(json["fd"].as_int64_t());
            }else{
                fd=static_cast<int>(json["fd"].as_double());
            }
            }();
[&](){
            if (json["pMemoryFdProperties"].as_vector().size()==0){
                pMemoryFdProperties=NULL;
            return; }auto& arr_tzzZhYk=json["pMemoryFdProperties"].as_vector();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            deserialize_struct(arr_tzzZhYk[UpKTZRJ].as_map(),pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HRcPPmY;[&](){
            if (json["result"].is_uint64_t()){
                temp_HRcPPmY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HRcPPmY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HRcPPmY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HRcPPmY;}();}();

debug_printf("Ending vkGetMemoryFdPropertiesKHR...\n");
debug_printf("Return value of vkGetMemoryFdPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryRemoteAddressNV( VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryRemoteAddressNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETMEMORYREMOTEADDRESSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=json::vector();
            return; }auto arr_JYmQngD=json::vector(1);
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryGetRemoteAddressInfo[tlzypUU]);
            arr_JYmQngD[tlzypUU]=temp_map;
            return;
            }();
        }
        json["pMemoryGetRemoteAddressInfo"]=arr_JYmQngD;}();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=json::vector();
            return; }auto arr_LTIxmQF=json::vector(1);
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=json::vector();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=json::vector();
            return; }auto arr_FUzakvN=json::vector(strlen(((char*)(pAddress[LIvckbR])))+1);
        for(int lBwzqzO=0; lBwzqzO < strlen(((char*)(pAddress[LIvckbR])))+1; lBwzqzO++){
            [&](){arr_FUzakvN[lBwzqzO]=static_cast<uint>(((char*)(pAddress[LIvckbR]))[lBwzqzO]);}();
        }
        arr_LTIxmQF[LIvckbR]=arr_FUzakvN;}();}();}();
        }
        json["pAddress"]=arr_LTIxmQF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYREMOTEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pAddress"].as_vector().size()==0){
                pAddress=NULL;
            return; }auto& arr_LTIxmQF=json["pAddress"].as_vector();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].as_vector().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].as_vector().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].as_vector().size()*sizeof(char));auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].as_vector();
        for(int lBwzqzO=0; lBwzqzO < arr_LTIxmQF[LIvckbR].as_vector().size(); lBwzqzO++){
            [&](){
            if (arr_FUzakvN[lBwzqzO].is_uint64_t()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_uint64_t());
            }else if (arr_FUzakvN[lBwzqzO].is_int64_t()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_int64_t());
            }else{
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].as_double());
            }
            }();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GmMstTE;[&](){
            if (json["result"].is_uint64_t()){
                temp_GmMstTE=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_GmMstTE=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_GmMstTE=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_GmMstTE;}();}();

debug_printf("Ending vkGetMemoryRemoteAddressNV...\n");
debug_printf("Return value of vkGetMemoryRemoteAddressNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalSemaphoreProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=json::vector();
            return; }auto arr_qgIgkyH=json::vector(1);
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalSemaphoreInfo[VMbMUUS]);
            arr_qgIgkyH[VMbMUUS]=temp_map;
            return;
            }();
        }
        json["pExternalSemaphoreInfo"]=arr_qgIgkyH;}();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=json::vector();
            return; }auto arr_yLCjbDt=json::vector(1);
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalSemaphoreProperties[rKjPzGR]);
            arr_yLCjbDt[rKjPzGR]=temp_map;
            return;
            }();
        }
        json["pExternalSemaphoreProperties"]=arr_yLCjbDt;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalSemaphoreProperties"].as_vector().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].as_vector();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            deserialize_struct(arr_yLCjbDt[rKjPzGR].as_map(),pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
return vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreFdKHR( VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreFdKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSEMAPHOREFDKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_fyTHWII=json::vector(1);
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[dBynwwO]);
            arr_fyTHWII[dBynwwO]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_fyTHWII;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_VbFkwnE;[&](){
            if (json["result"].is_uint64_t()){
                temp_VbFkwnE=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VbFkwnE=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VbFkwnE=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VbFkwnE;}();}();

debug_printf("Ending vkGetSemaphoreFdKHR...\n");
debug_printf("Return value of vkGetSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportSemaphoreFdKHR( VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportSemaphoreFdKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKIMPORTSEMAPHOREFDKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=json::vector();
            return; }auto arr_vWNEWeX=json::vector(1);
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImportSemaphoreFdInfo[kfpLCyT]);
            arr_vWNEWeX[kfpLCyT]=temp_map;
            return;
            }();
        }
        json["pImportSemaphoreFdInfo"]=arr_vWNEWeX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_cakEtRs;[&](){
            if (json["result"].is_uint64_t()){
                temp_cakEtRs=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_cakEtRs=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_cakEtRs=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_cakEtRs;}();}();

debug_printf("Ending vkImportSemaphoreFdKHR...\n");
debug_printf("Return value of vkImportSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalFenceProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=json::vector();
            return; }auto arr_DSVeGvM=json::vector(1);
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalFenceInfo[ApMvCYQ]);
            arr_DSVeGvM[ApMvCYQ]=temp_map;
            return;
            }();
        }
        json["pExternalFenceInfo"]=arr_DSVeGvM;}();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=json::vector();
            return; }auto arr_nPbItsj=json::vector(1);
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExternalFenceProperties[VoSEUdo]);
            arr_nPbItsj[VoSEUdo]=temp_map;
            return;
            }();
        }
        json["pExternalFenceProperties"]=arr_nPbItsj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalFenceProperties"].as_vector().size()==0){
                pExternalFenceProperties=NULL;
            return; }auto& arr_nPbItsj=json["pExternalFenceProperties"].as_vector();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            deserialize_struct(arr_nPbItsj[VoSEUdo].as_map(),pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalFenceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFencePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
return vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceFdKHR( VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetFenceFdKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETFENCEFDKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=json::vector();
            return; }auto arr_mgmOmEV=json::vector(1);
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pGetFdInfo[DYSusBe]);
            arr_mgmOmEV[DYSusBe]=temp_map;
            return;
            }();
        }
        json["pGetFdInfo"]=arr_mgmOmEV;}();
[&](){
            if (pFd==NULL){
                json["pFd"]=json::vector();
            return; }auto arr_iYlwGBh=json::vector(1);
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=static_cast<int>(pFd[ENGggcC]);}();
        }
        json["pFd"]=arr_iYlwGBh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].as_vector().size()==0){
                pFd=NULL;
            return; }auto& arr_iYlwGBh=json["pFd"].as_vector();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_uint64_t());
            }else if (arr_iYlwGBh[ENGggcC].is_int64_t()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_int64_t());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_LMnCBOV;[&](){
            if (json["result"].is_uint64_t()){
                temp_LMnCBOV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LMnCBOV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LMnCBOV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LMnCBOV;}();}();

debug_printf("Ending vkGetFenceFdKHR...\n");
debug_printf("Return value of vkGetFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportFenceFdKHR( VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportFenceFdKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKIMPORTFENCEFDKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=json::vector();
            return; }auto arr_PmxwQMO=json::vector(1);
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImportFenceFdInfo[QSUnAUF]);
            arr_PmxwQMO[QSUnAUF]=temp_map;
            return;
            }();
        }
        json["pImportFenceFdInfo"]=arr_PmxwQMO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_qKtqMsG;[&](){
            if (json["result"].is_uint64_t()){
                temp_qKtqMsG=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_qKtqMsG=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_qKtqMsG=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_qKtqMsG;}();}();

debug_printf("Ending vkImportFenceFdKHR...\n");
debug_printf("Return value of vkImportFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseDisplayEXT( VkPhysicalDevice physicalDevice, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkReleaseDisplayEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRELEASEDISPLAYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_ZiaeAKR;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZiaeAKR=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZiaeAKR=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZiaeAKR=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZiaeAKR;}();}();

debug_printf("Ending vkReleaseDisplayEXT...\n");
debug_printf("Return value of vkReleaseDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDisplayPowerControlEXT( VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo ){
//Will only be called by the client
debug_printf("Executing vkDisplayPowerControlEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDISPLAYPOWERCONTROLEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=json::vector();
            return; }auto arr_MrfcjyV=json::vector(1);
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayPowerInfo[xtIgTXd]);
            arr_MrfcjyV[xtIgTXd]=temp_map;
            return;
            }();
        }
        json["pDisplayPowerInfo"]=arr_MrfcjyV;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDISPLAYPOWERCONTROLEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

VkResult result;
[&](){[&](){int temp_XyteYho;[&](){
            if (json["result"].is_uint64_t()){
                temp_XyteYho=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_XyteYho=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_XyteYho=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_XyteYho;}();}();

debug_printf("Ending vkDisplayPowerControlEXT...\n");
debug_printf("Return value of vkDisplayPowerControlEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDeviceEventEXT( VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDeviceEventEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKREGISTERDEVICEEVENTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=json::vector();
            return; }auto arr_PBonFka=json::vector(1);
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDeviceEventInfo[JNqwWzK]);
            arr_PBonFka[JNqwWzK]=temp_map;
            return;
            }();
        }
        json["pDeviceEventInfo"]=arr_PBonFka;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDEVICEEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZZbHdPH;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZZbHdPH=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZZbHdPH=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZZbHdPH=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZZbHdPH;}();}();

debug_printf("Ending vkRegisterDeviceEventEXT...\n");
debug_printf("Return value of vkRegisterDeviceEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDisplayEventEXT( VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDisplayEventEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKREGISTERDISPLAYEVENTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=json::vector();
            return; }auto arr_EEWRWgk=json::vector(1);
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayEventInfo[ZywgBIl]);
            arr_EEWRWgk[ZywgBIl]=temp_map;
            return;
            }();
        }
        json["pDisplayEventInfo"]=arr_EEWRWgk;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFence==NULL){
                json["pFence"]=json::vector();
            return; }auto arr_SJohVKr=json::vector(1);
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        json["pFence"]=arr_SJohVKr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDISPLAYEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pFence"].as_vector().size()==0){
                pFence=NULL;
            return; }auto& arr_SJohVKr=json["pFence"].as_vector();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_taUgaUB;[&](){
            if (json["result"].is_uint64_t()){
                temp_taUgaUB=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_taUgaUB=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_taUgaUB=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_taUgaUB;}();}();

debug_printf("Ending vkRegisterDisplayEventEXT...\n");
debug_printf("Return value of vkRegisterDisplayEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainCounterEXT( VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainCounterEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSWAPCHAINCOUNTEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=static_cast<int>(counter);}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=json::vector();
            return; }auto arr_VmPfCNz=json::vector(1);
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=static_cast<uint>(pCounterValue[BVcpEyO]);}();
        }
        json["pCounterValue"]=arr_VmPfCNz;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINCOUNTEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){[&](){int temp_RusGBTK;[&](){
            if (json["counter"].is_uint64_t()){
                temp_RusGBTK=static_cast<int>(json["counter"].as_uint64_t());
            }else if (json["counter"].is_int64_t()){
                temp_RusGBTK=static_cast<int>(json["counter"].as_int64_t());
            }else{
                temp_RusGBTK=static_cast<int>(json["counter"].as_double());
            }
            }();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
[&](){
            if (json["pCounterValue"].as_vector().size()==0){
                pCounterValue=NULL;
            return; }auto& arr_VmPfCNz=json["pCounterValue"].as_vector();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){
            if (arr_VmPfCNz[BVcpEyO].is_uint64_t()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_uint64_t());
            }else if (arr_VmPfCNz[BVcpEyO].is_int64_t()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_int64_t());
            }else{
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ABsCcZw;[&](){
            if (json["result"].is_uint64_t()){
                temp_ABsCcZw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ABsCcZw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ABsCcZw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ABsCcZw;}();}();

debug_printf("Ending vkGetSwapchainCounterEXT...\n");
debug_printf("Return value of vkGetSwapchainCounterEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2EXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_KYzynfJ=json::vector(1);
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[QJCcfVY]);
            arr_KYzynfJ[QJCcfVY]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_KYzynfJ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }auto& arr_KYzynfJ=json["pSurfaceCapabilities"].as_vector();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            deserialize_struct(arr_KYzynfJ[QJCcfVY].as_map(),pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XSKmzOC;[&](){
            if (json["result"].is_uint64_t()){
                temp_XSKmzOC=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_XSKmzOC=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_XSKmzOC=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_XSKmzOC;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2EXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroups( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceGroups\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICEGROUPS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=json::vector();
            return; }auto arr_Cmahtvc=json::vector(1);
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=static_cast<uint>(pPhysicalDeviceGroupCount[SYfwvYv]);}();
        }
        json["pPhysicalDeviceGroupCount"]=arr_Cmahtvc;}();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=json::vector();
            return; }auto arr_kSmADNy=json::vector(*pPhysicalDeviceGroupCount);
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPhysicalDeviceGroupProperties[LorZWUi]);
            arr_kSmADNy[LorZWUi]=temp_map;
            return;
            }();
        }
        json["pPhysicalDeviceGroupProperties"]=arr_kSmADNy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEGROUPS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceGroupCount"].as_vector().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].as_vector();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){
            if (arr_Cmahtvc[SYfwvYv].is_uint64_t()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_uint64_t());
            }else if (arr_Cmahtvc[SYfwvYv].is_int64_t()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_int64_t());
            }else{
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPhysicalDeviceGroupProperties"].as_vector().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].as_vector();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            deserialize_struct(arr_kSmADNy[LorZWUi].as_map(),pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_PisRKZs;[&](){
            if (json["result"].is_uint64_t()){
                temp_PisRKZs=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_PisRKZs=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_PisRKZs=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_PisRKZs;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceGroups...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceGroups is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroupsKHR( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
return vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeatures( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPeerMemoryFeatures\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPPEERMEMORYFEATURES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=static_cast<uint>(heapIndex);}();
[&](){json["localDeviceIndex"]=static_cast<uint>(localDeviceIndex);}();
[&](){json["remoteDeviceIndex"]=static_cast<uint>(remoteDeviceIndex);}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=json::vector();
            return; }auto arr_IMNDPVx=json::vector(1);
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=static_cast<int>(pPeerMemoryFeatures[dvtpqQO]);}();}();}();
        }
        json["pPeerMemoryFeatures"]=arr_IMNDPVx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["heapIndex"].is_uint64_t()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_uint64_t());
            }else if (json["heapIndex"].is_int64_t()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_int64_t());
            }else{
                heapIndex=static_cast<uint32_t>(json["heapIndex"].as_double());
            }
            }();
[&](){
            if (json["localDeviceIndex"].is_uint64_t()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_uint64_t());
            }else if (json["localDeviceIndex"].is_int64_t()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_int64_t());
            }else{
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].as_double());
            }
            }();
[&](){
            if (json["remoteDeviceIndex"].is_uint64_t()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_uint64_t());
            }else if (json["remoteDeviceIndex"].is_int64_t()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_int64_t());
            }else{
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].as_double());
            }
            }();
[&](){
            if (json["pPeerMemoryFeatures"].as_vector().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].as_vector();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){
            if (arr_IMNDPVx[dvtpqQO].is_uint64_t()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_uint64_t());
            }else if (arr_IMNDPVx[dvtpqQO].is_int64_t()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_int64_t());
            }else{
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].as_double());
            }
            }();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceGroupPeerMemoryFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeaturesKHR( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
return vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDBUFFERMEMORY2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_NWunNSr=json::vector(bindInfoCount);
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[DbCSPHR]);
            arr_NWunNSr[DbCSPHR]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_NWunNSr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_vNOwvGi;[&](){
            if (json["result"].is_uint64_t()){
                temp_vNOwvGi=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vNOwvGi=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vNOwvGi=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vNOwvGi;}();}();

debug_printf("Ending vkBindBufferMemory2...\n");
debug_printf("Return value of vkBindBufferMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
return vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDIMAGEMEMORY2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_FifZmRy=json::vector(bindInfoCount);
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[TInZfLo]);
            arr_FifZmRy[TInZfLo]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_FifZmRy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_rQeTCPF;[&](){
            if (json["result"].is_uint64_t()){
                temp_rQeTCPF=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_rQeTCPF=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_rQeTCPF=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_rQeTCPF;}();}();

debug_printf("Ending vkBindImageMemory2...\n");
debug_printf("Return value of vkBindImageMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
return vkBindImageMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMask( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDeviceMask\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEVICEMASK);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=static_cast<uint>(deviceMask);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEVICEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["deviceMask"].is_uint64_t()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_uint64_t());
            }else if (json["deviceMask"].is_int64_t()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_int64_t());
            }else{
                deviceMask=static_cast<uint32_t>(json["deviceMask"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetDeviceMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMaskKHR( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
return vkCmdSetDeviceMask(commandBuffer, deviceMask);
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupPresentCapabilitiesKHR( VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPresentCapabilitiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPPRESENTCAPABILITIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=json::vector();
            return; }auto arr_gEodIfI=json::vector(1);
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDeviceGroupPresentCapabilities[HHoUQIw]);
            arr_gEodIfI[HHoUQIw]=temp_map;
            return;
            }();
        }
        json["pDeviceGroupPresentCapabilities"]=arr_gEodIfI;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pDeviceGroupPresentCapabilities"].as_vector().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].as_vector();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            deserialize_struct(arr_gEodIfI[HHoUQIw].as_map(),pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_sVUfVso;[&](){
            if (json["result"].is_uint64_t()){
                temp_sVUfVso=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_sVUfVso=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_sVUfVso=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_sVUfVso;}();}();

debug_printf("Ending vkGetDeviceGroupPresentCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupPresentCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupSurfacePresentModesKHR( VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupSurfacePresentModesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEGROUPSURFACEPRESENTMODESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=json::vector();
            return; }auto arr_RUtBuZy=json::vector(1);
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=static_cast<int>(pModes[OxSHrMn]);}();}();}();
        }
        json["pModes"]=arr_RUtBuZy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pModes"].as_vector().size()==0){
                pModes=NULL;
            return; }auto& arr_RUtBuZy=json["pModes"].as_vector();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){
            if (arr_RUtBuZy[OxSHrMn].is_uint64_t()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_uint64_t());
            }else if (arr_RUtBuZy[OxSHrMn].is_int64_t()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_int64_t());
            }else{
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].as_double());
            }
            }();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lHEVacH;[&](){
            if (json["result"].is_uint64_t()){
                temp_lHEVacH=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_lHEVacH=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_lHEVacH=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_lHEVacH;}();}();

debug_printf("Ending vkGetDeviceGroupSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImage2KHR( VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImage2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKACQUIRENEXTIMAGE2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=json::vector();
            return; }auto arr_plPbild=json::vector(1);
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAcquireInfo[QzLRJum]);
            arr_plPbild[QzLRJum]=temp_map;
            return;
            }();
        }
        json["pAcquireInfo"]=arr_plPbild;}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=json::vector();
            return; }auto arr_oSqpNfH=json::vector(1);
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=static_cast<uint>(pImageIndex[BEjuBtR]);}();
        }
        json["pImageIndex"]=arr_oSqpNfH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGE2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pImageIndex"].as_vector().size()==0){
                pImageIndex=NULL;
            return; }auto& arr_oSqpNfH=json["pImageIndex"].as_vector();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_uint64_t());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64_t()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_int64_t());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_NeZlQTZ;[&](){
            if (json["result"].is_uint64_t()){
                temp_NeZlQTZ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_NeZlQTZ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_NeZlQTZ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_NeZlQTZ;}();}();

debug_printf("Ending vkAcquireNextImage2KHR...\n");
debug_printf("Return value of vkAcquireNextImage2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBase( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchBase\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDISPATCHBASE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=static_cast<uint>(baseGroupX);}();
[&](){json["baseGroupY"]=static_cast<uint>(baseGroupY);}();
[&](){json["baseGroupZ"]=static_cast<uint>(baseGroupZ);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHBASE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["baseGroupX"].is_uint64_t()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_uint64_t());
            }else if (json["baseGroupX"].is_int64_t()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_int64_t());
            }else{
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].as_double());
            }
            }();
[&](){
            if (json["baseGroupY"].is_uint64_t()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_uint64_t());
            }else if (json["baseGroupY"].is_int64_t()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_int64_t());
            }else{
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].as_double());
            }
            }();
[&](){
            if (json["baseGroupZ"].is_uint64_t()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_uint64_t());
            }else if (json["baseGroupZ"].is_int64_t()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_int64_t());
            }else{
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].as_double());
            }
            }();
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

debug_printf("Ending vkCmdDispatchBase...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBaseKHR( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
return vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDevicePresentRectanglesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDevicePresentRectanglesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=json::vector();
            return; }auto arr_vsEoMvr=json::vector(1);
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=static_cast<uint>(pRectCount[TgFYlRi]);}();
        }
        json["pRectCount"]=arr_vsEoMvr;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=json::vector();
            return; }auto arr_BxIGDMm=json::vector(*pRectCount);
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRects[LNnHsjT]);
            arr_BxIGDMm[LNnHsjT]=temp_map;
            return;
            }();
        }
        json["pRects"]=arr_BxIGDMm;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pRectCount"].as_vector().size()==0){
                pRectCount=NULL;
            return; }auto& arr_vsEoMvr=json["pRectCount"].as_vector();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){
            if (arr_vsEoMvr[TgFYlRi].is_uint64_t()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_uint64_t());
            }else if (arr_vsEoMvr[TgFYlRi].is_int64_t()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_int64_t());
            }else{
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pRects"].as_vector().size()==0){
                pRects=NULL;
            return; }auto& arr_BxIGDMm=json["pRects"].as_vector();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            deserialize_struct(arr_BxIGDMm[LNnHsjT].as_map(),pRects[LNnHsjT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_RnpDULR;[&](){
            if (json["result"].is_uint64_t()){
                temp_RnpDULR=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_RnpDULR=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_RnpDULR=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_RnpDULR;}();}();

debug_printf("Ending vkGetPhysicalDevicePresentRectanglesKHR...\n");
debug_printf("Return value of vkGetPhysicalDevicePresentRectanglesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplate( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorUpdateTemplate\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDESCRIPTORUPDATETEMPLATE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_GOaQfzV=json::vector(1);
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[bDXkRSI]);
            arr_GOaQfzV[bDXkRSI]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_GOaQfzV;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=json::vector();
            return; }auto arr_wchWplA=json::vector(1);
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        json["pDescriptorUpdateTemplate"]=arr_wchWplA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorUpdateTemplate"].as_vector().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].as_vector();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_EHbIYub;[&](){
            if (json["result"].is_uint64_t()){
                temp_EHbIYub=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_EHbIYub=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_EHbIYub=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_EHbIYub;}();}();

                if (pDescriptorUpdateTemplate!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorUpdateTemplate[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorUpdateTemplate...\n");
debug_printf("Return value of vkCreateDescriptorUpdateTemplate is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplateKHR( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
return vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplate( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorUpdateTemplate\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDESCRIPTORUPDATETEMPLATE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkDestroyDescriptorUpdateTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplateKHR( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
return vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplate( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSetWithTemplate\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKUPDATEDESCRIPTORSETWITHTEMPLATE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(strlen(((char*)(pData)))+1);
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkUpdateDescriptorSetWithTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplateKHR( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
return vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetWithTemplateKHR( VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetWithTemplateKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_ZUZjIQc=json::vector(strlen(((char*)(pData)))+1);
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=static_cast<uint>(((char*)(pData))[wgKJNeB]);}();
        }
        json["pData"]=arr_ZUZjIQc;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();


debug_printf("Ending vkCmdPushDescriptorSetWithTemplateKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkSetHdrMetadataEXT( VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata ){
//Will only be called by the client
debug_printf("Executing vkSetHdrMetadataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETHDRMETADATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=static_cast<uint>(swapchainCount);}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=json::vector();
            return; }auto arr_ItrwriJ=json::vector(swapchainCount);
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        json["pSwapchains"]=arr_ItrwriJ;}();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=json::vector();
            return; }auto arr_gUCeGgy=json::vector(swapchainCount);
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMetadata[qGnEfca]);
            arr_gUCeGgy[qGnEfca]=temp_map;
            return;
            }();
        }
        json["pMetadata"]=arr_gUCeGgy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETHDRMETADATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["swapchainCount"].is_uint64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_uint64_t());
            }else if (json["swapchainCount"].is_int64_t()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_int64_t());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].as_double());
            }
            }();



debug_printf("Ending vkSetHdrMetadataEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainStatusKHR( VkDevice device, VkSwapchainKHR swapchain ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainStatusKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSWAPCHAINSTATUSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINSTATUSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkResult result;
[&](){[&](){int temp_AdtrAXT;[&](){
            if (json["result"].is_uint64_t()){
                temp_AdtrAXT=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_AdtrAXT=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_AdtrAXT=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_AdtrAXT;}();}();

debug_printf("Ending vkGetSwapchainStatusKHR...\n");
debug_printf("Return value of vkGetSwapchainStatusKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRefreshCycleDurationGOOGLE( VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties ){
//Will only be called by the client
debug_printf("Executing vkGetRefreshCycleDurationGOOGLE\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETREFRESHCYCLEDURATIONGOOGLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=json::vector();
            return; }auto arr_nDUaeZL=json::vector(1);
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayTimingProperties[NSFWKiB]);
            arr_nDUaeZL[NSFWKiB]=temp_map;
            return;
            }();
        }
        json["pDisplayTimingProperties"]=arr_nDUaeZL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETREFRESHCYCLEDURATIONGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pDisplayTimingProperties"].as_vector().size()==0){
                pDisplayTimingProperties=NULL;
            return; }auto& arr_nDUaeZL=json["pDisplayTimingProperties"].as_vector();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            deserialize_struct(arr_nDUaeZL[NSFWKiB].as_map(),pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YFfCUgf;[&](){
            if (json["result"].is_uint64_t()){
                temp_YFfCUgf=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_YFfCUgf=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_YFfCUgf=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_YFfCUgf;}();}();

debug_printf("Ending vkGetRefreshCycleDurationGOOGLE...\n");
debug_printf("Return value of vkGetRefreshCycleDurationGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPastPresentationTimingGOOGLE( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings ){
//Will only be called by the client
debug_printf("Executing vkGetPastPresentationTimingGOOGLE\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPASTPRESENTATIONTIMINGGOOGLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=json::vector();
            return; }auto arr_LiCpViZ=json::vector(1);
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=static_cast<uint>(pPresentationTimingCount[ihpxywU]);}();
        }
        json["pPresentationTimingCount"]=arr_LiCpViZ;}();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=json::vector();
            return; }auto arr_CGvQjMK=json::vector(*pPresentationTimingCount);
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPresentationTimings[CzbyDFb]);
            arr_CGvQjMK[CzbyDFb]=temp_map;
            return;
            }();
        }
        json["pPresentationTimings"]=arr_CGvQjMK;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pPresentationTimingCount"].as_vector().size()==0){
                pPresentationTimingCount=NULL;
            return; }auto& arr_LiCpViZ=json["pPresentationTimingCount"].as_vector();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){
            if (arr_LiCpViZ[ihpxywU].is_uint64_t()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_uint64_t());
            }else if (arr_LiCpViZ[ihpxywU].is_int64_t()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_int64_t());
            }else{
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPresentationTimings"].as_vector().size()==0){
                pPresentationTimings=NULL;
            return; }auto& arr_CGvQjMK=json["pPresentationTimings"].as_vector();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            deserialize_struct(arr_CGvQjMK[CzbyDFb].as_map(),pPresentationTimings[CzbyDFb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_SaSGjng;[&](){
            if (json["result"].is_uint64_t()){
                temp_SaSGjng=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_SaSGjng=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_SaSGjng=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_SaSGjng;}();}();

debug_printf("Ending vkGetPastPresentationTimingGOOGLE...\n");
debug_printf("Return value of vkGetPastPresentationTimingGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWSCALINGNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=json::vector();
            return; }auto arr_gZVGKnq=json::vector(viewportCount);
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewportWScalings[GRZXlou]);
            arr_gZVGKnq[GRZXlou]=temp_map;
            return;
            }();
        }
        json["pViewportWScalings"]=arr_gZVGKnq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportWScalingNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEXT( VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=static_cast<uint>(firstDiscardRectangle);}();
[&](){json["discardRectangleCount"]=static_cast<uint>(discardRectangleCount);}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=json::vector();
            return; }auto arr_uUeweOj=json::vector(discardRectangleCount);
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDiscardRectangles[WtUHHLW]);
            arr_uUeweOj[WtUHHLW]=temp_map;
            return;
            }();
        }
        json["pDiscardRectangles"]=arr_uUeweOj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstDiscardRectangle"].is_uint64_t()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_uint64_t());
            }else if (json["firstDiscardRectangle"].is_int64_t()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_int64_t());
            }else{
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].as_double());
            }
            }();
[&](){
            if (json["discardRectangleCount"].is_uint64_t()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_uint64_t());
            }else if (json["discardRectangleCount"].is_int64_t()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_int64_t());
            }else{
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetDiscardRectangleEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=static_cast<uint>(discardRectangleEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GnHxsqE;[&](){
            if (json["discardRectangleEnable"].is_uint64_t()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_uint64_t());
            }else if (json["discardRectangleEnable"].is_int64_t()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_int64_t());
            }else{
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].as_double());
            }
            }();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

debug_printf("Ending vkCmdSetDiscardRectangleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleModeEXT( VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleModeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDISCARDRECTANGLEMODEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=static_cast<int>(discardRectangleMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iBxDvRc;[&](){
            if (json["discardRectangleMode"].is_uint64_t()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_uint64_t());
            }else if (json["discardRectangleMode"].is_int64_t()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_int64_t());
            }else{
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].as_double());
            }
            }();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

debug_printf("Ending vkCmdSetDiscardRectangleModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEXT( VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSAMPLELOCATIONSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=json::vector();
            return; }auto arr_KfRxBlJ=json::vector(1);
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSampleLocationsInfo[XjGOezZ]);
            arr_KfRxBlJ[XjGOezZ]=temp_map;
            return;
            }();
        }
        json["pSampleLocationsInfo"]=arr_KfRxBlJ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetSampleLocationsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMultisamplePropertiesEXT( VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMultisamplePropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=json::vector();
            return; }auto arr_IduiRHb=json::vector(1);
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMultisampleProperties[xJhEIjr]);
            arr_IduiRHb[xJhEIjr]=temp_map;
            return;
            }();
        }
        json["pMultisampleProperties"]=arr_IduiRHb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){
            if (json["pMultisampleProperties"].as_vector().size()==0){
                pMultisampleProperties=NULL;
            return; }auto& arr_IduiRHb=json["pMultisampleProperties"].as_vector();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            deserialize_struct(arr_IduiRHb[xJhEIjr].as_map(),pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=json::vector();
            return; }auto arr_kqlTDpj=json::vector(1);
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceInfo[yiVsRWe]);
            arr_kqlTDpj[yiVsRWe]=temp_map;
            return;
            }();
        }
        json["pSurfaceInfo"]=arr_kqlTDpj;}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=json::vector();
            return; }auto arr_JfroxEi=json::vector(1);
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceCapabilities[Baebpht]);
            arr_JfroxEi[Baebpht]=temp_map;
            return;
            }();
        }
        json["pSurfaceCapabilities"]=arr_JfroxEi;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceCapabilities"].as_vector().size()==0){
                pSurfaceCapabilities=NULL;
            return; }auto& arr_JfroxEi=json["pSurfaceCapabilities"].as_vector();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            deserialize_struct(arr_JfroxEi[Baebpht].as_map(),pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_vrcoNXr;[&](){
            if (json["result"].is_uint64_t()){
                temp_vrcoNXr=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vrcoNXr=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vrcoNXr=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vrcoNXr;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormats2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormats2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESURFACEFORMATS2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=json::vector();
            return; }auto arr_kqlTDpj=json::vector(1);
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceInfo[yiVsRWe]);
            arr_kqlTDpj[yiVsRWe]=temp_map;
            return;
            }();
        }
        json["pSurfaceInfo"]=arr_kqlTDpj;}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=json::vector();
            return; }auto arr_mbQwRYl=json::vector(1);
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=static_cast<uint>(pSurfaceFormatCount[bFtFQKD]);}();
        }
        json["pSurfaceFormatCount"]=arr_mbQwRYl;}();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=json::vector();
            return; }auto arr_AuCicsY=json::vector(*pSurfaceFormatCount);
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSurfaceFormats[lVrVWxA]);
            arr_AuCicsY[lVrVWxA]=temp_map;
            return;
            }();
        }
        json["pSurfaceFormats"]=arr_AuCicsY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceFormatCount"].as_vector().size()==0){
                pSurfaceFormatCount=NULL;
            return; }auto& arr_mbQwRYl=json["pSurfaceFormatCount"].as_vector();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_uint64_t());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64_t()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_int64_t());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].as_vector().size()==0){
                pSurfaceFormats=NULL;
            return; }auto& arr_AuCicsY=json["pSurfaceFormats"].as_vector();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            deserialize_struct(arr_AuCicsY[lVrVWxA].as_map(),pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_IOZGDeU;[&](){
            if (json["result"].is_uint64_t()){
                temp_IOZGDeU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_IOZGDeU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_IOZGDeU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_IOZGDeU;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormats2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayProperties2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_WgClQQW=json::vector(*pPropertyCount);
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[IPCMyur]);
            arr_WgClQQW[IPCMyur]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_WgClQQW;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_WgClQQW=json["pProperties"].as_vector();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            deserialize_struct(arr_WgClQQW[IPCMyur].as_map(),pProperties[IPCMyur]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_hJvdKix;[&](){
            if (json["result"].is_uint64_t()){
                temp_hJvdKix=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_hJvdKix=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_hJvdKix=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_hJvdKix;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlaneProperties2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oqLTQEe=json::vector(*pPropertyCount);
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[KJvijjP]);
            arr_oqLTQEe[KJvijjP]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oqLTQEe;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_oqLTQEe=json["pProperties"].as_vector();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            deserialize_struct(arr_oqLTQEe[KJvijjP].as_map(),pProperties[KJvijjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HhYxptS;[&](){
            if (json["result"].is_uint64_t()){
                temp_HhYxptS=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HhYxptS=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HhYxptS=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HhYxptS;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlaneProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModeProperties2KHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModeProperties2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDISPLAYMODEPROPERTIES2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_LvUqkhm=json::vector(*pPropertyCount);
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[gThvzcU]);
            arr_LvUqkhm[gThvzcU]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_LvUqkhm;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_LvUqkhm=json["pProperties"].as_vector();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            deserialize_struct(arr_LvUqkhm[gThvzcU].as_map(),pProperties[gThvzcU]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xnvCFuo;[&](){
            if (json["result"].is_uint64_t()){
                temp_xnvCFuo=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_xnvCFuo=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_xnvCFuo=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_xnvCFuo;}();}();

debug_printf("Ending vkGetDisplayModeProperties2KHR...\n");
debug_printf("Return value of vkGetDisplayModeProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilities2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDISPLAYPLANECAPABILITIES2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=json::vector();
            return; }auto arr_rwBYAlG=json::vector(1);
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDisplayPlaneInfo[iEdZMtQ]);
            arr_rwBYAlG[iEdZMtQ]=temp_map;
            return;
            }();
        }
        json["pDisplayPlaneInfo"]=arr_rwBYAlG;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_perBkIp=json::vector(1);
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[wDZGRHI]);
            arr_perBkIp[wDZGRHI]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_perBkIp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }auto& arr_perBkIp=json["pCapabilities"].as_vector();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            deserialize_struct(arr_perBkIp[wDZGRHI].as_map(),pCapabilities[wDZGRHI]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_SuQXlIN;[&](){
            if (json["result"].is_uint64_t()){
                temp_SuQXlIN=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_SuQXlIN=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_SuQXlIN=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_SuQXlIN;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilities2KHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETBUFFERMEMORYREQUIREMENTS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_xrBSgMU=json::vector(1);
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[XaVdoIX]);
            arr_xrBSgMU[XaVdoIX]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_xrBSgMU;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2KHR( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEMEMORYREQUIREMENTS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_OVesMNt=json::vector(1);
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[xSwhhlO]);
            arr_OVesMNt[xSwhhlO]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_OVesMNt;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2KHR( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGESPARSEMEMORYREQUIREMENTS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_frlqZZl=json::vector(1);
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[DnuwqwS]);
            arr_frlqZZl[DnuwqwS]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_frlqZZl;}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_vCRbLVA=json::vector(*pSparseMemoryRequirementCount);
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[QTojQNx]);
            arr_vCRbLVA[QTojQNx]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_vCRbLVA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_vector();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            deserialize_struct(arr_vCRbLVA[QTojQNx].as_map(),pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2KHR( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirements( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceBufferMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEBUFFERMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LbYKRdp=json::vector(1);
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[sabbuKR]);
            arr_LbYKRdp[sabbuKR]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LbYKRdp;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirementsKHR( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGEMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_dGiJKQX=json::vector(1);
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[Hfcgcwr]);
            arr_dGiJKQX[Hfcgcwr]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_dGiJKQX;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSparseMemoryRequirements\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_dGiJKQX=json::vector(1);
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[Hfcgcwr]);
            arr_dGiJKQX[Hfcgcwr]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_dGiJKQX;}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=json::vector();
            return; }auto arr_QpqRnvg=json::vector(1);
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=static_cast<uint>(pSparseMemoryRequirementCount[pFgmjla]);}();
        }
        json["pSparseMemoryRequirementCount"]=arr_QpqRnvg;}();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=json::vector();
            return; }auto arr_vCRbLVA=json::vector(*pSparseMemoryRequirementCount);
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSparseMemoryRequirements[QTojQNx]);
            arr_vCRbLVA[QTojQNx]=temp_map;
            return;
            }();
        }
        json["pSparseMemoryRequirements"]=arr_vCRbLVA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].as_vector().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].as_vector();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_uint64_t());
            }else if (arr_QpqRnvg[pFgmjla].is_int64_t()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_int64_t());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].as_vector().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].as_vector();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            deserialize_struct(arr_vCRbLVA[QTojQNx].as_map(),pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversion( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
//Will only be called by the client
debug_printf("Executing vkCreateSamplerYcbcrConversion\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESAMPLERYCBCRCONVERSION);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_kLHhxUL=json::vector(1);
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[zgqBgkX]);
            arr_kLHhxUL[zgqBgkX]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_kLHhxUL;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=json::vector();
            return; }auto arr_joRRIst=json::vector(1);
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        json["pYcbcrConversion"]=arr_joRRIst;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pYcbcrConversion"].as_vector().size()==0){
                pYcbcrConversion=NULL;
            return; }auto& arr_joRRIst=json["pYcbcrConversion"].as_vector();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_isarYKk;[&](){
            if (json["result"].is_uint64_t()){
                temp_isarYKk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_isarYKk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_isarYKk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_isarYKk;}();}();

                if (pYcbcrConversion!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pYcbcrConversion[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSamplerYcbcrConversion...\n");
debug_printf("Return value of vkCreateSamplerYcbcrConversion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversionKHR( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
return vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversion( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySamplerYcbcrConversion\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSAMPLERYCBCRCONVERSION);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();


debug_printf("Ending vkDestroySamplerYcbcrConversion...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversionKHR( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
return vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue2( VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEQUEUE2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=json::vector();
            return; }auto arr_bNCRimR=json::vector(1);
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pQueueInfo[ubuvbaB]);
            arr_bNCRimR[ubuvbaB]=temp_map;
            return;
            }();
        }
        json["pQueueInfo"]=arr_bNCRimR;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=json::vector();
            return; }auto arr_rYZbcEA=json::vector(1);
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        json["pQueue"]=arr_rYZbcEA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pQueue"].as_vector().size()==0){
                pQueue=NULL;
            return; }auto& arr_rYZbcEA=json["pQueue"].as_vector();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

debug_printf("Ending vkGetDeviceQueue2...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateValidationCacheEXT( VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache ){
//Will only be called by the client
debug_printf("Executing vkCreateValidationCacheEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEVALIDATIONCACHEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_ZCXiwLp=json::vector(1);
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[XeWuaSR]);
            arr_ZCXiwLp[XeWuaSR]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_ZCXiwLp;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=json::vector();
            return; }auto arr_oYoDWhC=json::vector(1);
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        json["pValidationCache"]=arr_oYoDWhC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pValidationCache"].as_vector().size()==0){
                pValidationCache=NULL;
            return; }auto& arr_oYoDWhC=json["pValidationCache"].as_vector();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_NGqSAPw;[&](){
            if (json["result"].is_uint64_t()){
                temp_NGqSAPw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_NGqSAPw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_NGqSAPw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_NGqSAPw;}();}();

                if (pValidationCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pValidationCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateValidationCacheEXT...\n");
debug_printf("Return value of vkCreateValidationCacheEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyValidationCacheEXT( VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyValidationCacheEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYVALIDATIONCACHEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();


debug_printf("Ending vkDestroyValidationCacheEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetValidationCacheDataEXT( VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetValidationCacheDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETVALIDATIONCACHEDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVALIDATIONCACHEDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_qUleAuZ;[&](){
            if (json["result"].is_uint64_t()){
                temp_qUleAuZ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_qUleAuZ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_qUleAuZ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_qUleAuZ;}();}();

debug_printf("Ending vkGetValidationCacheDataEXT...\n");
debug_printf("Return value of vkGetValidationCacheDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergeValidationCachesEXT( VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergeValidationCachesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKMERGEVALIDATIONCACHESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=static_cast<uint>(srcCacheCount);}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=json::vector();
            return; }auto arr_xXUlTaQ=json::vector(srcCacheCount);
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        json["pSrcCaches"]=arr_xXUlTaQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEVALIDATIONCACHESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
[&](){
            if (json["srcCacheCount"].is_uint64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_uint64_t());
            }else if (json["srcCacheCount"].is_int64_t()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_int64_t());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_fgUntwV;[&](){
            if (json["result"].is_uint64_t()){
                temp_fgUntwV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_fgUntwV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_fgUntwV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_fgUntwV;}();}();

debug_printf("Ending vkMergeValidationCachesEXT...\n");
debug_printf("Return value of vkMergeValidationCachesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupport( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSupport\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTSUPPORT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dFRsqIW=json::vector(1);
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tUGauKK]);
            arr_dFRsqIW[tUGauKK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dFRsqIW;}();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=json::vector();
            return; }auto arr_xgzGluH=json::vector(1);
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSupport[UvZyHDI]);
            arr_xgzGluH[UvZyHDI]=temp_map;
            return;
            }();
        }
        json["pSupport"]=arr_xgzGluH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSupport"].as_vector().size()==0){
                pSupport=NULL;
            return; }auto& arr_xgzGluH=json["pSupport"].as_vector();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            deserialize_struct(arr_xgzGluH[UvZyHDI].as_map(),pSupport[UvZyHDI]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSupport...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupportKHR( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
return vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderInfoAMD( VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetShaderInfoAMD\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSHADERINFOAMD);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=static_cast<int>(shaderStage);}();}();}();
[&](){[&](){[&](){json["infoType"]=static_cast<int>(infoType);}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=json::vector();
            return; }auto arr_ouDPuUh=json::vector(1);
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=static_cast<int>(pInfoSize[wpUCmEy]);}();
        }
        json["pInfoSize"]=arr_ouDPuUh;}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UHSCjHI=json::vector(*pInfoSize);
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){arr_UHSCjHI[rexTFCi]=static_cast<uint>(((char*)(pInfo))[rexTFCi]);}();
        }
        json["pInfo"]=arr_UHSCjHI;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERINFOAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){[&](){int temp_nGZQHxq;[&](){
            if (json["shaderStage"].is_uint64_t()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_uint64_t());
            }else if (json["shaderStage"].is_int64_t()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_int64_t());
            }else{
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].as_double());
            }
            }();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
[&](){[&](){int temp_nNfHNkf;[&](){
            if (json["infoType"].is_uint64_t()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_uint64_t());
            }else if (json["infoType"].is_int64_t()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_int64_t());
            }else{
                temp_nNfHNkf=static_cast<int>(json["infoType"].as_double());
            }
            }();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
[&](){
            if (json["pInfoSize"].as_vector().size()==0){
                pInfoSize=NULL;
            return; }auto& arr_ouDPuUh=json["pInfoSize"].as_vector();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){
            if (arr_ouDPuUh[wpUCmEy].is_uint64_t()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_uint64_t());
            }else if (arr_ouDPuUh[wpUCmEy].is_int64_t()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_int64_t());
            }else{
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pInfo"].as_vector().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].as_vector().size()==0){
                temp_ziBtDwK=NULL;
            return; }temp_ziBtDwK=(char*)malloc(*pInfoSize*sizeof(char));auto& arr_UHSCjHI=json["pInfo"].as_vector();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){
            if (arr_UHSCjHI[rexTFCi].is_uint64_t()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_uint64_t());
            }else if (arr_UHSCjHI[rexTFCi].is_int64_t()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_int64_t());
            }else{
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].as_double());
            }
            }();
        }
        }();pInfo=temp_ziBtDwK;}();
VkResult result;
[&](){[&](){int temp_SeHBHly;[&](){
            if (json["result"].is_uint64_t()){
                temp_SeHBHly=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_SeHBHly=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_SeHBHly=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_SeHBHly;}();}();

debug_printf("Ending vkGetShaderInfoAMD...\n");
debug_printf("Return value of vkGetShaderInfoAMD is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetLocalDimmingAMD( VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable ){
//Will only be called by the client
debug_printf("Executing vkSetLocalDimmingAMD\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETLOCALDIMMINGAMD);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=static_cast<uint>(localDimmingEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETLOCALDIMMINGAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
[&](){uint32_t temp_jfGMipq;[&](){
            if (json["localDimmingEnable"].is_uint64_t()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_uint64_t());
            }else if (json["localDimmingEnable"].is_int64_t()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_int64_t());
            }else{
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].as_double());
            }
            }();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

debug_printf("Ending vkSetLocalDimmingAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT( VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainEXT* pTimeDomains ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCalibrateableTimeDomainsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=json::vector();
            return; }auto arr_siSbERs=json::vector(1);
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=static_cast<uint>(pTimeDomainCount[xFQhUzA]);}();
        }
        json["pTimeDomainCount"]=arr_siSbERs;}();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=json::vector();
            return; }auto arr_fMkUaJq=json::vector(*pTimeDomainCount);
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=static_cast<int>(pTimeDomains[ZiXuFCL]);}();}();}();
        }
        json["pTimeDomains"]=arr_fMkUaJq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pTimeDomainCount"].as_vector().size()==0){
                pTimeDomainCount=NULL;
            return; }auto& arr_siSbERs=json["pTimeDomainCount"].as_vector();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){
            if (arr_siSbERs[xFQhUzA].is_uint64_t()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_uint64_t());
            }else if (arr_siSbERs[xFQhUzA].is_int64_t()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_int64_t());
            }else{
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pTimeDomains"].as_vector().size()==0){
                pTimeDomains=NULL;
            return; }auto& arr_fMkUaJq=json["pTimeDomains"].as_vector();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){
            if (arr_fMkUaJq[ZiXuFCL].is_uint64_t()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_uint64_t());
            }else if (arr_fMkUaJq[ZiXuFCL].is_int64_t()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_int64_t());
            }else{
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].as_double());
            }
            }();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_mVFqWLu;[&](){
            if (json["result"].is_uint64_t()){
                temp_mVFqWLu=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_mVFqWLu=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_mVFqWLu=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_mVFqWLu;}();}();

debug_printf("Ending vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceCalibrateableTimeDomainsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetCalibratedTimestampsEXT( VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation ){
//Will only be called by the client
debug_printf("Executing vkGetCalibratedTimestampsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETCALIBRATEDTIMESTAMPSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=static_cast<uint>(timestampCount);}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=json::vector();
            return; }auto arr_XQeyMsT=json::vector(timestampCount);
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTimestampInfos[aXwwgcz]);
            arr_XQeyMsT[aXwwgcz]=temp_map;
            return;
            }();
        }
        json["pTimestampInfos"]=arr_XQeyMsT;}();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=json::vector();
            return; }auto arr_CHzcvgg=json::vector(timestampCount);
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=static_cast<uint>(pTimestamps[ptqlrVt]);}();
        }
        json["pTimestamps"]=arr_CHzcvgg;}();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=json::vector();
            return; }auto arr_zQmthvJ=json::vector(1);
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=static_cast<uint>(pMaxDeviation[FUkBved]);}();
        }
        json["pMaxDeviation"]=arr_zQmthvJ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETCALIBRATEDTIMESTAMPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["timestampCount"].is_uint64_t()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_uint64_t());
            }else if (json["timestampCount"].is_int64_t()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_int64_t());
            }else{
                timestampCount=static_cast<uint32_t>(json["timestampCount"].as_double());
            }
            }();

[&](){
            if (json["pTimestamps"].as_vector().size()==0){
                pTimestamps=NULL;
            return; }auto& arr_CHzcvgg=json["pTimestamps"].as_vector();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){
            if (arr_CHzcvgg[ptqlrVt].is_uint64_t()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_uint64_t());
            }else if (arr_CHzcvgg[ptqlrVt].is_int64_t()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_int64_t());
            }else{
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pMaxDeviation"].as_vector().size()==0){
                pMaxDeviation=NULL;
            return; }auto& arr_zQmthvJ=json["pMaxDeviation"].as_vector();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){
            if (arr_zQmthvJ[FUkBved].is_uint64_t()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_uint64_t());
            }else if (arr_zQmthvJ[FUkBved].is_int64_t()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_int64_t());
            }else{
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_AqSIVIC;[&](){
            if (json["result"].is_uint64_t()){
                temp_AqSIVIC=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_AqSIVIC=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_AqSIVIC=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_AqSIVIC;}();}();

debug_printf("Ending vkGetCalibratedTimestampsEXT...\n");
debug_printf("Return value of vkGetCalibratedTimestampsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectNameEXT( VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectNameEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETDEBUGUTILSOBJECTNAMEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=json::vector();
            return; }auto arr_gpHzyjV=json::vector(1);
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pNameInfo[sXDrIfX]);
            arr_gpHzyjV[sXDrIfX]=temp_map;
            return;
            }();
        }
        json["pNameInfo"]=arr_gpHzyjV;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ZbhglLt;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZbhglLt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZbhglLt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZbhglLt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZbhglLt;}();}();

debug_printf("Ending vkSetDebugUtilsObjectNameEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectTagEXT( VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectTagEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETDEBUGUTILSOBJECTTAGEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=json::vector();
            return; }auto arr_jMraQzd=json::vector(1);
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTagInfo[lQZzjnQ]);
            arr_jMraQzd[lQZzjnQ]=temp_map;
            return;
            }();
        }
        json["pTagInfo"]=arr_jMraQzd;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_CgpaGeC;[&](){
            if (json["result"].is_uint64_t()){
                temp_CgpaGeC=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_CgpaGeC=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_CgpaGeC=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_CgpaGeC;}();}();

debug_printf("Ending vkSetDebugUtilsObjectTagEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkQueueBeginDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueBeginDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEBEGINDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueEndDebugUtilsLabelEXT( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueEndDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEENDDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();

debug_printf("Ending vkQueueEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueInsertDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueInsertDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUEINSERTDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndDebugUtilsLabelEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdInsertDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdInsertDebugUtilsLabelEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDINSERTDEBUGUTILSLABELEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=json::vector();
            return; }auto arr_GvONoAl=json::vector(1);
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLabelInfo[XxFTlct]);
            arr_GvONoAl[XxFTlct]=temp_map;
            return;
            }();
        }
        json["pLabelInfo"]=arr_GvONoAl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugUtilsMessengerEXT( VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugUtilsMessengerEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDEBUGUTILSMESSENGEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_alrnjyY=json::vector(1);
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[uDOYkhP]);
            arr_alrnjyY[uDOYkhP]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_alrnjyY;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=json::vector();
            return; }auto arr_INDwqtI=json::vector(1);
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        json["pMessenger"]=arr_INDwqtI;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pMessenger"].as_vector().size()==0){
                pMessenger=NULL;
            return; }auto& arr_INDwqtI=json["pMessenger"].as_vector();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GvoCfSy;[&](){
            if (json["result"].is_uint64_t()){
                temp_GvoCfSy=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_GvoCfSy=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_GvoCfSy=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_GvoCfSy;}();}();

                if (pMessenger!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMessenger[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugUtilsMessengerEXT...\n");
debug_printf("Return value of vkCreateDebugUtilsMessengerEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugUtilsMessengerEXT( VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugUtilsMessengerEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDEBUGUTILSMESSENGEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();


debug_printf("Ending vkDestroyDebugUtilsMessengerEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkSubmitDebugUtilsMessageEXT( VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData ){
//Will only be called by the client
debug_printf("Executing vkSubmitDebugUtilsMessageEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSUBMITDEBUGUTILSMESSAGEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=static_cast<int>(messageSeverity);}();}();}();
[&](){[&](){[&](){json["messageTypes"]=static_cast<int>(messageTypes);}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=json::vector();
            return; }auto arr_kahfHKb=json::vector(1);
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallbackData[YuXULtv]);
            arr_kahfHKb[YuXULtv]=temp_map;
            return;
            }();
        }
        json["pCallbackData"]=arr_kahfHKb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSUBMITDEBUGUTILSMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_UpocUQR;[&](){
            if (json["messageSeverity"].is_uint64_t()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_uint64_t());
            }else if (json["messageSeverity"].is_int64_t()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_int64_t());
            }else{
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].as_double());
            }
            }();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
[&](){[&](){int temp_vbjSEUE;[&](){
            if (json["messageTypes"].is_uint64_t()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_uint64_t());
            }else if (json["messageTypes"].is_int64_t()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_int64_t());
            }else{
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].as_double());
            }
            }();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();


debug_printf("Ending vkSubmitDebugUtilsMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryHostPointerPropertiesEXT( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryHostPointerPropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETMEMORYHOSTPOINTERPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=static_cast<int>(handleType);}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=json::vector();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=json::vector();
            return; }auto arr_iKHPNio=json::vector(strlen(((char*)(pHostPointer)))+1);
        for(int UFxRrhm=0; UFxRrhm < strlen(((char*)(pHostPointer)))+1; UFxRrhm++){
            [&](){arr_iKHPNio[UFxRrhm]=static_cast<uint>(((char*)(pHostPointer))[UFxRrhm]);}();
        }
        json["pHostPointer"]=arr_iKHPNio;}();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=json::vector();
            return; }auto arr_CBNxdHG=json::vector(1);
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryHostPointerProperties[hqDeAHT]);
            arr_CBNxdHG[hqDeAHT]=temp_map;
            return;
            }();
        }
        json["pMemoryHostPointerProperties"]=arr_CBNxdHG;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_uint64_t());
            }else if (json["handleType"].is_int64_t()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_int64_t());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].as_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();

[&](){
            if (json["pMemoryHostPointerProperties"].as_vector().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].as_vector();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            deserialize_struct(arr_CBNxdHG[hqDeAHT].as_map(),pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_Iwamftl;[&](){
            if (json["result"].is_uint64_t()){
                temp_Iwamftl=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_Iwamftl=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_Iwamftl=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_Iwamftl;}();}();

debug_printf("Ending vkGetMemoryHostPointerPropertiesEXT...\n");
debug_printf("Return value of vkGetMemoryHostPointerPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarkerAMD( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarkerAMD\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITEBUFFERMARKERAMD);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=static_cast<int>(pipelineStage);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){json["marker"]=static_cast<uint>(marker);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKERAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_uint64_t());
            }else if (json["pipelineStage"].is_int64_t()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_int64_t());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].as_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){
            if (json["marker"].is_uint64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_uint64_t());
            }else if (json["marker"].is_int64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_int64_t());
            }else{
                marker=static_cast<uint32_t>(json["marker"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteBufferMarkerAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATERENDERPASS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_cDssBor=json::vector(1);
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[SgbVidQ]);
            arr_cDssBor[SgbVidQ]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_cDssBor;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=json::vector();
            return; }auto arr_ZwdXTfx=json::vector(1);
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        json["pRenderPass"]=arr_ZwdXTfx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].as_vector().size()==0){
                pRenderPass=NULL;
            return; }auto& arr_ZwdXTfx=json["pRenderPass"].as_vector();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_DrIhxoS;[&](){
            if (json["result"].is_uint64_t()){
                temp_DrIhxoS=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_DrIhxoS=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_DrIhxoS=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_DrIhxoS;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass2...\n");
debug_printf("Return value of vkCreateRenderPass2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2KHR( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
return vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERPASS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=json::vector();
            return; }auto arr_XtnTubd=json::vector(1);
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderPassBegin[lCAvoJt]);
            arr_XtnTubd[lCAvoJt]=temp_map;
            return;
            }();
        }
        json["pRenderPassBegin"]=arr_XtnTubd;}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=json::vector();
            return; }auto arr_yxkVVDb=json::vector(1);
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassBeginInfo[nzkBQUL]);
            arr_yxkVVDb[nzkBQUL]=temp_map;
            return;
            }();
        }
        json["pSubpassBeginInfo"]=arr_yxkVVDb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdBeginRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2KHR( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
return vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDNEXTSUBPASS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=json::vector();
            return; }auto arr_yxkVVDb=json::vector(1);
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassBeginInfo[nzkBQUL]);
            arr_yxkVVDb[nzkBQUL]=temp_map;
            return;
            }();
        }
        json["pSubpassBeginInfo"]=arr_yxkVVDb;}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=json::vector();
            return; }auto arr_mmmwoMH=json::vector(1);
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassEndInfo[oMdHEHu]);
            arr_mmmwoMH[oMdHEHu]=temp_map;
            return;
            }();
        }
        json["pSubpassEndInfo"]=arr_mmmwoMH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdNextSubpass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2KHR( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDRENDERPASS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=json::vector();
            return; }auto arr_mmmwoMH=json::vector(1);
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubpassEndInfo[oMdHEHu]);
            arr_mmmwoMH[oMdHEHu]=temp_map;
            return;
            }();
        }
        json["pSubpassEndInfo"]=arr_mmmwoMH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2KHR( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValue( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreCounterValue\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSEMAPHORECOUNTERVALUE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=json::vector();
            return; }auto arr_xnMrErb=json::vector(1);
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=static_cast<uint>(pValue[fdUIVMD]);}();
        }
        json["pValue"]=arr_xnMrErb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHORECOUNTERVALUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){
            if (json["pValue"].as_vector().size()==0){
                pValue=NULL;
            return; }auto& arr_xnMrErb=json["pValue"].as_vector();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){
            if (arr_xnMrErb[fdUIVMD].is_uint64_t()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_uint64_t());
            }else if (arr_xnMrErb[fdUIVMD].is_int64_t()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_int64_t());
            }else{
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].as_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HswTyiI;[&](){
            if (json["result"].is_uint64_t()){
                temp_HswTyiI=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HswTyiI=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HswTyiI=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HswTyiI;}();}();

debug_printf("Ending vkGetSemaphoreCounterValue...\n");
debug_printf("Return value of vkGetSemaphoreCounterValue is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValueKHR( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
return vkGetSemaphoreCounterValue(device, semaphore, pValue);
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphores( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitSemaphores\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKWAITSEMAPHORES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=json::vector();
            return; }auto arr_xzakrWz=json::vector(1);
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pWaitInfo[hsOLCWG]);
            arr_xzakrWz[hsOLCWG]=temp_map;
            return;
            }();
        }
        json["pWaitInfo"]=arr_xzakrWz;}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITSEMAPHORES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_zsBKwrb;[&](){
            if (json["result"].is_uint64_t()){
                temp_zsBKwrb=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_zsBKwrb=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_zsBKwrb=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_zsBKwrb;}();}();

debug_printf("Ending vkWaitSemaphores...\n");
debug_printf("Return value of vkWaitSemaphores is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphoresKHR( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
return vkWaitSemaphores(device, pWaitInfo, timeout);
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphore( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
//Will only be called by the client
debug_printf("Executing vkSignalSemaphore\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSIGNALSEMAPHORE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=json::vector();
            return; }auto arr_WdRQTJS=json::vector(1);
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSignalInfo[MYLvJyX]);
            arr_WdRQTJS[MYLvJyX]=temp_map;
            return;
            }();
        }
        json["pSignalInfo"]=arr_WdRQTJS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSIGNALSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ebLddpw;[&](){
            if (json["result"].is_uint64_t()){
                temp_ebLddpw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ebLddpw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ebLddpw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ebLddpw;}();}();

debug_printf("Ending vkSignalSemaphore...\n");
debug_printf("Return value of vkSignalSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphoreKHR( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
return vkSignalSemaphore(device, pSignalInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectCount\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECTCOUNT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirectCount\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDEXEDINDIRECTCOUNT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexedIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdSetCheckpointNV( VkCommandBuffer commandBuffer, const void* pCheckpointMarker ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCheckpointNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCHECKPOINTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=json::vector();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=json::vector();
            return; }auto arr_eBRjtYz=json::vector(strlen(((char*)(pCheckpointMarker)))+1);
        for(int VYoknaS=0; VYoknaS < strlen(((char*)(pCheckpointMarker)))+1; VYoknaS++){
            [&](){arr_eBRjtYz[VYoknaS]=static_cast<uint>(((char*)(pCheckpointMarker))[VYoknaS]);}();
        }
        json["pCheckpointMarker"]=arr_eBRjtYz;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCHECKPOINTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetCheckpointNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointDataNV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointDataNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETQUEUECHECKPOINTDATANV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=json::vector();
            return; }auto arr_LsYqVIK=json::vector(1);
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=static_cast<uint>(pCheckpointDataCount[lgasnOP]);}();
        }
        json["pCheckpointDataCount"]=arr_LsYqVIK;}();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=json::vector();
            return; }auto arr_gxwhODc=json::vector(*pCheckpointDataCount);
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCheckpointData[TfFHlNo]);
            arr_gxwhODc[TfFHlNo]=temp_map;
            return;
            }();
        }
        json["pCheckpointData"]=arr_gxwhODc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATANV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].as_vector().size()==0){
                pCheckpointDataCount=NULL;
            return; }auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_vector();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_uint64_t());
            }else if (arr_LsYqVIK[lgasnOP].is_int64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_int64_t());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCheckpointData"].as_vector().size()==0){
                pCheckpointData=NULL;
            return; }auto& arr_gxwhODc=json["pCheckpointData"].as_vector();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            deserialize_struct(arr_gxwhODc[TfFHlNo].as_map(),pCheckpointData[TfFHlNo]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointDataNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindTransformFeedbackBuffersEXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes ){
//Will only be called by the client
debug_printf("Executing vkCmdBindTransformFeedbackBuffersEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=json::vector();
            return; }auto arr_OwyEmcF=json::vector(bindingCount);
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=static_cast<uint>(pSizes[YFhxzVl]);}();}();
        }
        json["pSizes"]=arr_OwyEmcF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();




debug_printf("Ending vkCmdBindTransformFeedbackBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginTransformFeedbackEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINTRANSFORMFEEDBACKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=static_cast<uint>(firstCounterBuffer);}();
[&](){json["counterBufferCount"]=static_cast<uint>(counterBufferCount);}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=json::vector();
            return; }auto arr_eyGyJgR=json::vector(counterBufferCount);
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        json["pCounterBuffers"]=arr_eyGyJgR;}();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=json::vector();
            return; }auto arr_AiSbQbQ=json::vector(counterBufferCount);
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=static_cast<uint>(pCounterBufferOffsets[ThYypfr]);}();}();
        }
        json["pCounterBufferOffsets"]=arr_AiSbQbQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstCounterBuffer"].is_uint64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_uint64_t());
            }else if (json["firstCounterBuffer"].is_int64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_int64_t());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_double());
            }
            }();
[&](){
            if (json["counterBufferCount"].is_uint64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_uint64_t());
            }else if (json["counterBufferCount"].is_int64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_int64_t());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdBeginTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdEndTransformFeedbackEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDTRANSFORMFEEDBACKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=static_cast<uint>(firstCounterBuffer);}();
[&](){json["counterBufferCount"]=static_cast<uint>(counterBufferCount);}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=json::vector();
            return; }auto arr_eyGyJgR=json::vector(counterBufferCount);
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        json["pCounterBuffers"]=arr_eyGyJgR;}();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=json::vector();
            return; }auto arr_AiSbQbQ=json::vector(counterBufferCount);
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=static_cast<uint>(pCounterBufferOffsets[ThYypfr]);}();}();
        }
        json["pCounterBufferOffsets"]=arr_AiSbQbQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstCounterBuffer"].is_uint64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_uint64_t());
            }else if (json["firstCounterBuffer"].is_int64_t()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_int64_t());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].as_double());
            }
            }();
[&](){
            if (json["counterBufferCount"].is_uint64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_uint64_t());
            }else if (json["counterBufferCount"].is_int64_t()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_int64_t());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdEndTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQueryIndexedEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINQUERYINDEXEDEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){[&](){[&](){json["flags"]=static_cast<int>(flags);}();}();}();
[&](){json["index"]=static_cast<uint>(index);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_uint64_t());
            }else if (json["flags"].is_int64_t()){
                temp_iyzDJOK=static_cast<int>(json["flags"].as_int64_t());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].as_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
[&](){
            if (json["index"].is_uint64_t()){
                index=static_cast<uint32_t>(json["index"].as_uint64_t());
            }else if (json["index"].is_int64_t()){
                index=static_cast<uint32_t>(json["index"].as_int64_t());
            }else{
                index=static_cast<uint32_t>(json["index"].as_double());
            }
            }();

debug_printf("Ending vkCmdBeginQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQueryIndexedEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDQUERYINDEXEDEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
[&](){json["index"]=static_cast<uint>(index);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();
[&](){
            if (json["index"].is_uint64_t()){
                index=static_cast<uint32_t>(json["index"].as_uint64_t());
            }else if (json["index"].is_int64_t()){
                index=static_cast<uint32_t>(json["index"].as_int64_t());
            }else{
                index=static_cast<uint32_t>(json["index"].as_double());
            }
            }();

debug_printf("Ending vkCmdEndQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectByteCountEXT( VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectByteCountEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWINDIRECTBYTECOUNTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=static_cast<uint>(instanceCount);}();
[&](){json["firstInstance"]=static_cast<uint>(firstInstance);}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=static_cast<uint>(counterBufferOffset);}();}();
[&](){json["counterOffset"]=static_cast<uint>(counterOffset);}();
[&](){json["vertexStride"]=static_cast<uint>(vertexStride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["instanceCount"].is_uint64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_uint64_t());
            }else if (json["instanceCount"].is_int64_t()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_int64_t());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].as_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_uint64_t());
            }else if (json["firstInstance"].is_int64_t()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_int64_t());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].as_double());
            }
            }();
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
[&](){uint64_t temp_AQwWAlK;[&](){
            if (json["counterBufferOffset"].is_uint64_t()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_uint64_t());
            }else if (json["counterBufferOffset"].is_int64_t()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_int64_t());
            }else{
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].as_double());
            }
            }();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
[&](){
            if (json["counterOffset"].is_uint64_t()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_uint64_t());
            }else if (json["counterOffset"].is_int64_t()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_int64_t());
            }else{
                counterOffset=static_cast<uint32_t>(json["counterOffset"].as_double());
            }
            }();
[&](){
            if (json["vertexStride"].is_uint64_t()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_uint64_t());
            }else if (json["vertexStride"].is_int64_t()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_int64_t());
            }else{
                vertexStride=static_cast<uint32_t>(json["vertexStride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirectByteCountEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETEXCLUSIVESCISSORNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=static_cast<uint>(firstExclusiveScissor);}();
[&](){json["exclusiveScissorCount"]=static_cast<uint>(exclusiveScissorCount);}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=json::vector();
            return; }auto arr_aPFLQnr=json::vector(exclusiveScissorCount);
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExclusiveScissors[uoWCiOs]);
            arr_aPFLQnr[uoWCiOs]=temp_map;
            return;
            }();
        }
        json["pExclusiveScissors"]=arr_aPFLQnr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstExclusiveScissor"].is_uint64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_uint64_t());
            }else if (json["firstExclusiveScissor"].is_int64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_int64_t());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_double());
            }
            }();
[&](){
            if (json["exclusiveScissorCount"].is_uint64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_uint64_t());
            }else if (json["exclusiveScissorCount"].is_int64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_int64_t());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetExclusiveScissorNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorEnableNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETEXCLUSIVESCISSORENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=static_cast<uint>(firstExclusiveScissor);}();
[&](){json["exclusiveScissorCount"]=static_cast<uint>(exclusiveScissorCount);}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=json::vector();
            return; }auto arr_xqHCjsr=json::vector(exclusiveScissorCount);
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=static_cast<uint>(pExclusiveScissorEnables[ZwZaOgk]);}();}();
        }
        json["pExclusiveScissorEnables"]=arr_xqHCjsr;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstExclusiveScissor"].is_uint64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_uint64_t());
            }else if (json["firstExclusiveScissor"].is_int64_t()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_int64_t());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].as_double());
            }
            }();
[&](){
            if (json["exclusiveScissorCount"].is_uint64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_uint64_t());
            }else if (json["exclusiveScissorCount"].is_int64_t()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_int64_t());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetExclusiveScissorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadingRateImageNV( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadingRateImageNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDSHADINGRATEIMAGENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADINGRATEIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindShadingRateImageNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportShadingRatePaletteNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportShadingRatePaletteNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTSHADINGRATEPALETTENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=json::vector();
            return; }auto arr_QGCIyPL=json::vector(viewportCount);
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pShadingRatePalettes[iwmSeHU]);
            arr_QGCIyPL[iwmSeHU]=temp_map;
            return;
            }();
        }
        json["pShadingRatePalettes"]=arr_QGCIyPL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportShadingRatePaletteNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoarseSampleOrderNV( VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoarseSampleOrderNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOARSESAMPLEORDERNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=static_cast<int>(sampleOrderType);}();}();}();
[&](){json["customSampleOrderCount"]=static_cast<uint>(customSampleOrderCount);}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=json::vector();
            return; }auto arr_UoJKhih=json::vector(customSampleOrderCount);
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCustomSampleOrders[nBPVlSV]);
            arr_UoJKhih[nBPVlSV]=temp_map;
            return;
            }();
        }
        json["pCustomSampleOrders"]=arr_UoJKhih;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOARSESAMPLEORDERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iGYbmmy;[&](){
            if (json["sampleOrderType"].is_uint64_t()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_uint64_t());
            }else if (json["sampleOrderType"].is_int64_t()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_int64_t());
            }else{
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].as_double());
            }
            }();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
[&](){
            if (json["customSampleOrderCount"].is_uint64_t()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_uint64_t());
            }else if (json["customSampleOrderCount"].is_int64_t()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_int64_t());
            }else{
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetCoarseSampleOrderNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksNV( VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=static_cast<uint>(taskCount);}();
[&](){json["firstTask"]=static_cast<uint>(firstTask);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["taskCount"].is_uint64_t()){
                taskCount=static_cast<uint32_t>(json["taskCount"].as_uint64_t());
            }else if (json["taskCount"].is_int64_t()){
                taskCount=static_cast<uint32_t>(json["taskCount"].as_int64_t());
            }else{
                taskCount=static_cast<uint32_t>(json["taskCount"].as_double());
            }
            }();
[&](){
            if (json["firstTask"].is_uint64_t()){
                firstTask=static_cast<uint32_t>(json["firstTask"].as_uint64_t());
            }else if (json["firstTask"].is_int64_t()){
                firstTask=static_cast<uint32_t>(json["firstTask"].as_int64_t());
            }else{
                firstTask=static_cast<uint32_t>(json["firstTask"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTCOUNTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksEXT( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=static_cast<uint>(groupCountX);}();
[&](){json["groupCountY"]=static_cast<uint>(groupCountY);}();
[&](){json["groupCountZ"]=static_cast<uint>(groupCountZ);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_uint64_t());
            }else if (json["groupCountX"].is_int64_t()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_int64_t());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].as_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_uint64_t());
            }else if (json["groupCountY"].is_int64_t()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_int64_t());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].as_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_uint64_t());
            }else if (json["groupCountZ"].is_int64_t()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_int64_t());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){json["drawCount"]=static_cast<uint>(drawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_uint64_t());
            }else if (json["drawCount"].is_int64_t()){
                drawCount=static_cast<uint32_t>(json["drawCount"].as_int64_t());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=static_cast<uint>(countBufferOffset);}();}();
[&](){json["maxDrawCount"]=static_cast<uint>(maxDrawCount);}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_uint64_t());
            }else if (json["countBufferOffset"].is_int64_t()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_int64_t());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].as_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_uint64_t());
            }else if (json["maxDrawCount"].is_int64_t()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_int64_t());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].as_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCompileDeferredNV( VkDevice device, VkPipeline pipeline, uint32_t shader ){
//Will only be called by the client
debug_printf("Executing vkCompileDeferredNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOMPILEDEFERREDNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=static_cast<uint>(shader);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOMPILEDEFERREDNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["shader"].is_uint64_t()){
                shader=static_cast<uint32_t>(json["shader"].as_uint64_t());
            }else if (json["shader"].is_int64_t()){
                shader=static_cast<uint32_t>(json["shader"].as_int64_t());
            }else{
                shader=static_cast<uint32_t>(json["shader"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_lkDOwDU;[&](){
            if (json["result"].is_uint64_t()){
                temp_lkDOwDU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_lkDOwDU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_lkDOwDU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_lkDOwDU;}();}();

debug_printf("Ending vkCompileDeferredNV...\n");
debug_printf("Return value of vkCompileDeferredNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureNV( VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEACCELERATIONSTRUCTURENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_cRwwWhs=json::vector(1);
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[oEOLGTm]);
            arr_cRwwWhs[oEOLGTm]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_cRwwWhs;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=json::vector();
            return; }auto arr_FUsucto=json::vector(1);
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        json["pAccelerationStructure"]=arr_FUsucto;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].as_vector().size()==0){
                pAccelerationStructure=NULL;
            return; }auto& arr_FUsucto=json["pAccelerationStructure"].as_vector();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_IuEtyfT;[&](){
            if (json["result"].is_uint64_t()){
                temp_IuEtyfT=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_IuEtyfT=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_IuEtyfT=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_IuEtyfT;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureNV...\n");
debug_printf("Return value of vkCreateAccelerationStructureNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindInvocationMaskHUAWEI( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindInvocationMaskHUAWEI\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDINVOCATIONMASKHUAWEI);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=static_cast<int>(imageLayout);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINVOCATIONMASKHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_uint64_t());
            }else if (json["imageLayout"].is_int64_t()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_int64_t());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].as_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindInvocationMaskHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureKHR( VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYACCELERATIONSTRUCTURENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureMemoryRequirementsNV( VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureMemoryRequirementsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QKzjkmC=json::vector(1);
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[eEDmZTf]);
            arr_QKzjkmC[eEDmZTf]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QKzjkmC;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_lzklPBG=json::vector(1);
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[HmtSVPA]);
            arr_lzklPBG[HmtSVPA]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_lzklPBG;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_lzklPBG=json["pMemoryRequirements"].as_vector();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            deserialize_struct(arr_lzklPBG[HmtSVPA].as_map(),pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindAccelerationStructureMemoryNV( VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindAccelerationStructureMemoryNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDACCELERATIONSTRUCTUREMEMORYNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=static_cast<uint>(bindInfoCount);}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=json::vector();
            return; }auto arr_rhzkvXd=json::vector(bindInfoCount);
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindInfos[tRvmYFr]);
            arr_rhzkvXd[tRvmYFr]=temp_map;
            return;
            }();
        }
        json["pBindInfos"]=arr_rhzkvXd;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_uint64_t());
            }else if (json["bindInfoCount"].is_int64_t()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_int64_t());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_tcqhJAr;[&](){
            if (json["result"].is_uint64_t()){
                temp_tcqhJAr=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_tcqhJAr=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_tcqhJAr=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_tcqhJAr;}();}();

debug_printf("Ending vkBindAccelerationStructureMemoryNV...\n");
debug_printf("Return value of vkBindAccelerationStructureMemoryNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureNV( VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTURENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=static_cast<int>(mode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){[&](){int temp_KfOqWqs;[&](){
            if (json["mode"].is_uint64_t()){
                temp_KfOqWqs=static_cast<int>(json["mode"].as_uint64_t());
            }else if (json["mode"].is_int64_t()){
                temp_KfOqWqs=static_cast<int>(json["mode"].as_int64_t());
            }else{
                temp_KfOqWqs=static_cast<int>(json["mode"].as_double());
            }
            }();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

debug_printf("Ending vkCmdCopyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mSSajtp=json::vector(1);
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ghvrBgW]);
            arr_mSSajtp[ghvrBgW]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mSSajtp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mSSajtp=json::vector(1);
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ghvrBgW]);
            arr_mSSajtp[ghvrBgW]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mSSajtp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_oTeNRkE;[&](){
            if (json["result"].is_uint64_t()){
                temp_oTeNRkE=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_oTeNRkE=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_oTeNRkE=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_oTeNRkE;}();}();

debug_printf("Ending vkCopyAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureToMemoryKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureToMemoryKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_MpzusRq=json::vector(1);
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[hToWSKz]);
            arr_MpzusRq[hToWSKz]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_MpzusRq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureToMemoryKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureToMemoryKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureToMemoryKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_MpzusRq=json::vector(1);
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[hToWSKz]);
            arr_MpzusRq[hToWSKz]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_MpzusRq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_yBdwNKk;[&](){
            if (json["result"].is_uint64_t()){
                temp_yBdwNKk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yBdwNKk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yBdwNKk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yBdwNKk;}();}();

debug_printf("Ending vkCopyAccelerationStructureToMemoryKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureToMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_yRNSaUF=json::vector(1);
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ulOBYSb]);
            arr_yRNSaUF[ulOBYSb]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_yRNSaUF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_yRNSaUF=json::vector(1);
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ulOBYSb]);
            arr_yRNSaUF[ulOBYSb]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_yRNSaUF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_sCYLTOz;[&](){
            if (json["result"].is_uint64_t()){
                temp_sCYLTOz=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_sCYLTOz=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_sCYLTOz=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_sCYLTOz;}();}();

debug_printf("Ending vkCopyMemoryToAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyMemoryToAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesKHR( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_oCGlcEh=json::vector(accelerationStructureCount);
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        json["pAccelerationStructures"]=arr_oCGlcEh;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesNV( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_NSQEnJt=json::vector(accelerationStructureCount);
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        json["pAccelerationStructures"]=arr_NSQEnJt;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructureNV( VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructureNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_GYyRhgo=json::vector(1);
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[jJuvWAP]);
            arr_GYyRhgo[jJuvWAP]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_GYyRhgo;}();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=static_cast<uint>(instanceOffset);}();}();
[&](){[&](){json["update"]=static_cast<uint>(update);}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=static_cast<uint>(scratchOffset);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
[&](){uint64_t temp_sEYJico;[&](){
            if (json["instanceOffset"].is_uint64_t()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_uint64_t());
            }else if (json["instanceOffset"].is_int64_t()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_int64_t());
            }else{
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].as_double());
            }
            }();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
[&](){uint32_t temp_LpVZhJf;[&](){
            if (json["update"].is_uint64_t()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_uint64_t());
            }else if (json["update"].is_int64_t()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_int64_t());
            }else{
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].as_double());
            }
            }();update=(VkBool32)temp_LpVZhJf;}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
[&](){uint64_t temp_rbfZpmL;[&](){
            if (json["scratchOffset"].is_uint64_t()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_uint64_t());
            }else if (json["scratchOffset"].is_int64_t()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_int64_t());
            }else{
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].as_double());
            }
            }();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

debug_printf("Ending vkCmdBuildAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteAccelerationStructuresPropertiesKHR( VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteAccelerationStructuresPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=static_cast<uint>(accelerationStructureCount);}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=json::vector();
            return; }auto arr_oCGlcEh=json::vector(accelerationStructureCount);
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        json["pAccelerationStructures"]=arr_oCGlcEh;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){json["stride"]=static_cast<int>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_uint64_t());
            }else if (json["accelerationStructureCount"].is_int64_t()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_int64_t());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].as_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<size_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<size_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<size_t>(json["stride"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_NtoSKQr;[&](){
            if (json["result"].is_uint64_t()){
                temp_NtoSKQr=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_NtoSKQr=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_NtoSKQr=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_NtoSKQr;}();}();

debug_printf("Ending vkWriteAccelerationStructuresPropertiesKHR...\n");
debug_printf("Return value of vkWriteAccelerationStructuresPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDTRACERAYSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=json::vector();
            return; }auto arr_SlnAEUX=json::vector(1);
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRaygenShaderBindingTable[VKRuDIv]);
            arr_SlnAEUX[VKRuDIv]=temp_map;
            return;
            }();
        }
        json["pRaygenShaderBindingTable"]=arr_SlnAEUX;}();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=json::vector();
            return; }auto arr_vBQknzc=json::vector(1);
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMissShaderBindingTable[ZhvHpIX]);
            arr_vBQknzc[ZhvHpIX]=temp_map;
            return;
            }();
        }
        json["pMissShaderBindingTable"]=arr_vBQknzc;}();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=json::vector();
            return; }auto arr_IhHhjXk=json::vector(1);
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHitShaderBindingTable[yriMdrU]);
            arr_IhHhjXk[yriMdrU]=temp_map;
            return;
            }();
        }
        json["pHitShaderBindingTable"]=arr_IhHhjXk;}();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=json::vector();
            return; }auto arr_EmEYSBY=json::vector(1);
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallableShaderBindingTable[TiOHiqW]);
            arr_EmEYSBY[TiOHiqW]=temp_map;
            return;
            }();
        }
        json["pCallableShaderBindingTable"]=arr_EmEYSBY;}();
[&](){json["width"]=static_cast<uint>(width);}();
[&](){json["height"]=static_cast<uint>(height);}();
[&](){json["depth"]=static_cast<uint>(depth);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){
            if (json["width"].is_uint64_t()){
                width=static_cast<uint32_t>(json["width"].as_uint64_t());
            }else if (json["width"].is_int64_t()){
                width=static_cast<uint32_t>(json["width"].as_int64_t());
            }else{
                width=static_cast<uint32_t>(json["width"].as_double());
            }
            }();
[&](){
            if (json["height"].is_uint64_t()){
                height=static_cast<uint32_t>(json["height"].as_uint64_t());
            }else if (json["height"].is_int64_t()){
                height=static_cast<uint32_t>(json["height"].as_int64_t());
            }else{
                height=static_cast<uint32_t>(json["height"].as_double());
            }
            }();
[&](){
            if (json["depth"].is_uint64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_uint64_t());
            }else if (json["depth"].is_int64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_int64_t());
            }else{
                depth=static_cast<uint32_t>(json["depth"].as_double());
            }
            }();

debug_printf("Ending vkCmdTraceRaysKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysNV( VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDTRACERAYSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=static_cast<uint>(raygenShaderBindingOffset);}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=static_cast<uint>(missShaderBindingOffset);}();}();
[&](){[&](){json["missShaderBindingStride"]=static_cast<uint>(missShaderBindingStride);}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=static_cast<uint>(hitShaderBindingOffset);}();}();
[&](){[&](){json["hitShaderBindingStride"]=static_cast<uint>(hitShaderBindingStride);}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=static_cast<uint>(callableShaderBindingOffset);}();}();
[&](){[&](){json["callableShaderBindingStride"]=static_cast<uint>(callableShaderBindingStride);}();}();
[&](){json["width"]=static_cast<uint>(width);}();
[&](){json["height"]=static_cast<uint>(height);}();
[&](){json["depth"]=static_cast<uint>(depth);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
[&](){uint64_t temp_nbAYEyt;[&](){
            if (json["raygenShaderBindingOffset"].is_uint64_t()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_uint64_t());
            }else if (json["raygenShaderBindingOffset"].is_int64_t()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_int64_t());
            }else{
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].as_double());
            }
            }();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
[&](){uint64_t temp_ORIaXGF;[&](){
            if (json["missShaderBindingOffset"].is_uint64_t()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_uint64_t());
            }else if (json["missShaderBindingOffset"].is_int64_t()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_int64_t());
            }else{
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].as_double());
            }
            }();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
[&](){uint64_t temp_BOvfilr;[&](){
            if (json["missShaderBindingStride"].is_uint64_t()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_uint64_t());
            }else if (json["missShaderBindingStride"].is_int64_t()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_int64_t());
            }else{
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].as_double());
            }
            }();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
[&](){uint64_t temp_oKlCsJj;[&](){
            if (json["hitShaderBindingOffset"].is_uint64_t()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_uint64_t());
            }else if (json["hitShaderBindingOffset"].is_int64_t()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_int64_t());
            }else{
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].as_double());
            }
            }();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
[&](){uint64_t temp_qhwyGdu;[&](){
            if (json["hitShaderBindingStride"].is_uint64_t()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_uint64_t());
            }else if (json["hitShaderBindingStride"].is_int64_t()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_int64_t());
            }else{
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].as_double());
            }
            }();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
[&](){uint64_t temp_WmjXZmz;[&](){
            if (json["callableShaderBindingOffset"].is_uint64_t()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_uint64_t());
            }else if (json["callableShaderBindingOffset"].is_int64_t()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_int64_t());
            }else{
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].as_double());
            }
            }();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
[&](){uint64_t temp_giLAAVF;[&](){
            if (json["callableShaderBindingStride"].is_uint64_t()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_uint64_t());
            }else if (json["callableShaderBindingStride"].is_int64_t()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_int64_t());
            }else{
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].as_double());
            }
            }();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
[&](){
            if (json["width"].is_uint64_t()){
                width=static_cast<uint32_t>(json["width"].as_uint64_t());
            }else if (json["width"].is_int64_t()){
                width=static_cast<uint32_t>(json["width"].as_int64_t());
            }else{
                width=static_cast<uint32_t>(json["width"].as_double());
            }
            }();
[&](){
            if (json["height"].is_uint64_t()){
                height=static_cast<uint32_t>(json["height"].as_uint64_t());
            }else if (json["height"].is_int64_t()){
                height=static_cast<uint32_t>(json["height"].as_int64_t());
            }else{
                height=static_cast<uint32_t>(json["height"].as_double());
            }
            }();
[&](){
            if (json["depth"].is_uint64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_uint64_t());
            }else if (json["depth"].is_int64_t()){
                depth=static_cast<uint32_t>(json["depth"].as_int64_t());
            }else{
                depth=static_cast<uint32_t>(json["depth"].as_double());
            }
            }();

debug_printf("Ending vkCmdTraceRaysNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupHandlesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETRAYTRACINGSHADERGROUPHANDLESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=static_cast<uint>(firstGroup);}();
[&](){json["groupCount"]=static_cast<uint>(groupCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["firstGroup"].is_uint64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_uint64_t());
            }else if (json["firstGroup"].is_int64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_int64_t());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_double());
            }
            }();
[&](){
            if (json["groupCount"].is_uint64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_uint64_t());
            }else if (json["groupCount"].is_int64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_int64_t());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].as_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_KLLRitp;[&](){
            if (json["result"].is_uint64_t()){
                temp_KLLRitp=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_KLLRitp=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_KLLRitp=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_KLLRitp;}();}();

debug_printf("Ending vkGetRayTracingShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesNV( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
return vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingCaptureReplayShaderGroupHandlesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=static_cast<uint>(firstGroup);}();
[&](){json["groupCount"]=static_cast<uint>(groupCount);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["firstGroup"].is_uint64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_uint64_t());
            }else if (json["firstGroup"].is_int64_t()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_int64_t());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].as_double());
            }
            }();
[&](){
            if (json["groupCount"].is_uint64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_uint64_t());
            }else if (json["groupCount"].is_int64_t()){
                groupCount=static_cast<uint32_t>(json["groupCount"].as_int64_t());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].as_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_eyQTZEO;[&](){
            if (json["result"].is_uint64_t()){
                temp_eyQTZEO=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_eyQTZEO=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_eyQTZEO=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_eyQTZEO;}();}();

debug_printf("Ending vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingCaptureReplayShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureHandleNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureHandleNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREHANDLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREHANDLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_BimoMvo;[&](){
            if (json["result"].is_uint64_t()){
                temp_BimoMvo=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_BimoMvo=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_BimoMvo=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_BimoMvo;}();}();

debug_printf("Ending vkGetAccelerationStructureHandleNV...\n");
debug_printf("Return value of vkGetAccelerationStructureHandleNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesNV( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATERAYTRACINGPIPELINESNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_bzMTsat=json::vector(createInfoCount);
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[oRbABSQ]);
            arr_bzMTsat[oRbABSQ]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_bzMTsat;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();


[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vIEvAGL;[&](){
            if (json["result"].is_uint64_t()){
                temp_vIEvAGL=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_vIEvAGL=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_vIEvAGL=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_vIEvAGL;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesNV...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATERAYTRACINGPIPELINESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_zltFjJj=json::vector(createInfoCount);
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[Szqaxlk]);
            arr_zltFjJj[Szqaxlk]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_zltFjJj;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=json::vector();
            return; }auto arr_wuOYMDC=json::vector(createInfoCount);
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        json["pPipelines"]=arr_wuOYMDC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();


[&](){
            if (json["pPipelines"].as_vector().size()==0){
                pPipelines=NULL;
            return; }auto& arr_wuOYMDC=json["pPipelines"].as_vector();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_HNasHBP;[&](){
            if (json["result"].is_uint64_t()){
                temp_HNasHBP=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HNasHBP=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HNasHBP=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HNasHBP;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesKHR...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_kVfVVDF=json::vector(*pPropertyCount);
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[WfgOgPA]);
            arr_kVfVVDF[WfgOgPA]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_kVfVVDF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_kVfVVDF=json["pProperties"].as_vector();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            deserialize_struct(arr_kVfVVDF[WfgOgPA].as_map(),pProperties[WfgOgPA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wCoTUxK;[&](){
            if (json["result"].is_uint64_t()){
                temp_wCoTUxK=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_wCoTUxK=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_wCoTUxK=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_wCoTUxK;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirectKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirectKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDTRACERAYSINDIRECTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=json::vector();
            return; }auto arr_SlnAEUX=json::vector(1);
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRaygenShaderBindingTable[VKRuDIv]);
            arr_SlnAEUX[VKRuDIv]=temp_map;
            return;
            }();
        }
        json["pRaygenShaderBindingTable"]=arr_SlnAEUX;}();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=json::vector();
            return; }auto arr_vBQknzc=json::vector(1);
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMissShaderBindingTable[ZhvHpIX]);
            arr_vBQknzc[ZhvHpIX]=temp_map;
            return;
            }();
        }
        json["pMissShaderBindingTable"]=arr_vBQknzc;}();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=json::vector();
            return; }auto arr_IhHhjXk=json::vector(1);
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHitShaderBindingTable[yriMdrU]);
            arr_IhHhjXk[yriMdrU]=temp_map;
            return;
            }();
        }
        json["pHitShaderBindingTable"]=arr_IhHhjXk;}();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=json::vector();
            return; }auto arr_EmEYSBY=json::vector(1);
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCallableShaderBindingTable[TiOHiqW]);
            arr_EmEYSBY[TiOHiqW]=temp_map;
            return;
            }();
        }
        json["pCallableShaderBindingTable"]=arr_EmEYSBY;}();
[&](){[&](){json["indirectDeviceAddress"]=static_cast<uint>(indirectDeviceAddress);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_uint64_t());
            }else if (json["indirectDeviceAddress"].is_int64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_int64_t());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirect2KHR( VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirect2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDTRACERAYSINDIRECT2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=static_cast<uint>(indirectDeviceAddress);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_uint64_t());
            }else if (json["indirectDeviceAddress"].is_int64_t()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_int64_t());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].as_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirect2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceAccelerationStructureCompatibilityKHR( VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceAccelerationStructureCompatibilityKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=json::vector();
            return; }auto arr_wbhdpeb=json::vector(1);
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVersionInfo[vhWWlwM]);
            arr_wbhdpeb[vhWWlwM]=temp_map;
            return;
            }();
        }
        json["pVersionInfo"]=arr_wbhdpeb;}();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=json::vector();
            return; }auto arr_dBMhFMX=json::vector(1);
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=static_cast<int>(pCompatibility[nzOFTGF]);}();}();}();
        }
        json["pCompatibility"]=arr_dBMhFMX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].as_vector().size()==0){
                pCompatibility=NULL;
            return; }auto& arr_dBMhFMX=json["pCompatibility"].as_vector();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_uint64_t());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_int64_t());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR( VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupStackSizeKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=static_cast<uint>(group);}();
[&](){[&](){[&](){json["groupShader"]=static_cast<int>(groupShader);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["group"].is_uint64_t()){
                group=static_cast<uint32_t>(json["group"].as_uint64_t());
            }else if (json["group"].is_int64_t()){
                group=static_cast<uint32_t>(json["group"].as_int64_t());
            }else{
                group=static_cast<uint32_t>(json["group"].as_double());
            }
            }();
[&](){[&](){int temp_EOWKSMj;[&](){
            if (json["groupShader"].is_uint64_t()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_uint64_t());
            }else if (json["groupShader"].is_int64_t()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_int64_t());
            }else{
                temp_EOWKSMj=static_cast<int>(json["groupShader"].as_double());
            }
            }();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();
VkDeviceSize result;
[&](){uint64_t temp_ZqPypzB;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].as_double());
            }
            }();result=(VkDeviceSize)temp_ZqPypzB;}();

debug_printf("Ending vkGetRayTracingShaderGroupStackSizeKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetRayTracingPipelineStackSizeKHR( VkCommandBuffer commandBuffer, uint32_t pipelineStackSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRayTracingPipelineStackSizeKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=static_cast<uint>(pipelineStackSize);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["pipelineStackSize"].is_uint64_t()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_uint64_t());
            }else if (json["pipelineStackSize"].is_int64_t()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_int64_t());
            }else{
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetRayTracingPipelineStackSizeKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetImageViewHandleNVX( VkDevice device, const VkImageViewHandleInfoNVX* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewHandleNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWHANDLENVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_mfMZJfb=json::vector(1);
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dQabsff]);
            arr_mfMZJfb[dQabsff]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_mfMZJfb;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWHANDLENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint32_t result;
[&](){
            if (json["result"].is_uint64_t()){
                result=static_cast<uint32_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                result=static_cast<uint32_t>(json["result"].as_int64_t());
            }else{
                result=static_cast<uint32_t>(json["result"].as_double());
            }
            }();

debug_printf("Ending vkGetImageViewHandleNVX...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewAddressNVX( VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewAddressNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWADDRESSNVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hveoAIn=json::vector(1);
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[FiVrJfn]);
            arr_hveoAIn[FiVrJfn]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hveoAIn;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWADDRESSNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_hveoAIn=json["pProperties"].as_vector();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            deserialize_struct(arr_hveoAIn[FiVrJfn].as_map(),pProperties[FiVrJfn]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_APQqeGV;[&](){
            if (json["result"].is_uint64_t()){
                temp_APQqeGV=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_APQqeGV=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_APQqeGV=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_APQqeGV;}();}();

debug_printf("Ending vkGetImageViewAddressNVX...\n");
debug_printf("Return value of vkGetImageViewAddressNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=static_cast<uint>(queueFamilyIndex);}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=json::vector();
            return; }auto arr_QuwxWHd=json::vector(1);
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=static_cast<uint>(pCounterCount[HDbVSFc]);}();
        }
        json["pCounterCount"]=arr_QuwxWHd;}();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=json::vector();
            return; }auto arr_vEVlsJt=json::vector(*pCounterCount);
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCounters[WmftXku]);
            arr_vEVlsJt[WmftXku]=temp_map;
            return;
            }();
        }
        json["pCounters"]=arr_vEVlsJt;}();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=json::vector();
            return; }auto arr_znRZkzO=json::vector(*pCounterCount);
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCounterDescriptions[GjxogPx]);
            arr_znRZkzO[GjxogPx]=temp_map;
            return;
            }();
        }
        json["pCounterDescriptions"]=arr_znRZkzO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_uint64_t());
            }else if (json["queueFamilyIndex"].is_int64_t()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_int64_t());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].as_double());
            }
            }();
[&](){
            if (json["pCounterCount"].as_vector().size()==0){
                pCounterCount=NULL;
            return; }auto& arr_QuwxWHd=json["pCounterCount"].as_vector();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){
            if (arr_QuwxWHd[HDbVSFc].is_uint64_t()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_uint64_t());
            }else if (arr_QuwxWHd[HDbVSFc].is_int64_t()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_int64_t());
            }else{
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCounters"].as_vector().size()==0){
                pCounters=NULL;
            return; }auto& arr_vEVlsJt=json["pCounters"].as_vector();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            deserialize_struct(arr_vEVlsJt[WmftXku].as_map(),pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (json["pCounterDescriptions"].as_vector().size()==0){
                pCounterDescriptions=NULL;
            return; }auto& arr_znRZkzO=json["pCounterDescriptions"].as_vector();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            deserialize_struct(arr_znRZkzO[GjxogPx].as_map(),pCounterDescriptions[GjxogPx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_iuXpjxQ;[&](){
            if (json["result"].is_uint64_t()){
                temp_iuXpjxQ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_iuXpjxQ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_iuXpjxQ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_iuXpjxQ;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR( VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=json::vector();
            return; }auto arr_HfbrSJi=json::vector(1);
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPerformanceQueryCreateInfo[aEYwfht]);
            arr_HfbrSJi[aEYwfht]=temp_map;
            return;
            }();
        }
        json["pPerformanceQueryCreateInfo"]=arr_HfbrSJi;}();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=json::vector();
            return; }auto arr_QgclfwI=json::vector(1);
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=static_cast<uint>(pNumPasses[vyixxEg]);}();
        }
        json["pNumPasses"]=arr_QgclfwI;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pNumPasses"].as_vector().size()==0){
                pNumPasses=NULL;
            return; }auto& arr_QgclfwI=json["pNumPasses"].as_vector();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){
            if (arr_QgclfwI[vyixxEg].is_uint64_t()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_uint64_t());
            }else if (arr_QgclfwI[vyixxEg].is_int64_t()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_int64_t());
            }else{
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].as_double());
            }
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireProfilingLockKHR( VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkAcquireProfilingLockKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKACQUIREPROFILINGLOCKKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_BslWEPE=json::vector(1);
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[ZgSmBLm]);
            arr_BslWEPE[ZgSmBLm]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_BslWEPE;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_Proylyu;[&](){
            if (json["result"].is_uint64_t()){
                temp_Proylyu=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_Proylyu=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_Proylyu=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_Proylyu;}();}();

debug_printf("Ending vkAcquireProfilingLockKHR...\n");
debug_printf("Return value of vkAcquireProfilingLockKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkReleaseProfilingLockKHR( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkReleaseProfilingLockKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRELEASEPROFILINGLOCKKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkReleaseProfilingLockKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageDrmFormatModifierPropertiesEXT( VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageDrmFormatModifierPropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_oxSUmzu=json::vector(1);
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[JPWNMan]);
            arr_oxSUmzu[JPWNMan]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_oxSUmzu;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_oxSUmzu=json["pProperties"].as_vector();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            deserialize_struct(arr_oxSUmzu[JPWNMan].as_map(),pProperties[JPWNMan]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_BityiSk;[&](){
            if (json["result"].is_uint64_t()){
                temp_BityiSk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_BityiSk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_BityiSk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_BityiSk;}();}();

debug_printf("Ending vkGetImageDrmFormatModifierPropertiesEXT...\n");
debug_printf("Return value of vkGetImageDrmFormatModifierPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureAddress\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETBUFFEROPAQUECAPTUREADDRESS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LRSftdl=json::vector(1);
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[CPHfQOs]);
            arr_LRSftdl[CPHfQOs]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LRSftdl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){
            if (json["result"].is_uint64_t()){
                result=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                result=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                result=static_cast<uint64_t>(json["result"].as_double());
            }
            }();

debug_printf("Ending vkGetBufferOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferDeviceAddress\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETBUFFERDEVICEADDRESS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_LRSftdl=json::vector(1);
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[CPHfQOs]);
            arr_LRSftdl[CPHfQOs]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_LRSftdl;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERDEVICEADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_qUAUGbq;[&](){
            if (json["result"].is_uint64_t()){
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].as_double());
            }
            }();result=(VkDeviceAddress)temp_qUAUGbq;}();

debug_printf("Ending vkGetBufferDeviceAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressEXT( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateHeadlessSurfaceEXT( VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateHeadlessSurfaceEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEHEADLESSSURFACEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_yHbnuDf=json::vector(1);
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[CyHXDmy]);
            arr_yHbnuDf[CyHXDmy]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_yHbnuDf;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=json::vector();
            return; }auto arr_zGtWguc=json::vector(1);
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        json["pSurface"]=arr_zGtWguc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEHEADLESSSURFACEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].as_vector().size()==0){
                pSurface=NULL;
            return; }auto& arr_zGtWguc=json["pSurface"].as_vector();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_TzZyHWk;[&](){
            if (json["result"].is_uint64_t()){
                temp_TzZyHWk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TzZyHWk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_TzZyHWk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_TzZyHWk;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateHeadlessSurfaceEXT...\n");
debug_printf("Return value of vkCreateHeadlessSurfaceEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV( VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=json::vector();
            return; }auto arr_VrJxAqY=json::vector(1);
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=static_cast<uint>(pCombinationCount[jKkiHUO]);}();
        }
        json["pCombinationCount"]=arr_VrJxAqY;}();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=json::vector();
            return; }auto arr_aOIaDFM=json::vector(*pCombinationCount);
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCombinations[oxJqbjP]);
            arr_aOIaDFM[oxJqbjP]=temp_map;
            return;
            }();
        }
        json["pCombinations"]=arr_aOIaDFM;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pCombinationCount"].as_vector().size()==0){
                pCombinationCount=NULL;
            return; }auto& arr_VrJxAqY=json["pCombinationCount"].as_vector();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){
            if (arr_VrJxAqY[jKkiHUO].is_uint64_t()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_uint64_t());
            }else if (arr_VrJxAqY[jKkiHUO].is_int64_t()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_int64_t());
            }else{
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCombinations"].as_vector().size()==0){
                pCombinations=NULL;
            return; }auto& arr_aOIaDFM=json["pCombinations"].as_vector();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            deserialize_struct(arr_aOIaDFM[oxJqbjP].as_map(),pCombinations[oxJqbjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_yOeKofu;[&](){
            if (json["result"].is_uint64_t()){
                temp_yOeKofu=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yOeKofu=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yOeKofu=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yOeKofu;}();}();

debug_printf("Ending vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInitializePerformanceApiINTEL( VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo ){
//Will only be called by the client
debug_printf("Executing vkInitializePerformanceApiINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKINITIALIZEPERFORMANCEAPIINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=json::vector();
            return; }auto arr_BGIuPda=json::vector(1);
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInitializeInfo[pMSNyrD]);
            arr_BGIuPda[pMSNyrD]=temp_map;
            return;
            }();
        }
        json["pInitializeInfo"]=arr_BGIuPda;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_giEXhKW;[&](){
            if (json["result"].is_uint64_t()){
                temp_giEXhKW=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_giEXhKW=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_giEXhKW=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_giEXhKW;}();}();

debug_printf("Ending vkInitializePerformanceApiINTEL...\n");
debug_printf("Return value of vkInitializePerformanceApiINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUninitializePerformanceApiINTEL( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkUninitializePerformanceApiINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKUNINITIALIZEPERFORMANCEAPIINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkUninitializePerformanceApiINTEL...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceMarkerINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCEMARKERINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_jnuNlGq=json::vector(1);
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[zTzAESc]);
            arr_jnuNlGq[zTzAESc]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_jnuNlGq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_xYiZXdw;[&](){
            if (json["result"].is_uint64_t()){
                temp_xYiZXdw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_xYiZXdw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_xYiZXdw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_xYiZXdw;}();}();

debug_printf("Ending vkCmdSetPerformanceMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceStreamMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceStreamMarkerINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCESTREAMMARKERINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=json::vector();
            return; }auto arr_MVQnSpz=json::vector(1);
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMarkerInfo[xfSMHfo]);
            arr_MVQnSpz[xfSMHfo]=temp_map;
            return;
            }();
        }
        json["pMarkerInfo"]=arr_MVQnSpz;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_icTHZCa;[&](){
            if (json["result"].is_uint64_t()){
                temp_icTHZCa=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_icTHZCa=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_icTHZCa=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_icTHZCa;}();}();

debug_printf("Ending vkCmdSetPerformanceStreamMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceStreamMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceOverrideINTEL( VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceOverrideINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPERFORMANCEOVERRIDEINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=json::vector();
            return; }auto arr_LHSFuEM=json::vector(1);
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pOverrideInfo[KZSCUHM]);
            arr_LHSFuEM[KZSCUHM]=temp_map;
            return;
            }();
        }
        json["pOverrideInfo"]=arr_LHSFuEM;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_kyUAzJJ;[&](){
            if (json["result"].is_uint64_t()){
                temp_kyUAzJJ=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_kyUAzJJ=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_kyUAzJJ=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_kyUAzJJ;}();}();

debug_printf("Ending vkCmdSetPerformanceOverrideINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceOverrideINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquirePerformanceConfigurationINTEL( VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration ){
//Will only be called by the client
debug_printf("Executing vkAcquirePerformanceConfigurationINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKACQUIREPERFORMANCECONFIGURATIONINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=json::vector();
            return; }auto arr_ZyqvvlF=json::vector(1);
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAcquireInfo[RYEcOAO]);
            arr_ZyqvvlF[RYEcOAO]=temp_map;
            return;
            }();
        }
        json["pAcquireInfo"]=arr_ZyqvvlF;}();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=json::vector();
            return; }auto arr_zSRZrDS=json::vector(1);
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        json["pConfiguration"]=arr_zSRZrDS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pConfiguration"].as_vector().size()==0){
                pConfiguration=NULL;
            return; }auto& arr_zSRZrDS=json["pConfiguration"].as_vector();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_AsKhKBD;[&](){
            if (json["result"].is_uint64_t()){
                temp_AsKhKBD=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_AsKhKBD=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_AsKhKBD=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_AsKhKBD;}();}();

debug_printf("Ending vkAcquirePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkAcquirePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleasePerformanceConfigurationINTEL( VkDevice device, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkReleasePerformanceConfigurationINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRELEASEPERFORMANCECONFIGURATIONINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_ZlGbunc;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZlGbunc=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZlGbunc=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZlGbunc=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZlGbunc;}();}();

debug_printf("Ending vkReleasePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkReleasePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSetPerformanceConfigurationINTEL( VkQueue queue, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkQueueSetPerformanceConfigurationINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUESETPERFORMANCECONFIGURATIONINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_jsqfGAY;[&](){
            if (json["result"].is_uint64_t()){
                temp_jsqfGAY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_jsqfGAY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_jsqfGAY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_jsqfGAY;}();}();

debug_printf("Ending vkQueueSetPerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkQueueSetPerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPerformanceParameterINTEL( VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetPerformanceParameterINTEL\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPERFORMANCEPARAMETERINTEL);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=static_cast<int>(parameter);}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=json::vector();
            return; }auto arr_hOmaGpc=json::vector(1);
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pValue[lyxuUNd]);
            arr_hOmaGpc[lyxuUNd]=temp_map;
            return;
            }();
        }
        json["pValue"]=arr_hOmaGpc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPERFORMANCEPARAMETERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_TQususa;[&](){
            if (json["parameter"].is_uint64_t()){
                temp_TQususa=static_cast<int>(json["parameter"].as_uint64_t());
            }else if (json["parameter"].is_int64_t()){
                temp_TQususa=static_cast<int>(json["parameter"].as_int64_t());
            }else{
                temp_TQususa=static_cast<int>(json["parameter"].as_double());
            }
            }();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
[&](){
            if (json["pValue"].as_vector().size()==0){
                pValue=NULL;
            return; }auto& arr_hOmaGpc=json["pValue"].as_vector();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            deserialize_struct(arr_hOmaGpc[lyxuUNd].as_map(),pValue[lyxuUNd]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_AOHjoLz;[&](){
            if (json["result"].is_uint64_t()){
                temp_AOHjoLz=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_AOHjoLz=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_AOHjoLz=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_AOHjoLz;}();}();

debug_printf("Ending vkGetPerformanceParameterINTEL...\n");
debug_printf("Return value of vkGetPerformanceParameterINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddress( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryOpaqueCaptureAddress\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_hjweGct=json::vector(1);
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vcZpbuB]);
            arr_hjweGct[vcZpbuB]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_hjweGct;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){
            if (json["result"].is_uint64_t()){
                result=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                result=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                result=static_cast<uint64_t>(json["result"].as_double());
            }
            }();

debug_printf("Ending vkGetDeviceMemoryOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
return vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutablePropertiesKHR( VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutablePropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLEPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=json::vector();
            return; }auto arr_SxuxUqw=json::vector(1);
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineInfo[mwoMxRp]);
            arr_SxuxUqw[mwoMxRp]=temp_map;
            return;
            }();
        }
        json["pPipelineInfo"]=arr_SxuxUqw;}();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=json::vector();
            return; }auto arr_tlXPSPh=json::vector(1);
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=static_cast<uint>(pExecutableCount[ZFmbkCm]);}();
        }
        json["pExecutableCount"]=arr_tlXPSPh;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_vtfdUfF=json::vector(*pExecutableCount);
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[uPFqrVz]);
            arr_vtfdUfF[uPFqrVz]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_vtfdUfF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pExecutableCount"].as_vector().size()==0){
                pExecutableCount=NULL;
            return; }auto& arr_tlXPSPh=json["pExecutableCount"].as_vector();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){
            if (arr_tlXPSPh[ZFmbkCm].is_uint64_t()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_uint64_t());
            }else if (arr_tlXPSPh[ZFmbkCm].is_int64_t()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_int64_t());
            }else{
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_vtfdUfF=json["pProperties"].as_vector();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            deserialize_struct(arr_vtfdUfF[uPFqrVz].as_map(),pProperties[uPFqrVz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bmoAfmd;[&](){
            if (json["result"].is_uint64_t()){
                temp_bmoAfmd=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_bmoAfmd=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_bmoAfmd=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_bmoAfmd;}();}();

debug_printf("Ending vkGetPipelineExecutablePropertiesKHR...\n");
debug_printf("Return value of vkGetPipelineExecutablePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableStatisticsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableStatisticsKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLESTATISTICSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=json::vector();
            return; }auto arr_xbHlsCc=json::vector(1);
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecutableInfo[JTDfcCv]);
            arr_xbHlsCc[JTDfcCv]=temp_map;
            return;
            }();
        }
        json["pExecutableInfo"]=arr_xbHlsCc;}();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=json::vector();
            return; }auto arr_BIkbvee=json::vector(1);
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=static_cast<uint>(pStatisticCount[MiieuSo]);}();
        }
        json["pStatisticCount"]=arr_BIkbvee;}();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=json::vector();
            return; }auto arr_cGybyJf=json::vector(*pStatisticCount);
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pStatistics[ktSOZGx]);
            arr_cGybyJf[ktSOZGx]=temp_map;
            return;
            }();
        }
        json["pStatistics"]=arr_cGybyJf;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pStatisticCount"].as_vector().size()==0){
                pStatisticCount=NULL;
            return; }auto& arr_BIkbvee=json["pStatisticCount"].as_vector();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){
            if (arr_BIkbvee[MiieuSo].is_uint64_t()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_uint64_t());
            }else if (arr_BIkbvee[MiieuSo].is_int64_t()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_int64_t());
            }else{
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pStatistics"].as_vector().size()==0){
                pStatistics=NULL;
            return; }auto& arr_cGybyJf=json["pStatistics"].as_vector();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            deserialize_struct(arr_cGybyJf[ktSOZGx].as_map(),pStatistics[ktSOZGx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tgNgnbg;[&](){
            if (json["result"].is_uint64_t()){
                temp_tgNgnbg=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_tgNgnbg=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_tgNgnbg=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_tgNgnbg;}();}();

debug_printf("Ending vkGetPipelineExecutableStatisticsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableStatisticsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableInternalRepresentationsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableInternalRepresentationsKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=json::vector();
            return; }auto arr_xbHlsCc=json::vector(1);
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecutableInfo[JTDfcCv]);
            arr_xbHlsCc[JTDfcCv]=temp_map;
            return;
            }();
        }
        json["pExecutableInfo"]=arr_xbHlsCc;}();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=json::vector();
            return; }auto arr_bVgggzH=json::vector(1);
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=static_cast<uint>(pInternalRepresentationCount[urjNjhc]);}();
        }
        json["pInternalRepresentationCount"]=arr_bVgggzH;}();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=json::vector();
            return; }auto arr_yqajgdo=json::vector(*pInternalRepresentationCount);
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInternalRepresentations[OdpgULc]);
            arr_yqajgdo[OdpgULc]=temp_map;
            return;
            }();
        }
        json["pInternalRepresentations"]=arr_yqajgdo;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pInternalRepresentationCount"].as_vector().size()==0){
                pInternalRepresentationCount=NULL;
            return; }auto& arr_bVgggzH=json["pInternalRepresentationCount"].as_vector();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){
            if (arr_bVgggzH[urjNjhc].is_uint64_t()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_uint64_t());
            }else if (arr_bVgggzH[urjNjhc].is_int64_t()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_int64_t());
            }else{
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pInternalRepresentations"].as_vector().size()==0){
                pInternalRepresentations=NULL;
            return; }auto& arr_yqajgdo=json["pInternalRepresentations"].as_vector();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            deserialize_struct(arr_yqajgdo[OdpgULc].as_map(),pInternalRepresentations[OdpgULc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZbFBqRu;[&](){
            if (json["result"].is_uint64_t()){
                temp_ZbFBqRu=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ZbFBqRu=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ZbFBqRu=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ZbFBqRu;}();}();

debug_printf("Ending vkGetPipelineExecutableInternalRepresentationsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableInternalRepresentationsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEXT( VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLINESTIPPLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=static_cast<uint>(lineStippleFactor);}();
[&](){json["lineStipplePattern"]=static_cast<uint>(lineStipplePattern);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["lineStippleFactor"].is_uint64_t()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_uint64_t());
            }else if (json["lineStippleFactor"].is_int64_t()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_int64_t());
            }else{
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].as_double());
            }
            }();
[&](){
            if (json["lineStipplePattern"].is_uint64_t()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_uint64_t());
            }else if (json["lineStipplePattern"].is_int64_t()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_int64_t());
            }else{
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetLineStippleEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolProperties( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceToolProperties\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICETOOLPROPERTIES);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=json::vector();
            return; }auto arr_PNAKwfC=json::vector(1);
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=static_cast<uint>(pToolCount[iRGIIgT]);}();
        }
        json["pToolCount"]=arr_PNAKwfC;}();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=json::vector();
            return; }auto arr_OYowiCQ=json::vector(*pToolCount);
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pToolProperties[dlPXJcQ]);
            arr_OYowiCQ[dlPXJcQ]=temp_map;
            return;
            }();
        }
        json["pToolProperties"]=arr_OYowiCQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICETOOLPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pToolCount"].as_vector().size()==0){
                pToolCount=NULL;
            return; }auto& arr_PNAKwfC=json["pToolCount"].as_vector();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){
            if (arr_PNAKwfC[iRGIIgT].is_uint64_t()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_uint64_t());
            }else if (arr_PNAKwfC[iRGIIgT].is_int64_t()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_int64_t());
            }else{
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pToolProperties"].as_vector().size()==0){
                pToolProperties=NULL;
            return; }auto& arr_OYowiCQ=json["pToolProperties"].as_vector();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            deserialize_struct(arr_OYowiCQ[dlPXJcQ].as_map(),pToolProperties[dlPXJcQ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_quwAQvB;[&](){
            if (json["result"].is_uint64_t()){
                temp_quwAQvB=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_quwAQvB=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_quwAQvB=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_quwAQvB;}();}();

debug_printf("Ending vkGetPhysicalDeviceToolProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceToolProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolPropertiesEXT( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
return vkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureKHR( VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEACCELERATIONSTRUCTUREKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XoURuCS=json::vector(1);
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[bGUDBRC]);
            arr_XoURuCS[bGUDBRC]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XoURuCS;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=json::vector();
            return; }auto arr_vKbZGTA=json::vector(1);
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        json["pAccelerationStructure"]=arr_vKbZGTA;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].as_vector().size()==0){
                pAccelerationStructure=NULL;
            return; }auto& arr_vKbZGTA=json["pAccelerationStructure"].as_vector();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_xpTclnw;[&](){
            if (json["result"].is_uint64_t()){
                temp_xpTclnw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_xpTclnw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_xpTclnw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_xpTclnw;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureKHR...\n");
debug_printf("Return value of vkCreateAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=json::vector();
            return; }auto arr_FMxYLmq=json::vector(1);
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=json::vector();
            return; }auto arr_PKxEvVS=json::vector(infoCount);
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            arr_PKxEvVS[IUJrDJF]=temp_map;
            return;
            }();
        }
        arr_FMxYLmq[CRaOjpb]=arr_PKxEvVS;}();
        }
        json["ppBuildRangeInfos"]=arr_FMxYLmq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdBuildAccelerationStructuresKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresIndirectKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresIndirectKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=json::vector();
            return; }auto arr_YkBEqzj=json::vector(infoCount);
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=static_cast<uint>(pIndirectDeviceAddresses[tMAuxlx]);}();}();
        }
        json["pIndirectDeviceAddresses"]=arr_YkBEqzj;}();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=json::vector();
            return; }auto arr_Helprzq=json::vector(infoCount);
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=static_cast<uint>(pIndirectStrides[IXUUYlr]);}();
        }
        json["pIndirectStrides"]=arr_Helprzq;}();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=json::vector();
            return; }auto arr_DfsqJWs=json::vector(1);
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=json::vector();
            return; }auto arr_kfQrDXL=json::vector(infoCount);
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=static_cast<uint>(ppMaxPrimitiveCounts[TyNkaSn][SABezVP]);}();
        }
        arr_DfsqJWs[TyNkaSn]=arr_kfQrDXL;}();
        }
        json["ppMaxPrimitiveCounts"]=arr_DfsqJWs;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();





debug_printf("Ending vkCmdBuildAccelerationStructuresIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildAccelerationStructuresKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildAccelerationStructuresKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBUILDACCELERATIONSTRUCTURESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_lswJvjt=json::vector(infoCount);
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[frdaizU]);
            arr_lswJvjt[frdaizU]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_lswJvjt;}();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=json::vector();
            return; }auto arr_FMxYLmq=json::vector(1);
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=json::vector();
            return; }auto arr_PKxEvVS=json::vector(infoCount);
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            arr_PKxEvVS[IUJrDJF]=temp_map;
            return;
            }();
        }
        arr_FMxYLmq[CRaOjpb]=arr_PKxEvVS;}();
        }
        json["ppBuildRangeInfos"]=arr_FMxYLmq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();


VkResult result;
[&](){[&](){int temp_jDxtCth;[&](){
            if (json["result"].is_uint64_t()){
                temp_jDxtCth=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_jDxtCth=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_jDxtCth=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_jDxtCth;}();}();

debug_printf("Ending vkBuildAccelerationStructuresKHR...\n");
debug_printf("Return value of vkBuildAccelerationStructuresKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR( VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureDeviceAddressKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_CAfLmMn=json::vector(1);
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[DozYfEa]);
            arr_CAfLmMn[DozYfEa]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_CAfLmMn;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_TsXKzrv;[&](){
            if (json["result"].is_uint64_t()){
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].as_double());
            }
            }();result=(VkDeviceAddress)temp_TsXKzrv;}();

debug_printf("Ending vkGetAccelerationStructureDeviceAddressKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDeferredOperationKHR( VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation ){
//Will only be called by the client
debug_printf("Executing vkCreateDeferredOperationKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEDEFERREDOPERATIONKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=json::vector();
            return; }auto arr_fPVilHH=json::vector(1);
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        json["pDeferredOperation"]=arr_fPVilHH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDeferredOperation"].as_vector().size()==0){
                pDeferredOperation=NULL;
            return; }auto& arr_fPVilHH=json["pDeferredOperation"].as_vector();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LPzNqZx;[&](){
            if (json["result"].is_uint64_t()){
                temp_LPzNqZx=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LPzNqZx=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LPzNqZx=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LPzNqZx;}();}();

                if (pDeferredOperation!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDeferredOperation[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDeferredOperationKHR...\n");
debug_printf("Return value of vkCreateDeferredOperationKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDeferredOperationKHR( VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDeferredOperationKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYDEFERREDOPERATIONKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();


debug_printf("Ending vkDestroyDeferredOperationKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetDeferredOperationMaxConcurrencyKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationMaxConcurrencyKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
uint32_t result;
[&](){
            if (json["result"].is_uint64_t()){
                result=static_cast<uint32_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                result=static_cast<uint32_t>(json["result"].as_int64_t());
            }else{
                result=static_cast<uint32_t>(json["result"].as_double());
            }
            }();

debug_printf("Ending vkGetDeferredOperationMaxConcurrencyKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeferredOperationResultKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationResultKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEFERREDOPERATIONRESULTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONRESULTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_WGAgFkU;[&](){
            if (json["result"].is_uint64_t()){
                temp_WGAgFkU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_WGAgFkU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_WGAgFkU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_WGAgFkU;}();}();

debug_printf("Ending vkGetDeferredOperationResultKHR...\n");
debug_printf("Return value of vkGetDeferredOperationResultKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeferredOperationJoinKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkDeferredOperationJoinKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDEFERREDOPERATIONJOINKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEFERREDOPERATIONJOINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_DKlerev;[&](){
            if (json["result"].is_uint64_t()){
                temp_DKlerev=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_DKlerev=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_DKlerev=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_DKlerev;}();}();

debug_printf("Ending vkDeferredOperationJoinKHR...\n");
debug_printf("Return value of vkDeferredOperationJoinKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPipelineIndirectMemoryRequirementsNV( VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectMemoryRequirementsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XLStDVY=json::vector(1);
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[FoBxBjF]);
            arr_XLStDVY[FoBxBjF]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XLStDVY;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_ZIfZgsB=json::vector(1);
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[jKzQtoG]);
            arr_ZIfZgsB[jKzQtoG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_ZIfZgsB;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_ZIfZgsB=json["pMemoryRequirements"].as_vector();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            deserialize_struct(arr_ZIfZgsB[jKzQtoG].as_map(),pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetPipelineIndirectMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV( VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectDeviceAddressNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEINDIRECTDEVICEADDRESSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_iNXSdlN=json::vector(1);
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[EeNdDDD]);
            arr_iNXSdlN[EeNdDDD]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_iNXSdlN;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_FNTHIwh;[&](){
            if (json["result"].is_uint64_t()){
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].as_int64_t());
            }else{
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].as_double());
            }
            }();result=(VkDeviceAddress)temp_FNTHIwh;}();

debug_printf("Ending vkGetPipelineIndirectDeviceAddressNV...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullMode( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCullMode\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCULLMODE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=static_cast<int>(cullMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCULLMODE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_JocwJIC;[&](){
            if (json["cullMode"].is_uint64_t()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_uint64_t());
            }else if (json["cullMode"].is_int64_t()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_int64_t());
            }else{
                temp_JocwJIC=static_cast<int>(json["cullMode"].as_double());
            }
            }();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

debug_printf("Ending vkCmdSetCullMode...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullModeEXT( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
return vkCmdSetCullMode(commandBuffer, cullMode);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFace( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFrontFace\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETFRONTFACE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=static_cast<int>(frontFace);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRONTFACE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_ZBubEzp;[&](){
            if (json["frontFace"].is_uint64_t()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_uint64_t());
            }else if (json["frontFace"].is_int64_t()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_int64_t());
            }else{
                temp_ZBubEzp=static_cast<int>(json["frontFace"].as_double());
            }
            }();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

debug_printf("Ending vkCmdSetFrontFace...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFaceEXT( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
return vkCmdSetFrontFace(commandBuffer, frontFace);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopology( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveTopology\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPRIMITIVETOPOLOGY);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=static_cast<int>(primitiveTopology);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVETOPOLOGY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_jzAnfAA;[&](){
            if (json["primitiveTopology"].is_uint64_t()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_uint64_t());
            }else if (json["primitiveTopology"].is_int64_t()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_int64_t());
            }else{
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].as_double());
            }
            }();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

debug_printf("Ending vkCmdSetPrimitiveTopology...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopologyEXT( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
return vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCount( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWithCount\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWITHCOUNT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=json::vector();
            return; }auto arr_SyYryUE=json::vector(viewportCount);
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewports[HAuJlzw]);
            arr_SyYryUE[HAuJlzw]=temp_map;
            return;
            }();
        }
        json["pViewports"]=arr_SyYryUE;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCountEXT( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
return vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCount( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissorWithCount\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSCISSORWITHCOUNT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=static_cast<uint>(scissorCount);}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=json::vector();
            return; }auto arr_RpUaBcS=json::vector(scissorCount);
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pScissors[XBYGvVT]);
            arr_RpUaBcS[XBYGvVT]=temp_map;
            return;
            }();
        }
        json["pScissors"]=arr_RpUaBcS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSORWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["scissorCount"].is_uint64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_uint64_t());
            }else if (json["scissorCount"].is_int64_t()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_int64_t());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetScissorWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCountEXT( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
return vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer2KHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDINDEXBUFFER2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=static_cast<uint>(offset);}();}();
[&](){[&](){json["size"]=static_cast<uint>(size);}();}();
[&](){[&](){[&](){json["indexType"]=static_cast<int>(indexType);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_uint64_t());
            }else if (json["offset"].is_int64_t()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_int64_t());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].as_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_uint64_t());
            }else if (json["size"].is_int64_t()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_int64_t());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].as_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_uint64_t());
            }else if (json["indexType"].is_int64_t()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_int64_t());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].as_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDVERTEXBUFFERS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=static_cast<uint>(firstBinding);}();
[&](){json["bindingCount"]=static_cast<uint>(bindingCount);}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=json::vector();
            return; }auto arr_ENtnMTo=json::vector(bindingCount);
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        json["pBuffers"]=arr_ENtnMTo;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(bindingCount);
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=json::vector();
            return; }auto arr_OwyEmcF=json::vector(bindingCount);
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=static_cast<uint>(pSizes[YFhxzVl]);}();}();
        }
        json["pSizes"]=arr_OwyEmcF;}();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=json::vector();
            return; }auto arr_YFLMtWg=json::vector(bindingCount);
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=static_cast<uint>(pStrides[qlkJtZj]);}();}();
        }
        json["pStrides"]=arr_YFLMtWg;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_uint64_t());
            }else if (json["firstBinding"].is_int64_t()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_int64_t());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].as_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_uint64_t());
            }else if (json["bindingCount"].is_int64_t()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_int64_t());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].as_double());
            }
            }();





debug_printf("Ending vkCmdBindVertexBuffers2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2EXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
return vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthTestEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHTESTENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=static_cast<uint>(depthTestEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_WLSKeYp;[&](){
            if (json["depthTestEnable"].is_uint64_t()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_uint64_t());
            }else if (json["depthTestEnable"].is_int64_t()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_int64_t());
            }else{
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].as_double());
            }
            }();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

debug_printf("Ending vkCmdSetDepthTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
return vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnable( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthWriteEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHWRITEENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=static_cast<uint>(depthWriteEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHWRITEENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qztdWhG;[&](){
            if (json["depthWriteEnable"].is_uint64_t()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_uint64_t());
            }else if (json["depthWriteEnable"].is_int64_t()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_int64_t());
            }else{
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].as_double());
            }
            }();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

debug_printf("Ending vkCmdSetDepthWriteEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
return vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOp( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthCompareOp\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCOMPAREOP);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=static_cast<int>(depthCompareOp);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCOMPAREOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_GommENv;[&](){
            if (json["depthCompareOp"].is_uint64_t()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_uint64_t());
            }else if (json["depthCompareOp"].is_int64_t()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_int64_t());
            }else{
                temp_GommENv=static_cast<int>(json["depthCompareOp"].as_double());
            }
            }();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

debug_printf("Ending vkCmdSetDepthCompareOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOpEXT( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
return vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBoundsTestEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBOUNDSTESTENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=static_cast<uint>(depthBoundsTestEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDSTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qmudcyJ;[&](){
            if (json["depthBoundsTestEnable"].is_uint64_t()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_uint64_t());
            }else if (json["depthBoundsTestEnable"].is_int64_t()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_int64_t());
            }else{
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].as_double());
            }
            }();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

debug_printf("Ending vkCmdSetDepthBoundsTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
return vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnable( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilTestEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSTENCILTESTENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=static_cast<uint>(stencilTestEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qPvOEDS;[&](){
            if (json["stencilTestEnable"].is_uint64_t()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_uint64_t());
            }else if (json["stencilTestEnable"].is_int64_t()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_int64_t());
            }else{
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].as_double());
            }
            }();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

debug_printf("Ending vkCmdSetStencilTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
return vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOp( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilOp\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSTENCILOP);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=static_cast<int>(faceMask);}();}();}();
[&](){[&](){[&](){json["failOp"]=static_cast<int>(failOp);}();}();}();
[&](){[&](){[&](){json["passOp"]=static_cast<int>(passOp);}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=static_cast<int>(depthFailOp);}();}();}();
[&](){[&](){[&](){json["compareOp"]=static_cast<int>(compareOp);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_uint64_t());
            }else if (json["faceMask"].is_int64_t()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_int64_t());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].as_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){[&](){int temp_lKXncFy;[&](){
            if (json["failOp"].is_uint64_t()){
                temp_lKXncFy=static_cast<int>(json["failOp"].as_uint64_t());
            }else if (json["failOp"].is_int64_t()){
                temp_lKXncFy=static_cast<int>(json["failOp"].as_int64_t());
            }else{
                temp_lKXncFy=static_cast<int>(json["failOp"].as_double());
            }
            }();failOp=(VkStencilOp)temp_lKXncFy;}();}();
[&](){[&](){int temp_SPMLjKg;[&](){
            if (json["passOp"].is_uint64_t()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_uint64_t());
            }else if (json["passOp"].is_int64_t()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_int64_t());
            }else{
                temp_SPMLjKg=static_cast<int>(json["passOp"].as_double());
            }
            }();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
[&](){[&](){int temp_TdIKNtG;[&](){
            if (json["depthFailOp"].is_uint64_t()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_uint64_t());
            }else if (json["depthFailOp"].is_int64_t()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_int64_t());
            }else{
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].as_double());
            }
            }();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
[&](){[&](){int temp_NLoCySV;[&](){
            if (json["compareOp"].is_uint64_t()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_uint64_t());
            }else if (json["compareOp"].is_int64_t()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_int64_t());
            }else{
                temp_NLoCySV=static_cast<int>(json["compareOp"].as_double());
            }
            }();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

debug_printf("Ending vkCmdSetStencilOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOpEXT( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
return vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPatchControlPointsEXT( VkCommandBuffer commandBuffer, uint32_t patchControlPoints ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPatchControlPointsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPATCHCONTROLPOINTSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=static_cast<uint>(patchControlPoints);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPATCHCONTROLPOINTSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["patchControlPoints"].is_uint64_t()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_uint64_t());
            }else if (json["patchControlPoints"].is_int64_t()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_int64_t());
            }else{
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetPatchControlPointsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnable( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizerDiscardEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZERDISCARDENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=static_cast<uint>(rasterizerDiscardEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZERDISCARDENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_bdbWnok;[&](){
            if (json["rasterizerDiscardEnable"].is_uint64_t()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_uint64_t());
            }else if (json["rasterizerDiscardEnable"].is_int64_t()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_int64_t());
            }else{
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].as_double());
            }
            }();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

debug_printf("Ending vkCmdSetRasterizerDiscardEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnableEXT( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
return vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnable( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBiasEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIASENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=static_cast<uint>(depthBiasEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIASENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_ewcVkBi;[&](){
            if (json["depthBiasEnable"].is_uint64_t()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_uint64_t());
            }else if (json["depthBiasEnable"].is_int64_t()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_int64_t());
            }else{
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].as_double());
            }
            }();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

debug_printf("Ending vkCmdSetDepthBiasEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
return vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEXT( VkCommandBuffer commandBuffer, VkLogicOp logicOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLOGICOPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=static_cast<int>(logicOp);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_KRaggtp;[&](){
            if (json["logicOp"].is_uint64_t()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_uint64_t());
            }else if (json["logicOp"].is_int64_t()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_int64_t());
            }else{
                temp_KRaggtp=static_cast<int>(json["logicOp"].as_double());
            }
            }();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

debug_printf("Ending vkCmdSetLogicOpEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnable( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveRestartEnable\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPRIMITIVERESTARTENABLE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=static_cast<uint>(primitiveRestartEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVERESTARTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_mDszbuh;[&](){
            if (json["primitiveRestartEnable"].is_uint64_t()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_uint64_t());
            }else if (json["primitiveRestartEnable"].is_int64_t()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_int64_t());
            }else{
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].as_double());
            }
            }();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

debug_printf("Ending vkCmdSetPrimitiveRestartEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnableEXT( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
return vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetTessellationDomainOriginEXT( VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin ){
//Will only be called by the client
debug_printf("Executing vkCmdSetTessellationDomainOriginEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETTESSELLATIONDOMAINORIGINEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=static_cast<int>(domainOrigin);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MhaRSZf;[&](){
            if (json["domainOrigin"].is_uint64_t()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_uint64_t());
            }else if (json["domainOrigin"].is_int64_t()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_int64_t());
            }else{
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].as_double());
            }
            }();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

debug_printf("Ending vkCmdSetTessellationDomainOriginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClampEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClampEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClampEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLAMPENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=static_cast<uint>(depthClampEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLAMPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_DzsSqgr;[&](){
            if (json["depthClampEnable"].is_uint64_t()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_uint64_t());
            }else if (json["depthClampEnable"].is_int64_t()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_int64_t());
            }else{
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].as_double());
            }
            }();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

debug_printf("Ending vkCmdSetDepthClampEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPolygonModeEXT( VkCommandBuffer commandBuffer, VkPolygonMode polygonMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPolygonModeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPOLYGONMODEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=static_cast<int>(polygonMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPOLYGONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XzCpfxJ;[&](){
            if (json["polygonMode"].is_uint64_t()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_uint64_t());
            }else if (json["polygonMode"].is_int64_t()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_int64_t());
            }else{
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].as_double());
            }
            }();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

debug_printf("Ending vkCmdSetPolygonModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationSamplesEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationSamplesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZATIONSAMPLESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=static_cast<int>(rasterizationSamples);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSAMPLESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_YCyLybT;[&](){
            if (json["rasterizationSamples"].is_uint64_t()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_uint64_t());
            }else if (json["rasterizationSamples"].is_int64_t()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_int64_t());
            }else{
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].as_double());
            }
            }();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

debug_printf("Ending vkCmdSetRasterizationSamplesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleMaskEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask* pSampleMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleMaskEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSAMPLEMASKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=static_cast<int>(samples);}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=json::vector();
            return; }auto arr_nepOVVF=json::vector((samples + 31) / 32);
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=static_cast<uint>(pSampleMask[ASCUBEW]);}();}();
        }
        json["pSampleMask"]=arr_nepOVVF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_uint64_t());
            }else if (json["samples"].is_int64_t()){
                temp_lbKgbKj=static_cast<int>(json["samples"].as_int64_t());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].as_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();


debug_printf("Ending vkCmdSetSampleMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToCoverageEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToCoverageEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETALPHATOCOVERAGEENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=static_cast<uint>(alphaToCoverageEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GXlPpxl;[&](){
            if (json["alphaToCoverageEnable"].is_uint64_t()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_uint64_t());
            }else if (json["alphaToCoverageEnable"].is_int64_t()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_int64_t());
            }else{
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].as_double());
            }
            }();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

debug_printf("Ending vkCmdSetAlphaToCoverageEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToOneEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToOneEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETALPHATOONEENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=static_cast<uint>(alphaToOneEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOONEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_vIViDmy;[&](){
            if (json["alphaToOneEnable"].is_uint64_t()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_uint64_t());
            }else if (json["alphaToOneEnable"].is_int64_t()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_int64_t());
            }else{
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].as_double());
            }
            }();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

debug_printf("Ending vkCmdSetAlphaToOneEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEnableEXT( VkCommandBuffer commandBuffer, VkBool32 logicOpEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLOGICOPENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=static_cast<uint>(logicOpEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_efIIzNf;[&](){
            if (json["logicOpEnable"].is_uint64_t()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_uint64_t());
            }else if (json["logicOpEnable"].is_int64_t()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_int64_t());
            }else{
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].as_double());
            }
            }();logicOpEnable=(VkBool32)temp_efIIzNf;}();

debug_printf("Ending vkCmdSetLogicOpEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEnableEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=json::vector();
            return; }auto arr_saqDhTV=json::vector(attachmentCount);
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=static_cast<uint>(pColorBlendEnables[VGuJXMd]);}();}();
        }
        json["pColorBlendEnables"]=arr_saqDhTV;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEquationEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEquationEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDEQUATIONEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=json::vector();
            return; }auto arr_hKUQljx=json::vector(attachmentCount);
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColorBlendEquations[EHggOtN]);
            arr_hKUQljx[EHggOtN]=temp_map;
            return;
            }();
        }
        json["pColorBlendEquations"]=arr_hKUQljx;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDEQUATIONEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendEquationEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteMaskEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteMaskEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOLORWRITEMASKEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=json::vector();
            return; }auto arr_VFhepws=json::vector(attachmentCount);
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=static_cast<int>(pColorWriteMasks[PbQLtdZ]);}();}();}();
        }
        json["pColorWriteMasks"]=arr_VFhepws;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetColorWriteMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationStreamEXT( VkCommandBuffer commandBuffer, uint32_t rasterizationStream ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationStreamEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETRASTERIZATIONSTREAMEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=static_cast<uint>(rasterizationStream);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSTREAMEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["rasterizationStream"].is_uint64_t()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_uint64_t());
            }else if (json["rasterizationStream"].is_int64_t()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_int64_t());
            }else{
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetRasterizationStreamEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetConservativeRasterizationModeEXT( VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetConservativeRasterizationModeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=static_cast<int>(conservativeRasterizationMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_foXltQC;[&](){
            if (json["conservativeRasterizationMode"].is_uint64_t()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_uint64_t());
            }else if (json["conservativeRasterizationMode"].is_int64_t()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_int64_t());
            }else{
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].as_double());
            }
            }();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

debug_printf("Ending vkCmdSetConservativeRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExtraPrimitiveOverestimationSizeEXT( VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExtraPrimitiveOverestimationSizeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=static_cast<float>(extraPrimitiveOverestimationSize);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["extraPrimitiveOverestimationSize"].is_uint64_t()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_uint64_t());
            }else if (json["extraPrimitiveOverestimationSize"].is_int64_t()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_int64_t());
            }else{
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClipEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLIPENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=static_cast<uint>(depthClipEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_xexuvpr;[&](){
            if (json["depthClipEnable"].is_uint64_t()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_uint64_t());
            }else if (json["depthClipEnable"].is_int64_t()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_int64_t());
            }else{
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].as_double());
            }
            }();depthClipEnable=(VkBool32)temp_xexuvpr;}();

debug_printf("Ending vkCmdSetDepthClipEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEnableEXT( VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSAMPLELOCATIONSENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=static_cast<uint>(sampleLocationsEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_dFVPXvO;[&](){
            if (json["sampleLocationsEnable"].is_uint64_t()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_uint64_t());
            }else if (json["sampleLocationsEnable"].is_int64_t()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_int64_t());
            }else{
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].as_double());
            }
            }();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

debug_printf("Ending vkCmdSetSampleLocationsEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendAdvancedEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendAdvancedEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOLORBLENDADVANCEDEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=static_cast<uint>(firstAttachment);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=json::vector();
            return; }auto arr_VhJvkCW=json::vector(attachmentCount);
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pColorBlendAdvanced[rBcMzuv]);
            arr_VhJvkCW[rBcMzuv]=temp_map;
            return;
            }();
        }
        json["pColorBlendAdvanced"]=arr_VhJvkCW;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDADVANCEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_uint64_t());
            }else if (json["firstAttachment"].is_int64_t()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_int64_t());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].as_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendAdvancedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetProvokingVertexModeEXT( VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetProvokingVertexModeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETPROVOKINGVERTEXMODEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=static_cast<int>(provokingVertexMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPROVOKINGVERTEXMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_unvGJcm;[&](){
            if (json["provokingVertexMode"].is_uint64_t()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_uint64_t());
            }else if (json["provokingVertexMode"].is_int64_t()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_int64_t());
            }else{
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].as_double());
            }
            }();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

debug_printf("Ending vkCmdSetProvokingVertexModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineRasterizationModeEXT( VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineRasterizationModeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLINERASTERIZATIONMODEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=static_cast<int>(lineRasterizationMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_TzHFAEB;[&](){
            if (json["lineRasterizationMode"].is_uint64_t()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_uint64_t());
            }else if (json["lineRasterizationMode"].is_int64_t()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_int64_t());
            }else{
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].as_double());
            }
            }();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

debug_printf("Ending vkCmdSetLineRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETLINESTIPPLEENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=static_cast<uint>(stippledLineEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lOgURYj;[&](){
            if (json["stippledLineEnable"].is_uint64_t()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_uint64_t());
            }else if (json["stippledLineEnable"].is_int64_t()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_int64_t());
            }else{
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].as_double());
            }
            }();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

debug_printf("Ending vkCmdSetLineStippleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipNegativeOneToOneEXT( VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipNegativeOneToOneEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=static_cast<uint>(negativeOneToOne);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_KbgfkEI;[&](){
            if (json["negativeOneToOne"].is_uint64_t()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_uint64_t());
            }else if (json["negativeOneToOne"].is_int64_t()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_int64_t());
            }else{
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].as_double());
            }
            }();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

debug_printf("Ending vkCmdSetDepthClipNegativeOneToOneEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingEnableNV( VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTWSCALINGENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=static_cast<uint>(viewportWScalingEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_FBvKoOa;[&](){
            if (json["viewportWScalingEnable"].is_uint64_t()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_uint64_t());
            }else if (json["viewportWScalingEnable"].is_int64_t()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_int64_t());
            }else{
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].as_double());
            }
            }();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

debug_printf("Ending vkCmdSetViewportWScalingEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportSwizzleNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportSwizzleNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVIEWPORTSWIZZLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=static_cast<uint>(firstViewport);}();
[&](){json["viewportCount"]=static_cast<uint>(viewportCount);}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=json::vector();
            return; }auto arr_mlTjeMw=json::vector(viewportCount);
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pViewportSwizzles[jvBpVNx]);
            arr_mlTjeMw[jvBpVNx]=temp_map;
            return;
            }();
        }
        json["pViewportSwizzles"]=arr_mlTjeMw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSWIZZLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_uint64_t());
            }else if (json["firstViewport"].is_int64_t()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_int64_t());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].as_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_uint64_t());
            }else if (json["viewportCount"].is_int64_t()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_int64_t());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportSwizzleNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGETOCOLORENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=static_cast<uint>(coverageToColorEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_StrBHxz;[&](){
            if (json["coverageToColorEnable"].is_uint64_t()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_uint64_t());
            }else if (json["coverageToColorEnable"].is_int64_t()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_int64_t());
            }else{
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].as_double());
            }
            }();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

debug_printf("Ending vkCmdSetCoverageToColorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorLocationNV( VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorLocationNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGETOCOLORLOCATIONNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=static_cast<uint>(coverageToColorLocation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["coverageToColorLocation"].is_uint64_t()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_uint64_t());
            }else if (json["coverageToColorLocation"].is_int64_t()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_int64_t());
            }else{
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].as_double());
            }
            }();

debug_printf("Ending vkCmdSetCoverageToColorLocationNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationModeNV( VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationModeNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONMODENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=static_cast<int>(coverageModulationMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_BTSRuJL;[&](){
            if (json["coverageModulationMode"].is_uint64_t()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_uint64_t());
            }else if (json["coverageModulationMode"].is_int64_t()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_int64_t());
            }else{
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].as_double());
            }
            }();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

debug_printf("Ending vkCmdSetCoverageModulationModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONTABLEENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=static_cast<uint>(coverageModulationTableEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lmSvUmH;[&](){
            if (json["coverageModulationTableEnable"].is_uint64_t()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_uint64_t());
            }else if (json["coverageModulationTableEnable"].is_int64_t()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_int64_t());
            }else{
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].as_double());
            }
            }();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

debug_printf("Ending vkCmdSetCoverageModulationTableEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableNV( VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEMODULATIONTABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=static_cast<uint>(coverageModulationTableCount);}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=json::vector();
            return; }auto arr_FKEHfYD=json::vector(coverageModulationTableCount);
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=static_cast<float>(pCoverageModulationTable[pMqhQqL]);}();
        }
        json["pCoverageModulationTable"]=arr_FKEHfYD;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["coverageModulationTableCount"].is_uint64_t()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_uint64_t());
            }else if (json["coverageModulationTableCount"].is_int64_t()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_int64_t());
            }else{
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetCoverageModulationTableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetShadingRateImageEnableNV( VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetShadingRateImageEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETSHADINGRATEIMAGEENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=static_cast<uint>(shadingRateImageEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSHADINGRATEIMAGEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_BQfvSQF;[&](){
            if (json["shadingRateImageEnable"].is_uint64_t()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_uint64_t());
            }else if (json["shadingRateImageEnable"].is_int64_t()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_int64_t());
            }else{
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].as_double());
            }
            }();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

debug_printf("Ending vkCmdSetShadingRateImageEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageReductionModeNV( VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageReductionModeNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOVERAGEREDUCTIONMODENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=static_cast<int>(coverageReductionMode);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEREDUCTIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MbjGgOv;[&](){
            if (json["coverageReductionMode"].is_uint64_t()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_uint64_t());
            }else if (json["coverageReductionMode"].is_int64_t()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_int64_t());
            }else{
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].as_double());
            }
            }();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

debug_printf("Ending vkCmdSetCoverageReductionModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRepresentativeFragmentTestEnableNV( VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRepresentativeFragmentTestEnableNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=static_cast<uint>(representativeFragmentTestEnable);}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_VmtUEuY;[&](){
            if (json["representativeFragmentTestEnable"].is_uint64_t()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_uint64_t());
            }else if (json["representativeFragmentTestEnable"].is_int64_t()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_int64_t());
            }else{
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].as_double());
            }
            }();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

debug_printf("Ending vkCmdSetRepresentativeFragmentTestEnableNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlot( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
//Will only be called by the client
debug_printf("Executing vkCreatePrivateDataSlot\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEPRIVATEDATASLOT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_OhzuPlW=json::vector(1);
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[KUjUcQv]);
            arr_OhzuPlW[KUjUcQv]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_OhzuPlW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=json::vector();
            return; }auto arr_EOSkjPn=json::vector(1);
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        json["pPrivateDataSlot"]=arr_EOSkjPn;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPrivateDataSlot"].as_vector().size()==0){
                pPrivateDataSlot=NULL;
            return; }auto& arr_EOSkjPn=json["pPrivateDataSlot"].as_vector();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_qQVSpod;[&](){
            if (json["result"].is_uint64_t()){
                temp_qQVSpod=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_qQVSpod=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_qQVSpod=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_qQVSpod;}();}();

                if (pPrivateDataSlot!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPrivateDataSlot[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePrivateDataSlot...\n");
debug_printf("Return value of vkCreatePrivateDataSlot is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlotEXT( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
return vkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlot( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPrivateDataSlot\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYPRIVATEDATASLOT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();


debug_printf("Ending vkDestroyPrivateDataSlot...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlotEXT( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
return vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
//Will only be called by the client
debug_printf("Executing vkSetPrivateData\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETPRIVATEDATA);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["objectHandle"]=static_cast<uint>(objectHandle);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=static_cast<uint>(data);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){
            if (json["objectHandle"].is_uint64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_uint64_t());
            }else if (json["objectHandle"].is_int64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_int64_t());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_double());
            }
            }();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){
            if (json["data"].is_uint64_t()){
                data=static_cast<uint64_t>(json["data"].as_uint64_t());
            }else if (json["data"].is_int64_t()){
                data=static_cast<uint64_t>(json["data"].as_int64_t());
            }else{
                data=static_cast<uint64_t>(json["data"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_HIenTTf;[&](){
            if (json["result"].is_uint64_t()){
                temp_HIenTTf=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HIenTTf=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HIenTTf=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HIenTTf;}();}();

debug_printf("Ending vkSetPrivateData...\n");
debug_printf("Return value of vkSetPrivateData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
return vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
}
__attribute__((visibility ("hidden"))) void vkGetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPrivateData\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPRIVATEDATA);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=static_cast<int>(objectType);}();}();}();
[&](){json["objectHandle"]=static_cast<uint>(objectHandle);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }auto arr_niIcbqy=json::vector(1);
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=static_cast<uint>(pData[rXHtNoy]);}();
        }
        json["pData"]=arr_niIcbqy;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_uint64_t());
            }else if (json["objectType"].is_int64_t()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_int64_t());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].as_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){
            if (json["objectHandle"].is_uint64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_uint64_t());
            }else if (json["objectHandle"].is_int64_t()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_int64_t());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].as_double());
            }
            }();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }auto& arr_niIcbqy=json["pData"].as_vector();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){
            if (arr_niIcbqy[rXHtNoy].is_uint64_t()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_uint64_t());
            }else if (arr_niIcbqy[rXHtNoy].is_int64_t()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_int64_t());
            }else{
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].as_double());
            }
            }();
        }
        }();

debug_printf("Ending vkGetPrivateData...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
return vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFER2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=json::vector();
            return; }auto arr_RrXlJAO=json::vector(1);
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyBufferInfo[tCibIjb]);
            arr_RrXlJAO[tCibIjb]=temp_map;
            return;
            }();
        }
        json["pCopyBufferInfo"]=arr_RrXlJAO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
return vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGE2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=json::vector();
            return; }auto arr_fhmwDMM=json::vector(1);
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageInfo[vtScDqF]);
            arr_fhmwDMM[vtScDqF]=temp_map;
            return;
            }();
        }
        json["pCopyImageInfo"]=arr_fhmwDMM;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2KHR( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
return vkCmdCopyImage2(commandBuffer, pCopyImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBLITIMAGE2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=json::vector();
            return; }auto arr_uMZBSOh=json::vector(1);
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBlitImageInfo[mMDYqpe]);
            arr_uMZBSOh[mMDYqpe]=temp_map;
            return;
            }();
        }
        json["pBlitImageInfo"]=arr_uMZBSOh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBlitImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2KHR( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
return vkCmdBlitImage2(commandBuffer, pBlitImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYBUFFERTOIMAGE2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=json::vector();
            return; }auto arr_GgxIzVF=json::vector(1);
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyBufferToImageInfo[kZlUXOa]);
            arr_GgxIzVF[kZlUXOa]=temp_map;
            return;
            }();
        }
        json["pCopyBufferToImageInfo"]=arr_GgxIzVF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBufferToImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
return vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYIMAGETOBUFFER2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=json::vector();
            return; }auto arr_dKwPEQq=json::vector(1);
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToBufferInfo[SXwhnUi]);
            arr_dKwPEQq[SXwhnUi]=temp_map;
            return;
            }();
        }
        json["pCopyImageToBufferInfo"]=arr_dKwPEQq;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImageToBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
return vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDRESOLVEIMAGE2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=json::vector();
            return; }auto arr_WXEMxut=json::vector(1);
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pResolveImageInfo[oSccZaz]);
            arr_WXEMxut[oSccZaz]=temp_map;
            return;
            }();
        }
        json["pResolveImageInfo"]=arr_WXEMxut;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdResolveImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2KHR( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
return vkCmdResolveImage2(commandBuffer, pResolveImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateKHR( VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETFRAGMENTSHADINGRATEKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=json::vector();
            return; }auto arr_RBQYqfx=json::vector(1);
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFragmentSize[rHAqvQQ]);
            arr_RBQYqfx[rHAqvQQ]=temp_map;
            return;
            }();
        }
        json["pFragmentSize"]=arr_RBQYqfx;}();
[&](){auto arr_foscmwP=json::vector(2);
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=static_cast<int>(combinerOps[uBsarms]);}();}();}();
        }
        json["combinerOps"]=arr_foscmwP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){auto& arr_foscmwP=json["combinerOps"].as_vector();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR( VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFragmentShadingRatesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=json::vector();
            return; }auto arr_CjAZByp=json::vector(1);
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=static_cast<uint>(pFragmentShadingRateCount[vQwTqIV]);}();
        }
        json["pFragmentShadingRateCount"]=arr_CjAZByp;}();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=json::vector();
            return; }auto arr_UdwJpYv=json::vector(*pFragmentShadingRateCount);
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFragmentShadingRates[bVRSXYW]);
            arr_UdwJpYv[bVRSXYW]=temp_map;
            return;
            }();
        }
        json["pFragmentShadingRates"]=arr_UdwJpYv;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFragmentShadingRateCount"].as_vector().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }auto& arr_CjAZByp=json["pFragmentShadingRateCount"].as_vector();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){
            if (arr_CjAZByp[vQwTqIV].is_uint64_t()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_uint64_t());
            }else if (arr_CjAZByp[vQwTqIV].is_int64_t()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_int64_t());
            }else{
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pFragmentShadingRates"].as_vector().size()==0){
                pFragmentShadingRates=NULL;
            return; }auto& arr_UdwJpYv=json["pFragmentShadingRates"].as_vector();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            deserialize_struct(arr_UdwJpYv[bVRSXYW].as_map(),pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YWmAync;[&](){
            if (json["result"].is_uint64_t()){
                temp_YWmAync=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_YWmAync=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_YWmAync=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_YWmAync;}();}();

debug_printf("Ending vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceFragmentShadingRatesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateEnumNV( VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateEnumNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETFRAGMENTSHADINGRATEENUMNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=static_cast<int>(shadingRate);}();}();}();
[&](){auto arr_foscmwP=json::vector(2);
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=static_cast<int>(combinerOps[uBsarms]);}();}();}();
        }
        json["combinerOps"]=arr_foscmwP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_CqLMxeN;[&](){
            if (json["shadingRate"].is_uint64_t()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_uint64_t());
            }else if (json["shadingRate"].is_int64_t()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_int64_t());
            }else{
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].as_double());
            }
            }();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
[&](){auto& arr_foscmwP=json["combinerOps"].as_vector();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateEnumNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureBuildSizesKHR( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureBuildSizesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=static_cast<int>(buildType);}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=json::vector();
            return; }auto arr_rNWxDog=json::vector(1);
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBuildInfo[DpqeGQs]);
            arr_rNWxDog[DpqeGQs]=temp_map;
            return;
            }();
        }
        json["pBuildInfo"]=arr_rNWxDog;}();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=json::vector();
            return; }auto arr_vNFCnZs=json::vector(pBuildInfo->geometryCount);
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=static_cast<uint>(pMaxPrimitiveCounts[KHWuVmo]);}();
        }
        json["pMaxPrimitiveCounts"]=arr_vNFCnZs;}();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=json::vector();
            return; }auto arr_aJATMZS=json::vector(1);
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSizeInfo[pwtSWhd]);
            arr_aJATMZS[pwtSWhd]=temp_map;
            return;
            }();
        }
        json["pSizeInfo"]=arr_aJATMZS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_uint64_t());
            }else if (json["buildType"].is_int64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_int64_t());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].as_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();


[&](){
            if (json["pSizeInfo"].as_vector().size()==0){
                pSizeInfo=NULL;
            return; }auto& arr_aJATMZS=json["pSizeInfo"].as_vector();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            deserialize_struct(arr_aJATMZS[pwtSWhd].as_map(),pSizeInfo[pwtSWhd]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureBuildSizesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetVertexInputEXT( VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions ){
//Will only be called by the client
debug_printf("Executing vkCmdSetVertexInputEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETVERTEXINPUTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=static_cast<uint>(vertexBindingDescriptionCount);}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=json::vector();
            return; }auto arr_CLcpEBv=json::vector(vertexBindingDescriptionCount);
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexBindingDescriptions[BlSYyCp]);
            arr_CLcpEBv[BlSYyCp]=temp_map;
            return;
            }();
        }
        json["pVertexBindingDescriptions"]=arr_CLcpEBv;}();
[&](){json["vertexAttributeDescriptionCount"]=static_cast<uint>(vertexAttributeDescriptionCount);}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=json::vector();
            return; }auto arr_nigNRkL=json::vector(vertexAttributeDescriptionCount);
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVertexAttributeDescriptions[UWEyBUU]);
            arr_nigNRkL[UWEyBUU]=temp_map;
            return;
            }();
        }
        json["pVertexAttributeDescriptions"]=arr_nigNRkL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVERTEXINPUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["vertexBindingDescriptionCount"].is_uint64_t()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_uint64_t());
            }else if (json["vertexBindingDescriptionCount"].is_int64_t()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_int64_t());
            }else{
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].as_double());
            }
            }();

[&](){
            if (json["vertexAttributeDescriptionCount"].is_uint64_t()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_uint64_t());
            }else if (json["vertexAttributeDescriptionCount"].is_int64_t()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_int64_t());
            }else{
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetVertexInputEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteEnableEXT( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteEnableEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETCOLORWRITEENABLEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=static_cast<uint>(attachmentCount);}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=json::vector();
            return; }auto arr_jmtmyTP=json::vector(attachmentCount);
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=static_cast<uint>(pColorWriteEnables[yHXwpvy]);}();}();
        }
        json["pColorWriteEnables"]=arr_jmtmyTP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["attachmentCount"].is_uint64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_uint64_t());
            }else if (json["attachmentCount"].is_int64_t()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_int64_t());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdSetColorWriteEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETEVENT2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=json::vector();
            return; }auto arr_RUiZhht=json::vector(1);
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfo[rtSvYgr]);
            arr_RUiZhht[rtSvYgr]=temp_map;
            return;
            }();
        }
        json["pDependencyInfo"]=arr_RUiZhht;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkCmdSetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
return vkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDRESETEVENT2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=static_cast<int>(stageMask);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_bRKcCBq;[&](){
            if (json["stageMask"].is_uint64_t()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_uint64_t());
            }else if (json["stageMask"].is_int64_t()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_int64_t());
            }else{
                temp_bRKcCBq=static_cast<int>(json["stageMask"].as_double());
            }
            }();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

debug_printf("Ending vkCmdResetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
return vkCmdResetEvent2(commandBuffer, event, stageMask);
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWAITEVENTS2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=static_cast<uint>(eventCount);}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=json::vector();
            return; }auto arr_tUuyOPJ=json::vector(eventCount);
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        json["pEvents"]=arr_tUuyOPJ;}();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=json::vector();
            return; }auto arr_ZVkfhDe=json::vector(eventCount);
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfos[jvYalYw]);
            arr_ZVkfhDe[jvYalYw]=temp_map;
            return;
            }();
        }
        json["pDependencyInfos"]=arr_ZVkfhDe;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["eventCount"].is_uint64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_uint64_t());
            }else if (json["eventCount"].is_int64_t()){
                eventCount=static_cast<uint32_t>(json["eventCount"].as_int64_t());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdWaitEvents2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2KHR( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
return vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDPIPELINEBARRIER2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=json::vector();
            return; }auto arr_RUiZhht=json::vector(1);
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDependencyInfo[rtSvYgr]);
            arr_RUiZhht[rtSvYgr]=temp_map;
            return;
            }();
        }
        json["pDependencyInfo"]=arr_RUiZhht;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPipelineBarrier2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2KHR( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
return vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKQUEUESUBMIT2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=static_cast<uint>(submitCount);}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=json::vector();
            return; }auto arr_shQKWeV=json::vector(submitCount);
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubmits[uwYUklT]);
            arr_shQKWeV[uwYUklT]=temp_map;
            return;
            }();
        }
        json["pSubmits"]=arr_shQKWeV;}();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["submitCount"].is_uint64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_uint64_t());
            }else if (json["submitCount"].is_int64_t()){
                submitCount=static_cast<uint32_t>(json["submitCount"].as_int64_t());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].as_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_kyODmSO;[&](){
            if (json["result"].is_uint64_t()){
                temp_kyODmSO=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_kyODmSO=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_kyODmSO=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_kyODmSO;}();}();

debug_printf("Ending vkQueueSubmit2...\n");
debug_printf("Return value of vkQueueSubmit2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2KHR( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
return vkQueueSubmit2(queue, submitCount, pSubmits, fence);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp2\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITETIMESTAMP2);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=static_cast<int>(stage);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=static_cast<uint>(query);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_uint64_t());
            }else if (json["stage"].is_int64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_int64_t());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64_t()){
                query=static_cast<uint32_t>(json["query"].as_uint64_t());
            }else if (json["query"].is_int64_t()){
                query=static_cast<uint32_t>(json["query"].as_int64_t());
            }else{
                query=static_cast<uint32_t>(json["query"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteTimestamp2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2KHR( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
return vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarker2AMD( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarker2AMD\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITEBUFFERMARKER2AMD);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=static_cast<int>(stage);}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=static_cast<uint>(dstOffset);}();}();
[&](){json["marker"]=static_cast<uint>(marker);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKER2AMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_uint64_t());
            }else if (json["stage"].is_int64_t()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_int64_t());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].as_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_uint64_t());
            }else if (json["dstOffset"].is_int64_t()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_int64_t());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].as_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){
            if (json["marker"].is_uint64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_uint64_t());
            }else if (json["marker"].is_int64_t()){
                marker=static_cast<uint32_t>(json["marker"].as_int64_t());
            }else{
                marker=static_cast<uint32_t>(json["marker"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteBufferMarker2AMD...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointData2NV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointData2NV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETQUEUECHECKPOINTDATA2NV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=json::vector();
            return; }auto arr_LsYqVIK=json::vector(1);
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=static_cast<uint>(pCheckpointDataCount[lgasnOP]);}();
        }
        json["pCheckpointDataCount"]=arr_LsYqVIK;}();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=json::vector();
            return; }auto arr_jIvYyZg=json::vector(*pCheckpointDataCount);
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCheckpointData[yGwfptp]);
            arr_jIvYyZg[yGwfptp]=temp_map;
            return;
            }();
        }
        json["pCheckpointData"]=arr_jIvYyZg;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATA2NV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].as_vector().size()==0){
                pCheckpointDataCount=NULL;
            return; }auto& arr_LsYqVIK=json["pCheckpointDataCount"].as_vector();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_uint64_t());
            }else if (arr_LsYqVIK[lgasnOP].is_int64_t()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_int64_t());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCheckpointData"].as_vector().size()==0){
                pCheckpointData=NULL;
            return; }auto& arr_jIvYyZg=json["pCheckpointData"].as_vector();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            deserialize_struct(arr_jIvYyZg[yGwfptp].as_map(),pCheckpointData[yGwfptp]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointData2NV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToImageEXT( VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToImageEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOIMAGEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=json::vector();
            return; }auto arr_VVrQQGW=json::vector(1);
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyMemoryToImageInfo[pVINPWa]);
            arr_VVrQQGW[pVINPWa]=temp_map;
            return;
            }();
        }
        json["pCopyMemoryToImageInfo"]=arr_VVrQQGW;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_LkGTyEt;[&](){
            if (json["result"].is_uint64_t()){
                temp_LkGTyEt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_LkGTyEt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_LkGTyEt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_LkGTyEt;}();}();

debug_printf("Ending vkCopyMemoryToImageEXT...\n");
debug_printf("Return value of vkCopyMemoryToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToMemoryEXT( VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToMemoryEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYIMAGETOMEMORYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=json::vector();
            return; }auto arr_uAVSOVI=json::vector(1);
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToMemoryInfo[vveMAPG]);
            arr_uAVSOVI[vveMAPG]=temp_map;
            return;
            }();
        }
        json["pCopyImageToMemoryInfo"]=arr_uAVSOVI;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_reiMRMs;[&](){
            if (json["result"].is_uint64_t()){
                temp_reiMRMs=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_reiMRMs=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_reiMRMs=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_reiMRMs;}();}();

debug_printf("Ending vkCopyImageToMemoryEXT...\n");
debug_printf("Return value of vkCopyImageToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToImageEXT( VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToImageEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYIMAGETOIMAGEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=json::vector();
            return; }auto arr_mMvIKFh=json::vector(1);
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCopyImageToImageInfo[vOMFrGb]);
            arr_mMvIKFh[vOMFrGb]=temp_map;
            return;
            }();
        }
        json["pCopyImageToImageInfo"]=arr_mMvIKFh;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_rdZDVxa;[&](){
            if (json["result"].is_uint64_t()){
                temp_rdZDVxa=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_rdZDVxa=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_rdZDVxa=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_rdZDVxa;}();}();

debug_printf("Ending vkCopyImageToImageEXT...\n");
debug_printf("Return value of vkCopyImageToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkTransitionImageLayoutEXT( VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions ){
//Will only be called by the client
debug_printf("Executing vkTransitionImageLayoutEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKTRANSITIONIMAGELAYOUTEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=static_cast<uint>(transitionCount);}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=json::vector();
            return; }auto arr_KQaENWu=json::vector(transitionCount);
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pTransitions[EeppCgm]);
            arr_KQaENWu[EeppCgm]=temp_map;
            return;
            }();
        }
        json["pTransitions"]=arr_KQaENWu;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRANSITIONIMAGELAYOUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["transitionCount"].is_uint64_t()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_uint64_t());
            }else if (json["transitionCount"].is_int64_t()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_int64_t());
            }else{
                transitionCount=static_cast<uint32_t>(json["transitionCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_pjFnweb;[&](){
            if (json["result"].is_uint64_t()){
                temp_pjFnweb=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_pjFnweb=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_pjFnweb=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_pjFnweb;}();}();

debug_printf("Ending vkTransitionImageLayoutEXT...\n");
debug_printf("Return value of vkTransitionImageLayoutEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoCapabilitiesKHR( VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoCapabilitiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=json::vector();
            return; }auto arr_eFObkVe=json::vector(1);
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoProfile[YJbJtas]);
            arr_eFObkVe[YJbJtas]=temp_map;
            return;
            }();
        }
        json["pVideoProfile"]=arr_eFObkVe;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=json::vector();
            return; }auto arr_rprZzlH=json::vector(1);
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCapabilities[NPLkdlm]);
            arr_rprZzlH[NPLkdlm]=temp_map;
            return;
            }();
        }
        json["pCapabilities"]=arr_rprZzlH;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].as_vector().size()==0){
                pCapabilities=NULL;
            return; }auto& arr_rprZzlH=json["pCapabilities"].as_vector();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            deserialize_struct(arr_rprZzlH[NPLkdlm].as_map(),pCapabilities[NPLkdlm]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_DRSBHXR;[&](){
            if (json["result"].is_uint64_t()){
                temp_DRSBHXR=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_DRSBHXR=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_DRSBHXR=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_DRSBHXR;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoFormatPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoFormatPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=json::vector();
            return; }auto arr_JJWKnHz=json::vector(1);
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoFormatInfo[FIocPZR]);
            arr_JJWKnHz[FIocPZR]=temp_map;
            return;
            }();
        }
        json["pVideoFormatInfo"]=arr_JJWKnHz;}();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=json::vector();
            return; }auto arr_kJoqfTP=json::vector(1);
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=static_cast<uint>(pVideoFormatPropertyCount[hCeCDXk]);}();
        }
        json["pVideoFormatPropertyCount"]=arr_kJoqfTP;}();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=json::vector();
            return; }auto arr_GhjQGHj=json::vector(*pVideoFormatPropertyCount);
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVideoFormatProperties[mUXWOpX]);
            arr_GhjQGHj[mUXWOpX]=temp_map;
            return;
            }();
        }
        json["pVideoFormatProperties"]=arr_GhjQGHj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pVideoFormatPropertyCount"].as_vector().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].as_vector();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){
            if (arr_kJoqfTP[hCeCDXk].is_uint64_t()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_uint64_t());
            }else if (arr_kJoqfTP[hCeCDXk].is_int64_t()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_int64_t());
            }else{
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pVideoFormatProperties"].as_vector().size()==0){
                pVideoFormatProperties=NULL;
            return; }auto& arr_GhjQGHj=json["pVideoFormatProperties"].as_vector();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            deserialize_struct(arr_GhjQGHj[mUXWOpX].as_map(),pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_KDbEDAY;[&](){
            if (json["result"].is_uint64_t()){
                temp_KDbEDAY=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_KDbEDAY=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_KDbEDAY=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_KDbEDAY;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoFormatPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionKHR( VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEVIDEOSESSIONKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_mCuZMrp=json::vector(1);
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[tsYbFnY]);
            arr_mCuZMrp[tsYbFnY]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_mCuZMrp;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=json::vector();
            return; }auto arr_YUuHYdT=json::vector(1);
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        json["pVideoSession"]=arr_YUuHYdT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSession"].as_vector().size()==0){
                pVideoSession=NULL;
            return; }auto& arr_YUuHYdT=json["pVideoSession"].as_vector();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_dWIUHBt;[&](){
            if (json["result"].is_uint64_t()){
                temp_dWIUHBt=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_dWIUHBt=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_dWIUHBt=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_dWIUHBt;}();}();

                if (pVideoSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionKHR...\n");
debug_printf("Return value of vkCreateVideoSessionKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionKHR( VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYVIDEOSESSIONKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();


debug_printf("Ending vkDestroyVideoSessionKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionParametersKHR( VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionParametersKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEVIDEOSESSIONPARAMETERSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_PbbIaMM=json::vector(1);
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[uFIOrHK]);
            arr_PbbIaMM[uFIOrHK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_PbbIaMM;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=json::vector();
            return; }auto arr_drxJQhO=json::vector(1);
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        json["pVideoSessionParameters"]=arr_drxJQhO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSessionParameters"].as_vector().size()==0){
                pVideoSessionParameters=NULL;
            return; }auto& arr_drxJQhO=json["pVideoSessionParameters"].as_vector();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_sWaVcNh;[&](){
            if (json["result"].is_uint64_t()){
                temp_sWaVcNh=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_sWaVcNh=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_sWaVcNh=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_sWaVcNh;}();}();

                if (pVideoSessionParameters!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSessionParameters[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkCreateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUpdateVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo ){
//Will only be called by the client
debug_printf("Executing vkUpdateVideoSessionParametersKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKUPDATEVIDEOSESSIONPARAMETERSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=json::vector();
            return; }auto arr_miOYaCQ=json::vector(1);
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pUpdateInfo[gnypMkA]);
            arr_miOYaCQ[gnypMkA]=temp_map;
            return;
            }();
        }
        json["pUpdateInfo"]=arr_miOYaCQ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();

VkResult result;
[&](){[&](){int temp_EZpQGsU;[&](){
            if (json["result"].is_uint64_t()){
                temp_EZpQGsU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_EZpQGsU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_EZpQGsU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_EZpQGsU;}();}();

debug_printf("Ending vkUpdateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkUpdateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionParametersKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYVIDEOSESSIONPARAMETERSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();


debug_printf("Ending vkDestroyVideoSessionParametersKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetVideoSessionMemoryRequirementsKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetVideoSessionMemoryRequirementsKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=json::vector();
            return; }auto arr_pJPineF=json::vector(1);
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=static_cast<uint>(pMemoryRequirementsCount[NMpDmPR]);}();
        }
        json["pMemoryRequirementsCount"]=arr_pJPineF;}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=json::vector();
            return; }auto arr_UuJQZUu=json::vector(*pMemoryRequirementsCount);
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryRequirements[FfNBlzG]);
            arr_UuJQZUu[FfNBlzG]=temp_map;
            return;
            }();
        }
        json["pMemoryRequirements"]=arr_UuJQZUu;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){
            if (json["pMemoryRequirementsCount"].as_vector().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }auto& arr_pJPineF=json["pMemoryRequirementsCount"].as_vector();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){
            if (arr_pJPineF[NMpDmPR].is_uint64_t()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_uint64_t());
            }else if (arr_pJPineF[NMpDmPR].is_int64_t()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_int64_t());
            }else{
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pMemoryRequirements"].as_vector().size()==0){
                pMemoryRequirements=NULL;
            return; }auto& arr_UuJQZUu=json["pMemoryRequirements"].as_vector();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            deserialize_struct(arr_UuJQZUu[FfNBlzG].as_map(),pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bfyMKzS;[&](){
            if (json["result"].is_uint64_t()){
                temp_bfyMKzS=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_bfyMKzS=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_bfyMKzS=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_bfyMKzS;}();}();

debug_printf("Ending vkGetVideoSessionMemoryRequirementsKHR...\n");
debug_printf("Return value of vkGetVideoSessionMemoryRequirementsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindVideoSessionMemoryKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos ){
//Will only be called by the client
debug_printf("Executing vkBindVideoSessionMemoryKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDVIDEOSESSIONMEMORYKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=static_cast<uint>(bindSessionMemoryInfoCount);}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=json::vector();
            return; }auto arr_XamFtca=json::vector(bindSessionMemoryInfoCount);
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindSessionMemoryInfos[bWiRCGV]);
            arr_XamFtca[bWiRCGV]=temp_map;
            return;
            }();
        }
        json["pBindSessionMemoryInfos"]=arr_XamFtca;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDVIDEOSESSIONMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){
            if (json["bindSessionMemoryInfoCount"].is_uint64_t()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_uint64_t());
            }else if (json["bindSessionMemoryInfoCount"].is_int64_t()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_int64_t());
            }else{
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_VaKszLh;[&](){
            if (json["result"].is_uint64_t()){
                temp_VaKszLh=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VaKszLh=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VaKszLh=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VaKszLh;}();}();

debug_printf("Ending vkBindVideoSessionMemoryKHR...\n");
debug_printf("Return value of vkBindVideoSessionMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDecodeVideoKHR( VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDecodeVideoKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDECODEVIDEOKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=json::vector();
            return; }auto arr_FUuNCSo=json::vector(1);
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDecodeInfo[jmrOltD]);
            arr_FUuNCSo[jmrOltD]=temp_map;
            return;
            }();
        }
        json["pDecodeInfo"]=arr_FUuNCSo;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECODEVIDEOKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDecodeVideoKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginVideoCodingKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINVIDEOCODINGKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=json::vector();
            return; }auto arr_pSWbqZw=json::vector(1);
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBeginInfo[tVSxYNW]);
            arr_pSWbqZw[tVSxYNW]=temp_map;
            return;
            }();
        }
        json["pBeginInfo"]=arr_pSWbqZw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdControlVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdControlVideoCodingKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCONTROLVIDEOCODINGKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=json::vector();
            return; }auto arr_vJmaWsp=json::vector(1);
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCodingControlInfo[MLwaMsn]);
            arr_vJmaWsp[MLwaMsn]=temp_map;
            return;
            }();
        }
        json["pCodingControlInfo"]=arr_vJmaWsp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCONTROLVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdControlVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndVideoCodingKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDVIDEOCODINGKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=json::vector();
            return; }auto arr_OpexQSo=json::vector(1);
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pEndCodingInfo[KxwYkSG]);
            arr_OpexQSo[KxwYkSG]=temp_map;
            return;
            }();
        }
        json["pEndCodingInfo"]=arr_OpexQSo;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryNV( VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDECOMPRESSMEMORYNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=static_cast<uint>(decompressRegionCount);}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=json::vector();
            return; }auto arr_oMszjDS=json::vector(decompressRegionCount);
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDecompressMemoryRegions[PnFzdhd]);
            arr_oMszjDS[PnFzdhd]=temp_map;
            return;
            }();
        }
        json["pDecompressMemoryRegions"]=arr_oMszjDS;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["decompressRegionCount"].is_uint64_t()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_uint64_t());
            }else if (json["decompressRegionCount"].is_int64_t()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_int64_t());
            }else{
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdDecompressMemoryNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryIndirectCountNV( VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryIndirectCountNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=static_cast<uint>(indirectCommandsAddress);}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=static_cast<uint>(indirectCommandsCountAddress);}();}();
[&](){json["stride"]=static_cast<uint>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_nwmsRdL;[&](){
            if (json["indirectCommandsAddress"].is_uint64_t()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_uint64_t());
            }else if (json["indirectCommandsAddress"].is_int64_t()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_int64_t());
            }else{
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].as_double());
            }
            }();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
[&](){uint64_t temp_TcxQHrV;[&](){
            if (json["indirectCommandsCountAddress"].is_uint64_t()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_uint64_t());
            }else if (json["indirectCommandsCountAddress"].is_int64_t()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_int64_t());
            }else{
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].as_double());
            }
            }();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<uint32_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<uint32_t>(json["stride"].as_double());
            }
            }();

debug_printf("Ending vkCmdDecompressMemoryIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuModuleNVX( VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule ){
//Will only be called by the client
debug_printf("Executing vkCreateCuModuleNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATECUMODULENVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_FjdqPXh=json::vector(1);
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[TUVhIjf]);
            arr_FjdqPXh[TUVhIjf]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_FjdqPXh;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pModule==NULL){
                json["pModule"]=json::vector();
            return; }auto arr_FnQIexZ=json::vector(1);
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        json["pModule"]=arr_FnQIexZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pModule"].as_vector().size()==0){
                pModule=NULL;
            return; }auto& arr_FnQIexZ=json["pModule"].as_vector();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yCFJkOi;[&](){
            if (json["result"].is_uint64_t()){
                temp_yCFJkOi=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yCFJkOi=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yCFJkOi=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yCFJkOi;}();}();

                if (pModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuModuleNVX...\n");
debug_printf("Return value of vkCreateCuModuleNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuFunctionNVX( VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction ){
//Will only be called by the client
debug_printf("Executing vkCreateCuFunctionNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATECUFUNCTIONNVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_XkBojZi=json::vector(1);
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[twsSgji]);
            arr_XkBojZi[twsSgji]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_XkBojZi;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=json::vector();
            return; }auto arr_TrIYEcP=json::vector(1);
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        json["pFunction"]=arr_TrIYEcP;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFunction"].as_vector().size()==0){
                pFunction=NULL;
            return; }auto& arr_TrIYEcP=json["pFunction"].as_vector();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_rHMlbiM;[&](){
            if (json["result"].is_uint64_t()){
                temp_rHMlbiM=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_rHMlbiM=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_rHMlbiM=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_rHMlbiM;}();}();

                if (pFunction!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFunction[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuFunctionNVX...\n");
debug_printf("Return value of vkCreateCuFunctionNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCuModuleNVX( VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuModuleNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYCUMODULENVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();


debug_printf("Ending vkDestroyCuModuleNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyCuFunctionNVX( VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuFunctionNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYCUFUNCTIONNVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();


debug_printf("Ending vkDestroyCuFunctionNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCuLaunchKernelNVX( VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCuLaunchKernelNVX\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCULAUNCHKERNELNVX);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=json::vector();
            return; }auto arr_UKYVund=json::vector(1);
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLaunchInfo[eUSpbRB]);
            arr_UKYVund[eUSpbRB]=temp_map;
            return;
            }();
        }
        json["pLaunchInfo"]=arr_UKYVund;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCULAUNCHKERNELNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCuLaunchKernelNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSizeEXT( VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSizeEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTSIZEEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=json::vector();
            return; }auto arr_xOYiCiO=json::vector(1);
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=static_cast<uint>(pLayoutSizeInBytes[QcQjmSi]);}();}();
        }
        json["pLayoutSizeInBytes"]=arr_xOYiCiO;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){
            if (json["pLayoutSizeInBytes"].as_vector().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].as_vector();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){
            if (arr_xOYiCiO[QcQjmSi].is_uint64_t()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_uint64_t());
            }else if (arr_xOYiCiO[QcQjmSi].is_int64_t()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_int64_t());
            }else{
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].as_double());
            }
            }();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutBindingOffsetEXT( VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutBindingOffsetEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=static_cast<uint>(binding);}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=json::vector();
            return; }auto arr_dquZgZN=json::vector(1);
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=static_cast<uint>(pOffset[LNetLnu]);}();}();
        }
        json["pOffset"]=arr_dquZgZN;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){
            if (json["binding"].is_uint64_t()){
                binding=static_cast<uint32_t>(json["binding"].as_uint64_t());
            }else if (json["binding"].is_int64_t()){
                binding=static_cast<uint32_t>(json["binding"].as_int64_t());
            }else{
                binding=static_cast<uint32_t>(json["binding"].as_double());
            }
            }();
[&](){
            if (json["pOffset"].as_vector().size()==0){
                pOffset=NULL;
            return; }auto& arr_dquZgZN=json["pOffset"].as_vector();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){
            if (arr_dquZgZN[LNetLnu].is_uint64_t()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_uint64_t());
            }else if (arr_dquZgZN[LNetLnu].is_int64_t()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_int64_t());
            }else{
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].as_double());
            }
            }();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorEXT( VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTOREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=json::vector();
            return; }auto arr_RGgHhwd=json::vector(1);
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDescriptorInfo[cdcTeyn]);
            arr_RGgHhwd[cdcTeyn]=temp_map;
            return;
            }();
        }
        json["pDescriptorInfo"]=arr_RGgHhwd;}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=json::vector();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=json::vector();
            return; }auto arr_NUAdiYW=json::vector(dataSize);
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){arr_NUAdiYW[skXTLXg]=static_cast<uint>(((char*)(pDescriptor))[skXTLXg]);}();
        }
        json["pDescriptor"]=arr_NUAdiYW;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTOREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pDescriptor"].as_vector().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].as_vector().size()==0){
                temp_mEHYUhJ=NULL;
            return; }temp_mEHYUhJ=(char*)malloc(dataSize*sizeof(char));auto& arr_NUAdiYW=json["pDescriptor"].as_vector();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){
            if (arr_NUAdiYW[skXTLXg].is_uint64_t()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_uint64_t());
            }else if (arr_NUAdiYW[skXTLXg].is_int64_t()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_int64_t());
            }else{
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].as_double());
            }
            }();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

debug_printf("Ending vkGetDescriptorEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBuffersEXT( VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBuffersEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORBUFFERSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=static_cast<uint>(bufferCount);}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=json::vector();
            return; }auto arr_guwgqGC=json::vector(bufferCount);
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindingInfos[btgeqwi]);
            arr_guwgqGC[btgeqwi]=temp_map;
            return;
            }();
        }
        json["pBindingInfos"]=arr_guwgqGC;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["bufferCount"].is_uint64_t()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_uint64_t());
            }else if (json["bufferCount"].is_int64_t()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_int64_t());
            }else{
                bufferCount=static_cast<uint32_t>(json["bufferCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdBindDescriptorBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDescriptorBufferOffsetsEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDescriptorBufferOffsetsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDESCRIPTORBUFFEROFFSETSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=static_cast<uint>(firstSet);}();
[&](){json["setCount"]=static_cast<uint>(setCount);}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=json::vector();
            return; }auto arr_zejaAgt=json::vector(setCount);
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=static_cast<uint>(pBufferIndices[tuuKbsL]);}();
        }
        json["pBufferIndices"]=arr_zejaAgt;}();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=json::vector();
            return; }auto arr_YvpyTDd=json::vector(setCount);
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=static_cast<uint>(pOffsets[ySwhvse]);}();}();
        }
        json["pOffsets"]=arr_YvpyTDd;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["firstSet"].is_uint64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_uint64_t());
            }else if (json["firstSet"].is_int64_t()){
                firstSet=static_cast<uint32_t>(json["firstSet"].as_int64_t());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].as_double());
            }
            }();
[&](){
            if (json["setCount"].is_uint64_t()){
                setCount=static_cast<uint32_t>(json["setCount"].as_uint64_t());
            }else if (json["setCount"].is_int64_t()){
                setCount=static_cast<uint32_t>(json["setCount"].as_int64_t());
            }else{
                setCount=static_cast<uint32_t>(json["setCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdSetDescriptorBufferOffsetsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBufferEmbeddedSamplersEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBufferEmbeddedSamplersEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=static_cast<int>(pipelineBindPoint);}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=static_cast<uint>(set);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_uint64_t());
            }else if (json["pipelineBindPoint"].is_int64_t()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_int64_t());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].as_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64_t()){
                set=static_cast<uint32_t>(json["set"].as_uint64_t());
            }else if (json["set"].is_int64_t()){
                set=static_cast<uint32_t>(json["set"].as_int64_t());
            }else{
                set=static_cast<uint32_t>(json["set"].as_double());
            }
            }();

debug_printf("Ending vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureDescriptorDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_Hxvezrr=json::vector(1);
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[VgzeNwX]);
            arr_Hxvezrr[VgzeNwX]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_Hxvezrr;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_BreRMSA;[&](){
            if (json["result"].is_uint64_t()){
                temp_BreRMSA=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_BreRMSA=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_BreRMSA=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_BreRMSA;}();}();

debug_printf("Ending vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetBufferOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageOpaqueCaptureDescriptorDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_vrxBIsi=json::vector(1);
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[swRpuDc]);
            arr_vrxBIsi[swRpuDc]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_vrxBIsi;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_PrnsDXW;[&](){
            if (json["result"].is_uint64_t()){
                temp_PrnsDXW=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_PrnsDXW=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_PrnsDXW=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_PrnsDXW;}();}();

debug_printf("Ending vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewOpaqueCaptureDescriptorDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_CYlSaQv=json::vector(1);
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[pmdADqD]);
            arr_CYlSaQv[pmdADqD]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_CYlSaQv;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_UkGTadX;[&](){
            if (json["result"].is_uint64_t()){
                temp_UkGTadX=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_UkGTadX=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_UkGTadX=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_UkGTadX;}();}();

debug_printf("Ending vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageViewOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetSamplerOpaqueCaptureDescriptorDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_RMPxsVS=json::vector(1);
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[SScNLQN]);
            arr_RMPxsVS[SScNLQN]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_RMPxsVS;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_qhwUZoX;[&](){
            if (json["result"].is_uint64_t()){
                temp_qhwUZoX=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_qhwUZoX=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_qhwUZoX=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_qhwUZoX;}();}();

debug_printf("Ending vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetSamplerOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_iLnHGmk=json::vector(1);
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[kbTuVMH]);
            arr_iLnHGmk[kbTuVMH]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_iLnHGmk;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(strlen(((char*)(pData)))+1);
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].as_vector().size()*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < json["pData"].as_vector().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_EdBxllU;[&](){
            if (json["result"].is_uint64_t()){
                temp_EdBxllU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_EdBxllU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_EdBxllU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_EdBxllU;}();}();

debug_printf("Ending vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetDeviceMemoryPriorityEXT( VkDevice device, VkDeviceMemory memory, float priority ){
//Will only be called by the client
debug_printf("Executing vkSetDeviceMemoryPriorityEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKSETDEVICEMEMORYPRIORITYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=static_cast<float>(priority);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEVICEMEMORYPRIORITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){
            if (json["priority"].is_uint64_t()){
                priority=static_cast<float>(json["priority"].as_uint64_t());
            }else if (json["priority"].is_int64_t()){
                priority=static_cast<float>(json["priority"].as_int64_t());
            }else{
                priority=static_cast<float>(json["priority"].as_double());
            }
            }();

debug_printf("Ending vkSetDeviceMemoryPriorityEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkAcquireDrmDisplayEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKACQUIREDRMDISPLAYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=static_cast<int>(drmFd);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["drmFd"].is_uint64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_uint64_t());
            }else if (json["drmFd"].is_int64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_int64_t());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].as_double());
            }
            }();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_VLASVci;[&](){
            if (json["result"].is_uint64_t()){
                temp_VLASVci=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_VLASVci=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_VLASVci=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_VLASVci;}();}();

debug_printf("Ending vkAcquireDrmDisplayEXT...\n");
debug_printf("Return value of vkAcquireDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display ){
//Will only be called by the client
debug_printf("Executing vkGetDrmDisplayEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDRMDISPLAYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=static_cast<int>(drmFd);}();
[&](){json["connectorId"]=static_cast<uint>(connectorId);}();
[&](){
            if (display==NULL){
                json["display"]=json::vector();
            return; }auto arr_DpFHFgI=json::vector(1);
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        json["display"]=arr_DpFHFgI;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["drmFd"].is_uint64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_uint64_t());
            }else if (json["drmFd"].is_int64_t()){
                drmFd=static_cast<int32_t>(json["drmFd"].as_int64_t());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].as_double());
            }
            }();
[&](){
            if (json["connectorId"].is_uint64_t()){
                connectorId=static_cast<uint32_t>(json["connectorId"].as_uint64_t());
            }else if (json["connectorId"].is_int64_t()){
                connectorId=static_cast<uint32_t>(json["connectorId"].as_int64_t());
            }else{
                connectorId=static_cast<uint32_t>(json["connectorId"].as_double());
            }
            }();
[&](){
            if (json["display"].as_vector().size()==0){
                display=NULL;
            return; }auto& arr_DpFHFgI=json["display"].as_vector();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pCKulNk;[&](){
            if (json["result"].is_uint64_t()){
                temp_pCKulNk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_pCKulNk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_pCKulNk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_pCKulNk;}();}();

debug_printf("Ending vkGetDrmDisplayEXT...\n");
debug_printf("Return value of vkGetDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForPresentKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForPresentKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKWAITFORPRESENTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=static_cast<uint>(presentId);}();
[&](){json["timeout"]=static_cast<uint>(timeout);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["presentId"].is_uint64_t()){
                presentId=static_cast<uint64_t>(json["presentId"].as_uint64_t());
            }else if (json["presentId"].is_int64_t()){
                presentId=static_cast<uint64_t>(json["presentId"].as_int64_t());
            }else{
                presentId=static_cast<uint64_t>(json["presentId"].as_double());
            }
            }();
[&](){
            if (json["timeout"].is_uint64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_uint64_t());
            }else if (json["timeout"].is_int64_t()){
                timeout=static_cast<uint64_t>(json["timeout"].as_int64_t());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_GxvXpqW;[&](){
            if (json["result"].is_uint64_t()){
                temp_GxvXpqW=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_GxvXpqW=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_GxvXpqW=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_GxvXpqW;}();}();

debug_printf("Ending vkWaitForPresentKHR...\n");
debug_printf("Return value of vkWaitForPresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRendering( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRendering\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBEGINRENDERING);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=json::vector();
            return; }auto arr_DOEgrev=json::vector(1);
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingInfo[dAqQfxy]);
            arr_DOEgrev[dAqQfxy]=temp_map;
            return;
            }();
        }
        json["pRenderingInfo"]=arr_DOEgrev;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderingKHR( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
return vkCmdBeginRendering(commandBuffer, pRenderingInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRendering( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRendering\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDENDRENDERING);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderingKHR( VkCommandBuffer commandBuffer ){
return vkCmdEndRendering(commandBuffer);
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutHostMappingInfoVALVE( VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutHostMappingInfoVALVE\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=json::vector();
            return; }auto arr_JTmPGZt=json::vector(1);
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBindingReference[OEumPxJ]);
            arr_JTmPGZt[OEumPxJ]=temp_map;
            return;
            }();
        }
        json["pBindingReference"]=arr_JTmPGZt;}();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=json::vector();
            return; }auto arr_zODJzpL=json::vector(1);
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pHostMapping[jHGvhna]);
            arr_zODJzpL[jHGvhna]=temp_map;
            return;
            }();
        }
        json["pHostMapping"]=arr_zODJzpL;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pHostMapping"].as_vector().size()==0){
                pHostMapping=NULL;
            return; }auto& arr_zODJzpL=json["pHostMapping"].as_vector();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            deserialize_struct(arr_zODJzpL[jHGvhna].as_map(),pHostMapping[jHGvhna]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetHostMappingVALVE( VkDevice device, VkDescriptorSet descriptorSet, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetHostMappingVALVE\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDESCRIPTORSETHOSTMAPPINGVALVE);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_JgRLJSK=json::vector(1);
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(strlen(((char*)(ppData[NsRFkBj])))+1);
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[NsRFkBj]))[jYdchEs]);}();
        }
        arr_JgRLJSK[NsRFkBj]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_JgRLJSK;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }auto& arr_JgRLJSK=json["ppData"].as_vector();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_vector().size()*sizeof(char));auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].as_vector();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].as_vector().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetHostMappingVALVE...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateMicromapEXT( VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap ){
//Will only be called by the client
debug_printf("Executing vkCreateMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_vrQtrYo=json::vector(1);
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[cfhYIUK]);
            arr_vrQtrYo[cfhYIUK]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_vrQtrYo;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=json::vector();
            return; }auto arr_mHmzwPX=json::vector(1);
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        json["pMicromap"]=arr_mHmzwPX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMicromap"].as_vector().size()==0){
                pMicromap=NULL;
            return; }auto& arr_mHmzwPX=json["pMicromap"].as_vector();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_kPZvlkz;[&](){
            if (json["result"].is_uint64_t()){
                temp_kPZvlkz=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_kPZvlkz=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_kPZvlkz=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_kPZvlkz;}();}();

                if (pMicromap!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMicromap[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateMicromapEXT...\n");
debug_printf("Return value of vkCreateMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildMicromapsEXT( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildMicromapsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBUILDMICROMAPSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_KdoluBZ=json::vector(infoCount);
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[bfMWBOA]);
            arr_KdoluBZ[bfMWBOA]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_KdoluBZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();


debug_printf("Ending vkCmdBuildMicromapsEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildMicromapsEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildMicromapsEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBUILDMICROMAPSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=static_cast<uint>(infoCount);}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=json::vector();
            return; }auto arr_KdoluBZ=json::vector(infoCount);
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfos[bfMWBOA]);
            arr_KdoluBZ[bfMWBOA]=temp_map;
            return;
            }();
        }
        json["pInfos"]=arr_KdoluBZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){
            if (json["infoCount"].is_uint64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_uint64_t());
            }else if (json["infoCount"].is_int64_t()){
                infoCount=static_cast<uint32_t>(json["infoCount"].as_int64_t());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].as_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_UtJGuJG;[&](){
            if (json["result"].is_uint64_t()){
                temp_UtJGuJG=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_UtJGuJG=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_UtJGuJG=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_UtJGuJG;}();}();

debug_printf("Ending vkBuildMicromapsEXT...\n");
debug_printf("Return value of vkBuildMicromapsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyMicromapEXT( VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();


debug_printf("Ending vkDestroyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UIlbXxp=json::vector(1);
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vDMleIo]);
            arr_UIlbXxp[vDMleIo]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_UIlbXxp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_UIlbXxp=json::vector(1);
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[vDMleIo]);
            arr_UIlbXxp[vDMleIo]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_UIlbXxp;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_ONHPOzE;[&](){
            if (json["result"].is_uint64_t()){
                temp_ONHPOzE=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ONHPOzE=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ONHPOzE=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ONHPOzE;}();}();

debug_printf("Ending vkCopyMicromapEXT...\n");
debug_printf("Return value of vkCopyMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapToMemoryEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapToMemoryEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMICROMAPTOMEMORYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_EiLirbT=json::vector(1);
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dzsAOWF]);
            arr_EiLirbT[dzsAOWF]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_EiLirbT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapToMemoryEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapToMemoryEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapToMemoryEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYMICROMAPTOMEMORYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_EiLirbT=json::vector(1);
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[dzsAOWF]);
            arr_EiLirbT[dzsAOWF]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_EiLirbT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_FivEhpk;[&](){
            if (json["result"].is_uint64_t()){
                temp_FivEhpk=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_FivEhpk=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_FivEhpk=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_FivEhpk;}();}();

debug_printf("Ending vkCopyMicromapToMemoryEXT...\n");
debug_printf("Return value of vkCopyMicromapToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDCOPYMEMORYTOMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QufOGLT=json::vector(1);
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[semZpgt]);
            arr_QufOGLT[semZpgt]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QufOGLT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToMicromapEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCOPYMEMORYTOMICROMAPEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_QufOGLT=json::vector(1);
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[semZpgt]);
            arr_QufOGLT[semZpgt]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_QufOGLT;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_TKYMlWK;[&](){
            if (json["result"].is_uint64_t()){
                temp_TKYMlWK=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TKYMlWK=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_TKYMlWK=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_TKYMlWK;}();}();

debug_printf("Ending vkCopyMemoryToMicromapEXT...\n");
debug_printf("Return value of vkCopyMemoryToMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteMicromapsPropertiesEXT( VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteMicromapsPropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDWRITEMICROMAPSPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=static_cast<uint>(micromapCount);}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=json::vector();
            return; }auto arr_NriAFXg=json::vector(micromapCount);
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        json["pMicromaps"]=arr_NriAFXg;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=static_cast<uint>(firstQuery);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["micromapCount"].is_uint64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_uint64_t());
            }else if (json["micromapCount"].is_int64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_int64_t());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_uint64_t());
            }else if (json["firstQuery"].is_int64_t()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_int64_t());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].as_double());
            }
            }();

debug_printf("Ending vkCmdWriteMicromapsPropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteMicromapsPropertiesEXT( VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteMicromapsPropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKWRITEMICROMAPSPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=static_cast<uint>(micromapCount);}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=json::vector();
            return; }auto arr_NriAFXg=json::vector(micromapCount);
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        json["pMicromaps"]=arr_NriAFXg;}();
[&](){[&](){[&](){json["queryType"]=static_cast<int>(queryType);}();}();}();
[&](){json["dataSize"]=static_cast<int>(dataSize);}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(dataSize);
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
[&](){json["stride"]=static_cast<int>(stride);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["micromapCount"].is_uint64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_uint64_t());
            }else if (json["micromapCount"].is_int64_t()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_int64_t());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].as_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_uint64_t());
            }else if (json["queryType"].is_int64_t()){
                temp_VdJSktT=static_cast<int>(json["queryType"].as_int64_t());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].as_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){
            if (json["dataSize"].is_uint64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_uint64_t());
            }else if (json["dataSize"].is_int64_t()){
                dataSize=static_cast<size_t>(json["dataSize"].as_int64_t());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].as_double());
            }
            }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){
            if (json["stride"].is_uint64_t()){
                stride=static_cast<size_t>(json["stride"].as_uint64_t());
            }else if (json["stride"].is_int64_t()){
                stride=static_cast<size_t>(json["stride"].as_int64_t());
            }else{
                stride=static_cast<size_t>(json["stride"].as_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_zcmywrl;[&](){
            if (json["result"].is_uint64_t()){
                temp_zcmywrl=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_zcmywrl=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_zcmywrl=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_zcmywrl;}();}();

debug_printf("Ending vkWriteMicromapsPropertiesEXT...\n");
debug_printf("Return value of vkWriteMicromapsPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMicromapCompatibilityEXT( VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMicromapCompatibilityEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEMICROMAPCOMPATIBILITYEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=json::vector();
            return; }auto arr_PYqUGEM=json::vector(1);
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pVersionInfo[odfXDEI]);
            arr_PYqUGEM[odfXDEI]=temp_map;
            return;
            }();
        }
        json["pVersionInfo"]=arr_PYqUGEM;}();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=json::vector();
            return; }auto arr_dBMhFMX=json::vector(1);
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=static_cast<int>(pCompatibility[nzOFTGF]);}();}();}();
        }
        json["pCompatibility"]=arr_dBMhFMX;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].as_vector().size()==0){
                pCompatibility=NULL;
            return; }auto& arr_dBMhFMX=json["pCompatibility"].as_vector();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_uint64_t());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64_t()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_int64_t());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].as_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceMicromapCompatibilityEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetMicromapBuildSizesEXT( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetMicromapBuildSizesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETMICROMAPBUILDSIZESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=static_cast<int>(buildType);}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=json::vector();
            return; }auto arr_lREHNwp=json::vector(1);
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pBuildInfo[nPItxru]);
            arr_lREHNwp[nPItxru]=temp_map;
            return;
            }();
        }
        json["pBuildInfo"]=arr_lREHNwp;}();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=json::vector();
            return; }auto arr_fJKSsZw=json::vector(1);
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSizeInfo[XgjgtXU]);
            arr_fJKSsZw[XgjgtXU]=temp_map;
            return;
            }();
        }
        json["pSizeInfo"]=arr_fJKSsZw;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMICROMAPBUILDSIZESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_uint64_t());
            }else if (json["buildType"].is_int64_t()){
                temp_XouAsBI=static_cast<int>(json["buildType"].as_int64_t());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].as_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();

[&](){
            if (json["pSizeInfo"].as_vector().size()==0){
                pSizeInfo=NULL;
            return; }auto& arr_fJKSsZw=json["pSizeInfo"].as_vector();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            deserialize_struct(arr_fJKSsZw[XgjgtXU].as_map(),pSizeInfo[XgjgtXU]);
            }();
        }
        }();

debug_printf("Ending vkGetMicromapBuildSizesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleIdentifierEXT( VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleIdentifierEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSHADERMODULEIDENTIFIEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=json::vector();
            return; }auto arr_ICaFqGG=json::vector(1);
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIdentifier[DSBkSwY]);
            arr_ICaFqGG[DSBkSwY]=temp_map;
            return;
            }();
        }
        json["pIdentifier"]=arr_ICaFqGG;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULEIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
[&](){
            if (json["pIdentifier"].as_vector().size()==0){
                pIdentifier=NULL;
            return; }auto& arr_ICaFqGG=json["pIdentifier"].as_vector();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            deserialize_struct(arr_ICaFqGG[DSBkSwY].as_map(),pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleCreateInfoIdentifierEXT( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleCreateInfoIdentifierEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSHADERMODULECREATEINFOIDENTIFIEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_iSZUILM=json::vector(1);
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[dKxemXH]);
            arr_iSZUILM[dKxemXH]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_iSZUILM;}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=json::vector();
            return; }auto arr_ICaFqGG=json::vector(1);
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pIdentifier[DSBkSwY]);
            arr_ICaFqGG[DSBkSwY]=temp_map;
            return;
            }();
        }
        json["pIdentifier"]=arr_ICaFqGG;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pIdentifier"].as_vector().size()==0){
                pIdentifier=NULL;
            return; }auto& arr_ICaFqGG=json["pIdentifier"].as_vector();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            deserialize_struct(arr_ICaFqGG[DSBkSwY].as_map(),pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleCreateInfoIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2KHR( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout2KHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETIMAGESUBRESOURCELAYOUT2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=json::vector();
            return; }auto arr_xtdYssI=json::vector(1);
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pSubresource[HvvKvoL]);
            arr_xtdYssI[HvvKvoL]=temp_map;
            return;
            }();
        }
        json["pSubresource"]=arr_xtdYssI;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JxnVeqW=json::vector(1);
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jEkaLQP]);
            arr_JxnVeqW[jEkaLQP]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JxnVeqW;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }auto& arr_JxnVeqW=json["pLayout"].as_vector();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            deserialize_struct(arr_JxnVeqW[jEkaLQP].as_map(),pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2EXT( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
return vkGetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelinePropertiesEXT( VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelinePropertiesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPIPELINEPROPERTIESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=json::vector();
            return; }auto arr_eGbOPJq=json::vector(1);
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineInfo[iUjmOrp]);
            arr_eGbOPJq[iUjmOrp]=temp_map;
            return;
            }();
        }
        json["pPipelineInfo"]=arr_eGbOPJq;}();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=json::vector();
            return; }auto arr_eMgMlNc=json::vector(1);
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pPipelineProperties[cJpCXwz]);
            arr_eMgMlNc[cJpCXwz]=temp_map;
            return;
            }();
        }
        json["pPipelineProperties"]=arr_eMgMlNc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pPipelineProperties"].as_vector().size()==0){
                pPipelineProperties=NULL;
            return; }auto& arr_eMgMlNc=json["pPipelineProperties"].as_vector();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            deserialize_struct(arr_eMgMlNc[cJpCXwz].as_map(),pPipelineProperties[cJpCXwz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XOJEaHr;[&](){
            if (json["result"].is_uint64_t()){
                temp_XOJEaHr=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_XOJEaHr=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_XOJEaHr=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_XOJEaHr;}();}();

debug_printf("Ending vkGetPipelinePropertiesEXT...\n");
debug_printf("Return value of vkGetPipelinePropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFramebufferTilePropertiesQCOM( VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetFramebufferTilePropertiesQCOM\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETFRAMEBUFFERTILEPROPERTIESQCOM);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=json::vector();
            return; }auto arr_vUkyKfO=json::vector(1);
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=static_cast<uint>(pPropertiesCount[YhfeqPW]);}();
        }
        json["pPropertiesCount"]=arr_vUkyKfO;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hYNBodF=json::vector(*pPropertiesCount);
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oGElcJh]);
            arr_hYNBodF[oGElcJh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hYNBodF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
[&](){
            if (json["pPropertiesCount"].as_vector().size()==0){
                pPropertiesCount=NULL;
            return; }auto& arr_vUkyKfO=json["pPropertiesCount"].as_vector();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){
            if (arr_vUkyKfO[YhfeqPW].is_uint64_t()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_uint64_t());
            }else if (arr_vUkyKfO[YhfeqPW].is_int64_t()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_int64_t());
            }else{
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_hYNBodF=json["pProperties"].as_vector();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            deserialize_struct(arr_hYNBodF[oGElcJh].as_map(),pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_TLkSlaU;[&](){
            if (json["result"].is_uint64_t()){
                temp_TLkSlaU=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_TLkSlaU=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_TLkSlaU=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_TLkSlaU;}();}();

debug_printf("Ending vkGetFramebufferTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetFramebufferTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDynamicRenderingTilePropertiesQCOM( VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDynamicRenderingTilePropertiesQCOM\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=json::vector();
            return; }auto arr_DOEgrev=json::vector(1);
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pRenderingInfo[dAqQfxy]);
            arr_DOEgrev[dAqQfxy]=temp_map;
            return;
            }();
        }
        json["pRenderingInfo"]=arr_DOEgrev;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_hYNBodF=json::vector(1);
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[oGElcJh]);
            arr_hYNBodF[oGElcJh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_hYNBodF;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_hYNBodF=json["pProperties"].as_vector();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            deserialize_struct(arr_hYNBodF[oGElcJh].as_map(),pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_inlNtLF;[&](){
            if (json["result"].is_uint64_t()){
                temp_inlNtLF=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_inlNtLF=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_inlNtLF=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_inlNtLF;}();}();

debug_printf("Ending vkGetDynamicRenderingTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetDynamicRenderingTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV( VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceOpticalFlowImageFormatsNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=json::vector();
            return; }auto arr_oyPfnWV=json::vector(1);
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pOpticalFlowImageFormatInfo[HqzITOl]);
            arr_oyPfnWV[HqzITOl]=temp_map;
            return;
            }();
        }
        json["pOpticalFlowImageFormatInfo"]=arr_oyPfnWV;}();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=json::vector();
            return; }auto arr_OWVxAsX=json::vector(1);
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=static_cast<uint>(pFormatCount[AvMKjKj]);}();
        }
        json["pFormatCount"]=arr_OWVxAsX;}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=json::vector();
            return; }auto arr_oZncgpa=json::vector(*pFormatCount);
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pImageFormatProperties[gkJgIzP]);
            arr_oZncgpa[gkJgIzP]=temp_map;
            return;
            }();
        }
        json["pImageFormatProperties"]=arr_oZncgpa;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pFormatCount"].as_vector().size()==0){
                pFormatCount=NULL;
            return; }auto& arr_OWVxAsX=json["pFormatCount"].as_vector();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){
            if (arr_OWVxAsX[AvMKjKj].is_uint64_t()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_uint64_t());
            }else if (arr_OWVxAsX[AvMKjKj].is_int64_t()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_int64_t());
            }else{
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pImageFormatProperties"].as_vector().size()==0){
                pImageFormatProperties=NULL;
            return; }auto& arr_oZncgpa=json["pImageFormatProperties"].as_vector();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            deserialize_struct(arr_oZncgpa[gkJgIzP].as_map(),pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tYfFThn;[&](){
            if (json["result"].is_uint64_t()){
                temp_tYfFThn=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_tYfFThn=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_tYfFThn=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_tYfFThn;}();}();

debug_printf("Ending vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceOpticalFlowImageFormatsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateOpticalFlowSessionNV( VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession ){
//Will only be called by the client
debug_printf("Executing vkCreateOpticalFlowSessionNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATEOPTICALFLOWSESSIONNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=json::vector();
            return; }auto arr_dKVOiZE=json::vector(1);
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfo[LaeeodD]);
            arr_dKVOiZE[LaeeodD]=temp_map;
            return;
            }();
        }
        json["pCreateInfo"]=arr_dKVOiZE;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pSession==NULL){
                json["pSession"]=json::vector();
            return; }auto arr_PyNQerY=json::vector(1);
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        json["pSession"]=arr_PyNQerY;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSession"].as_vector().size()==0){
                pSession=NULL;
            return; }auto& arr_PyNQerY=json["pSession"].as_vector();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_gzRTYMj;[&](){
            if (json["result"].is_uint64_t()){
                temp_gzRTYMj=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_gzRTYMj=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_gzRTYMj=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_gzRTYMj;}();}();

                if (pSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateOpticalFlowSessionNV...\n");
debug_printf("Return value of vkCreateOpticalFlowSessionNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyOpticalFlowSessionNV( VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyOpticalFlowSessionNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYOPTICALFLOWSESSIONNV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkDestroyOpticalFlowSessionNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindOpticalFlowSessionImageNV( VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout ){
//Will only be called by the client
debug_printf("Executing vkBindOpticalFlowSessionImageNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKBINDOPTICALFLOWSESSIONIMAGENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=static_cast<int>(bindingPoint);}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=static_cast<int>(layout);}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDOPTICALFLOWSESSIONIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
[&](){[&](){int temp_dqYOkbF;[&](){
            if (json["bindingPoint"].is_uint64_t()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_uint64_t());
            }else if (json["bindingPoint"].is_int64_t()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_int64_t());
            }else{
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].as_double());
            }
            }();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
[&](){deserialize_VkImageView(json["view"], view);}();
[&](){[&](){int temp_IaQZtFR;[&](){
            if (json["layout"].is_uint64_t()){
                temp_IaQZtFR=static_cast<int>(json["layout"].as_uint64_t());
            }else if (json["layout"].is_int64_t()){
                temp_IaQZtFR=static_cast<int>(json["layout"].as_int64_t());
            }else{
                temp_IaQZtFR=static_cast<int>(json["layout"].as_double());
            }
            }();layout=(VkImageLayout)temp_IaQZtFR;}();}();
VkResult result;
[&](){[&](){int temp_PXkQMYg;[&](){
            if (json["result"].is_uint64_t()){
                temp_PXkQMYg=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_PXkQMYg=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_PXkQMYg=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_PXkQMYg;}();}();

debug_printf("Ending vkBindOpticalFlowSessionImageNV...\n");
debug_printf("Return value of vkBindOpticalFlowSessionImageNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdOpticalFlowExecuteNV( VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdOpticalFlowExecuteNV\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDOPTICALFLOWEXECUTENV);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=json::vector();
            return; }auto arr_CyySpro=json::vector(1);
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pExecuteInfo[XLHKKBA]);
            arr_CyySpro[XLHKKBA]=temp_map;
            return;
            }();
        }
        json["pExecuteInfo"]=arr_CyySpro;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDOPTICALFLOWEXECUTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkCmdOpticalFlowExecuteNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceFaultInfoEXT( VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceFaultInfoEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEFAULTINFOEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=json::vector();
            return; }auto arr_LWLqmdd=json::vector(1);
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFaultCounts[RexMRxZ]);
            arr_LWLqmdd[RexMRxZ]=temp_map;
            return;
            }();
        }
        json["pFaultCounts"]=arr_LWLqmdd;}();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=json::vector();
            return; }auto arr_CRNBZxs=json::vector(1);
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pFaultInfo[AHHHhvb]);
            arr_CRNBZxs[AHHHhvb]=temp_map;
            return;
            }();
        }
        json["pFaultInfo"]=arr_CRNBZxs;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEFAULTINFOEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pFaultCounts"].as_vector().size()==0){
                pFaultCounts=NULL;
            return; }auto& arr_LWLqmdd=json["pFaultCounts"].as_vector();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            deserialize_struct(arr_LWLqmdd[RexMRxZ].as_map(),pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (json["pFaultInfo"].as_vector().size()==0){
                pFaultInfo=NULL;
            return; }auto& arr_CRNBZxs=json["pFaultInfo"].as_vector();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            deserialize_struct(arr_CRNBZxs[AHHHhvb].as_map(),pFaultInfo[AHHHhvb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_QCKCJeX;[&](){
            if (json["result"].is_uint64_t()){
                temp_QCKCJeX=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_QCKCJeX=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_QCKCJeX=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_QCKCJeX;}();}();

debug_printf("Ending vkGetDeviceFaultInfoEXT...\n");
debug_printf("Return value of vkGetDeviceFaultInfoEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias2EXT( VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias2EXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDSETDEPTHBIAS2EXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=json::vector();
            return; }auto arr_AKZgFGf=json::vector(1);
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pDepthBiasInfo[kGsXYsB]);
            arr_AKZgFGf[kGsXYsB]=temp_map;
            return;
            }();
        }
        json["pDepthBiasInfo"]=arr_AKZgFGf;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetDepthBias2EXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseSwapchainImagesEXT( VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo ){
//Will only be called by the client
debug_printf("Executing vkReleaseSwapchainImagesEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKRELEASESWAPCHAINIMAGESEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=json::vector();
            return; }auto arr_jcnZDBn=json::vector(1);
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pReleaseInfo[dRtPqPF]);
            arr_jcnZDBn[dRtPqPF]=temp_map;
            return;
            }();
        }
        json["pReleaseInfo"]=arr_jcnZDBn;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASESWAPCHAINIMAGESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_MnSoniu;[&](){
            if (json["result"].is_uint64_t()){
                temp_MnSoniu=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_MnSoniu=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_MnSoniu=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_MnSoniu;}();}();

debug_printf("Ending vkReleaseSwapchainImagesEXT...\n");
debug_printf("Return value of vkReleaseSwapchainImagesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSubresourceLayoutKHR( VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSubresourceLayoutKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=json::vector();
            return; }auto arr_SwRDgPP=json::vector(1);
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pInfo[wxoktPv]);
            arr_SwRDgPP[wxoktPv]=temp_map;
            return;
            }();
        }
        json["pInfo"]=arr_SwRDgPP;}();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=json::vector();
            return; }auto arr_JxnVeqW=json::vector(1);
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pLayout[jEkaLQP]);
            arr_JxnVeqW[jEkaLQP]=temp_map;
            return;
            }();
        }
        json["pLayout"]=arr_JxnVeqW;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pLayout"].as_vector().size()==0){
                pLayout=NULL;
            return; }auto& arr_JxnVeqW=json["pLayout"].as_vector();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            deserialize_struct(arr_JxnVeqW[jEkaLQP].as_map(),pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSubresourceLayoutKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory2KHR( VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory2KHR\n");
MemoryMapLock.lock();

    json::map json;
    json["stream_type"]=static_cast<int>(VKMAPMEMORY2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;

        if (pMemoryMapInfo->size==VK_WHOLE_SIZE){
            VkMemoryMapInfoKHR new_map_info=*pMemoryMapInfo;
            new_map_info.size=devicememory_to_size[(uintptr_t)new_map_info.memory]-new_map_info.offset;
            pMemoryMapInfo=&new_map_info;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=json::vector();
            return; }auto arr_udcndbe=json::vector(1);
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryMapInfo[iwSaLAe]);
            arr_udcndbe[iwSaLAe]=temp_map;
            return;
            }();
        }
        json["pMemoryMapInfo"]=arr_udcndbe;}();
[&](){
            if (ppData==NULL){
                json["ppData"]=json::vector();
            return; }auto arr_JgRLJSK=json::vector(1);
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=json::vector();
            return; }auto arr_vLfeDBZ=json::vector(strlen(((char*)(ppData[NsRFkBj])))+1);
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=static_cast<uint>(((char*)(ppData[NsRFkBj]))[jYdchEs]);}();
        }
        arr_JgRLJSK[NsRFkBj]=arr_vLfeDBZ;}();}();
        }
        json["ppData"]=arr_JgRLJSK;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["ppData"].as_vector().size()==0){
                ppData=NULL;
            return; }auto& arr_JgRLJSK=json["ppData"].as_vector();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].as_vector().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].as_vector().size()*sizeof(char));auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].as_vector();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].as_vector().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_uint64_t());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64_t()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_int64_t());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].as_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ISWBnyX;[&](){
            if (json["result"].is_uint64_t()){
                temp_ISWBnyX=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_ISWBnyX=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_ISWBnyX=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_ISWBnyX;}();}();

        json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=server_memory_json.as_uint64_t(); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,json["mem"].as_uint64_t());
        
        #ifndef CLIENT
            json["mem"]=json["mem"].as_uint64_t();
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory2KHR...\n");
debug_printf("Return value of vkMapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUnmapMemory2KHR( VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory2KHR\n");
MemoryMapLock.lock();

    json::map json;
    json["stream_type"]=static_cast<int>(VKUNMAPMEMORY2KHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=json::vector();
            return; }auto arr_hZlnXPf=json::vector(1);
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pMemoryUnmapInfo[caczdhq]);
            arr_hZlnXPf[caczdhq]=temp_map;
            return;
            }();
        }
        json["pMemoryUnmapInfo"]=arr_hZlnXPf;}();
}
deregisterDeviceMemoryMap(pMemoryUnmapInfo->memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_yHbgkCw;[&](){
            if (json["result"].is_uint64_t()){
                temp_yHbgkCw=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_yHbgkCw=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_yHbgkCw=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_yHbgkCw;}();}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory2KHR...\n");
debug_printf("Return value of vkUnmapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShadersEXT( VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCreateShadersEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCREATESHADERSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=static_cast<uint>(createInfoCount);}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=json::vector();
            return; }auto arr_mOfZnnW=json::vector(createInfoCount);
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pCreateInfos[bOiKywR]);
            arr_mOfZnnW[bOiKywR]=temp_map;
            return;
            }();
        }
        json["pCreateInfos"]=arr_mOfZnnW;}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=json::vector();
            return; }auto arr_ndnxxFm=json::vector(createInfoCount);
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        json["pShaders"]=arr_ndnxxFm;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["createInfoCount"].is_uint64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_uint64_t());
            }else if (json["createInfoCount"].is_int64_t()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_int64_t());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].as_double());
            }
            }();


[&](){
            if (json["pShaders"].as_vector().size()==0){
                pShaders=NULL;
            return; }auto& arr_ndnxxFm=json["pShaders"].as_vector();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_DjHJocd;[&](){
            if (json["result"].is_uint64_t()){
                temp_DjHJocd=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_DjHJocd=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_DjHJocd=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_DjHJocd;}();}();

                if (pShaders!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaders[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShadersEXT...\n");
debug_printf("Return value of vkCreateShadersEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderEXT( VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKDESTROYSHADEREXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=json::vector();
            return; }auto arr_daGjOqj=json::vector(1);
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pAllocator[fdxDfEW]);
            arr_daGjOqj[fdxDfEW]=temp_map;
            return;
            }();
        }
        json["pAllocator"]=arr_daGjOqj;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();


debug_printf("Ending vkDestroyShaderEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderBinaryDataEXT( VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetShaderBinaryDataEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETSHADERBINARYDATAEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=json::vector();
            return; }auto arr_Zcusyfw=json::vector(1);
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=static_cast<int>(pDataSize[HCzJfGC]);}();
        }
        json["pDataSize"]=arr_Zcusyfw;}();
[&](){
            if (pData==NULL){
                json["pData"]=json::vector();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=json::vector();
            return; }auto arr_KuWJuFa=json::vector(*pDataSize);
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=static_cast<uint>(((char*)(pData))[tDEuamw]);}();
        }
        json["pData"]=arr_KuWJuFa;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERBINARYDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
[&](){
            if (json["pDataSize"].as_vector().size()==0){
                pDataSize=NULL;
            return; }auto& arr_Zcusyfw=json["pDataSize"].as_vector();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_uint64_t());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64_t()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_int64_t());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].as_vector().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].as_vector().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));auto& arr_KuWJuFa=json["pData"].as_vector();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_uint64_t());
            }else if (arr_KuWJuFa[tDEuamw].is_int64_t()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_int64_t());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].as_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_zXjNUAM;[&](){
            if (json["result"].is_uint64_t()){
                temp_zXjNUAM=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_zXjNUAM=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_zXjNUAM=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_zXjNUAM;}();}();

debug_printf("Ending vkGetShaderBinaryDataEXT...\n");
debug_printf("Return value of vkGetShaderBinaryDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadersEXT( VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadersEXT\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKCMDBINDSHADERSEXT);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=static_cast<uint>(stageCount);}();
[&](){
            if (pStages==NULL){
                json["pStages"]=json::vector();
            return; }auto arr_phXrzxO=json::vector(stageCount);
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=static_cast<int>(pStages[uFucfxh]);}();}();}();
        }
        json["pStages"]=arr_phXrzxO;}();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=json::vector();
            return; }auto arr_ZjERyql=json::vector(stageCount);
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        json["pShaders"]=arr_ZjERyql;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["stageCount"].is_uint64_t()){
                stageCount=static_cast<uint32_t>(json["stageCount"].as_uint64_t());
            }else if (json["stageCount"].is_int64_t()){
                stageCount=static_cast<uint32_t>(json["stageCount"].as_int64_t());
            }else{
                stageCount=static_cast<uint32_t>(json["stageCount"].as_double());
            }
            }();



debug_printf("Ending vkCmdBindShadersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR\n");

    json::map json;
    json["stream_type"]=static_cast<int>(VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR);
    
    auto parent_json=json::map();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
json["parent"]=parent_json;
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=json::vector();
            return; }auto arr_ICoMmRG=json::vector(1);
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=static_cast<uint>(pPropertyCount[srQaIwu]);}();
        }
        json["pPropertyCount"]=arr_ICoMmRG;}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=json::vector();
            return; }auto arr_PEzgESc=json::vector(*pPropertyCount);
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto temp_map=json::map();
            serialize_struct(temp_map, pProperties[iTGjLCh]);
            arr_PEzgESc[iTGjLCh]=temp_map;
            return;
            }();
        }
        json["pProperties"]=arr_PEzgESc;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(json["stream_type"].as_uint64_t())){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].as_vector().size()==0){
                pPropertyCount=NULL;
            return; }auto& arr_ICoMmRG=json["pPropertyCount"].as_vector();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_uint64_t());
            }else if (arr_ICoMmRG[srQaIwu].is_int64_t()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_int64_t());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].as_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].as_vector().size()==0){
                pProperties=NULL;
            return; }auto& arr_PEzgESc=json["pProperties"].as_vector();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            deserialize_struct(arr_PEzgESc[iTGjLCh].as_map(),pProperties[iTGjLCh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HxBNOnK;[&](){
            if (json["result"].is_uint64_t()){
                temp_HxBNOnK=static_cast<int>(json["result"].as_uint64_t());
            }else if (json["result"].is_int64_t()){
                temp_HxBNOnK=static_cast<int>(json["result"].as_int64_t());
            }else{
                temp_HxBNOnK=static_cast<int>(json["result"].as_double());
            }
            }();result=(VkResult)temp_HxBNOnK;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
}
#endif

#ifndef CLIENT
int main(int argc, char** argv){
    startServer();
}
#endif

