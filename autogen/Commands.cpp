
#include <debug.hpp>
#include <boost/json.hpp>

#include <stdexcept>
#include <shared_mutex>
#include <future>
#include "vk_enum_string_helper.h"
#include <set>
#include <vulkan/vulkan.h>

#include <Serialization.hpp>
#include <Server.hpp>
#include <Synchronization.hpp>

#ifdef CLIENT
    #include <Surface.hpp>
    
    std::map<uintptr_t, VkDeviceSize> devicememory_to_size;
    void registerDeviceMemory(VkDeviceMemory memory, VkDeviceSize size){
        devicememory_to_size[(uintptr_t)memory]=size;
    }
#endif

typedef std::shared_mutex Lock;

Lock MemoryMapLock;
Lock MemoryOperationLock; //This is not needed (but may be preferred, at the expense of unneccessary locking)

#ifndef CLIENT

#ifdef __APPLE__
    std::string vulkan_library_name="libvulkan.dylib";
#endif
#include <dlfcn.h>
auto vulkan_library=dlopen(vulkan_library_name.c_str(), RTLD_LAZY | RTLD_GLOBAL);
auto get_instance_proc_addr=(PFN_vkGetInstanceProcAddr)dlsym(vulkan_library,"vkGetInstanceProcAddr");
auto get_device_proc_addr=(PFN_vkGetDeviceProcAddr)dlsym(vulkan_library,"vkGetDeviceProcAddr");


    void handle_vkCreateInstance(boost::json::object& json){
    //Will only be called by the server
    
 VkInstanceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkInstanceCreateInfo*)malloc(1*sizeof(VkInstanceCreateInfo));
        auto& arr_KMjnDnU=json["pCreateInfo"].get_array();
        for(int tBToPhv=0; tBToPhv < 1; tBToPhv++){
            [&](){
            auto& temp=arr_KMjnDnU[tBToPhv].get_object();
            deserialize_struct(temp,pCreateInfo[tBToPhv]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkInstance* pInstance;
[&](){
            if (json["pInstance"].get_array().size()==0){
                pInstance=NULL;
            return; }pInstance=(VkInstance*)malloc(1*sizeof(VkInstance));
        auto& arr_GanofFb=json["pInstance"].get_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();

    PFN_vkCreateInstance call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateInstance)get_instance_proc_addr(parent,"vkCreateInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateInstance)get_device_proc_addr(parent,"vkCreateInstance");
    }  
    
VkResult  result;
{


        VkInstanceCreateInfo* temp_info=pCreateInfo;

        VkInstanceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        #ifdef VK_USE_PLATFORM_METAL_EXT
            extensions_set.erase(std::string("VK_KHR_xcb_surface"));
            extensions_set.erase(std::string("VK_KHR_xlib_surface"));
        #endif
        
        extensions_set.insert(std::string(VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME));
        //extensions_set.insert(std::string(VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME));
        extensions_set.insert(std::string(VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;            
        
result=call_function(pCreateInfo, pAllocator, pInstance);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_yCteunD=json["pCreateInfo"].get_array();
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto& temp=arr_yCteunD[pSiEPar].emplace_object();
            return serialize_struct(temp, pCreateInfo[pSiEPar]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=boost::json::array();
            return; }json["pInstance"]=boost::json::array(1);
        auto& arr_GanofFb=json["pInstance"].get_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        }();


        json["stream_type"]=VKCREATEINSTANCE;
        writeToConn(json);
    }

    void handle_vkDestroyInstance(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyInstance call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyInstance)get_instance_proc_addr(parent,"vkDestroyInstance");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyInstance)get_device_proc_addr(parent,"vkDestroyInstance");
    }  
    
{
call_function(instance, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYINSTANCE;
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDevices(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceCount;
[&](){
            if (json["pPhysicalDeviceCount"].get_array().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }pPhysicalDeviceCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].get_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){
            if (arr_ngpFKeB[TRqNryD].is_uint64()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_uint64());
            }else if (arr_ngpFKeB[TRqNryD].is_int64()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_int64());
            }else{
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_double());
            }
            }();
        }
        }();
VkPhysicalDevice* pPhysicalDevices;
[&](){
            if (json["pPhysicalDevices"].get_array().size()==0){
                pPhysicalDevices=NULL;
            return; }pPhysicalDevices=(VkPhysicalDevice*)malloc(*pPhysicalDeviceCount*sizeof(VkPhysicalDevice));
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].get_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();

    PFN_vkEnumeratePhysicalDevices call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDevices)get_instance_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDevices)get_device_proc_addr(parent,"vkEnumeratePhysicalDevices");
    }  
    
VkResult  result;
{
result=call_function(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=boost::json::array();
            return; }json["pPhysicalDeviceCount"]=boost::json::array(1);
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].get_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=pPhysicalDeviceCount[TRqNryD];}();
        }
        }();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=boost::json::array();
            return; }json["pPhysicalDevices"]=boost::json::array(*pPhysicalDeviceCount);
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].get_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        }();


        json["stream_type"]=VKENUMERATEPHYSICALDEVICES;
        writeToConn(json);
    }

    void handle_vkGetDeviceProcAddr(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 char* pName;
[&](){
            if (json["pName"].get_array().size()==0){
                pName=NULL;
            return; }pName=(char*)malloc(json["pName"].get_array().size()*sizeof(char));
        auto& arr_OBaQazs=json["pName"].get_array();
        for(int eoosrrl=0; eoosrrl < json["pName"].get_array().size(); eoosrrl++){
            [&](){
            if (arr_OBaQazs[eoosrrl].is_uint64()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_uint64());
            }else if (arr_OBaQazs[eoosrrl].is_int64()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_int64());
            }else{
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_double());
            }
            }();
        }
        }();

    PFN_vkGetDeviceProcAddr call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceProcAddr)get_instance_proc_addr(parent,"vkGetDeviceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceProcAddr)get_device_proc_addr(parent,"vkGetDeviceProcAddr");
    }  
    
PFN_vkVoidFunction  result;
{
result=call_function(device, pName);
}
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }json["pName"]=boost::json::array(strlen(pName)+1);
        auto& arr_XCtfitt=json["pName"].get_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();


        json["stream_type"]=VKGETDEVICEPROCADDR;
        writeToConn(json);
    }

    void handle_vkGetInstanceProcAddr(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 char* pName;
[&](){
            if (json["pName"].get_array().size()==0){
                pName=NULL;
            return; }pName=(char*)malloc(json["pName"].get_array().size()*sizeof(char));
        auto& arr_OBaQazs=json["pName"].get_array();
        for(int eoosrrl=0; eoosrrl < json["pName"].get_array().size(); eoosrrl++){
            [&](){
            if (arr_OBaQazs[eoosrrl].is_uint64()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_uint64());
            }else if (arr_OBaQazs[eoosrrl].is_int64()){
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_int64());
            }else{
                pName[eoosrrl]=static_cast<char>(arr_OBaQazs[eoosrrl].get_double());
            }
            }();
        }
        }();

    PFN_vkGetInstanceProcAddr call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetInstanceProcAddr)get_instance_proc_addr(parent,"vkGetInstanceProcAddr");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetInstanceProcAddr)get_device_proc_addr(parent,"vkGetInstanceProcAddr");
    }  
    
PFN_vkVoidFunction  result;
{
result=call_function(instance, pName);
}
debug_printf("Getting %s\n",pName);
json.clear();
json["result"]=(uintptr_t)result;
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }json["pName"]=boost::json::array(strlen(pName)+1);
        auto& arr_XCtfitt=json["pName"].get_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();


        json["stream_type"]=VKGETINSTANCEPROCADDR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties*)malloc(1*sizeof(VkPhysicalDeviceProperties));
        auto& arr_rSttUuQ=json["pProperties"].get_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].get_object();
            deserialize_struct(temp,pProperties[RBAofpr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_rSttUuQ=json["pProperties"].get_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].emplace_object();
            return serialize_struct(temp, pProperties[RBAofpr]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].get_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_uint64());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_int64());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_double());
            }
            }();
        }
        }();
VkQueueFamilyProperties* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].get_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties));
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].get_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].get_object();
            deserialize_struct(temp,pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }json["pQueueFamilyPropertyCount"]=boost::json::array(1);
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }json["pQueueFamilyProperties"]=boost::json::array(*pQueueFamilyPropertyCount);
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].get_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].get_array().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties));
        auto& arr_cVJWqPt=json["pMemoryProperties"].get_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].get_object();
            deserialize_struct(temp,pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }json["pMemoryProperties"]=boost::json::array(1);
        auto& arr_cVJWqPt=json["pMemoryProperties"].get_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].emplace_object();
            return serialize_struct(temp, pMemoryProperties[iqfYjRc]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures* pFeatures;
[&](){
            if (json["pFeatures"].get_array().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures*)malloc(1*sizeof(VkPhysicalDeviceFeatures));
        auto& arr_MNJcbZO=json["pFeatures"].get_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].get_object();
            deserialize_struct(temp,pFeatures[IqPoadP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }json["pFeatures"]=boost::json::array(1);
        auto& arr_MNJcbZO=json["pFeatures"].get_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].emplace_object();
            return serialize_struct(temp, pFeatures[IqPoadP]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEFEATURES;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties* pFormatProperties;
[&](){
            if (json["pFormatProperties"].get_array().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties*)malloc(1*sizeof(VkFormatProperties));
        auto& arr_ktGodop=json["pFormatProperties"].get_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].get_object();
            deserialize_struct(temp,pFormatProperties[CLkwuSw]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }json["pFormatProperties"]=boost::json::array(1);
        auto& arr_ktGodop=json["pFormatProperties"].get_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].emplace_object();
            return serialize_struct(temp, pFormatProperties[CLkwuSw]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkImageFormatProperties* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties*)malloc(1*sizeof(VkImageFormatProperties));
        auto& arr_sBgMBXU=json["pImageFormatProperties"].get_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].get_object();
            deserialize_struct(temp,pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(1);
        auto& arr_sBgMBXU=json["pImageFormatProperties"].get_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES;
        writeToConn(json);
    }

    void handle_vkCreateDevice(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkDeviceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDeviceCreateInfo*)malloc(1*sizeof(VkDeviceCreateInfo));
        auto& arr_weWBoax=json["pCreateInfo"].get_array();
        for(int JAVPgPK=0; JAVPgPK < 1; JAVPgPK++){
            [&](){
            auto& temp=arr_weWBoax[JAVPgPK].get_object();
            deserialize_struct(temp,pCreateInfo[JAVPgPK]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDevice* pDevice;
[&](){
            if (json["pDevice"].get_array().size()==0){
                pDevice=NULL;
            return; }pDevice=(VkDevice*)malloc(1*sizeof(VkDevice));
        auto& arr_WTIobJE=json["pDevice"].get_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();

    PFN_vkCreateDevice call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDevice)get_instance_proc_addr(parent,"vkCreateDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDevice)get_device_proc_addr(parent,"vkCreateDevice");
    }  
    
VkResult  result;
{

        VkDeviceCreateInfo* temp_info=pCreateInfo;

        VkDeviceCreateInfo* pCreateInfo=temp_info;

        //Instead, copy to a set, do modification, then copy it back
        
        std::set<std::string> extensions_set;
        
        for(int i=0; i< pCreateInfo->enabledExtensionCount; i++){
            extensions_set.insert(std::string(pCreateInfo->ppEnabledExtensionNames[i]));
        }
        
        extensions_set.insert(std::string(VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME));
        
        auto extensions_length=extensions_set.size();
        auto extensions_list=(char **)malloc(extensions_length*sizeof(char*));
        
        int i=0;
        for (auto& elem: extensions_set){
            extensions_list[i]=strdup(elem.c_str());
            i++;
        }
        
        for (int i=0; i< extensions_length; i++){
            debug_printf("Final extension: %s\n",extensions_list[i]);
        }

        pCreateInfo->ppEnabledExtensionNames=extensions_list;
        pCreateInfo->enabledExtensionCount=extensions_length;            
        
result=call_function(physicalDevice, pCreateInfo, pAllocator, pDevice);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TuuJAwt=json["pCreateInfo"].get_array();
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto& temp=arr_TuuJAwt[Ktbkccz].emplace_object();
            return serialize_struct(temp, pCreateInfo[Ktbkccz]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=boost::json::array();
            return; }json["pDevice"]=boost::json::array(1);
        auto& arr_WTIobJE=json["pDevice"].get_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        }();


        json["stream_type"]=VKCREATEDEVICE;
        writeToConn(json);
    }

    void handle_vkDestroyDevice(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDevice call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDevice)get_instance_proc_addr(parent,"vkDestroyDevice");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDevice)get_device_proc_addr(parent,"vkDestroyDevice");
    }  
    
{
call_function(device, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDEVICE;
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceVersion(boost::json::object& json){
    //Will only be called by the server
    
uint32_t* pApiVersion;
[&](){
            if (json["pApiVersion"].get_array().size()==0){
                pApiVersion=NULL;
            return; }pApiVersion=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_qBCKjKo=json["pApiVersion"].get_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){
            if (arr_qBCKjKo[KJjQFCs].is_uint64()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_uint64());
            }else if (arr_qBCKjKo[KJjQFCs].is_int64()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_int64());
            }else{
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_double());
            }
            }();
        }
        }();

    PFN_vkEnumerateInstanceVersion call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceVersion)get_instance_proc_addr(parent,"vkEnumerateInstanceVersion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceVersion)get_device_proc_addr(parent,"vkEnumerateInstanceVersion");
    }  
    
VkResult  result;
{
result=call_function(pApiVersion);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=boost::json::array();
            return; }json["pApiVersion"]=boost::json::array(1);
        auto& arr_qBCKjKo=json["pApiVersion"].get_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=pApiVersion[KJjQFCs];}();
        }
        }();


        json["stream_type"]=VKENUMERATEINSTANCEVERSION;
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceLayerProperties(boost::json::object& json){
    //Will only be called by the server
    
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].get_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceLayerProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceLayerProperties)get_device_proc_addr(parent,"vkEnumerateInstanceLayerProperties");
    }  
    
VkResult  result;
{
result=call_function(pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEINSTANCELAYERPROPERTIES;
        writeToConn(json);
    }

    void handle_vkEnumerateInstanceExtensionProperties(boost::json::object& json){
    //Will only be called by the server
    
 char* pLayerName;
[&](){
            if (json["pLayerName"].get_array().size()==0){
                pLayerName=NULL;
            return; }pLayerName=(char*)malloc(json["pLayerName"].get_array().size()*sizeof(char));
        auto& arr_pwIbPmt=json["pLayerName"].get_array();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].get_array().size(); ybQeduD++){
            [&](){
            if (arr_pwIbPmt[ybQeduD].is_uint64()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_uint64());
            }else if (arr_pwIbPmt[ybQeduD].is_int64()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_int64());
            }else{
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_double());
            }
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].get_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateInstanceExtensionProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateInstanceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateInstanceExtensionProperties");
    }  
    
VkResult  result;
{
result=call_function(pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }json["pLayerName"]=boost::json::array(strlen(pLayerName)+1);
        auto& arr_xWfwWBl=json["pLayerName"].get_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEINSTANCEEXTENSIONPROPERTIES;
        writeToConn(json);
    }

    void handle_vkEnumerateDeviceLayerProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkLayerProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkLayerProperties*)malloc(*pPropertyCount*sizeof(VkLayerProperties));
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].get_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceLayerProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateDeviceLayerProperties)get_device_proc_addr(parent,"vkEnumerateDeviceLayerProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEDEVICELAYERPROPERTIES;
        writeToConn(json);
    }

    void handle_vkEnumerateDeviceExtensionProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 char* pLayerName;
[&](){
            if (json["pLayerName"].get_array().size()==0){
                pLayerName=NULL;
            return; }pLayerName=(char*)malloc(json["pLayerName"].get_array().size()*sizeof(char));
        auto& arr_pwIbPmt=json["pLayerName"].get_array();
        for(int ybQeduD=0; ybQeduD < json["pLayerName"].get_array().size(); ybQeduD++){
            [&](){
            if (arr_pwIbPmt[ybQeduD].is_uint64()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_uint64());
            }else if (arr_pwIbPmt[ybQeduD].is_int64()){
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_int64());
            }else{
                pLayerName[ybQeduD]=static_cast<char>(arr_pwIbPmt[ybQeduD].get_double());
            }
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkExtensionProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkExtensionProperties*)malloc(*pPropertyCount*sizeof(VkExtensionProperties));
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].get_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

    PFN_vkEnumerateDeviceExtensionProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_instance_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumerateDeviceExtensionProperties)get_device_proc_addr(parent,"vkEnumerateDeviceExtensionProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pLayerName, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }json["pLayerName"]=boost::json::array(strlen(pLayerName)+1);
        auto& arr_xWfwWBl=json["pLayerName"].get_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEDEVICEEXTENSIONPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetDeviceQueue(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
uint32_t queueIndex;
[&](){
            if (json["queueIndex"].is_uint64()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_uint64());
            }else if (json["queueIndex"].is_int64()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_int64());
            }else{
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_double());
            }
            }();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].get_array().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceQueue)get_instance_proc_addr(parent,"vkGetDeviceQueue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceQueue)get_device_proc_addr(parent,"vkGetDeviceQueue");
    }  
    
{
call_function(device, queueFamilyIndex, queueIndex, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){json["queueIndex"]=queueIndex;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }json["pQueue"]=boost::json::array(1);
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();


        json["stream_type"]=VKGETDEVICEQUEUE;
        writeToConn(json);
    }

    void handle_vkQueueSubmit(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){
            if (json["submitCount"].is_uint64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_uint64());
            }else if (json["submitCount"].is_int64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_int64());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].get_double());
            }
            }();
 VkSubmitInfo* pSubmits;
[&](){
            if (json["pSubmits"].get_array().size()==0){
                pSubmits=NULL;
            return; }pSubmits=(VkSubmitInfo*)malloc(submitCount*sizeof(VkSubmitInfo));
        auto& arr_TcbTpKH=json["pSubmits"].get_array();
        for(int XjgvzRX=0; XjgvzRX < submitCount; XjgvzRX++){
            [&](){
            auto& temp=arr_TcbTpKH[XjgvzRX].get_object();
            deserialize_struct(temp,pSubmits[XjgvzRX]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSubmit)get_instance_proc_addr(parent,"vkQueueSubmit");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSubmit)get_device_proc_addr(parent,"vkQueueSubmit");
    }  
    
VkResult  result;
{
result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }json["pSubmits"]=boost::json::array(submitCount);
        auto& arr_kYcwgKD=json["pSubmits"].get_array();
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto& temp=arr_kYcwgKD[FrUhwZA].emplace_object();
            return serialize_struct(temp, pSubmits[FrUhwZA]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=VKQUEUESUBMIT;
        writeToConn(json);
    }

    void handle_vkQueueWaitIdle(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueWaitIdle call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueWaitIdle)get_instance_proc_addr(parent,"vkQueueWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueWaitIdle)get_device_proc_addr(parent,"vkQueueWaitIdle");
    }  
    
VkResult  result;
{
result=call_function(queue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();


        json["stream_type"]=VKQUEUEWAITIDLE;
        writeToConn(json);
    }

    void handle_vkDeviceWaitIdle(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkDeviceWaitIdle call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDeviceWaitIdle)get_instance_proc_addr(parent,"vkDeviceWaitIdle");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDeviceWaitIdle)get_device_proc_addr(parent,"vkDeviceWaitIdle");
    }  
    
VkResult  result;
{
result=call_function(device);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=VKDEVICEWAITIDLE;
        writeToConn(json);
    }

    void handle_vkAllocateMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].get_array().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkMemoryAllocateInfo*)malloc(1*sizeof(VkMemoryAllocateInfo));
        auto& arr_deRkgom=json["pAllocateInfo"].get_array();
        for(int ujZsXLJ=0; ujZsXLJ < 1; ujZsXLJ++){
            [&](){
            auto& temp=arr_deRkgom[ujZsXLJ].get_object();
            deserialize_struct(temp,pAllocateInfo[ujZsXLJ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDeviceMemory* pMemory;
[&](){
            if (json["pMemory"].get_array().size()==0){
                pMemory=NULL;
            return; }pMemory=(VkDeviceMemory*)malloc(1*sizeof(VkDeviceMemory));
        auto& arr_JqUSUSb=json["pMemory"].get_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();

    PFN_vkAllocateMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateMemory)get_instance_proc_addr(parent,"vkAllocateMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateMemory)get_device_proc_addr(parent,"vkAllocateMemory");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pAllocator, pMemory);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_NGCHnPz=json["pAllocateInfo"].get_array();
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto& temp=arr_NGCHnPz[MAXIAGO].emplace_object();
            return serialize_struct(temp, pAllocateInfo[MAXIAGO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }json["pMemory"]=boost::json::array(1);
        auto& arr_JqUSUSb=json["pMemory"].get_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        }();


        json["stream_type"]=VKALLOCATEMEMORY;
        writeToConn(json);
    }

    void handle_vkFreeMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkFreeMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeMemory)get_instance_proc_addr(parent,"vkFreeMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeMemory)get_device_proc_addr(parent,"vkFreeMemory");
    }  
    
{
call_function(device, memory, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKFREEMEMORY;
        writeToConn(json);
    }

    void handle_vkMapMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
VkMemoryMapFlags flags;
[&](){[&](){int temp_UEEqVUK;[&](){
            if (json["flags"].is_uint64()){
                temp_UEEqVUK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_UEEqVUK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_UEEqVUK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
void** ppData;
[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_syvZTtN=json["ppData"].get_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].get_array().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].get_array().size()==0){
                temp_syvZTtN=NULL;
            return; }temp_syvZTtN=(char*)malloc(size*sizeof(char));
        auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].get_array();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();

    PFN_vkMapMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMapMemory)get_instance_proc_addr(parent,"vkMapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMapMemory)get_device_proc_addr(parent,"vkMapMemory");
    }  
    
VkResult  result;
{
result=call_function(device, memory, offset, size, flags, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_syvZTtN=json["ppData"].get_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }arr_syvZTtN[weOJAdg]=boost::json::array(size);
        auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].get_array();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[weOJAdg]))[jYdchEs];}();
        }
        }();}();
        }
        }();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        json["stream_type"]=VKMAPMEMORY;
        writeToConn(json);
    }

    void handle_vkUnmapMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

    PFN_vkUnmapMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUnmapMemory)get_instance_proc_addr(parent,"vkUnmapMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUnmapMemory)get_device_proc_addr(parent,"vkUnmapMemory");
    }  
    
{
call_function(device, memory);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();


        json["stream_type"]=VKUNMAPMEMORY;
        writeToConn(json);
    }

    void handle_vkFlushMappedMemoryRanges(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){
            if (json["memoryRangeCount"].is_uint64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_uint64());
            }else if (json["memoryRangeCount"].is_int64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_int64());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_double());
            }
            }();
 VkMappedMemoryRange* pMemoryRanges;
[&](){
            if (json["pMemoryRanges"].get_array().size()==0){
                pMemoryRanges=NULL;
            return; }pMemoryRanges=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));
        auto& arr_nFHDtPn=json["pMemoryRanges"].get_array();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            auto& temp=arr_nFHDtPn[oXMPKll].get_object();
            deserialize_struct(temp,pMemoryRanges[oXMPKll]);
            }();
        }
        }();

    PFN_vkFlushMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFlushMappedMemoryRanges)get_instance_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFlushMappedMemoryRanges)get_device_proc_addr(parent,"vkFlushMappedMemoryRanges");
    }  
    
VkResult  result;
{
result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }json["pMemoryRanges"]=boost::json::array(memoryRangeCount);
        auto& arr_sKDZFVw=json["pMemoryRanges"].get_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();


        json["stream_type"]=VKFLUSHMAPPEDMEMORYRANGES;
        writeToConn(json);
    }

    void handle_vkInvalidateMappedMemoryRanges(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t memoryRangeCount;
[&](){
            if (json["memoryRangeCount"].is_uint64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_uint64());
            }else if (json["memoryRangeCount"].is_int64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_int64());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_double());
            }
            }();
 VkMappedMemoryRange* pMemoryRanges;
[&](){
            if (json["pMemoryRanges"].get_array().size()==0){
                pMemoryRanges=NULL;
            return; }pMemoryRanges=(VkMappedMemoryRange*)malloc(memoryRangeCount*sizeof(VkMappedMemoryRange));
        auto& arr_nFHDtPn=json["pMemoryRanges"].get_array();
        for(int oXMPKll=0; oXMPKll < memoryRangeCount; oXMPKll++){
            [&](){
            auto& temp=arr_nFHDtPn[oXMPKll].get_object();
            deserialize_struct(temp,pMemoryRanges[oXMPKll]);
            }();
        }
        }();

    PFN_vkInvalidateMappedMemoryRanges call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_instance_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkInvalidateMappedMemoryRanges)get_device_proc_addr(parent,"vkInvalidateMappedMemoryRanges");
    }  
    
VkResult  result;
{
result=call_function(device, memoryRangeCount, pMemoryRanges);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }json["pMemoryRanges"]=boost::json::array(memoryRangeCount);
        auto& arr_sKDZFVw=json["pMemoryRanges"].get_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();


        json["stream_type"]=VKINVALIDATEMAPPEDMEMORYRANGES;
        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryCommitment(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize* pCommittedMemoryInBytes;
[&](){
            if (json["pCommittedMemoryInBytes"].get_array().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }pCommittedMemoryInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].get_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){
            if (arr_BkHcKeY[iEYXrVv].is_uint64()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_uint64());
            }else if (arr_BkHcKeY[iEYXrVv].is_int64()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_int64());
            }else{
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_double());
            }
            }();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

    PFN_vkGetDeviceMemoryCommitment call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_instance_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMemoryCommitment)get_device_proc_addr(parent,"vkGetDeviceMemoryCommitment");
    }  
    
{
call_function(device, memory, pCommittedMemoryInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=boost::json::array();
            return; }json["pCommittedMemoryInBytes"]=boost::json::array(1);
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].get_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=pCommittedMemoryInBytes[iEYXrVv];}();}();
        }
        }();


        json["stream_type"]=VKGETDEVICEMEMORYCOMMITMENT;
        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].get_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements");
    }  
    
{
call_function(device, buffer, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();


        json["stream_type"]=VKGETBUFFERMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkBindBufferMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_uint64());
            }else if (json["memoryOffset"].is_int64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_int64());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindBufferMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindBufferMemory)get_instance_proc_addr(parent,"vkBindBufferMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindBufferMemory)get_device_proc_addr(parent,"vkBindBufferMemory");
    }  
    
VkResult  result;
{
result=call_function(device, buffer, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();


        json["stream_type"]=VKBINDBUFFERMEMORY;
        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkMemoryRequirements* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements*)malloc(1*sizeof(VkMemoryRequirements));
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].get_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageMemoryRequirements)get_device_proc_addr(parent,"vkGetImageMemoryRequirements");
    }  
    
{
call_function(device, image, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGEMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkBindImageMemory(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
VkDeviceSize memoryOffset;
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_uint64());
            }else if (json["memoryOffset"].is_int64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_int64());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();

    PFN_vkBindImageMemory call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindImageMemory)get_instance_proc_addr(parent,"vkBindImageMemory");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindImageMemory)get_device_proc_addr(parent,"vkBindImageMemory");
    }  
    
VkResult  result;
{
result=call_function(device, image, memory, memoryOffset);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();


        json["stream_type"]=VKBINDIMAGEMEMORY;
        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements));
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].get_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements");
    }  
    
{
call_function(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].get_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkSparseImageFormatProperties* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties));
        auto& arr_jINYdYP=json["pProperties"].get_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].get_object();
            deserialize_struct(temp,pProperties[BOLcXca]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties");
    }  
    
{
call_function(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_jINYdYP=json["pProperties"].get_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].emplace_object();
            return serialize_struct(temp, pProperties[BOLcXca]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES;
        writeToConn(json);
    }

    void handle_vkQueueBindSparse(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();
 VkBindSparseInfo* pBindInfo;
[&](){
            if (json["pBindInfo"].get_array().size()==0){
                pBindInfo=NULL;
            return; }pBindInfo=(VkBindSparseInfo*)malloc(bindInfoCount*sizeof(VkBindSparseInfo));
        auto& arr_yoxMwfS=json["pBindInfo"].get_array();
        for(int dbkPgzh=0; dbkPgzh < bindInfoCount; dbkPgzh++){
            [&](){
            auto& temp=arr_yoxMwfS[dbkPgzh].get_object();
            deserialize_struct(temp,pBindInfo[dbkPgzh]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueBindSparse call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueBindSparse)get_instance_proc_addr(parent,"vkQueueBindSparse");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueBindSparse)get_device_proc_addr(parent,"vkQueueBindSparse");
    }  
    
VkResult  result;
{
result=call_function(queue, bindInfoCount, pBindInfo, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=boost::json::array();
            return; }json["pBindInfo"]=boost::json::array(bindInfoCount);
        auto& arr_eUGJCxJ=json["pBindInfo"].get_array();
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto& temp=arr_eUGJCxJ[ujBkVap].emplace_object();
            return serialize_struct(temp, pBindInfo[ujBkVap]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=VKQUEUEBINDSPARSE;
        writeToConn(json);
    }

    void handle_vkCreateFence(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFenceCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkFenceCreateInfo*)malloc(1*sizeof(VkFenceCreateInfo));
        auto& arr_cSMNytM=json["pCreateInfo"].get_array();
        for(int JOkcmyM=0; JOkcmyM < 1; JOkcmyM++){
            [&](){
            auto& temp=arr_cSMNytM[JOkcmyM].get_object();
            deserialize_struct(temp,pCreateInfo[JOkcmyM]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkCreateFence call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateFence)get_instance_proc_addr(parent,"vkCreateFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateFence)get_device_proc_addr(parent,"vkCreateFence");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_qbBwXza=json["pCreateInfo"].get_array();
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto& temp=arr_qbBwXza[kPSKeJY].emplace_object();
            return serialize_struct(temp, pCreateInfo[kPSKeJY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        json["stream_type"]=VKCREATEFENCE;
        writeToConn(json);
    }

    void handle_vkDestroyFence(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyFence call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyFence)get_instance_proc_addr(parent,"vkDestroyFence");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyFence)get_device_proc_addr(parent,"vkDestroyFence");
    }  
    
{
call_function(device, fence, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYFENCE;
        writeToConn(json);
    }

    void handle_vkResetFences(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){
            if (json["fenceCount"].is_uint64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_uint64());
            }else if (json["fenceCount"].is_int64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_int64());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_double());
            }
            }();
 VkFence* pFences;
[&](){
            if (json["pFences"].get_array().size()==0){
                pFences=NULL;
            return; }pFences=(VkFence*)malloc(fenceCount*sizeof(VkFence));
        auto& arr_nntmqqP=json["pFences"].get_array();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], pFences[hksYnfK]);}();
        }
        }();

    PFN_vkResetFences call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetFences)get_instance_proc_addr(parent,"vkResetFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetFences)get_device_proc_addr(parent,"vkResetFences");
    }  
    
VkResult  result;
{
result=call_function(device, fenceCount, pFences);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }json["pFences"]=boost::json::array(fenceCount);
        auto& arr_UUllwqV=json["pFences"].get_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();


        json["stream_type"]=VKRESETFENCES;
        writeToConn(json);
    }

    void handle_vkGetFenceStatus(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkGetFenceStatus call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFenceStatus)get_instance_proc_addr(parent,"vkGetFenceStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFenceStatus)get_device_proc_addr(parent,"vkGetFenceStatus");
    }  
    
VkResult  result;
{
result=call_function(device, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=VKGETFENCESTATUS;
        writeToConn(json);
    }

    void handle_vkWaitForFences(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t fenceCount;
[&](){
            if (json["fenceCount"].is_uint64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_uint64());
            }else if (json["fenceCount"].is_int64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_int64());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_double());
            }
            }();
 VkFence* pFences;
[&](){
            if (json["pFences"].get_array().size()==0){
                pFences=NULL;
            return; }pFences=(VkFence*)malloc(fenceCount*sizeof(VkFence));
        auto& arr_nntmqqP=json["pFences"].get_array();
        for(int hksYnfK=0; hksYnfK < fenceCount; hksYnfK++){
            [&](){deserialize_VkFence(arr_nntmqqP[hksYnfK], pFences[hksYnfK]);}();
        }
        }();
VkBool32 waitAll;
[&](){uint32_t temp_pqKsrTL;[&](){
            if (json["waitAll"].is_uint64()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_uint64());
            }else if (json["waitAll"].is_int64()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_int64());
            }else{
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_double());
            }
            }();waitAll=(VkBool32)temp_pqKsrTL;}();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();

    PFN_vkWaitForFences call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitForFences)get_instance_proc_addr(parent,"vkWaitForFences");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitForFences)get_device_proc_addr(parent,"vkWaitForFences");
    }  
    
VkResult  result;
{
result=call_function(device, fenceCount, pFences, waitAll, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }json["pFences"]=boost::json::array(fenceCount);
        auto& arr_UUllwqV=json["pFences"].get_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
[&](){[&](){json["waitAll"]=waitAll;}();}();
[&](){json["timeout"]=timeout;}();

            if (result!=VK_TIMEOUT){
                SyncAll();
            }
            


        json["stream_type"]=VKWAITFORFENCES;
        writeToConn(json);
    }

    void handle_vkCreateSemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSemaphoreCreateInfo*)malloc(1*sizeof(VkSemaphoreCreateInfo));
        auto& arr_FJDFSKM=json["pCreateInfo"].get_array();
        for(int aGXpPVQ=0; aGXpPVQ < 1; aGXpPVQ++){
            [&](){
            auto& temp=arr_FJDFSKM[aGXpPVQ].get_object();
            deserialize_struct(temp,pCreateInfo[aGXpPVQ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSemaphore* pSemaphore;
[&](){
            if (json["pSemaphore"].get_array().size()==0){
                pSemaphore=NULL;
            return; }pSemaphore=(VkSemaphore*)malloc(1*sizeof(VkSemaphore));
        auto& arr_rvNHvxY=json["pSemaphore"].get_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();

    PFN_vkCreateSemaphore call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSemaphore)get_instance_proc_addr(parent,"vkCreateSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSemaphore)get_device_proc_addr(parent,"vkCreateSemaphore");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSemaphore);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_hQVwpIP=json["pCreateInfo"].get_array();
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto& temp=arr_hQVwpIP[TzTYDbe].emplace_object();
            return serialize_struct(temp, pCreateInfo[TzTYDbe]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=boost::json::array();
            return; }json["pSemaphore"]=boost::json::array(1);
        auto& arr_rvNHvxY=json["pSemaphore"].get_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        }();


        json["stream_type"]=VKCREATESEMAPHORE;
        writeToConn(json);
    }

    void handle_vkDestroySemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySemaphore call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySemaphore)get_instance_proc_addr(parent,"vkDestroySemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySemaphore)get_device_proc_addr(parent,"vkDestroySemaphore");
    }  
    
{
call_function(device, semaphore, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSEMAPHORE;
        writeToConn(json);
    }

    void handle_vkCreateEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkEventCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkEventCreateInfo*)malloc(1*sizeof(VkEventCreateInfo));
        auto& arr_cHgRyNm=json["pCreateInfo"].get_array();
        for(int gikyLcY=0; gikyLcY < 1; gikyLcY++){
            [&](){
            auto& temp=arr_cHgRyNm[gikyLcY].get_object();
            deserialize_struct(temp,pCreateInfo[gikyLcY]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkEvent* pEvent;
[&](){
            if (json["pEvent"].get_array().size()==0){
                pEvent=NULL;
            return; }pEvent=(VkEvent*)malloc(1*sizeof(VkEvent));
        auto& arr_edObbrc=json["pEvent"].get_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();

    PFN_vkCreateEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateEvent)get_instance_proc_addr(parent,"vkCreateEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateEvent)get_device_proc_addr(parent,"vkCreateEvent");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pEvent);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_wqWioqo=json["pCreateInfo"].get_array();
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto& temp=arr_wqWioqo[ThfQKZW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ThfQKZW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=boost::json::array();
            return; }json["pEvent"]=boost::json::array(1);
        auto& arr_edObbrc=json["pEvent"].get_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        }();


        json["stream_type"]=VKCREATEEVENT;
        writeToConn(json);
    }

    void handle_vkDestroyEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyEvent)get_instance_proc_addr(parent,"vkDestroyEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyEvent)get_device_proc_addr(parent,"vkDestroyEvent");
    }  
    
{
call_function(device, event, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYEVENT;
        writeToConn(json);
    }

    void handle_vkGetEventStatus(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkGetEventStatus call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetEventStatus)get_instance_proc_addr(parent,"vkGetEventStatus");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetEventStatus)get_device_proc_addr(parent,"vkGetEventStatus");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=VKGETEVENTSTATUS;
        writeToConn(json);
    }

    void handle_vkSetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkSetEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetEvent)get_instance_proc_addr(parent,"vkSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetEvent)get_device_proc_addr(parent,"vkSetEvent");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=VKSETEVENT;
        writeToConn(json);
    }

    void handle_vkResetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();

    PFN_vkResetEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetEvent)get_instance_proc_addr(parent,"vkResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetEvent)get_device_proc_addr(parent,"vkResetEvent");
    }  
    
VkResult  result;
{
result=call_function(device, event);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();


        json["stream_type"]=VKRESETEVENT;
        writeToConn(json);
    }

    void handle_vkCreateQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkQueryPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkQueryPoolCreateInfo*)malloc(1*sizeof(VkQueryPoolCreateInfo));
        auto& arr_OFyRSSf=json["pCreateInfo"].get_array();
        for(int HxljsQx=0; HxljsQx < 1; HxljsQx++){
            [&](){
            auto& temp=arr_OFyRSSf[HxljsQx].get_object();
            deserialize_struct(temp,pCreateInfo[HxljsQx]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkQueryPool* pQueryPool;
[&](){
            if (json["pQueryPool"].get_array().size()==0){
                pQueryPool=NULL;
            return; }pQueryPool=(VkQueryPool*)malloc(1*sizeof(VkQueryPool));
        auto& arr_uEjfPmz=json["pQueryPool"].get_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();

    PFN_vkCreateQueryPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateQueryPool)get_instance_proc_addr(parent,"vkCreateQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateQueryPool)get_device_proc_addr(parent,"vkCreateQueryPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pQueryPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_AOuTZQo=json["pCreateInfo"].get_array();
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto& temp=arr_AOuTZQo[SvYxRUl].emplace_object();
            return serialize_struct(temp, pCreateInfo[SvYxRUl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=boost::json::array();
            return; }json["pQueryPool"]=boost::json::array(1);
        auto& arr_uEjfPmz=json["pQueryPool"].get_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        }();


        json["stream_type"]=VKCREATEQUERYPOOL;
        writeToConn(json);
    }

    void handle_vkDestroyQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyQueryPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyQueryPool)get_instance_proc_addr(parent,"vkDestroyQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyQueryPool)get_device_proc_addr(parent,"vkDestroyQueryPool");
    }  
    
{
call_function(device, queryPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYQUERYPOOL;
        writeToConn(json);
    }

    void handle_vkGetQueryPoolResults(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_int64());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkGetQueryPoolResults call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueryPoolResults)get_instance_proc_addr(parent,"vkGetQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueryPoolResults)get_device_proc_addr(parent,"vkGetQueryPoolResults");
    }  
    
VkResult  result;
{
result=call_function(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKGETQUERYPOOLRESULTS;
        writeToConn(json);
    }

    void handle_vkResetQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();

    PFN_vkResetQueryPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetQueryPool)get_instance_proc_addr(parent,"vkResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetQueryPool)get_device_proc_addr(parent,"vkResetQueryPool");
    }  
    
{
call_function(device, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();


        json["stream_type"]=VKRESETQUERYPOOL;
        writeToConn(json);
    }

    void handle_vkCreateBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkBufferCreateInfo*)malloc(1*sizeof(VkBufferCreateInfo));
        auto& arr_vAtICCQ=json["pCreateInfo"].get_array();
        for(int kBYZDCM=0; kBYZDCM < 1; kBYZDCM++){
            [&](){
            auto& temp=arr_vAtICCQ[kBYZDCM].get_object();
            deserialize_struct(temp,pCreateInfo[kBYZDCM]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkBuffer* pBuffer;
[&](){
            if (json["pBuffer"].get_array().size()==0){
                pBuffer=NULL;
            return; }pBuffer=(VkBuffer*)malloc(1*sizeof(VkBuffer));
        auto& arr_cIWQmjJ=json["pBuffer"].get_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();

    PFN_vkCreateBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateBuffer)get_instance_proc_addr(parent,"vkCreateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateBuffer)get_device_proc_addr(parent,"vkCreateBuffer");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_YapwvbL=json["pCreateInfo"].get_array();
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto& temp=arr_YapwvbL[XkzMxbI].emplace_object();
            return serialize_struct(temp, pCreateInfo[XkzMxbI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=boost::json::array();
            return; }json["pBuffer"]=boost::json::array(1);
        auto& arr_cIWQmjJ=json["pBuffer"].get_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        }();


        json["stream_type"]=VKCREATEBUFFER;
        writeToConn(json);
    }

    void handle_vkDestroyBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyBuffer)get_instance_proc_addr(parent,"vkDestroyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyBuffer)get_device_proc_addr(parent,"vkDestroyBuffer");
    }  
    
{
call_function(device, buffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYBUFFER;
        writeToConn(json);
    }

    void handle_vkCreateBufferView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferViewCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkBufferViewCreateInfo*)malloc(1*sizeof(VkBufferViewCreateInfo));
        auto& arr_MSlizKJ=json["pCreateInfo"].get_array();
        for(int bEIfqcJ=0; bEIfqcJ < 1; bEIfqcJ++){
            [&](){
            auto& temp=arr_MSlizKJ[bEIfqcJ].get_object();
            deserialize_struct(temp,pCreateInfo[bEIfqcJ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkBufferView* pView;
[&](){
            if (json["pView"].get_array().size()==0){
                pView=NULL;
            return; }pView=(VkBufferView*)malloc(1*sizeof(VkBufferView));
        auto& arr_FoBLnTF=json["pView"].get_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();

    PFN_vkCreateBufferView call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateBufferView)get_instance_proc_addr(parent,"vkCreateBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateBufferView)get_device_proc_addr(parent,"vkCreateBufferView");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_SvrkcZl=json["pCreateInfo"].get_array();
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto& temp=arr_SvrkcZl[cSdiRJj].emplace_object();
            return serialize_struct(temp, pCreateInfo[cSdiRJj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }json["pView"]=boost::json::array(1);
        auto& arr_FoBLnTF=json["pView"].get_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        }();


        json["stream_type"]=VKCREATEBUFFERVIEW;
        writeToConn(json);
    }

    void handle_vkDestroyBufferView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkBufferView bufferView;
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyBufferView call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyBufferView)get_instance_proc_addr(parent,"vkDestroyBufferView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyBufferView)get_device_proc_addr(parent,"vkDestroyBufferView");
    }  
    
{
call_function(device, bufferView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYBUFFERVIEW;
        writeToConn(json);
    }

    void handle_vkCreateImage(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto& arr_yCiQzQk=json["pCreateInfo"].get_array();
        for(int QiYISUj=0; QiYISUj < 1; QiYISUj++){
            [&](){
            auto& temp=arr_yCiQzQk[QiYISUj].get_object();
            deserialize_struct(temp,pCreateInfo[QiYISUj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkImage* pImage;
[&](){
            if (json["pImage"].get_array().size()==0){
                pImage=NULL;
            return; }pImage=(VkImage*)malloc(1*sizeof(VkImage));
        auto& arr_YGmHGGw=json["pImage"].get_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();

    PFN_vkCreateImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateImage)get_instance_proc_addr(parent,"vkCreateImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateImage)get_device_proc_addr(parent,"vkCreateImage");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pImage);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TpPCnAy=json["pCreateInfo"].get_array();
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto& temp=arr_TpPCnAy[pRwmwcF].emplace_object();
            return serialize_struct(temp, pCreateInfo[pRwmwcF]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pImage==NULL){
                json["pImage"]=boost::json::array();
            return; }json["pImage"]=boost::json::array(1);
        auto& arr_YGmHGGw=json["pImage"].get_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        }();


        json["stream_type"]=VKCREATEIMAGE;
        writeToConn(json);
    }

    void handle_vkDestroyImage(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyImage)get_instance_proc_addr(parent,"vkDestroyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyImage)get_device_proc_addr(parent,"vkDestroyImage");
    }  
    
{
call_function(device, image, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYIMAGE;
        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkImageSubresource* pSubresource;
[&](){
            if (json["pSubresource"].get_array().size()==0){
                pSubresource=NULL;
            return; }pSubresource=(VkImageSubresource*)malloc(1*sizeof(VkImageSubresource));
        auto& arr_zbWgqCd=json["pSubresource"].get_array();
        for(int ioHtFIy=0; ioHtFIy < 1; ioHtFIy++){
            [&](){
            auto& temp=arr_zbWgqCd[ioHtFIy].get_object();
            deserialize_struct(temp,pSubresource[ioHtFIy]);
            }();
        }
        }();
VkSubresourceLayout* pLayout;
[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout*)malloc(1*sizeof(VkSubresourceLayout));
        auto& arr_JAFsVvP=json["pLayout"].get_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].get_object();
            deserialize_struct(temp,pLayout[jGHmbXh]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSubresourceLayout)get_device_proc_addr(parent,"vkGetImageSubresourceLayout");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }json["pSubresource"]=boost::json::array(1);
        auto& arr_bNRLlpX=json["pSubresource"].get_array();
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto& temp=arr_bNRLlpX[trrMzRH].emplace_object();
            return serialize_struct(temp, pSubresource[trrMzRH]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JAFsVvP=json["pLayout"].get_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].emplace_object();
            return serialize_struct(temp, pLayout[jGHmbXh]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGESUBRESOURCELAYOUT;
        writeToConn(json);
    }

    void handle_vkCreateImageView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkImageViewCreateInfo*)malloc(1*sizeof(VkImageViewCreateInfo));
        auto& arr_JenFyWd=json["pCreateInfo"].get_array();
        for(int RiehwsS=0; RiehwsS < 1; RiehwsS++){
            [&](){
            auto& temp=arr_JenFyWd[RiehwsS].get_object();
            deserialize_struct(temp,pCreateInfo[RiehwsS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkImageView* pView;
[&](){
            if (json["pView"].get_array().size()==0){
                pView=NULL;
            return; }pView=(VkImageView*)malloc(1*sizeof(VkImageView));
        auto& arr_GCwrdnq=json["pView"].get_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();

    PFN_vkCreateImageView call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateImageView)get_instance_proc_addr(parent,"vkCreateImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateImageView)get_device_proc_addr(parent,"vkCreateImageView");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pView);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TYfFrkP=json["pCreateInfo"].get_array();
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto& temp=arr_TYfFrkP[HNOogbj].emplace_object();
            return serialize_struct(temp, pCreateInfo[HNOogbj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }json["pView"]=boost::json::array(1);
        auto& arr_GCwrdnq=json["pView"].get_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        }();


        json["stream_type"]=VKCREATEIMAGEVIEW;
        writeToConn(json);
    }

    void handle_vkDestroyImageView(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyImageView call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyImageView)get_instance_proc_addr(parent,"vkDestroyImageView");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyImageView)get_device_proc_addr(parent,"vkDestroyImageView");
    }  
    
{
call_function(device, imageView, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYIMAGEVIEW;
        writeToConn(json);
    }

    void handle_vkCreateShaderModule(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkShaderModuleCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));
        auto& arr_GtIQgds=json["pCreateInfo"].get_array();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            auto& temp=arr_GtIQgds[PbmosKP].get_object();
            deserialize_struct(temp,pCreateInfo[PbmosKP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkShaderModule* pShaderModule;
[&](){
            if (json["pShaderModule"].get_array().size()==0){
                pShaderModule=NULL;
            return; }pShaderModule=(VkShaderModule*)malloc(1*sizeof(VkShaderModule));
        auto& arr_FaKUyxw=json["pShaderModule"].get_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();

    PFN_vkCreateShaderModule call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateShaderModule)get_instance_proc_addr(parent,"vkCreateShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateShaderModule)get_device_proc_addr(parent,"vkCreateShaderModule");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pShaderModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iSZUILM=json["pCreateInfo"].get_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=boost::json::array();
            return; }json["pShaderModule"]=boost::json::array(1);
        auto& arr_FaKUyxw=json["pShaderModule"].get_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        }();


        json["stream_type"]=VKCREATESHADERMODULE;
        writeToConn(json);
    }

    void handle_vkDestroyShaderModule(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyShaderModule call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyShaderModule)get_instance_proc_addr(parent,"vkDestroyShaderModule");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyShaderModule)get_device_proc_addr(parent,"vkDestroyShaderModule");
    }  
    
{
call_function(device, shaderModule, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSHADERMODULE;
        writeToConn(json);
    }

    void handle_vkCreatePipelineCache(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineCacheCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPipelineCacheCreateInfo*)malloc(1*sizeof(VkPipelineCacheCreateInfo));
        auto& arr_tPFcwyz=json["pCreateInfo"].get_array();
        for(int ccOebrR=0; ccOebrR < 1; ccOebrR++){
            [&](){
            auto& temp=arr_tPFcwyz[ccOebrR].get_object();
            deserialize_struct(temp,pCreateInfo[ccOebrR]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipelineCache* pPipelineCache;
[&](){
            if (json["pPipelineCache"].get_array().size()==0){
                pPipelineCache=NULL;
            return; }pPipelineCache=(VkPipelineCache*)malloc(1*sizeof(VkPipelineCache));
        auto& arr_mogHiwV=json["pPipelineCache"].get_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();

    PFN_vkCreatePipelineCache call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePipelineCache)get_instance_proc_addr(parent,"vkCreatePipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePipelineCache)get_device_proc_addr(parent,"vkCreatePipelineCache");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPipelineCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_wTXOYfz=json["pCreateInfo"].get_array();
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto& temp=arr_wTXOYfz[iWdFkeP].emplace_object();
            return serialize_struct(temp, pCreateInfo[iWdFkeP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=boost::json::array();
            return; }json["pPipelineCache"]=boost::json::array(1);
        auto& arr_mogHiwV=json["pPipelineCache"].get_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        }();


        json["stream_type"]=VKCREATEPIPELINECACHE;
        writeToConn(json);
    }

    void handle_vkDestroyPipelineCache(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipelineCache call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipelineCache)get_instance_proc_addr(parent,"vkDestroyPipelineCache");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipelineCache)get_device_proc_addr(parent,"vkDestroyPipelineCache");
    }  
    
{
call_function(device, pipelineCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYPIPELINECACHE;
        writeToConn(json);
    }

    void handle_vkGetPipelineCacheData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetPipelineCacheData call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineCacheData)get_instance_proc_addr(parent,"vkGetPipelineCacheData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineCacheData)get_device_proc_addr(parent,"vkGetPipelineCacheData");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETPIPELINECACHEDATA;
        writeToConn(json);
    }

    void handle_vkMergePipelineCaches(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache dstCache;
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){
            if (json["srcCacheCount"].is_uint64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_uint64());
            }else if (json["srcCacheCount"].is_int64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_int64());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_double());
            }
            }();
 VkPipelineCache* pSrcCaches;
[&](){
            if (json["pSrcCaches"].get_array().size()==0){
                pSrcCaches=NULL;
            return; }pSrcCaches=(VkPipelineCache*)malloc(srcCacheCount*sizeof(VkPipelineCache));
        auto& arr_criceHb=json["pSrcCaches"].get_array();
        for(int TBfRFpH=0; TBfRFpH < srcCacheCount; TBfRFpH++){
            [&](){deserialize_VkPipelineCache(arr_criceHb[TBfRFpH], pSrcCaches[TBfRFpH]);}();
        }
        }();

    PFN_vkMergePipelineCaches call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMergePipelineCaches)get_instance_proc_addr(parent,"vkMergePipelineCaches");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMergePipelineCaches)get_device_proc_addr(parent,"vkMergePipelineCaches");
    }  
    
VkResult  result;
{
result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }json["pSrcCaches"]=boost::json::array(srcCacheCount);
        auto& arr_DmqfOOL=json["pSrcCaches"].get_array();
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        }();


        json["stream_type"]=VKMERGEPIPELINECACHES;
        writeToConn(json);
    }

    void handle_vkCreateGraphicsPipelines(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();
 VkGraphicsPipelineCreateInfo* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkGraphicsPipelineCreateInfo*)malloc(createInfoCount*sizeof(VkGraphicsPipelineCreateInfo));
        auto& arr_bKkRMWv=json["pCreateInfos"].get_array();
        for(int kSHyOYR=0; kSHyOYR < createInfoCount; kSHyOYR++){
            [&](){
            auto& temp=arr_bKkRMWv[kSHyOYR].get_object();
            deserialize_struct(temp,pCreateInfos[kSHyOYR]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateGraphicsPipelines call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateGraphicsPipelines)get_instance_proc_addr(parent,"vkCreateGraphicsPipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateGraphicsPipelines)get_device_proc_addr(parent,"vkCreateGraphicsPipelines");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_juQDvLY=json["pCreateInfos"].get_array();
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto& temp=arr_juQDvLY[wqGiARr].emplace_object();
            return serialize_struct(temp, pCreateInfos[wqGiARr]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        json["stream_type"]=VKCREATEGRAPHICSPIPELINES;
        writeToConn(json);
    }

    void handle_vkCreateComputePipelines(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();
 VkComputePipelineCreateInfo* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkComputePipelineCreateInfo*)malloc(createInfoCount*sizeof(VkComputePipelineCreateInfo));
        auto& arr_THdSKsK=json["pCreateInfos"].get_array();
        for(int qnUOnCC=0; qnUOnCC < createInfoCount; qnUOnCC++){
            [&](){
            auto& temp=arr_THdSKsK[qnUOnCC].get_object();
            deserialize_struct(temp,pCreateInfos[qnUOnCC]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateComputePipelines call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateComputePipelines)get_instance_proc_addr(parent,"vkCreateComputePipelines");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateComputePipelines)get_device_proc_addr(parent,"vkCreateComputePipelines");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_eqiaDas=json["pCreateInfos"].get_array();
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto& temp=arr_eqiaDas[NsFJrJk].emplace_object();
            return serialize_struct(temp, pCreateInfos[NsFJrJk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        json["stream_type"]=VKCREATECOMPUTEPIPELINES;
        writeToConn(json);
    }

    void handle_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderpass;
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
VkExtent2D* pMaxWorkgroupSize;
[&](){
            if (json["pMaxWorkgroupSize"].get_array().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }pMaxWorkgroupSize=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].get_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].get_object();
            deserialize_struct(temp,pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();

    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_instance_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)get_device_proc_addr(parent,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
    }  
    
VkResult  result;
{
result=call_function(device, renderpass, pMaxWorkgroupSize);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=boost::json::array();
            return; }json["pMaxWorkgroupSize"]=boost::json::array(1);
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].get_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].emplace_object();
            return serialize_struct(temp, pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI;
        writeToConn(json);
    }

    void handle_vkDestroyPipeline(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipeline call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipeline)get_instance_proc_addr(parent,"vkDestroyPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipeline)get_device_proc_addr(parent,"vkDestroyPipeline");
    }  
    
{
call_function(device, pipeline, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYPIPELINE;
        writeToConn(json);
    }

    void handle_vkCreatePipelineLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPipelineLayoutCreateInfo*)malloc(1*sizeof(VkPipelineLayoutCreateInfo));
        auto& arr_oLPmvyU=json["pCreateInfo"].get_array();
        for(int wpAzccn=0; wpAzccn < 1; wpAzccn++){
            [&](){
            auto& temp=arr_oLPmvyU[wpAzccn].get_object();
            deserialize_struct(temp,pCreateInfo[wpAzccn]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipelineLayout* pPipelineLayout;
[&](){
            if (json["pPipelineLayout"].get_array().size()==0){
                pPipelineLayout=NULL;
            return; }pPipelineLayout=(VkPipelineLayout*)malloc(1*sizeof(VkPipelineLayout));
        auto& arr_NheDZho=json["pPipelineLayout"].get_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();

    PFN_vkCreatePipelineLayout call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePipelineLayout)get_instance_proc_addr(parent,"vkCreatePipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePipelineLayout)get_device_proc_addr(parent,"vkCreatePipelineLayout");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPipelineLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iyZpkhm=json["pCreateInfo"].get_array();
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto& temp=arr_iyZpkhm[AdWYCmn].emplace_object();
            return serialize_struct(temp, pCreateInfo[AdWYCmn]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=boost::json::array();
            return; }json["pPipelineLayout"]=boost::json::array(1);
        auto& arr_NheDZho=json["pPipelineLayout"].get_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        }();


        json["stream_type"]=VKCREATEPIPELINELAYOUT;
        writeToConn(json);
    }

    void handle_vkDestroyPipelineLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineLayout pipelineLayout;
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPipelineLayout call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPipelineLayout)get_instance_proc_addr(parent,"vkDestroyPipelineLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPipelineLayout)get_device_proc_addr(parent,"vkDestroyPipelineLayout");
    }  
    
{
call_function(device, pipelineLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYPIPELINELAYOUT;
        writeToConn(json);
    }

    void handle_vkCreateSampler(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSamplerCreateInfo*)malloc(1*sizeof(VkSamplerCreateInfo));
        auto& arr_tMhVauC=json["pCreateInfo"].get_array();
        for(int yZfhKUj=0; yZfhKUj < 1; yZfhKUj++){
            [&](){
            auto& temp=arr_tMhVauC[yZfhKUj].get_object();
            deserialize_struct(temp,pCreateInfo[yZfhKUj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSampler* pSampler;
[&](){
            if (json["pSampler"].get_array().size()==0){
                pSampler=NULL;
            return; }pSampler=(VkSampler*)malloc(1*sizeof(VkSampler));
        auto& arr_nEROYrx=json["pSampler"].get_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();

    PFN_vkCreateSampler call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSampler)get_instance_proc_addr(parent,"vkCreateSampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSampler)get_device_proc_addr(parent,"vkCreateSampler");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSampler);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_xWlqrLm=json["pCreateInfo"].get_array();
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto& temp=arr_xWlqrLm[yMsdBPh].emplace_object();
            return serialize_struct(temp, pCreateInfo[yMsdBPh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=boost::json::array();
            return; }json["pSampler"]=boost::json::array(1);
        auto& arr_nEROYrx=json["pSampler"].get_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        }();


        json["stream_type"]=VKCREATESAMPLER;
        writeToConn(json);
    }

    void handle_vkDestroySampler(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSampler sampler;
[&](){deserialize_VkSampler(json["sampler"], sampler);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySampler call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySampler)get_instance_proc_addr(parent,"vkDestroySampler");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySampler)get_device_proc_addr(parent,"vkDestroySampler");
    }  
    
{
call_function(device, sampler, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSAMPLER;
        writeToConn(json);
    }

    void handle_vkCreateDescriptorSetLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));
        auto& arr_oELBvJU=json["pCreateInfo"].get_array();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            auto& temp=arr_oELBvJU[RmYFXzA].get_object();
            deserialize_struct(temp,pCreateInfo[RmYFXzA]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorSetLayout* pSetLayout;
[&](){
            if (json["pSetLayout"].get_array().size()==0){
                pSetLayout=NULL;
            return; }pSetLayout=(VkDescriptorSetLayout*)malloc(1*sizeof(VkDescriptorSetLayout));
        auto& arr_iCAhOCt=json["pSetLayout"].get_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();

    PFN_vkCreateDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorSetLayout)get_instance_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorSetLayout)get_device_proc_addr(parent,"vkCreateDescriptorSetLayout");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSetLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dFRsqIW=json["pCreateInfo"].get_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=boost::json::array();
            return; }json["pSetLayout"]=boost::json::array(1);
        auto& arr_iCAhOCt=json["pSetLayout"].get_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        }();


        json["stream_type"]=VKCREATEDESCRIPTORSETLAYOUT;
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorSetLayout(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout descriptorSetLayout;
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorSetLayout call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_instance_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorSetLayout)get_device_proc_addr(parent,"vkDestroyDescriptorSetLayout");
    }  
    
{
call_function(device, descriptorSetLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDESCRIPTORSETLAYOUT;
        writeToConn(json);
    }

    void handle_vkCreateDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorPoolCreateInfo*)malloc(1*sizeof(VkDescriptorPoolCreateInfo));
        auto& arr_aaNyAKF=json["pCreateInfo"].get_array();
        for(int zIfzhBg=0; zIfzhBg < 1; zIfzhBg++){
            [&](){
            auto& temp=arr_aaNyAKF[zIfzhBg].get_object();
            deserialize_struct(temp,pCreateInfo[zIfzhBg]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorPool* pDescriptorPool;
[&](){
            if (json["pDescriptorPool"].get_array().size()==0){
                pDescriptorPool=NULL;
            return; }pDescriptorPool=(VkDescriptorPool*)malloc(1*sizeof(VkDescriptorPool));
        auto& arr_zvYCksx=json["pDescriptorPool"].get_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();

    PFN_vkCreateDescriptorPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorPool)get_instance_proc_addr(parent,"vkCreateDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorPool)get_device_proc_addr(parent,"vkCreateDescriptorPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pDescriptorPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_fChMCRL=json["pCreateInfo"].get_array();
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto& temp=arr_fChMCRL[XgrRVVh].emplace_object();
            return serialize_struct(temp, pCreateInfo[XgrRVVh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=boost::json::array();
            return; }json["pDescriptorPool"]=boost::json::array(1);
        auto& arr_zvYCksx=json["pDescriptorPool"].get_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        }();


        json["stream_type"]=VKCREATEDESCRIPTORPOOL;
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorPool)get_instance_proc_addr(parent,"vkDestroyDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorPool)get_device_proc_addr(parent,"vkDestroyDescriptorPool");
    }  
    
{
call_function(device, descriptorPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDESCRIPTORPOOL;
        writeToConn(json);
    }

    void handle_vkResetDescriptorPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
VkDescriptorPoolResetFlags flags;
[&](){[&](){int temp_zAsidUJ;[&](){
            if (json["flags"].is_uint64()){
                temp_zAsidUJ=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_zAsidUJ=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_zAsidUJ=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();

    PFN_vkResetDescriptorPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetDescriptorPool)get_instance_proc_addr(parent,"vkResetDescriptorPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetDescriptorPool)get_device_proc_addr(parent,"vkResetDescriptorPool");
    }  
    
VkResult  result;
{
result=call_function(device, descriptorPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKRESETDESCRIPTORPOOL;
        writeToConn(json);
    }

    void handle_vkAllocateDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].get_array().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkDescriptorSetAllocateInfo*)malloc(1*sizeof(VkDescriptorSetAllocateInfo));
        auto& arr_scxnpgA=json["pAllocateInfo"].get_array();
        for(int LkJrMgh=0; LkJrMgh < 1; LkJrMgh++){
            [&](){
            auto& temp=arr_scxnpgA[LkJrMgh].get_object();
            deserialize_struct(temp,pAllocateInfo[LkJrMgh]);
            }();
        }
        }();
VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].get_array().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(pAllocateInfo->descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_hwQSDBT=json["pDescriptorSets"].get_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();

    PFN_vkAllocateDescriptorSets call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateDescriptorSets)get_instance_proc_addr(parent,"vkAllocateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateDescriptorSets)get_device_proc_addr(parent,"vkAllocateDescriptorSets");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_yVqYJHW=json["pAllocateInfo"].get_array();
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto& temp=arr_yVqYJHW[jTINpTr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[jTINpTr]);
            }();
        }
        }();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(pAllocateInfo->descriptorSetCount);
        auto& arr_hwQSDBT=json["pDescriptorSets"].get_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        }();


        json["stream_type"]=VKALLOCATEDESCRIPTORSETS;
        writeToConn(json);
    }

    void handle_vkFreeDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorPool descriptorPool;
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
uint32_t descriptorSetCount;
[&](){
            if (json["descriptorSetCount"].is_uint64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_uint64());
            }else if (json["descriptorSetCount"].is_int64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_int64());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_double());
            }
            }();
 VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].get_array().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_EoTJzqV=json["pDescriptorSets"].get_array();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], pDescriptorSets[ignhEiw]);}();
        }
        }();

    PFN_vkFreeDescriptorSets call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeDescriptorSets)get_instance_proc_addr(parent,"vkFreeDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeDescriptorSets)get_device_proc_addr(parent,"vkFreeDescriptorSets");
    }  
    
VkResult  result;
{
result=call_function(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(descriptorSetCount);
        auto& arr_JZNsxgK=json["pDescriptorSets"].get_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();


        json["stream_type"]=VKFREEDESCRIPTORSETS;
        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t descriptorWriteCount;
[&](){
            if (json["descriptorWriteCount"].is_uint64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_uint64());
            }else if (json["descriptorWriteCount"].is_int64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_int64());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_double());
            }
            }();
 VkWriteDescriptorSet* pDescriptorWrites;
[&](){
            if (json["pDescriptorWrites"].get_array().size()==0){
                pDescriptorWrites=NULL;
            return; }pDescriptorWrites=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));
        auto& arr_YJcGFpk=json["pDescriptorWrites"].get_array();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            auto& temp=arr_YJcGFpk[PyFuMgH].get_object();
            deserialize_struct(temp,pDescriptorWrites[PyFuMgH]);
            }();
        }
        }();
uint32_t descriptorCopyCount;
[&](){
            if (json["descriptorCopyCount"].is_uint64()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_uint64());
            }else if (json["descriptorCopyCount"].is_int64()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_int64());
            }else{
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_double());
            }
            }();
 VkCopyDescriptorSet* pDescriptorCopies;
[&](){
            if (json["pDescriptorCopies"].get_array().size()==0){
                pDescriptorCopies=NULL;
            return; }pDescriptorCopies=(VkCopyDescriptorSet*)malloc(descriptorCopyCount*sizeof(VkCopyDescriptorSet));
        auto& arr_kgDeqJO=json["pDescriptorCopies"].get_array();
        for(int ygJPsJJ=0; ygJPsJJ < descriptorCopyCount; ygJPsJJ++){
            [&](){
            auto& temp=arr_kgDeqJO[ygJPsJJ].get_object();
            deserialize_struct(temp,pDescriptorCopies[ygJPsJJ]);
            }();
        }
        }();

    PFN_vkUpdateDescriptorSets call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateDescriptorSets)get_instance_proc_addr(parent,"vkUpdateDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateDescriptorSets)get_device_proc_addr(parent,"vkUpdateDescriptorSets");
    }  
    
{
call_function(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }json["pDescriptorWrites"]=boost::json::array(descriptorWriteCount);
        auto& arr_AuOrFWk=json["pDescriptorWrites"].get_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
[&](){json["descriptorCopyCount"]=descriptorCopyCount;}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=boost::json::array();
            return; }json["pDescriptorCopies"]=boost::json::array(descriptorCopyCount);
        auto& arr_WWZDhqd=json["pDescriptorCopies"].get_array();
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto& temp=arr_WWZDhqd[ryeXdkw].emplace_object();
            return serialize_struct(temp, pDescriptorCopies[ryeXdkw]);
            }();
        }
        }();


        json["stream_type"]=VKUPDATEDESCRIPTORSETS;
        writeToConn(json);
    }

    void handle_vkCreateFramebuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFramebufferCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkFramebufferCreateInfo*)malloc(1*sizeof(VkFramebufferCreateInfo));
        auto& arr_JrEGPNB=json["pCreateInfo"].get_array();
        for(int NUUgVax=0; NUUgVax < 1; NUUgVax++){
            [&](){
            auto& temp=arr_JrEGPNB[NUUgVax].get_object();
            deserialize_struct(temp,pCreateInfo[NUUgVax]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkFramebuffer* pFramebuffer;
[&](){
            if (json["pFramebuffer"].get_array().size()==0){
                pFramebuffer=NULL;
            return; }pFramebuffer=(VkFramebuffer*)malloc(1*sizeof(VkFramebuffer));
        auto& arr_xECXRAK=json["pFramebuffer"].get_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();

    PFN_vkCreateFramebuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateFramebuffer)get_instance_proc_addr(parent,"vkCreateFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateFramebuffer)get_device_proc_addr(parent,"vkCreateFramebuffer");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFramebuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_LBIrWmz=json["pCreateInfo"].get_array();
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto& temp=arr_LBIrWmz[jMLqpUb].emplace_object();
            return serialize_struct(temp, pCreateInfo[jMLqpUb]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=boost::json::array();
            return; }json["pFramebuffer"]=boost::json::array(1);
        auto& arr_xECXRAK=json["pFramebuffer"].get_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        }();


        json["stream_type"]=VKCREATEFRAMEBUFFER;
        writeToConn(json);
    }

    void handle_vkDestroyFramebuffer(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyFramebuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyFramebuffer)get_instance_proc_addr(parent,"vkDestroyFramebuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyFramebuffer)get_device_proc_addr(parent,"vkDestroyFramebuffer");
    }  
    
{
call_function(device, framebuffer, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYFRAMEBUFFER;
        writeToConn(json);
    }

    void handle_vkCreateRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderPassCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkRenderPassCreateInfo*)malloc(1*sizeof(VkRenderPassCreateInfo));
        auto& arr_aQkDqwy=json["pCreateInfo"].get_array();
        for(int RbeQDgp=0; RbeQDgp < 1; RbeQDgp++){
            [&](){
            auto& temp=arr_aQkDqwy[RbeQDgp].get_object();
            deserialize_struct(temp,pCreateInfo[RbeQDgp]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].get_array().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRenderPass)get_instance_proc_addr(parent,"vkCreateRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRenderPass)get_device_proc_addr(parent,"vkCreateRenderPass");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_upxhtZe=json["pCreateInfo"].get_array();
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto& temp=arr_upxhtZe[oHJSJzU].emplace_object();
            return serialize_struct(temp, pCreateInfo[oHJSJzU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }json["pRenderPass"]=boost::json::array(1);
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();


        json["stream_type"]=VKCREATERENDERPASS;
        writeToConn(json);
    }

    void handle_vkDestroyRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyRenderPass call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyRenderPass)get_instance_proc_addr(parent,"vkDestroyRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyRenderPass)get_device_proc_addr(parent,"vkDestroyRenderPass");
    }  
    
{
call_function(device, renderPass, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYRENDERPASS;
        writeToConn(json);
    }

    void handle_vkGetRenderAreaGranularity(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkRenderPass renderPass;
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].get_array().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].get_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderAreaGranularity call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRenderAreaGranularity)get_instance_proc_addr(parent,"vkGetRenderAreaGranularity");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRenderAreaGranularity)get_device_proc_addr(parent,"vkGetRenderAreaGranularity");
    }  
    
{
call_function(device, renderPass, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }json["pGranularity"]=boost::json::array(1);
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();


        json["stream_type"]=VKGETRENDERAREAGRANULARITY;
        writeToConn(json);
    }

    void handle_vkGetRenderingAreaGranularityKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderingAreaInfoKHR* pRenderingAreaInfo;
[&](){
            if (json["pRenderingAreaInfo"].get_array().size()==0){
                pRenderingAreaInfo=NULL;
            return; }pRenderingAreaInfo=(VkRenderingAreaInfoKHR*)malloc(1*sizeof(VkRenderingAreaInfoKHR));
        auto& arr_WDJFhzk=json["pRenderingAreaInfo"].get_array();
        for(int Eyzmwzy=0; Eyzmwzy < 1; Eyzmwzy++){
            [&](){
            auto& temp=arr_WDJFhzk[Eyzmwzy].get_object();
            deserialize_struct(temp,pRenderingAreaInfo[Eyzmwzy]);
            }();
        }
        }();
VkExtent2D* pGranularity;
[&](){
            if (json["pGranularity"].get_array().size()==0){
                pGranularity=NULL;
            return; }pGranularity=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].get_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

    PFN_vkGetRenderingAreaGranularityKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_instance_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRenderingAreaGranularityKHR)get_device_proc_addr(parent,"vkGetRenderingAreaGranularityKHR");
    }  
    
{
call_function(device, pRenderingAreaInfo, pGranularity);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=boost::json::array();
            return; }json["pRenderingAreaInfo"]=boost::json::array(1);
        auto& arr_QFvDqfG=json["pRenderingAreaInfo"].get_array();
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto& temp=arr_QFvDqfG[WRYBJDa].emplace_object();
            return serialize_struct(temp, pRenderingAreaInfo[WRYBJDa]);
            }();
        }
        }();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }json["pGranularity"]=boost::json::array(1);
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();


        json["stream_type"]=VKGETRENDERINGAREAGRANULARITYKHR;
        writeToConn(json);
    }

    void handle_vkCreateCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCommandPoolCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCommandPoolCreateInfo*)malloc(1*sizeof(VkCommandPoolCreateInfo));
        auto& arr_gbWnDrT=json["pCreateInfo"].get_array();
        for(int kFYaAKf=0; kFYaAKf < 1; kFYaAKf++){
            [&](){
            auto& temp=arr_gbWnDrT[kFYaAKf].get_object();
            deserialize_struct(temp,pCreateInfo[kFYaAKf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkCommandPool* pCommandPool;
[&](){
            if (json["pCommandPool"].get_array().size()==0){
                pCommandPool=NULL;
            return; }pCommandPool=(VkCommandPool*)malloc(1*sizeof(VkCommandPool));
        auto& arr_ohCGecZ=json["pCommandPool"].get_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();

    PFN_vkCreateCommandPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCommandPool)get_instance_proc_addr(parent,"vkCreateCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCommandPool)get_device_proc_addr(parent,"vkCreateCommandPool");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pCommandPool);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_ISnaSOj=json["pCreateInfo"].get_array();
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto& temp=arr_ISnaSOj[ubLLexW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ubLLexW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=boost::json::array();
            return; }json["pCommandPool"]=boost::json::array(1);
        auto& arr_ohCGecZ=json["pCommandPool"].get_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        }();


        json["stream_type"]=VKCREATECOMMANDPOOL;
        writeToConn(json);
    }

    void handle_vkDestroyCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCommandPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCommandPool)get_instance_proc_addr(parent,"vkDestroyCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCommandPool)get_device_proc_addr(parent,"vkDestroyCommandPool");
    }  
    
{
call_function(device, commandPool, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYCOMMANDPOOL;
        writeToConn(json);
    }

    void handle_vkResetCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolResetFlags flags;
[&](){[&](){int temp_ZfbLqrp;[&](){
            if (json["flags"].is_uint64()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();

    PFN_vkResetCommandPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetCommandPool)get_instance_proc_addr(parent,"vkResetCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetCommandPool)get_device_proc_addr(parent,"vkResetCommandPool");
    }  
    
VkResult  result;
{
result=call_function(device, commandPool, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKRESETCOMMANDPOOL;
        writeToConn(json);
    }

    void handle_vkAllocateCommandBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCommandBufferAllocateInfo* pAllocateInfo;
[&](){
            if (json["pAllocateInfo"].get_array().size()==0){
                pAllocateInfo=NULL;
            return; }pAllocateInfo=(VkCommandBufferAllocateInfo*)malloc(1*sizeof(VkCommandBufferAllocateInfo));
        auto& arr_IZSSdEC=json["pAllocateInfo"].get_array();
        for(int VNokfaI=0; VNokfaI < 1; VNokfaI++){
            [&](){
            auto& temp=arr_IZSSdEC[VNokfaI].get_object();
            deserialize_struct(temp,pAllocateInfo[VNokfaI]);
            }();
        }
        }();
VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].get_array().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(pAllocateInfo->commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_WZYlBGU=json["pCommandBuffers"].get_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();

    PFN_vkAllocateCommandBuffers call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAllocateCommandBuffers)get_instance_proc_addr(parent,"vkAllocateCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAllocateCommandBuffers)get_device_proc_addr(parent,"vkAllocateCommandBuffers");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocateInfo, pCommandBuffers);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_ZURucFE=json["pAllocateInfo"].get_array();
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto& temp=arr_ZURucFE[VMrKYrr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[VMrKYrr]);
            }();
        }
        }();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(pAllocateInfo->commandBufferCount);
        auto& arr_WZYlBGU=json["pCommandBuffers"].get_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        }();


        json["stream_type"]=VKALLOCATECOMMANDBUFFERS;
        writeToConn(json);
    }

    void handle_vkFreeCommandBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
uint32_t commandBufferCount;
[&](){
            if (json["commandBufferCount"].is_uint64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_uint64());
            }else if (json["commandBufferCount"].is_int64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_int64());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_double());
            }
            }();
 VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].get_array().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_aIQpbyi=json["pCommandBuffers"].get_array();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], pCommandBuffers[Neoyndt]);}();
        }
        }();

    PFN_vkFreeCommandBuffers call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkFreeCommandBuffers)get_instance_proc_addr(parent,"vkFreeCommandBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkFreeCommandBuffers)get_device_proc_addr(parent,"vkFreeCommandBuffers");
    }  
    
{
call_function(device, commandPool, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(commandBufferCount);
        auto& arr_PdRlpEO=json["pCommandBuffers"].get_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();


        json["stream_type"]=VKFREECOMMANDBUFFERS;
        writeToConn(json);
    }

    void handle_vkBeginCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCommandBufferBeginInfo* pBeginInfo;
[&](){
            if (json["pBeginInfo"].get_array().size()==0){
                pBeginInfo=NULL;
            return; }pBeginInfo=(VkCommandBufferBeginInfo*)malloc(1*sizeof(VkCommandBufferBeginInfo));
        auto& arr_IMPwIrn=json["pBeginInfo"].get_array();
        for(int yjPwvUw=0; yjPwvUw < 1; yjPwvUw++){
            [&](){
            auto& temp=arr_IMPwIrn[yjPwvUw].get_object();
            deserialize_struct(temp,pBeginInfo[yjPwvUw]);
            }();
        }
        }();

    PFN_vkBeginCommandBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBeginCommandBuffer)get_instance_proc_addr(parent,"vkBeginCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBeginCommandBuffer)get_device_proc_addr(parent,"vkBeginCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pBeginInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }json["pBeginInfo"]=boost::json::array(1);
        auto& arr_cULABHU=json["pBeginInfo"].get_array();
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto& temp=arr_cULABHU[MlslWJM].emplace_object();
            return serialize_struct(temp, pBeginInfo[MlslWJM]);
            }();
        }
        }();


        json["stream_type"]=VKBEGINCOMMANDBUFFER;
        writeToConn(json);
    }

    void handle_vkEndCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkEndCommandBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEndCommandBuffer)get_instance_proc_addr(parent,"vkEndCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEndCommandBuffer)get_device_proc_addr(parent,"vkEndCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKENDCOMMANDBUFFER;
        writeToConn(json);
    }

    void handle_vkResetCommandBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCommandBufferResetFlags flags;
[&](){[&](){int temp_lxCkbVG;[&](){
            if (json["flags"].is_uint64()){
                temp_lxCkbVG=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_lxCkbVG=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_lxCkbVG=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();

    PFN_vkResetCommandBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkResetCommandBuffer)get_instance_proc_addr(parent,"vkResetCommandBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkResetCommandBuffer)get_device_proc_addr(parent,"vkResetCommandBuffer");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, flags);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKRESETCOMMANDBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdBindPipeline(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdBindPipeline call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindPipeline)get_instance_proc_addr(parent,"vkCmdBindPipeline");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindPipeline)get_device_proc_addr(parent,"vkCmdBindPipeline");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        json["stream_type"]=VKCMDBINDPIPELINE;
        writeToConn(json);
    }

    void handle_vkCmdSetAttachmentFeedbackLoopEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageAspectFlags aspectMask;
[&](){[&](){int temp_LWxAVsj;[&](){
            if (json["aspectMask"].is_uint64()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_uint64());
            }else if (json["aspectMask"].is_int64()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_int64());
            }else{
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_double());
            }
            }();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)get_device_proc_addr(parent,"vkCmdSetAttachmentFeedbackLoopEnableEXT");
    }  
    
{
call_function(commandBuffer, aspectMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=aspectMask;}();}();}();


        json["stream_type"]=VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetViewport(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();
 VkViewport* pViewports;
[&](){
            if (json["pViewports"].get_array().size()==0){
                pViewports=NULL;
            return; }pViewports=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));
        auto& arr_NYoDqxX=json["pViewports"].get_array();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            auto& temp=arr_NYoDqxX[SjlAQpy].get_object();
            deserialize_struct(temp,pViewports[SjlAQpy]);
            }();
        }
        }();

    PFN_vkCmdSetViewport call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewport)get_instance_proc_addr(parent,"vkCmdSetViewport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewport)get_device_proc_addr(parent,"vkCmdSetViewport");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }json["pViewports"]=boost::json::array(viewportCount);
        auto& arr_SyYryUE=json["pViewports"].get_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVIEWPORT;
        writeToConn(json);
    }

    void handle_vkCmdSetScissor(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstScissor;
[&](){
            if (json["firstScissor"].is_uint64()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_uint64());
            }else if (json["firstScissor"].is_int64()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_int64());
            }else{
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_double());
            }
            }();
uint32_t scissorCount;
[&](){
            if (json["scissorCount"].is_uint64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_uint64());
            }else if (json["scissorCount"].is_int64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_int64());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_double());
            }
            }();
 VkRect2D* pScissors;
[&](){
            if (json["pScissors"].get_array().size()==0){
                pScissors=NULL;
            return; }pScissors=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));
        auto& arr_bIRAuhj=json["pScissors"].get_array();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            auto& temp=arr_bIRAuhj[QukNmCZ].get_object();
            deserialize_struct(temp,pScissors[QukNmCZ]);
            }();
        }
        }();

    PFN_vkCmdSetScissor call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetScissor)get_instance_proc_addr(parent,"vkCmdSetScissor");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetScissor)get_device_proc_addr(parent,"vkCmdSetScissor");
    }  
    
{
call_function(commandBuffer, firstScissor, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=firstScissor;}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }json["pScissors"]=boost::json::array(scissorCount);
        auto& arr_RpUaBcS=json["pScissors"].get_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETSCISSOR;
        writeToConn(json);
    }

    void handle_vkCmdSetLineWidth(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float lineWidth;
[&](){
            if (json["lineWidth"].is_uint64()){
                lineWidth=static_cast<float>(json["lineWidth"].get_uint64());
            }else if (json["lineWidth"].is_int64()){
                lineWidth=static_cast<float>(json["lineWidth"].get_int64());
            }else{
                lineWidth=static_cast<float>(json["lineWidth"].get_double());
            }
            }();

    PFN_vkCmdSetLineWidth call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineWidth)get_instance_proc_addr(parent,"vkCmdSetLineWidth");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineWidth)get_device_proc_addr(parent,"vkCmdSetLineWidth");
    }  
    
{
call_function(commandBuffer, lineWidth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=lineWidth;}();


        json["stream_type"]=VKCMDSETLINEWIDTH;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float depthBiasConstantFactor;
[&](){
            if (json["depthBiasConstantFactor"].is_uint64()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_uint64());
            }else if (json["depthBiasConstantFactor"].is_int64()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_int64());
            }else{
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_double());
            }
            }();
float depthBiasClamp;
[&](){
            if (json["depthBiasClamp"].is_uint64()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_uint64());
            }else if (json["depthBiasClamp"].is_int64()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_int64());
            }else{
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_double());
            }
            }();
float depthBiasSlopeFactor;
[&](){
            if (json["depthBiasSlopeFactor"].is_uint64()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_uint64());
            }else if (json["depthBiasSlopeFactor"].is_int64()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_int64());
            }else{
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_double());
            }
            }();

    PFN_vkCmdSetDepthBias call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBias)get_instance_proc_addr(parent,"vkCmdSetDepthBias");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBias)get_device_proc_addr(parent,"vkCmdSetDepthBias");
    }  
    
{
call_function(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=depthBiasConstantFactor;}();
[&](){json["depthBiasClamp"]=depthBiasClamp;}();
[&](){json["depthBiasSlopeFactor"]=depthBiasSlopeFactor;}();


        json["stream_type"]=VKCMDSETDEPTHBIAS;
        writeToConn(json);
    }

    void handle_vkCmdSetBlendConstants(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 float blendConstants[4];
[&](){
        auto& arr_jgecLWF=json["blendConstants"].get_array();
        for(int JTJKYzw=0; JTJKYzw < 4; JTJKYzw++){
            [&](){
            if (arr_jgecLWF[JTJKYzw].is_uint64()){
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].get_uint64());
            }else if (arr_jgecLWF[JTJKYzw].is_int64()){
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].get_int64());
            }else{
                blendConstants[JTJKYzw]=static_cast<float>(arr_jgecLWF[JTJKYzw].get_double());
            }
            }();
        }
        }();

    PFN_vkCmdSetBlendConstants call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetBlendConstants)get_instance_proc_addr(parent,"vkCmdSetBlendConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetBlendConstants)get_device_proc_addr(parent,"vkCmdSetBlendConstants");
    }  
    
{
call_function(commandBuffer, blendConstants);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["blendConstants"]=boost::json::array(4);
        auto& arr_HTjCZtj=json["blendConstants"].get_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_HTjCZtj[lLRJClr]=blendConstants[lLRJClr];}();
        }
        }();


        json["stream_type"]=VKCMDSETBLENDCONSTANTS;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBounds(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float minDepthBounds;
[&](){
            if (json["minDepthBounds"].is_uint64()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_uint64());
            }else if (json["minDepthBounds"].is_int64()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_int64());
            }else{
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_double());
            }
            }();
float maxDepthBounds;
[&](){
            if (json["maxDepthBounds"].is_uint64()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_uint64());
            }else if (json["maxDepthBounds"].is_int64()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_int64());
            }else{
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_double());
            }
            }();

    PFN_vkCmdSetDepthBounds call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBounds)get_instance_proc_addr(parent,"vkCmdSetDepthBounds");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBounds)get_device_proc_addr(parent,"vkCmdSetDepthBounds");
    }  
    
{
call_function(commandBuffer, minDepthBounds, maxDepthBounds);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=minDepthBounds;}();
[&](){json["maxDepthBounds"]=maxDepthBounds;}();


        json["stream_type"]=VKCMDSETDEPTHBOUNDS;
        writeToConn(json);
    }

    void handle_vkCmdSetStencilCompareMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t compareMask;
[&](){
            if (json["compareMask"].is_uint64()){
                compareMask=static_cast<uint32_t>(json["compareMask"].get_uint64());
            }else if (json["compareMask"].is_int64()){
                compareMask=static_cast<uint32_t>(json["compareMask"].get_int64());
            }else{
                compareMask=static_cast<uint32_t>(json["compareMask"].get_double());
            }
            }();

    PFN_vkCmdSetStencilCompareMask call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilCompareMask)get_instance_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilCompareMask)get_device_proc_addr(parent,"vkCmdSetStencilCompareMask");
    }  
    
{
call_function(commandBuffer, faceMask, compareMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["compareMask"]=compareMask;}();


        json["stream_type"]=VKCMDSETSTENCILCOMPAREMASK;
        writeToConn(json);
    }

    void handle_vkCmdSetStencilWriteMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t writeMask;
[&](){
            if (json["writeMask"].is_uint64()){
                writeMask=static_cast<uint32_t>(json["writeMask"].get_uint64());
            }else if (json["writeMask"].is_int64()){
                writeMask=static_cast<uint32_t>(json["writeMask"].get_int64());
            }else{
                writeMask=static_cast<uint32_t>(json["writeMask"].get_double());
            }
            }();

    PFN_vkCmdSetStencilWriteMask call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilWriteMask)get_instance_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilWriteMask)get_device_proc_addr(parent,"vkCmdSetStencilWriteMask");
    }  
    
{
call_function(commandBuffer, faceMask, writeMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["writeMask"]=writeMask;}();


        json["stream_type"]=VKCMDSETSTENCILWRITEMASK;
        writeToConn(json);
    }

    void handle_vkCmdSetStencilReference(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
uint32_t reference;
[&](){
            if (json["reference"].is_uint64()){
                reference=static_cast<uint32_t>(json["reference"].get_uint64());
            }else if (json["reference"].is_int64()){
                reference=static_cast<uint32_t>(json["reference"].get_int64());
            }else{
                reference=static_cast<uint32_t>(json["reference"].get_double());
            }
            }();

    PFN_vkCmdSetStencilReference call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilReference)get_instance_proc_addr(parent,"vkCmdSetStencilReference");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilReference)get_device_proc_addr(parent,"vkCmdSetStencilReference");
    }  
    
{
call_function(commandBuffer, faceMask, reference);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["reference"]=reference;}();


        json["stream_type"]=VKCMDSETSTENCILREFERENCE;
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorSets(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){
            if (json["firstSet"].is_uint64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_uint64());
            }else if (json["firstSet"].is_int64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_int64());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].get_double());
            }
            }();
uint32_t descriptorSetCount;
[&](){
            if (json["descriptorSetCount"].is_uint64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_uint64());
            }else if (json["descriptorSetCount"].is_int64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_int64());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_double());
            }
            }();
 VkDescriptorSet* pDescriptorSets;
[&](){
            if (json["pDescriptorSets"].get_array().size()==0){
                pDescriptorSets=NULL;
            return; }pDescriptorSets=(VkDescriptorSet*)malloc(descriptorSetCount*sizeof(VkDescriptorSet));
        auto& arr_EoTJzqV=json["pDescriptorSets"].get_array();
        for(int ignhEiw=0; ignhEiw < descriptorSetCount; ignhEiw++){
            [&](){deserialize_VkDescriptorSet(arr_EoTJzqV[ignhEiw], pDescriptorSets[ignhEiw]);}();
        }
        }();
uint32_t dynamicOffsetCount;
[&](){
            if (json["dynamicOffsetCount"].is_uint64()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_uint64());
            }else if (json["dynamicOffsetCount"].is_int64()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_int64());
            }else{
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_double());
            }
            }();
 uint32_t* pDynamicOffsets;
[&](){
            if (json["pDynamicOffsets"].get_array().size()==0){
                pDynamicOffsets=NULL;
            return; }pDynamicOffsets=(uint32_t*)malloc(dynamicOffsetCount*sizeof(uint32_t));
        auto& arr_QbUQxOl=json["pDynamicOffsets"].get_array();
        for(int yNPUnDM=0; yNPUnDM < dynamicOffsetCount; yNPUnDM++){
            [&](){
            if (arr_QbUQxOl[yNPUnDM].is_uint64()){
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].get_uint64());
            }else if (arr_QbUQxOl[yNPUnDM].is_int64()){
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].get_int64());
            }else{
                pDynamicOffsets[yNPUnDM]=static_cast<uint32_t>(arr_QbUQxOl[yNPUnDM].get_double());
            }
            }();
        }
        }();

    PFN_vkCmdBindDescriptorSets call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorSets)get_instance_proc_addr(parent,"vkCmdBindDescriptorSets");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorSets)get_device_proc_addr(parent,"vkCmdBindDescriptorSets");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(descriptorSetCount);
        auto& arr_JZNsxgK=json["pDescriptorSets"].get_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
[&](){json["dynamicOffsetCount"]=dynamicOffsetCount;}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=boost::json::array();
            return; }json["pDynamicOffsets"]=boost::json::array(dynamicOffsetCount);
        auto& arr_Zetuxcc=json["pDynamicOffsets"].get_array();
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=pDynamicOffsets[nxuqgVF];}();
        }
        }();


        json["stream_type"]=VKCMDBINDDESCRIPTORSETS;
        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_uint64());
            }else if (json["indexType"].is_int64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_int64());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindIndexBuffer)get_device_proc_addr(parent,"vkCmdBindIndexBuffer");
    }  
    
{
call_function(commandBuffer, buffer, offset, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();


        json["stream_type"]=VKCMDBINDINDEXBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].get_array().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].get_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].get_array().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].get_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_uint64());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_int64());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();

    PFN_vkCmdBindVertexBuffers call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindVertexBuffers)get_device_proc_addr(parent,"vkCmdBindVertexBuffers");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();


        json["stream_type"]=VKCMDBINDVERTEXBUFFERS;
        writeToConn(json);
    }

    void handle_vkCmdDraw(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexCount;
[&](){
            if (json["vertexCount"].is_uint64()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_uint64());
            }else if (json["vertexCount"].is_int64()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_int64());
            }else{
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_double());
            }
            }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
uint32_t firstVertex;
[&](){
            if (json["firstVertex"].is_uint64()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_uint64());
            }else if (json["firstVertex"].is_int64()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_int64());
            }else{
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();

    PFN_vkCmdDraw call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDraw)get_instance_proc_addr(parent,"vkCmdDraw");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDraw)get_device_proc_addr(parent,"vkCmdDraw");
    }  
    
{
call_function(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=vertexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstVertex"]=firstVertex;}();
[&](){json["firstInstance"]=firstInstance;}();


        json["stream_type"]=VKCMDDRAW;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexed(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t indexCount;
[&](){
            if (json["indexCount"].is_uint64()){
                indexCount=static_cast<uint32_t>(json["indexCount"].get_uint64());
            }else if (json["indexCount"].is_int64()){
                indexCount=static_cast<uint32_t>(json["indexCount"].get_int64());
            }else{
                indexCount=static_cast<uint32_t>(json["indexCount"].get_double());
            }
            }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
uint32_t firstIndex;
[&](){
            if (json["firstIndex"].is_uint64()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_uint64());
            }else if (json["firstIndex"].is_int64()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_int64());
            }else{
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_double());
            }
            }();
int32_t vertexOffset;
[&](){
            if (json["vertexOffset"].is_uint64()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_uint64());
            }else if (json["vertexOffset"].is_int64()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_int64());
            }else{
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();

    PFN_vkCmdDrawIndexed call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexed)get_instance_proc_addr(parent,"vkCmdDrawIndexed");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexed)get_device_proc_addr(parent,"vkCmdDrawIndexed");
    }  
    
{
call_function(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=indexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstIndex"]=firstIndex;}();
[&](){json["vertexOffset"]=vertexOffset;}();
[&](){json["firstInstance"]=firstInstance;}();


        json["stream_type"]=VKCMDDRAWINDEXED;
        writeToConn(json);
    }

    void handle_vkCmdDrawMultiEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
 VkMultiDrawInfoEXT* pVertexInfo;
[&](){
            if (json["pVertexInfo"].get_array().size()==0){
                pVertexInfo=NULL;
            return; }pVertexInfo=(VkMultiDrawInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawInfoEXT));
        auto& arr_SygHzZS=json["pVertexInfo"].get_array();
        for(int iVtYwjb=0; iVtYwjb < drawCount; iVtYwjb++){
            [&](){
            auto& temp=arr_SygHzZS[iVtYwjb].get_object();
            deserialize_struct(temp,pVertexInfo[iVtYwjb]);
            }();
        }
        }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawMultiEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMultiEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMultiEXT)get_device_proc_addr(parent,"vkCmdDrawMultiEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=boost::json::array();
            return; }json["pVertexInfo"]=boost::json::array(drawCount);
        auto& arr_NmVssTF=json["pVertexInfo"].get_array();
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto& temp=arr_NmVssTF[xJCsgzh].emplace_object();
            return serialize_struct(temp, pVertexInfo[xJCsgzh]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWMULTIEXT;
        writeToConn(json);
    }

    void handle_vkCmdDrawMultiIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
 VkMultiDrawIndexedInfoEXT* pIndexInfo;
[&](){
            if (json["pIndexInfo"].get_array().size()==0){
                pIndexInfo=NULL;
            return; }pIndexInfo=(VkMultiDrawIndexedInfoEXT*)malloc(drawCount*sizeof(VkMultiDrawIndexedInfoEXT));
        auto& arr_jliksnn=json["pIndexInfo"].get_array();
        for(int cbQpceE=0; cbQpceE < drawCount; cbQpceE++){
            [&](){
            auto& temp=arr_jliksnn[cbQpceE].get_object();
            deserialize_struct(temp,pIndexInfo[cbQpceE]);
            }();
        }
        }();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();
 int32_t* pVertexOffset;
[&](){
            if (json["pVertexOffset"].get_array().size()==0){
                pVertexOffset=NULL;
            return; }pVertexOffset=(int32_t*)malloc(1*sizeof(int32_t));
        auto& arr_IdSDtoD=json["pVertexOffset"].get_array();
        for(int XPkpqBK=0; XPkpqBK < 1; XPkpqBK++){
            [&](){
            if (arr_IdSDtoD[XPkpqBK].is_uint64()){
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].get_uint64());
            }else if (arr_IdSDtoD[XPkpqBK].is_int64()){
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].get_int64());
            }else{
                pVertexOffset[XPkpqBK]=static_cast<int32_t>(arr_IdSDtoD[XPkpqBK].get_double());
            }
            }();
        }
        }();

    PFN_vkCmdDrawMultiIndexedEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_instance_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMultiIndexedEXT)get_device_proc_addr(parent,"vkCmdDrawMultiIndexedEXT");
    }  
    
{
call_function(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=boost::json::array();
            return; }json["pIndexInfo"]=boost::json::array(drawCount);
        auto& arr_OvAOCiL=json["pIndexInfo"].get_array();
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto& temp=arr_OvAOCiL[FmfkOAV].emplace_object();
            return serialize_struct(temp, pIndexInfo[FmfkOAV]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=boost::json::array();
            return; }json["pVertexOffset"]=boost::json::array(1);
        auto& arr_PavgIEG=json["pVertexOffset"].get_array();
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=pVertexOffset[PNvrUEs];}();
        }
        }();


        json["stream_type"]=VKCMDDRAWMULTIINDEXEDEXT;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawIndirect call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirect)get_device_proc_addr(parent,"vkCmdDrawIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWINDIRECT;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawIndexedIndirect call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexedIndirect)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWINDEXEDINDIRECT;
        writeToConn(json);
    }

    void handle_vkCmdDispatch(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

    PFN_vkCmdDispatch call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatch)get_instance_proc_addr(parent,"vkCmdDispatch");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatch)get_device_proc_addr(parent,"vkCmdDispatch");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        json["stream_type"]=VKCMDDISPATCH;
        writeToConn(json);
    }

    void handle_vkCmdDispatchIndirect(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDispatchIndirect call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatchIndirect)get_instance_proc_addr(parent,"vkCmdDispatchIndirect");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatchIndirect)get_device_proc_addr(parent,"vkCmdDispatchIndirect");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();


        json["stream_type"]=VKCMDDISPATCHINDIRECT;
        writeToConn(json);
    }

    void handle_vkCmdSubpassShadingHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdSubpassShadingHUAWEI call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_instance_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSubpassShadingHUAWEI)get_device_proc_addr(parent,"vkCmdSubpassShadingHUAWEI");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDSUBPASSSHADINGHUAWEI;
        writeToConn(json);
    }

    void handle_vkCmdDrawClusterHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

    PFN_vkCmdDrawClusterHUAWEI call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawClusterHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterHUAWEI");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        json["stream_type"]=VKCMDDRAWCLUSTERHUAWEI;
        writeToConn(json);
    }

    void handle_vkCmdDrawClusterIndirectHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

    PFN_vkCmdDrawClusterIndirectHUAWEI call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_instance_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawClusterIndirectHUAWEI)get_device_proc_addr(parent,"vkCmdDrawClusterIndirectHUAWEI");
    }  
    
{
call_function(commandBuffer, buffer, offset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();


        json["stream_type"]=VKCMDDRAWCLUSTERINDIRECTHUAWEI;
        writeToConn(json);
    }

    void handle_vkCmdUpdatePipelineIndirectBufferNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

    PFN_vkCmdUpdatePipelineIndirectBufferNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_instance_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdUpdatePipelineIndirectBufferNV)get_device_proc_addr(parent,"vkCmdUpdatePipelineIndirectBufferNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();


        json["stream_type"]=VKCMDUPDATEPIPELINEINDIRECTBUFFERNV;
        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkBufferCopy* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferCopy*)malloc(regionCount*sizeof(VkBufferCopy));
        auto& arr_MJNgYRy=json["pRegions"].get_array();
        for(int BwnoKUH=0; BwnoKUH < regionCount; BwnoKUH++){
            [&](){
            auto& temp=arr_MJNgYRy[BwnoKUH].get_object();
            deserialize_struct(temp,pRegions[BwnoKUH]);
            }();
        }
        }();

    PFN_vkCmdCopyBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBuffer)get_instance_proc_addr(parent,"vkCmdCopyBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBuffer)get_device_proc_addr(parent,"vkCmdCopyBuffer");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_McSYWcQ=json["pRegions"].get_array();
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto& temp=arr_McSYWcQ[IaMuFrO].emplace_object();
            return serialize_struct(temp, pRegions[IaMuFrO]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdCopyImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkImageCopy* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageCopy*)malloc(regionCount*sizeof(VkImageCopy));
        auto& arr_sMBHaLF=json["pRegions"].get_array();
        for(int lLnttNm=0; lLnttNm < regionCount; lLnttNm++){
            [&](){
            auto& temp=arr_sMBHaLF[lLnttNm].get_object();
            deserialize_struct(temp,pRegions[lLnttNm]);
            }();
        }
        }();

    PFN_vkCmdCopyImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImage)get_instance_proc_addr(parent,"vkCmdCopyImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImage)get_device_proc_addr(parent,"vkCmdCopyImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_HMPixWj=json["pRegions"].get_array();
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto& temp=arr_HMPixWj[TvxHvSV].emplace_object();
            return serialize_struct(temp, pRegions[TvxHvSV]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdBlitImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkImageBlit* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageBlit*)malloc(regionCount*sizeof(VkImageBlit));
        auto& arr_aDcnXeL=json["pRegions"].get_array();
        for(int khqBNUP=0; khqBNUP < regionCount; khqBNUP++){
            [&](){
            auto& temp=arr_aDcnXeL[khqBNUP].get_object();
            deserialize_struct(temp,pRegions[khqBNUP]);
            }();
        }
        }();
VkFilter filter;
[&](){[&](){int temp_DaCTyEq;[&](){
            if (json["filter"].is_uint64()){
                temp_DaCTyEq=static_cast<int>(json["filter"].get_uint64());
            }else if (json["filter"].is_int64()){
                temp_DaCTyEq=static_cast<int>(json["filter"].get_int64());
            }else{
                temp_DaCTyEq=static_cast<int>(json["filter"].get_double());
            }
            }();filter=(VkFilter)temp_DaCTyEq;}();}();

    PFN_vkCmdBlitImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBlitImage)get_instance_proc_addr(parent,"vkCmdBlitImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBlitImage)get_device_proc_addr(parent,"vkCmdBlitImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_dQsoHhP=json["pRegions"].get_array();
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto& temp=arr_dQsoHhP[YEXYPDJ].emplace_object();
            return serialize_struct(temp, pRegions[YEXYPDJ]);
            }();
        }
        }();
[&](){[&](){[&](){json["filter"]=filter;}();}();}();


        json["stream_type"]=VKCMDBLITIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer srcBuffer;
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkBufferImageCopy* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));
        auto& arr_Gfapiec=json["pRegions"].get_array();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            auto& temp=arr_Gfapiec[edvwarx].get_object();
            deserialize_struct(temp,pRegions[edvwarx]);
            }();
        }
        }();

    PFN_vkCmdCopyBufferToImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBufferToImage)get_device_proc_addr(parent,"vkCmdCopyBufferToImage");
    }  
    
{
call_function(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_igZnVsu=json["pRegions"].get_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYBUFFERTOIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkBufferImageCopy* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkBufferImageCopy*)malloc(regionCount*sizeof(VkBufferImageCopy));
        auto& arr_Gfapiec=json["pRegions"].get_array();
        for(int edvwarx=0; edvwarx < regionCount; edvwarx++){
            [&](){
            auto& temp=arr_Gfapiec[edvwarx].get_object();
            deserialize_struct(temp,pRegions[edvwarx]);
            }();
        }
        }();

    PFN_vkCmdCopyImageToBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImageToBuffer)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_igZnVsu=json["pRegions"].get_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYIMAGETOBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_uint64());
            }else if (json["copyBufferAddress"].is_int64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_int64());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){
            if (json["copyCount"].is_uint64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_uint64());
            }else if (json["copyCount"].is_int64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_int64());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdCopyMemoryIndirectNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDCOPYMEMORYINDIRECTNV;
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToImageIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress copyBufferAddress;
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_uint64());
            }else if (json["copyBufferAddress"].is_int64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_int64());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
uint32_t copyCount;
[&](){
            if (json["copyCount"].is_uint64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_uint64());
            }else if (json["copyCount"].is_int64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_int64());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
 VkImageSubresourceLayers* pImageSubresources;
[&](){
            if (json["pImageSubresources"].get_array().size()==0){
                pImageSubresources=NULL;
            return; }pImageSubresources=(VkImageSubresourceLayers*)malloc(copyCount*sizeof(VkImageSubresourceLayers));
        auto& arr_WxjWdjD=json["pImageSubresources"].get_array();
        for(int ApBwZPM=0; ApBwZPM < copyCount; ApBwZPM++){
            [&](){
            auto& temp=arr_WxjWdjD[ApBwZPM].get_object();
            deserialize_struct(temp,pImageSubresources[ApBwZPM]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToImageIndirectNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_instance_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToImageIndirectNV)get_device_proc_addr(parent,"vkCmdCopyMemoryToImageIndirectNV");
    }  
    
{
call_function(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=boost::json::array();
            return; }json["pImageSubresources"]=boost::json::array(copyCount);
        auto& arr_hVMAkcO=json["pImageSubresources"].get_array();
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto& temp=arr_hVMAkcO[OfGHasS].emplace_object();
            return serialize_struct(temp, pImageSubresources[OfGHasS]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYMEMORYTOIMAGEINDIRECTNV;
        writeToConn(json);
    }

    void handle_vkCmdUpdateBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize dataSize;
[&](){uint64_t temp_SwYyzuh;[&](){
            if (json["dataSize"].is_uint64()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_int64());
            }else{
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_double());
            }
            }();dataSize=(VkDeviceSize)temp_SwYyzuh;}();
 void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_eeRffBc;[&](){
            if (json["pData"].get_array().size()==0){
                temp_eeRffBc=NULL;
            return; }temp_eeRffBc=(char*)malloc(dataSize*sizeof(char));
        auto& arr_EOPGHRq=json["pData"].get_array();
        for(int ElrKHKH=0; ElrKHKH < dataSize; ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64()){
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_uint64());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64()){
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_int64());
            }else{
                temp_eeRffBc[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_double());
            }
            }();
        }
        }();pData=temp_eeRffBc;}();

    PFN_vkCmdUpdateBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdUpdateBuffer)get_instance_proc_addr(parent,"vkCmdUpdateBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdUpdateBuffer)get_device_proc_addr(parent,"vkCmdUpdateBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["dataSize"]=dataSize;}();}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < dataSize; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();


        json["stream_type"]=VKCMDUPDATEBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdFillBuffer(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
uint32_t data;
[&](){
            if (json["data"].is_uint64()){
                data=static_cast<uint32_t>(json["data"].get_uint64());
            }else if (json["data"].is_int64()){
                data=static_cast<uint32_t>(json["data"].get_int64());
            }else{
                data=static_cast<uint32_t>(json["data"].get_double());
            }
            }();

    PFN_vkCmdFillBuffer call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdFillBuffer)get_instance_proc_addr(parent,"vkCmdFillBuffer");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdFillBuffer)get_device_proc_addr(parent,"vkCmdFillBuffer");
    }  
    
{
call_function(commandBuffer, dstBuffer, dstOffset, size, data);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){json["data"]=data;}();


        json["stream_type"]=VKCMDFILLBUFFER;
        writeToConn(json);
    }

    void handle_vkCmdClearColorImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
 VkClearColorValue* pColor;
[&](){
            if (json["pColor"].get_array().size()==0){
                pColor=NULL;
            return; }pColor=(VkClearColorValue*)malloc(1*sizeof(VkClearColorValue));
        auto& arr_GpwuhjC=json["pColor"].get_array();
        for(int ltCZWMn=0; ltCZWMn < 1; ltCZWMn++){
            [&](){
            auto& temp=arr_GpwuhjC[ltCZWMn].get_object();
            deserialize_struct(temp,pColor[ltCZWMn]);
            }();
        }
        }();
uint32_t rangeCount;
[&](){
            if (json["rangeCount"].is_uint64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_uint64());
            }else if (json["rangeCount"].is_int64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_int64());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_double());
            }
            }();
 VkImageSubresourceRange* pRanges;
[&](){
            if (json["pRanges"].get_array().size()==0){
                pRanges=NULL;
            return; }pRanges=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));
        auto& arr_HvOwEDl=json["pRanges"].get_array();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            auto& temp=arr_HvOwEDl[zzMqHgz].get_object();
            deserialize_struct(temp,pRanges[zzMqHgz]);
            }();
        }
        }();

    PFN_vkCmdClearColorImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearColorImage)get_instance_proc_addr(parent,"vkCmdClearColorImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearColorImage)get_device_proc_addr(parent,"vkCmdClearColorImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=boost::json::array();
            return; }json["pColor"]=boost::json::array(1);
        auto& arr_SGRyjqE=json["pColor"].get_array();
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto& temp=arr_SGRyjqE[ldPlUDi].emplace_object();
            return serialize_struct(temp, pColor[ldPlUDi]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }json["pRanges"]=boost::json::array(rangeCount);
        auto& arr_BisbUqU=json["pRanges"].get_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCLEARCOLORIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdClearDepthStencilImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();
 VkClearDepthStencilValue* pDepthStencil;
[&](){
            if (json["pDepthStencil"].get_array().size()==0){
                pDepthStencil=NULL;
            return; }pDepthStencil=(VkClearDepthStencilValue*)malloc(1*sizeof(VkClearDepthStencilValue));
        auto& arr_PIAYblz=json["pDepthStencil"].get_array();
        for(int zQOULOl=0; zQOULOl < 1; zQOULOl++){
            [&](){
            auto& temp=arr_PIAYblz[zQOULOl].get_object();
            deserialize_struct(temp,pDepthStencil[zQOULOl]);
            }();
        }
        }();
uint32_t rangeCount;
[&](){
            if (json["rangeCount"].is_uint64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_uint64());
            }else if (json["rangeCount"].is_int64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_int64());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_double());
            }
            }();
 VkImageSubresourceRange* pRanges;
[&](){
            if (json["pRanges"].get_array().size()==0){
                pRanges=NULL;
            return; }pRanges=(VkImageSubresourceRange*)malloc(rangeCount*sizeof(VkImageSubresourceRange));
        auto& arr_HvOwEDl=json["pRanges"].get_array();
        for(int zzMqHgz=0; zzMqHgz < rangeCount; zzMqHgz++){
            [&](){
            auto& temp=arr_HvOwEDl[zzMqHgz].get_object();
            deserialize_struct(temp,pRanges[zzMqHgz]);
            }();
        }
        }();

    PFN_vkCmdClearDepthStencilImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearDepthStencilImage)get_instance_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearDepthStencilImage)get_device_proc_addr(parent,"vkCmdClearDepthStencilImage");
    }  
    
{
call_function(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=boost::json::array();
            return; }json["pDepthStencil"]=boost::json::array(1);
        auto& arr_gYzlVps=json["pDepthStencil"].get_array();
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto& temp=arr_gYzlVps[jJUemfv].emplace_object();
            return serialize_struct(temp, pDepthStencil[jJUemfv]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }json["pRanges"]=boost::json::array(rangeCount);
        auto& arr_BisbUqU=json["pRanges"].get_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCLEARDEPTHSTENCILIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdClearAttachments(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkClearAttachment* pAttachments;
[&](){
            if (json["pAttachments"].get_array().size()==0){
                pAttachments=NULL;
            return; }pAttachments=(VkClearAttachment*)malloc(attachmentCount*sizeof(VkClearAttachment));
        auto& arr_cdEOPrs=json["pAttachments"].get_array();
        for(int bLOSZTT=0; bLOSZTT < attachmentCount; bLOSZTT++){
            [&](){
            auto& temp=arr_cdEOPrs[bLOSZTT].get_object();
            deserialize_struct(temp,pAttachments[bLOSZTT]);
            }();
        }
        }();
uint32_t rectCount;
[&](){
            if (json["rectCount"].is_uint64()){
                rectCount=static_cast<uint32_t>(json["rectCount"].get_uint64());
            }else if (json["rectCount"].is_int64()){
                rectCount=static_cast<uint32_t>(json["rectCount"].get_int64());
            }else{
                rectCount=static_cast<uint32_t>(json["rectCount"].get_double());
            }
            }();
 VkClearRect* pRects;
[&](){
            if (json["pRects"].get_array().size()==0){
                pRects=NULL;
            return; }pRects=(VkClearRect*)malloc(rectCount*sizeof(VkClearRect));
        auto& arr_cMVnppZ=json["pRects"].get_array();
        for(int RmtJABT=0; RmtJABT < rectCount; RmtJABT++){
            [&](){
            auto& temp=arr_cMVnppZ[RmtJABT].get_object();
            deserialize_struct(temp,pRects[RmtJABT]);
            }();
        }
        }();

    PFN_vkCmdClearAttachments call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdClearAttachments)get_instance_proc_addr(parent,"vkCmdClearAttachments");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdClearAttachments)get_device_proc_addr(parent,"vkCmdClearAttachments");
    }  
    
{
call_function(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=boost::json::array();
            return; }json["pAttachments"]=boost::json::array(attachmentCount);
        auto& arr_fOlilkR=json["pAttachments"].get_array();
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto& temp=arr_fOlilkR[BsFiayf].emplace_object();
            return serialize_struct(temp, pAttachments[BsFiayf]);
            }();
        }
        }();
[&](){json["rectCount"]=rectCount;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }json["pRects"]=boost::json::array(rectCount);
        auto& arr_cgJwUFb=json["pRects"].get_array();
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto& temp=arr_cgJwUFb[HncrKEH].emplace_object();
            return serialize_struct(temp, pRects[HncrKEH]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCLEARATTACHMENTS;
        writeToConn(json);
    }

    void handle_vkCmdResolveImage(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImage srcImage;
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
VkImageLayout srcImageLayout;
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
VkImage dstImage;
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
VkImageLayout dstImageLayout;
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
uint32_t regionCount;
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();
 VkImageResolve* pRegions;
[&](){
            if (json["pRegions"].get_array().size()==0){
                pRegions=NULL;
            return; }pRegions=(VkImageResolve*)malloc(regionCount*sizeof(VkImageResolve));
        auto& arr_XxhLAuH=json["pRegions"].get_array();
        for(int vuJYXjg=0; vuJYXjg < regionCount; vuJYXjg++){
            [&](){
            auto& temp=arr_XxhLAuH[vuJYXjg].get_object();
            deserialize_struct(temp,pRegions[vuJYXjg]);
            }();
        }
        }();

    PFN_vkCmdResolveImage call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResolveImage)get_instance_proc_addr(parent,"vkCmdResolveImage");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResolveImage)get_device_proc_addr(parent,"vkCmdResolveImage");
    }  
    
{
call_function(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_OGNZeww=json["pRegions"].get_array();
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto& temp=arr_OGNZeww[UbqELUx].emplace_object();
            return serialize_struct(temp, pRegions[UbqELUx]);
            }();
        }
        }();


        json["stream_type"]=VKCMDRESOLVEIMAGE;
        writeToConn(json);
    }

    void handle_vkCmdSetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdSetEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetEvent)get_instance_proc_addr(parent,"vkCmdSetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetEvent)get_device_proc_addr(parent,"vkCmdSetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        json["stream_type"]=VKCMDSETEVENT;
        writeToConn(json);
    }

    void handle_vkCmdResetEvent(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags stageMask;
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

    PFN_vkCmdResetEvent call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetEvent)get_instance_proc_addr(parent,"vkCmdResetEvent");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetEvent)get_device_proc_addr(parent,"vkCmdResetEvent");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        json["stream_type"]=VKCMDRESETEVENT;
        writeToConn(json);
    }

    void handle_vkCmdWaitEvents(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){
            if (json["eventCount"].is_uint64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_uint64());
            }else if (json["eventCount"].is_int64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_int64());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].get_double());
            }
            }();
 VkEvent* pEvents;
[&](){
            if (json["pEvents"].get_array().size()==0){
                pEvents=NULL;
            return; }pEvents=(VkEvent*)malloc(eventCount*sizeof(VkEvent));
        auto& arr_QYtHNne=json["pEvents"].get_array();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], pEvents[RuhNVwi]);}();
        }
        }();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_uint64());
            }else if (json["srcStageMask"].is_int64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_int64());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_uint64());
            }else if (json["dstStageMask"].is_int64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_int64());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
uint32_t memoryBarrierCount;
[&](){
            if (json["memoryBarrierCount"].is_uint64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_uint64());
            }else if (json["memoryBarrierCount"].is_int64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_int64());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_double());
            }
            }();
 VkMemoryBarrier* pMemoryBarriers;
[&](){
            if (json["pMemoryBarriers"].get_array().size()==0){
                pMemoryBarriers=NULL;
            return; }pMemoryBarriers=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));
        auto& arr_jpHrKrx=json["pMemoryBarriers"].get_array();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            auto& temp=arr_jpHrKrx[TyfEutX].get_object();
            deserialize_struct(temp,pMemoryBarriers[TyfEutX]);
            }();
        }
        }();
uint32_t bufferMemoryBarrierCount;
[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_uint64());
            }else if (json["bufferMemoryBarrierCount"].is_int64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_int64());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_double());
            }
            }();
 VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){
            if (json["pBufferMemoryBarriers"].get_array().size()==0){
                pBufferMemoryBarriers=NULL;
            return; }pBufferMemoryBarriers=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));
        auto& arr_gVbYbae=json["pBufferMemoryBarriers"].get_array();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            auto& temp=arr_gVbYbae[ewqDhcn].get_object();
            deserialize_struct(temp,pBufferMemoryBarriers[ewqDhcn]);
            }();
        }
        }();
uint32_t imageMemoryBarrierCount;
[&](){
            if (json["imageMemoryBarrierCount"].is_uint64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_uint64());
            }else if (json["imageMemoryBarrierCount"].is_int64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_int64());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_double());
            }
            }();
 VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){
            if (json["pImageMemoryBarriers"].get_array().size()==0){
                pImageMemoryBarriers=NULL;
            return; }pImageMemoryBarriers=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));
        auto& arr_bBtNYaN=json["pImageMemoryBarriers"].get_array();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            auto& temp=arr_bBtNYaN[ASYxaRK].get_object();
            deserialize_struct(temp,pImageMemoryBarriers[ASYxaRK]);
            }();
        }
        }();

    PFN_vkCmdWaitEvents call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWaitEvents)get_instance_proc_addr(parent,"vkCmdWaitEvents");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWaitEvents)get_device_proc_addr(parent,"vkCmdWaitEvents");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }json["pEvents"]=boost::json::array(eventCount);
        auto& arr_tUuyOPJ=json["pEvents"].get_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }json["pMemoryBarriers"]=boost::json::array(memoryBarrierCount);
        auto& arr_fXDYoDs=json["pMemoryBarriers"].get_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }json["pBufferMemoryBarriers"]=boost::json::array(bufferMemoryBarrierCount);
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].get_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }json["pImageMemoryBarriers"]=boost::json::array(imageMemoryBarrierCount);
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].get_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();


        json["stream_type"]=VKCMDWAITEVENTS;
        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags srcStageMask;
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_uint64());
            }else if (json["srcStageMask"].is_int64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_int64());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
VkPipelineStageFlags dstStageMask;
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_uint64());
            }else if (json["dstStageMask"].is_int64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_int64());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
VkDependencyFlags dependencyFlags;
[&](){[&](){int temp_MJCELwI;[&](){
            if (json["dependencyFlags"].is_uint64()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_uint64());
            }else if (json["dependencyFlags"].is_int64()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_int64());
            }else{
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_double());
            }
            }();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
uint32_t memoryBarrierCount;
[&](){
            if (json["memoryBarrierCount"].is_uint64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_uint64());
            }else if (json["memoryBarrierCount"].is_int64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_int64());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_double());
            }
            }();
 VkMemoryBarrier* pMemoryBarriers;
[&](){
            if (json["pMemoryBarriers"].get_array().size()==0){
                pMemoryBarriers=NULL;
            return; }pMemoryBarriers=(VkMemoryBarrier*)malloc(memoryBarrierCount*sizeof(VkMemoryBarrier));
        auto& arr_jpHrKrx=json["pMemoryBarriers"].get_array();
        for(int TyfEutX=0; TyfEutX < memoryBarrierCount; TyfEutX++){
            [&](){
            auto& temp=arr_jpHrKrx[TyfEutX].get_object();
            deserialize_struct(temp,pMemoryBarriers[TyfEutX]);
            }();
        }
        }();
uint32_t bufferMemoryBarrierCount;
[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_uint64());
            }else if (json["bufferMemoryBarrierCount"].is_int64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_int64());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_double());
            }
            }();
 VkBufferMemoryBarrier* pBufferMemoryBarriers;
[&](){
            if (json["pBufferMemoryBarriers"].get_array().size()==0){
                pBufferMemoryBarriers=NULL;
            return; }pBufferMemoryBarriers=(VkBufferMemoryBarrier*)malloc(bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier));
        auto& arr_gVbYbae=json["pBufferMemoryBarriers"].get_array();
        for(int ewqDhcn=0; ewqDhcn < bufferMemoryBarrierCount; ewqDhcn++){
            [&](){
            auto& temp=arr_gVbYbae[ewqDhcn].get_object();
            deserialize_struct(temp,pBufferMemoryBarriers[ewqDhcn]);
            }();
        }
        }();
uint32_t imageMemoryBarrierCount;
[&](){
            if (json["imageMemoryBarrierCount"].is_uint64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_uint64());
            }else if (json["imageMemoryBarrierCount"].is_int64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_int64());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_double());
            }
            }();
 VkImageMemoryBarrier* pImageMemoryBarriers;
[&](){
            if (json["pImageMemoryBarriers"].get_array().size()==0){
                pImageMemoryBarriers=NULL;
            return; }pImageMemoryBarriers=(VkImageMemoryBarrier*)malloc(imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier));
        auto& arr_bBtNYaN=json["pImageMemoryBarriers"].get_array();
        for(int ASYxaRK=0; ASYxaRK < imageMemoryBarrierCount; ASYxaRK++){
            [&](){
            auto& temp=arr_bBtNYaN[ASYxaRK].get_object();
            deserialize_struct(temp,pImageMemoryBarriers[ASYxaRK]);
            }();
        }
        }();

    PFN_vkCmdPipelineBarrier call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPipelineBarrier)get_instance_proc_addr(parent,"vkCmdPipelineBarrier");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPipelineBarrier)get_device_proc_addr(parent,"vkCmdPipelineBarrier");
    }  
    
{
call_function(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=dependencyFlags;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }json["pMemoryBarriers"]=boost::json::array(memoryBarrierCount);
        auto& arr_fXDYoDs=json["pMemoryBarriers"].get_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }json["pBufferMemoryBarriers"]=boost::json::array(bufferMemoryBarrierCount);
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].get_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }json["pImageMemoryBarriers"]=boost::json::array(imageMemoryBarrierCount);
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].get_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();


        json["stream_type"]=VKCMDPIPELINEBARRIER;
        writeToConn(json);
    }

    void handle_vkCmdBeginQuery(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

    PFN_vkCmdBeginQuery call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginQuery)get_instance_proc_addr(parent,"vkCmdBeginQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginQuery)get_device_proc_addr(parent,"vkCmdBeginQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKCMDBEGINQUERY;
        writeToConn(json);
    }

    void handle_vkCmdEndQuery(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

    PFN_vkCmdEndQuery call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndQuery)get_instance_proc_addr(parent,"vkCmdEndQuery");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndQuery)get_device_proc_addr(parent,"vkCmdEndQuery");
    }  
    
{
call_function(commandBuffer, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        json["stream_type"]=VKCMDENDQUERY;
        writeToConn(json);
    }

    void handle_vkCmdBeginConditionalRenderingEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin;
[&](){
            if (json["pConditionalRenderingBegin"].get_array().size()==0){
                pConditionalRenderingBegin=NULL;
            return; }pConditionalRenderingBegin=(VkConditionalRenderingBeginInfoEXT*)malloc(1*sizeof(VkConditionalRenderingBeginInfoEXT));
        auto& arr_OXqnNde=json["pConditionalRenderingBegin"].get_array();
        for(int xncJDyc=0; xncJDyc < 1; xncJDyc++){
            [&](){
            auto& temp=arr_OXqnNde[xncJDyc].get_object();
            deserialize_struct(temp,pConditionalRenderingBegin[xncJDyc]);
            }();
        }
        }();

    PFN_vkCmdBeginConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdBeginConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer, pConditionalRenderingBegin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=boost::json::array();
            return; }json["pConditionalRenderingBegin"]=boost::json::array(1);
        auto& arr_guEoeuh=json["pConditionalRenderingBegin"].get_array();
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto& temp=arr_guEoeuh[KETgcvj].emplace_object();
            return serialize_struct(temp, pConditionalRenderingBegin[KETgcvj]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBEGINCONDITIONALRENDERINGEXT;
        writeToConn(json);
    }

    void handle_vkCmdEndConditionalRenderingEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndConditionalRenderingEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_instance_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndConditionalRenderingEXT)get_device_proc_addr(parent,"vkCmdEndConditionalRenderingEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDENDCONDITIONALRENDERINGEXT;
        writeToConn(json);
    }

    void handle_vkCmdResetQueryPool(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();

    PFN_vkCmdResetQueryPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetQueryPool)get_instance_proc_addr(parent,"vkCmdResetQueryPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetQueryPool)get_device_proc_addr(parent,"vkCmdResetQueryPool");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();


        json["stream_type"]=VKCMDRESETQUERYPOOL;
        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_uint64());
            }else if (json["pipelineStage"].is_int64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_int64());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

    PFN_vkCmdWriteTimestamp call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteTimestamp)get_instance_proc_addr(parent,"vkCmdWriteTimestamp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteTimestamp)get_device_proc_addr(parent,"vkCmdWriteTimestamp");
    }  
    
{
call_function(commandBuffer, pipelineStage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        json["stream_type"]=VKCMDWRITETIMESTAMP;
        writeToConn(json);
    }

    void handle_vkCmdCopyQueryPoolResults(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
uint32_t queryCount;
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
VkDeviceSize stride;
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_int64());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
VkQueryResultFlags flags;
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

    PFN_vkCmdCopyQueryPoolResults call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_instance_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyQueryPoolResults)get_device_proc_addr(parent,"vkCmdCopyQueryPoolResults");
    }  
    
{
call_function(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKCMDCOPYQUERYPOOLRESULTS;
        writeToConn(json);
    }

    void handle_vkCmdPushConstants(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
VkShaderStageFlags stageFlags;
[&](){[&](){int temp_oWGKgUV;[&](){
            if (json["stageFlags"].is_uint64()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_uint64());
            }else if (json["stageFlags"].is_int64()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_int64());
            }else{
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_double());
            }
            }();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
uint32_t offset;
[&](){
            if (json["offset"].is_uint64()){
                offset=static_cast<uint32_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                offset=static_cast<uint32_t>(json["offset"].get_int64());
            }else{
                offset=static_cast<uint32_t>(json["offset"].get_double());
            }
            }();
uint32_t size;
[&](){
            if (json["size"].is_uint64()){
                size=static_cast<uint32_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                size=static_cast<uint32_t>(json["size"].get_int64());
            }else{
                size=static_cast<uint32_t>(json["size"].get_double());
            }
            }();
 void* pValues;
[&](){
            if (json["pValues"].get_array().size()==0){
                pValues=NULL;
            return; }char* temp_JvCgRni;[&](){
            if (json["pValues"].get_array().size()==0){
                temp_JvCgRni=NULL;
            return; }temp_JvCgRni=(char*)malloc(size*sizeof(char));
        auto& arr_iKKgvyR=json["pValues"].get_array();
        for(int msCxIJi=0; msCxIJi < size; msCxIJi++){
            [&](){
            if (arr_iKKgvyR[msCxIJi].is_uint64()){
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].get_uint64());
            }else if (arr_iKKgvyR[msCxIJi].is_int64()){
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].get_int64());
            }else{
                temp_JvCgRni[msCxIJi]=static_cast<char>(arr_iKKgvyR[msCxIJi].get_double());
            }
            }();
        }
        }();pValues=temp_JvCgRni;}();

    PFN_vkCmdPushConstants call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushConstants)get_instance_proc_addr(parent,"vkCmdPushConstants");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushConstants)get_device_proc_addr(parent,"vkCmdPushConstants");
    }  
    
{
call_function(commandBuffer, layout, stageFlags, offset, size, pValues);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=stageFlags;}();}();}();
[&](){json["offset"]=offset;}();
[&](){json["size"]=size;}();
[&](){
            if (pValues==NULL){
                json["pValues"]=boost::json::array();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=boost::json::array();
            return; }json["pValues"]=boost::json::array(size);
        auto& arr_xbuPmvw=json["pValues"].get_array();
        for(int vSvAlWQ=0; vSvAlWQ < size; vSvAlWQ++){
            [&](){arr_xbuPmvw[vSvAlWQ]=((char*)(pValues))[vSvAlWQ];}();
        }
        }();}();


        json["stream_type"]=VKCMDPUSHCONSTANTS;
        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderPassBeginInfo* pRenderPassBegin;
[&](){
            if (json["pRenderPassBegin"].get_array().size()==0){
                pRenderPassBegin=NULL;
            return; }pRenderPassBegin=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));
        auto& arr_DvmhBAI=json["pRenderPassBegin"].get_array();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            auto& temp=arr_DvmhBAI[MzTximI].get_object();
            deserialize_struct(temp,pRenderPassBegin[MzTximI]);
            }();
        }
        }();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_uint64());
            }else if (json["contents"].is_int64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_int64());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].get_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdBeginRenderPass call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRenderPass)get_instance_proc_addr(parent,"vkCmdBeginRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRenderPass)get_device_proc_addr(parent,"vkCmdBeginRenderPass");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }json["pRenderPassBegin"]=boost::json::array(1);
        auto& arr_XtnTubd=json["pRenderPassBegin"].get_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();


        json["stream_type"]=VKCMDBEGINRENDERPASS;
        writeToConn(json);
    }

    void handle_vkCmdNextSubpass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSubpassContents contents;
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_uint64());
            }else if (json["contents"].is_int64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_int64());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].get_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

    PFN_vkCmdNextSubpass call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdNextSubpass)get_instance_proc_addr(parent,"vkCmdNextSubpass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdNextSubpass)get_device_proc_addr(parent,"vkCmdNextSubpass");
    }  
    
{
call_function(commandBuffer, contents);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();


        json["stream_type"]=VKCMDNEXTSUBPASS;
        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRenderPass call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRenderPass)get_instance_proc_addr(parent,"vkCmdEndRenderPass");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRenderPass)get_device_proc_addr(parent,"vkCmdEndRenderPass");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDENDRENDERPASS;
        writeToConn(json);
    }

    void handle_vkCmdExecuteCommands(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t commandBufferCount;
[&](){
            if (json["commandBufferCount"].is_uint64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_uint64());
            }else if (json["commandBufferCount"].is_int64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_int64());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_double());
            }
            }();
 VkCommandBuffer* pCommandBuffers;
[&](){
            if (json["pCommandBuffers"].get_array().size()==0){
                pCommandBuffers=NULL;
            return; }pCommandBuffers=(VkCommandBuffer*)malloc(commandBufferCount*sizeof(VkCommandBuffer));
        auto& arr_aIQpbyi=json["pCommandBuffers"].get_array();
        for(int Neoyndt=0; Neoyndt < commandBufferCount; Neoyndt++){
            [&](){deserialize_VkCommandBuffer(arr_aIQpbyi[Neoyndt], pCommandBuffers[Neoyndt]);}();
        }
        }();

    PFN_vkCmdExecuteCommands call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdExecuteCommands)get_instance_proc_addr(parent,"vkCmdExecuteCommands");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdExecuteCommands)get_device_proc_addr(parent,"vkCmdExecuteCommands");
    }  
    
{
call_function(commandBuffer, commandBufferCount, pCommandBuffers);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(commandBufferCount);
        auto& arr_PdRlpEO=json["pCommandBuffers"].get_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();


        json["stream_type"]=VKCMDEXECUTECOMMANDS;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPropertiesKHR));
        auto& arr_jKVTjSh=json["pProperties"].get_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].get_object();
            deserialize_struct(temp,pProperties[ULwTWiE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_jKVTjSh=json["pProperties"].get_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].emplace_object();
            return serialize_struct(temp, pProperties[ULwTWiE]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayPlanePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlanePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlanePropertiesKHR));
        auto& arr_TBQSgXa=json["pProperties"].get_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].get_object();
            deserialize_struct(temp,pProperties[yGKhOKS]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_TBQSgXa=json["pProperties"].get_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].emplace_object();
            return serialize_struct(temp, pProperties[yGKhOKS]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneSupportedDisplaysKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t planeIndex;
[&](){
            if (json["planeIndex"].is_uint64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_uint64());
            }else if (json["planeIndex"].is_int64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_int64());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_double());
            }
            }();
uint32_t* pDisplayCount;
[&](){
            if (json["pDisplayCount"].get_array().size()==0){
                pDisplayCount=NULL;
            return; }pDisplayCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_HfQXIoE=json["pDisplayCount"].get_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){
            if (arr_HfQXIoE[tJtenSc].is_uint64()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_uint64());
            }else if (arr_HfQXIoE[tJtenSc].is_int64()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_int64());
            }else{
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_double());
            }
            }();
        }
        }();
VkDisplayKHR* pDisplays;
[&](){
            if (json["pDisplays"].get_array().size()==0){
                pDisplays=NULL;
            return; }pDisplays=(VkDisplayKHR*)malloc(*pDisplayCount*sizeof(VkDisplayKHR));
        auto& arr_zfKAWAH=json["pDisplays"].get_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();

    PFN_vkGetDisplayPlaneSupportedDisplaysKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneSupportedDisplaysKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneSupportedDisplaysKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=boost::json::array();
            return; }json["pDisplayCount"]=boost::json::array(1);
        auto& arr_HfQXIoE=json["pDisplayCount"].get_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=pDisplayCount[tJtenSc];}();
        }
        }();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=boost::json::array();
            return; }json["pDisplays"]=boost::json::array(*pDisplayCount);
        auto& arr_zfKAWAH=json["pDisplays"].get_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        }();


        json["stream_type"]=VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR;
        writeToConn(json);
    }

    void handle_vkGetDisplayModePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayModePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModePropertiesKHR*)malloc(*pPropertyCount*sizeof(VkDisplayModePropertiesKHR));
        auto& arr_kllbUBl=json["pProperties"].get_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].get_object();
            deserialize_struct(temp,pProperties[MCBnXbq]);
            }();
        }
        }();

    PFN_vkGetDisplayModePropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_instance_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayModePropertiesKHR)get_device_proc_addr(parent,"vkGetDisplayModePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_kllbUBl=json["pProperties"].get_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].emplace_object();
            return serialize_struct(temp, pProperties[MCBnXbq]);
            }();
        }
        }();


        json["stream_type"]=VKGETDISPLAYMODEPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkCreateDisplayModeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayModeCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDisplayModeCreateInfoKHR*)malloc(1*sizeof(VkDisplayModeCreateInfoKHR));
        auto& arr_UCnUDZD=json["pCreateInfo"].get_array();
        for(int WMiWEeP=0; WMiWEeP < 1; WMiWEeP++){
            [&](){
            auto& temp=arr_UCnUDZD[WMiWEeP].get_object();
            deserialize_struct(temp,pCreateInfo[WMiWEeP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDisplayModeKHR* pMode;
[&](){
            if (json["pMode"].get_array().size()==0){
                pMode=NULL;
            return; }pMode=(VkDisplayModeKHR*)malloc(1*sizeof(VkDisplayModeKHR));
        auto& arr_CHqKWyT=json["pMode"].get_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();

    PFN_vkCreateDisplayModeKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDisplayModeKHR)get_instance_proc_addr(parent,"vkCreateDisplayModeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDisplayModeKHR)get_device_proc_addr(parent,"vkCreateDisplayModeKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_mQflhNS=json["pCreateInfo"].get_array();
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto& temp=arr_mQflhNS[UOiSdEd].emplace_object();
            return serialize_struct(temp, pCreateInfo[UOiSdEd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMode==NULL){
                json["pMode"]=boost::json::array();
            return; }json["pMode"]=boost::json::array(1);
        auto& arr_CHqKWyT=json["pMode"].get_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        }();


        json["stream_type"]=VKCREATEDISPLAYMODEKHR;
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayModeKHR mode;
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
uint32_t planeIndex;
[&](){
            if (json["planeIndex"].is_uint64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_uint64());
            }else if (json["planeIndex"].is_int64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_int64());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_double());
            }
            }();
VkDisplayPlaneCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilitiesKHR*)malloc(1*sizeof(VkDisplayPlaneCapabilitiesKHR));
        auto& arr_HrzVMCr=json["pCapabilities"].get_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].get_object();
            deserialize_struct(temp,pCapabilities[aOxwnlc]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, mode, planeIndex, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_HrzVMCr=json["pCapabilities"].get_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].emplace_object();
            return serialize_struct(temp, pCapabilities[aOxwnlc]);
            }();
        }
        }();


        json["stream_type"]=VKGETDISPLAYPLANECAPABILITIESKHR;
        writeToConn(json);
    }

    void handle_vkCreateDisplayPlaneSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDisplaySurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDisplaySurfaceCreateInfoKHR*)malloc(1*sizeof(VkDisplaySurfaceCreateInfoKHR));
        auto& arr_KiZtqkd=json["pCreateInfo"].get_array();
        for(int MxInMZf=0; MxInMZf < 1; MxInMZf++){
            [&](){
            auto& temp=arr_KiZtqkd[MxInMZf].get_object();
            deserialize_struct(temp,pCreateInfo[MxInMZf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateDisplayPlaneSurfaceKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_instance_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDisplayPlaneSurfaceKHR)get_device_proc_addr(parent,"vkCreateDisplayPlaneSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_pnrRUFC=json["pCreateInfo"].get_array();
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto& temp=arr_pnrRUFC[KAVLDOd].emplace_object();
            return serialize_struct(temp, pCreateInfo[KAVLDOd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        json["stream_type"]=VKCREATEDISPLAYPLANESURFACEKHR;
        writeToConn(json);
    }

    void handle_vkCreateSharedSwapchainsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){
            if (json["swapchainCount"].is_uint64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_uint64());
            }else if (json["swapchainCount"].is_int64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_int64());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_double());
            }
            }();
 VkSwapchainCreateInfoKHR* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkSwapchainCreateInfoKHR*)malloc(swapchainCount*sizeof(VkSwapchainCreateInfoKHR));
        auto& arr_bfxCAiC=json["pCreateInfos"].get_array();
        for(int hPtbvYT=0; hPtbvYT < swapchainCount; hPtbvYT++){
            [&](){
            auto& temp=arr_bfxCAiC[hPtbvYT].get_object();
            deserialize_struct(temp,pCreateInfos[hPtbvYT]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSwapchainKHR* pSwapchains;
[&](){
            if (json["pSwapchains"].get_array().size()==0){
                pSwapchains=NULL;
            return; }pSwapchains=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));
        auto& arr_UlEaWkU=json["pSwapchains"].get_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();

    PFN_vkCreateSharedSwapchainsKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_instance_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSharedSwapchainsKHR)get_device_proc_addr(parent,"vkCreateSharedSwapchainsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(swapchainCount);
        auto& arr_GXhEUBn=json["pCreateInfos"].get_array();
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto& temp=arr_GXhEUBn[KSXdUUO].emplace_object();
            return serialize_struct(temp, pCreateInfos[KSXdUUO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }json["pSwapchains"]=boost::json::array(swapchainCount);
        auto& arr_UlEaWkU=json["pSwapchains"].get_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        }();


        json["stream_type"]=VKCREATESHAREDSWAPCHAINSKHR;
        writeToConn(json);
    }

    void handle_vkDestroySurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySurfaceKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySurfaceKHR)get_instance_proc_addr(parent,"vkDestroySurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySurfaceKHR)get_device_proc_addr(parent,"vkDestroySurfaceKHR");
    }  
    
{
call_function(instance, surface, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSURFACEKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkBool32* pSupported;
[&](){
            if (json["pSupported"].get_array().size()==0){
                pSupported=NULL;
            return; }pSupported=(VkBool32*)malloc(1*sizeof(VkBool32));
        auto& arr_SEnYPHg=json["pSupported"].get_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){
            if (arr_SEnYPHg[rAhuVoM].is_uint64()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_uint64());
            }else if (arr_SEnYPHg[rAhuVoM].is_int64()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_int64());
            }else{
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_double());
            }
            }();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceSupportKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceSupportKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, queueFamilyIndex, surface, pSupported);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=boost::json::array();
            return; }json["pSupported"]=boost::json::array(1);
        auto& arr_SEnYPHg=json["pSupported"].get_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=pSupported[rAhuVoM];}();}();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACESUPPORTKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilitiesKHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilitiesKHR*)malloc(1*sizeof(VkSurfaceCapabilitiesKHR));
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].get_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].get_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIESKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormatsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].get_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_uint64());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_int64());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_double());
            }
            }();
        }
        }();
VkSurfaceFormatKHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].get_array().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormatKHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormatKHR));
        auto& arr_FttXsVA=json["pSurfaceFormats"].get_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].get_object();
            deserialize_struct(temp,pSurfaceFormats[sioXabq]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormatsKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }json["pSurfaceFormatCount"]=boost::json::array(1);
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }json["pSurfaceFormats"]=boost::json::array(*pSurfaceFormatCount);
        auto& arr_FttXsVA=json["pSurfaceFormats"].get_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[sioXabq]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACEFORMATSKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfacePresentModesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pPresentModeCount;
[&](){
            if (json["pPresentModeCount"].get_array().size()==0){
                pPresentModeCount=NULL;
            return; }pPresentModeCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_jrQQyxv=json["pPresentModeCount"].get_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){
            if (arr_jrQQyxv[yThsxfd].is_uint64()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_uint64());
            }else if (arr_jrQQyxv[yThsxfd].is_int64()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_int64());
            }else{
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_double());
            }
            }();
        }
        }();
VkPresentModeKHR* pPresentModes;
[&](){
            if (json["pPresentModes"].get_array().size()==0){
                pPresentModes=NULL;
            return; }pPresentModes=(VkPresentModeKHR*)malloc(*pPresentModeCount*sizeof(VkPresentModeKHR));
        auto& arr_hrNyEFX=json["pPresentModes"].get_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){
            if (arr_hrNyEFX[ULOmMaK].is_uint64()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_uint64());
            }else if (arr_hrNyEFX[ULOmMaK].is_int64()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_int64());
            }else{
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_double());
            }
            }();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfacePresentModesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=boost::json::array();
            return; }json["pPresentModeCount"]=boost::json::array(1);
        auto& arr_jrQQyxv=json["pPresentModeCount"].get_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=pPresentModeCount[yThsxfd];}();
        }
        }();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=boost::json::array();
            return; }json["pPresentModes"]=boost::json::array(*pPresentModeCount);
        auto& arr_hrNyEFX=json["pPresentModes"].get_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=pPresentModes[ULOmMaK];}();}();}();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR;
        writeToConn(json);
    }

    void handle_vkCreateSwapchainKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSwapchainCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSwapchainCreateInfoKHR*)malloc(1*sizeof(VkSwapchainCreateInfoKHR));
        auto& arr_ioKDSXs=json["pCreateInfo"].get_array();
        for(int ugpCvwH=0; ugpCvwH < 1; ugpCvwH++){
            [&](){
            auto& temp=arr_ioKDSXs[ugpCvwH].get_object();
            deserialize_struct(temp,pCreateInfo[ugpCvwH]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSwapchainKHR* pSwapchain;
[&](){
            if (json["pSwapchain"].get_array().size()==0){
                pSwapchain=NULL;
            return; }pSwapchain=(VkSwapchainKHR*)malloc(1*sizeof(VkSwapchainKHR));
        auto& arr_vaTnpgr=json["pSwapchain"].get_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();

    PFN_vkCreateSwapchainKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSwapchainKHR)get_instance_proc_addr(parent,"vkCreateSwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSwapchainKHR)get_device_proc_addr(parent,"vkCreateSwapchainKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSwapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_egkAfIq=json["pCreateInfo"].get_array();
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto& temp=arr_egkAfIq[RzLCOHt].emplace_object();
            return serialize_struct(temp, pCreateInfo[RzLCOHt]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=boost::json::array();
            return; }json["pSwapchain"]=boost::json::array(1);
        auto& arr_vaTnpgr=json["pSwapchain"].get_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        }();


        json["stream_type"]=VKCREATESWAPCHAINKHR;
        writeToConn(json);
    }

    void handle_vkDestroySwapchainKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySwapchainKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySwapchainKHR)get_instance_proc_addr(parent,"vkDestroySwapchainKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySwapchainKHR)get_device_proc_addr(parent,"vkDestroySwapchainKHR");
    }  
    
{
call_function(device, swapchain, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSWAPCHAINKHR;
        writeToConn(json);
    }

    void handle_vkGetSwapchainImagesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pSwapchainImageCount;
[&](){
            if (json["pSwapchainImageCount"].get_array().size()==0){
                pSwapchainImageCount=NULL;
            return; }pSwapchainImageCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].get_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){
            if (arr_fUdbkNA[YVmxCel].is_uint64()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_uint64());
            }else if (arr_fUdbkNA[YVmxCel].is_int64()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_int64());
            }else{
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_double());
            }
            }();
        }
        }();
VkImage* pSwapchainImages;
[&](){
            if (json["pSwapchainImages"].get_array().size()==0){
                pSwapchainImages=NULL;
            return; }pSwapchainImages=(VkImage*)malloc(*pSwapchainImageCount*sizeof(VkImage));
        auto& arr_KNYDiQo=json["pSwapchainImages"].get_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();

    PFN_vkGetSwapchainImagesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainImagesKHR)get_instance_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainImagesKHR)get_device_proc_addr(parent,"vkGetSwapchainImagesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=boost::json::array();
            return; }json["pSwapchainImageCount"]=boost::json::array(1);
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].get_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=pSwapchainImageCount[YVmxCel];}();
        }
        }();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=boost::json::array();
            return; }json["pSwapchainImages"]=boost::json::array(*pSwapchainImageCount);
        auto& arr_KNYDiQo=json["pSwapchainImages"].get_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        }();


        json["stream_type"]=VKGETSWAPCHAINIMAGESKHR;
        writeToConn(json);
    }

    void handle_vkAcquireNextImageKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].get_array().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_uint64());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_int64());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_double());
            }
            }();
        }
        }();

    PFN_vkAcquireNextImageKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireNextImageKHR)get_instance_proc_addr(parent,"vkAcquireNextImageKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireNextImageKHR)get_device_proc_addr(parent,"vkAcquireNextImageKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=timeout;}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }json["pImageIndex"]=boost::json::array(1);
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();


        json["stream_type"]=VKACQUIRENEXTIMAGEKHR;
        writeToConn(json);
    }

    void handle_vkQueuePresentKHR(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkPresentInfoKHR* pPresentInfo;
[&](){
            if (json["pPresentInfo"].get_array().size()==0){
                pPresentInfo=NULL;
            return; }pPresentInfo=(VkPresentInfoKHR*)malloc(1*sizeof(VkPresentInfoKHR));
        auto& arr_lGNUHER=json["pPresentInfo"].get_array();
        for(int gefTrKz=0; gefTrKz < 1; gefTrKz++){
            [&](){
            auto& temp=arr_lGNUHER[gefTrKz].get_object();
            deserialize_struct(temp,pPresentInfo[gefTrKz]);
            }();
        }
        }();

    PFN_vkQueuePresentKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueuePresentKHR)get_instance_proc_addr(parent,"vkQueuePresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueuePresentKHR)get_device_proc_addr(parent,"vkQueuePresentKHR");
    }  
    
VkResult  result;
{
result=call_function(queue, pPresentInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=boost::json::array();
            return; }json["pPresentInfo"]=boost::json::array(1);
        auto& arr_EyhZHrS=json["pPresentInfo"].get_array();
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto& temp=arr_EyhZHrS[EKHdNlu].emplace_object();
            return serialize_struct(temp, pPresentInfo[EKHdNlu]);
            }();
        }
        }();


        json["stream_type"]=VKQUEUEPRESENTKHR;
        writeToConn(json);
    }

    void handle_vkCreateXlibSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkXlibSurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkXlibSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXlibSurfaceCreateInfoKHR));
        auto& arr_wdGSkCh=json["pCreateInfo"].get_array();
        for(int iNgqKFe=0; iNgqKFe < 1; iNgqKFe++){
            [&](){
            auto& temp=arr_wdGSkCh[iNgqKFe].get_object();
            deserialize_struct(temp,pCreateInfo[iNgqKFe]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXlibSurfaceKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateXlibSurfaceKHR)get_device_proc_addr(parent,"vkCreateXlibSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_xAdBgFR=json["pCreateInfo"].get_array();
        for(int sMWpcdX=0; sMWpcdX < 1; sMWpcdX++){
            [&](){
            auto& temp=arr_xAdBgFR[sMWpcdX].emplace_object();
            return serialize_struct(temp, pCreateInfo[sMWpcdX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        json["stream_type"]=VKCREATEXLIBSURFACEKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXlibPresentationSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
Display* dpy;
[&](){
            if (json["dpy"].get_array().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(value_to<uintptr_t>(json["dpy"]));}();
VisualID visualID;
[&](){visualID=(VisualID )(value_to<uintptr_t>(json["visualID"]));}();

    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXlibPresentationSupportKHR");
    }  
    
VkBool32  result;
{
result=call_function(physicalDevice, queueFamilyIndex, dpy, visualID);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (dpy==NULL){
                json["dpy"]=boost::json::array();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();


        json["stream_type"]=VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR;
        writeToConn(json);
    }

    void handle_vkCreateXcbSurfaceKHR(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkXcbSurfaceCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkXcbSurfaceCreateInfoKHR*)malloc(1*sizeof(VkXcbSurfaceCreateInfoKHR));
        auto& arr_fIYRZSR=json["pCreateInfo"].get_array();
        for(int QDYAgHl=0; QDYAgHl < 1; QDYAgHl++){
            [&](){
            auto& temp=arr_fIYRZSR[QDYAgHl].get_object();
            deserialize_struct(temp,pCreateInfo[QDYAgHl]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateXcbSurfaceKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_instance_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateXcbSurfaceKHR)get_device_proc_addr(parent,"vkCreateXcbSurfaceKHR");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_yvWYCbg=json["pCreateInfo"].get_array();
        for(int DeNvCZU=0; DeNvCZU < 1; DeNvCZU++){
            [&](){
            auto& temp=arr_yvWYCbg[DeNvCZU].emplace_object();
            return serialize_struct(temp, pCreateInfo[DeNvCZU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        json["stream_type"]=VKCREATEXCBSURFACEKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceXcbPresentationSupportKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
xcb_connection_t* connection;
[&](){
            if (json["connection"].get_array().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(value_to<uintptr_t>(json["connection"]));}();
xcb_visualid_t visual_id;
[&](){visual_id=(xcb_visualid_t )(value_to<uintptr_t>(json["visual_id"]));}();

    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceXcbPresentationSupportKHR");
    }  
    
VkBool32  result;
{
result=call_function(physicalDevice, queueFamilyIndex, connection, visual_id);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (connection==NULL){
                json["connection"]=boost::json::array();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();


        json["stream_type"]=VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR;
        writeToConn(json);
    }

    void handle_vkCreateDebugReportCallbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDebugReportCallbackCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDebugReportCallbackCreateInfoEXT*)malloc(1*sizeof(VkDebugReportCallbackCreateInfoEXT));
        auto& arr_bvXzZVI=json["pCreateInfo"].get_array();
        for(int wOLpuxo=0; wOLpuxo < 1; wOLpuxo++){
            [&](){
            auto& temp=arr_bvXzZVI[wOLpuxo].get_object();
            deserialize_struct(temp,pCreateInfo[wOLpuxo]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDebugReportCallbackEXT* pCallback;
[&](){
            if (json["pCallback"].get_array().size()==0){
                pCallback=NULL;
            return; }pCallback=(VkDebugReportCallbackEXT*)malloc(1*sizeof(VkDebugReportCallbackEXT));
        auto& arr_qwLilWz=json["pCallback"].get_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();

    PFN_vkCreateDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDebugReportCallbackEXT)get_device_proc_addr(parent,"vkCreateDebugReportCallbackEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pCallback);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_YvgjHhM=json["pCreateInfo"].get_array();
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto& temp=arr_YvgjHhM[BsRBklZ].emplace_object();
            return serialize_struct(temp, pCreateInfo[BsRBklZ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=boost::json::array();
            return; }json["pCallback"]=boost::json::array(1);
        auto& arr_qwLilWz=json["pCallback"].get_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        }();


        json["stream_type"]=VKCREATEDEBUGREPORTCALLBACKEXT;
        writeToConn(json);
    }

    void handle_vkDestroyDebugReportCallbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportCallbackEXT callback;
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDebugReportCallbackEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_instance_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDebugReportCallbackEXT)get_device_proc_addr(parent,"vkDestroyDebugReportCallbackEXT");
    }  
    
{
call_function(instance, callback, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDEBUGREPORTCALLBACKEXT;
        writeToConn(json);
    }

    void handle_vkDebugReportMessageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugReportFlagsEXT flags;
[&](){[&](){int temp_tiROuYA;[&](){
            if (json["flags"].is_uint64()){
                temp_tiROuYA=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_tiROuYA=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_tiROuYA=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
VkDebugReportObjectTypeEXT objectType;
[&](){[&](){int temp_rGtGMFh;[&](){
            if (json["objectType"].is_uint64()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
uint64_t object;
[&](){
            if (json["object"].is_uint64()){
                object=static_cast<uint64_t>(json["object"].get_uint64());
            }else if (json["object"].is_int64()){
                object=static_cast<uint64_t>(json["object"].get_int64());
            }else{
                object=static_cast<uint64_t>(json["object"].get_double());
            }
            }();
size_t location;
[&](){
            if (json["location"].is_uint64()){
                location=static_cast<size_t>(json["location"].get_uint64());
            }else if (json["location"].is_int64()){
                location=static_cast<size_t>(json["location"].get_int64());
            }else{
                location=static_cast<size_t>(json["location"].get_double());
            }
            }();
int32_t messageCode;
[&](){
            if (json["messageCode"].is_uint64()){
                messageCode=static_cast<int32_t>(json["messageCode"].get_uint64());
            }else if (json["messageCode"].is_int64()){
                messageCode=static_cast<int32_t>(json["messageCode"].get_int64());
            }else{
                messageCode=static_cast<int32_t>(json["messageCode"].get_double());
            }
            }();
 char* pLayerPrefix;
[&](){
            if (json["pLayerPrefix"].get_array().size()==0){
                pLayerPrefix=NULL;
            return; }pLayerPrefix=(char*)malloc(json["pLayerPrefix"].get_array().size()*sizeof(char));
        auto& arr_uXlnNyO=json["pLayerPrefix"].get_array();
        for(int tgIwrYh=0; tgIwrYh < json["pLayerPrefix"].get_array().size(); tgIwrYh++){
            [&](){
            if (arr_uXlnNyO[tgIwrYh].is_uint64()){
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].get_uint64());
            }else if (arr_uXlnNyO[tgIwrYh].is_int64()){
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].get_int64());
            }else{
                pLayerPrefix[tgIwrYh]=static_cast<char>(arr_uXlnNyO[tgIwrYh].get_double());
            }
            }();
        }
        }();
 char* pMessage;
[&](){
            if (json["pMessage"].get_array().size()==0){
                pMessage=NULL;
            return; }pMessage=(char*)malloc(json["pMessage"].get_array().size()*sizeof(char));
        auto& arr_hjvjHsV=json["pMessage"].get_array();
        for(int WEDXGTi=0; WEDXGTi < json["pMessage"].get_array().size(); WEDXGTi++){
            [&](){
            if (arr_hjvjHsV[WEDXGTi].is_uint64()){
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].get_uint64());
            }else if (arr_hjvjHsV[WEDXGTi].is_int64()){
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].get_int64());
            }else{
                pMessage[WEDXGTi]=static_cast<char>(arr_hjvjHsV[WEDXGTi].get_double());
            }
            }();
        }
        }();

    PFN_vkDebugReportMessageEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugReportMessageEXT)get_instance_proc_addr(parent,"vkDebugReportMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugReportMessageEXT)get_device_proc_addr(parent,"vkDebugReportMessageEXT");
    }  
    
{
call_function(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }json["pLayerPrefix"]=boost::json::array(strlen(pLayerPrefix)+1);
        auto& arr_SZVAgkt=json["pLayerPrefix"].get_array();
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=pLayerPrefix[ESuRCqF];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }json["pMessage"]=boost::json::array(strlen(pMessage)+1);
        auto& arr_rGBBIki=json["pMessage"].get_array();
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=pMessage[ZYKcZZQ];}();
        }
        }();


        json["stream_type"]=VKDEBUGREPORTMESSAGEEXT;
        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectNameEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugMarkerObjectNameInfoEXT* pNameInfo;
[&](){
            if (json["pNameInfo"].get_array().size()==0){
                pNameInfo=NULL;
            return; }pNameInfo=(VkDebugMarkerObjectNameInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectNameInfoEXT));
        auto& arr_VqYlRlZ=json["pNameInfo"].get_array();
        for(int rPEeNJT=0; rPEeNJT < 1; rPEeNJT++){
            [&](){
            auto& temp=arr_VqYlRlZ[rPEeNJT].get_object();
            deserialize_struct(temp,pNameInfo[rPEeNJT]);
            }();
        }
        }();

    PFN_vkDebugMarkerSetObjectNameEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugMarkerSetObjectNameEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectNameEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }json["pNameInfo"]=boost::json::array(1);
        auto& arr_WQmILKl=json["pNameInfo"].get_array();
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto& temp=arr_WQmILKl[VlhHang].emplace_object();
            return serialize_struct(temp, pNameInfo[VlhHang]);
            }();
        }
        }();


        json["stream_type"]=VKDEBUGMARKERSETOBJECTNAMEEXT;
        writeToConn(json);
    }

    void handle_vkDebugMarkerSetObjectTagEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugMarkerObjectTagInfoEXT* pTagInfo;
[&](){
            if (json["pTagInfo"].get_array().size()==0){
                pTagInfo=NULL;
            return; }pTagInfo=(VkDebugMarkerObjectTagInfoEXT*)malloc(1*sizeof(VkDebugMarkerObjectTagInfoEXT));
        auto& arr_RbbYJqv=json["pTagInfo"].get_array();
        for(int RnIbuuZ=0; RnIbuuZ < 1; RnIbuuZ++){
            [&](){
            auto& temp=arr_RbbYJqv[RnIbuuZ].get_object();
            deserialize_struct(temp,pTagInfo[RnIbuuZ]);
            }();
        }
        }();

    PFN_vkDebugMarkerSetObjectTagEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_instance_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDebugMarkerSetObjectTagEXT)get_device_proc_addr(parent,"vkDebugMarkerSetObjectTagEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }json["pTagInfo"]=boost::json::array(1);
        auto& arr_uESKIxS=json["pTagInfo"].get_array();
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto& temp=arr_uESKIxS[fibGciH].emplace_object();
            return serialize_struct(temp, pTagInfo[fibGciH]);
            }();
        }
        }();


        json["stream_type"]=VKDEBUGMARKERSETOBJECTTAGEXT;
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerBeginEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].get_array().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));
        auto& arr_dufSdWh=json["pMarkerInfo"].get_array();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            auto& temp=arr_dufSdWh[wWwHKWF].get_object();
            deserialize_struct(temp,pMarkerInfo[wWwHKWF]);
            }();
        }
        }();

    PFN_vkCmdDebugMarkerBeginEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerBeginEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerBeginEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_sUKpmoY=json["pMarkerInfo"].get_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();


        json["stream_type"]=VKCMDDEBUGMARKERBEGINEXT;
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerEndEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdDebugMarkerEndEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerEndEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerEndEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDDEBUGMARKERENDEXT;
        writeToConn(json);
    }

    void handle_vkCmdDebugMarkerInsertEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugMarkerMarkerInfoEXT* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].get_array().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkDebugMarkerMarkerInfoEXT*)malloc(1*sizeof(VkDebugMarkerMarkerInfoEXT));
        auto& arr_dufSdWh=json["pMarkerInfo"].get_array();
        for(int wWwHKWF=0; wWwHKWF < 1; wWwHKWF++){
            [&](){
            auto& temp=arr_dufSdWh[wWwHKWF].get_object();
            deserialize_struct(temp,pMarkerInfo[wWwHKWF]);
            }();
        }
        }();

    PFN_vkCmdDebugMarkerInsertEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_instance_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDebugMarkerInsertEXT)get_device_proc_addr(parent,"vkCmdDebugMarkerInsertEXT");
    }  
    
{
call_function(commandBuffer, pMarkerInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_sUKpmoY=json["pMarkerInfo"].get_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();


        json["stream_type"]=VKCMDDEBUGMARKERINSERTEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkImageType type;
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
VkImageTiling tiling;
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
VkImageUsageFlags usage;
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
VkImageCreateFlags flags;
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
VkExternalMemoryHandleTypeFlagsNV externalHandleType;
[&](){[&](){int temp_DSfbDyM;[&](){
            if (json["externalHandleType"].is_uint64()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_uint64());
            }else if (json["externalHandleType"].is_int64()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_int64());
            }else{
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_double());
            }
            }();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties;
[&](){
            if (json["pExternalImageFormatProperties"].get_array().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }pExternalImageFormatProperties=(VkExternalImageFormatPropertiesNV*)malloc(1*sizeof(VkExternalImageFormatPropertiesNV));
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].get_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].get_object();
            deserialize_struct(temp,pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=externalHandleType;}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=boost::json::array();
            return; }json["pExternalImageFormatProperties"]=boost::json::array(1);
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].get_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].emplace_object();
            return serialize_struct(temp, pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV;
        writeToConn(json);
    }

    void handle_vkCmdExecuteGeneratedCommandsNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 isPreprocessed;
[&](){uint32_t temp_tPMaOPc;[&](){
            if (json["isPreprocessed"].is_uint64()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_uint64());
            }else if (json["isPreprocessed"].is_int64()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_int64());
            }else{
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_double());
            }
            }();isPreprocessed=(VkBool32)temp_tPMaOPc;}();
 VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){
            if (json["pGeneratedCommandsInfo"].get_array().size()==0){
                pGeneratedCommandsInfo=NULL;
            return; }pGeneratedCommandsInfo=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));
        auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].get_array();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            auto& temp=arr_HWCDzqJ[ZktpRSr].get_object();
            deserialize_struct(temp,pGeneratedCommandsInfo[ZktpRSr]);
            }();
        }
        }();

    PFN_vkCmdExecuteGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdExecuteGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdExecuteGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=isPreprocessed;}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }json["pGeneratedCommandsInfo"]=boost::json::array(1);
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].get_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();


        json["stream_type"]=VKCMDEXECUTEGENERATEDCOMMANDSNV;
        writeToConn(json);
    }

    void handle_vkCmdPreprocessGeneratedCommandsNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo;
[&](){
            if (json["pGeneratedCommandsInfo"].get_array().size()==0){
                pGeneratedCommandsInfo=NULL;
            return; }pGeneratedCommandsInfo=(VkGeneratedCommandsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsInfoNV));
        auto& arr_HWCDzqJ=json["pGeneratedCommandsInfo"].get_array();
        for(int ZktpRSr=0; ZktpRSr < 1; ZktpRSr++){
            [&](){
            auto& temp=arr_HWCDzqJ[ZktpRSr].get_object();
            deserialize_struct(temp,pGeneratedCommandsInfo[ZktpRSr]);
            }();
        }
        }();

    PFN_vkCmdPreprocessGeneratedCommandsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_instance_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPreprocessGeneratedCommandsNV)get_device_proc_addr(parent,"vkCmdPreprocessGeneratedCommandsNV");
    }  
    
{
call_function(commandBuffer, pGeneratedCommandsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }json["pGeneratedCommandsInfo"]=boost::json::array(1);
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].get_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();


        json["stream_type"]=VKCMDPREPROCESSGENERATEDCOMMANDSNV;
        writeToConn(json);
    }

    void handle_vkCmdBindPipelineShaderGroupNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t groupIndex;
[&](){
            if (json["groupIndex"].is_uint64()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_uint64());
            }else if (json["groupIndex"].is_int64()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_int64());
            }else{
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_double());
            }
            }();

    PFN_vkCmdBindPipelineShaderGroupNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_instance_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindPipelineShaderGroupNV)get_device_proc_addr(parent,"vkCmdBindPipelineShaderGroupNV");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=groupIndex;}();


        json["stream_type"]=VKCMDBINDPIPELINESHADERGROUPNV;
        writeToConn(json);
    }

    void handle_vkGetGeneratedCommandsMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkGeneratedCommandsMemoryRequirementsInfoNV*)malloc(1*sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV));
        auto& arr_KgvktJY=json["pInfo"].get_array();
        for(int JNwrpFH=0; JNwrpFH < 1; JNwrpFH++){
            [&](){
            auto& temp=arr_KgvktJY[JNwrpFH].get_object();
            deserialize_struct(temp,pInfo[JNwrpFH]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetGeneratedCommandsMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetGeneratedCommandsMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetGeneratedCommandsMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_bVjZkmU=json["pInfo"].get_array();
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto& temp=arr_bVjZkmU[suoLDtj].emplace_object();
            return serialize_struct(temp, pInfo[suoLDtj]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV;
        writeToConn(json);
    }

    void handle_vkCreateIndirectCommandsLayoutNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkIndirectCommandsLayoutCreateInfoNV*)malloc(1*sizeof(VkIndirectCommandsLayoutCreateInfoNV));
        auto& arr_moJlSYv=json["pCreateInfo"].get_array();
        for(int GBtaMlf=0; GBtaMlf < 1; GBtaMlf++){
            [&](){
            auto& temp=arr_moJlSYv[GBtaMlf].get_object();
            deserialize_struct(temp,pCreateInfo[GBtaMlf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkIndirectCommandsLayoutNV* pIndirectCommandsLayout;
[&](){
            if (json["pIndirectCommandsLayout"].get_array().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }pIndirectCommandsLayout=(VkIndirectCommandsLayoutNV*)malloc(1*sizeof(VkIndirectCommandsLayoutNV));
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].get_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();

    PFN_vkCreateIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkCreateIndirectCommandsLayoutNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_EQPGiEt=json["pCreateInfo"].get_array();
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto& temp=arr_EQPGiEt[TPVCKbG].emplace_object();
            return serialize_struct(temp, pCreateInfo[TPVCKbG]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=boost::json::array();
            return; }json["pIndirectCommandsLayout"]=boost::json::array(1);
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].get_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        }();


        json["stream_type"]=VKCREATEINDIRECTCOMMANDSLAYOUTNV;
        writeToConn(json);
    }

    void handle_vkDestroyIndirectCommandsLayoutNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkIndirectCommandsLayoutNV indirectCommandsLayout;
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyIndirectCommandsLayoutNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_instance_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyIndirectCommandsLayoutNV)get_device_proc_addr(parent,"vkDestroyIndirectCommandsLayoutNV");
    }  
    
{
call_function(device, indirectCommandsLayout, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYINDIRECTCOMMANDSLAYOUTNV;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFeatures2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceFeatures2* pFeatures;
[&](){
            if (json["pFeatures"].get_array().size()==0){
                pFeatures=NULL;
            return; }pFeatures=(VkPhysicalDeviceFeatures2*)malloc(1*sizeof(VkPhysicalDeviceFeatures2));
        auto& arr_QUwriqy=json["pFeatures"].get_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].get_object();
            deserialize_struct(temp,pFeatures[AlewVZE]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFeatures2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFeatures2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFeatures2");
    }  
    
{
call_function(physicalDevice, pFeatures);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }json["pFeatures"]=boost::json::array(1);
        auto& arr_QUwriqy=json["pFeatures"].get_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].emplace_object();
            return serialize_struct(temp, pFeatures[AlewVZE]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEFEATURES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceProperties2* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPhysicalDeviceProperties2*)malloc(1*sizeof(VkPhysicalDeviceProperties2));
        auto& arr_oZVBLox=json["pProperties"].get_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].get_object();
            deserialize_struct(temp,pProperties[pxUpVYV]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceProperties2");
    }  
    
{
call_function(physicalDevice, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_oZVBLox=json["pProperties"].get_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].emplace_object();
            return serialize_struct(temp, pProperties[pxUpVYV]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkFormat format;
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
VkFormatProperties2* pFormatProperties;
[&](){
            if (json["pFormatProperties"].get_array().size()==0){
                pFormatProperties=NULL;
            return; }pFormatProperties=(VkFormatProperties2*)malloc(1*sizeof(VkFormatProperties2));
        auto& arr_RNYTnLU=json["pFormatProperties"].get_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].get_object();
            deserialize_struct(temp,pFormatProperties[VZFdkqX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFormatProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceFormatProperties2");
    }  
    
{
call_function(physicalDevice, format, pFormatProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }json["pFormatProperties"]=boost::json::array(1);
        auto& arr_RNYTnLU=json["pFormatProperties"].get_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].emplace_object();
            return serialize_struct(temp, pFormatProperties[VZFdkqX]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceImageFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo;
[&](){
            if (json["pImageFormatInfo"].get_array().size()==0){
                pImageFormatInfo=NULL;
            return; }pImageFormatInfo=(VkPhysicalDeviceImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceImageFormatInfo2));
        auto& arr_DmAdZhK=json["pImageFormatInfo"].get_array();
        for(int ZeNdrVN=0; ZeNdrVN < 1; ZeNdrVN++){
            [&](){
            auto& temp=arr_DmAdZhK[ZeNdrVN].get_object();
            deserialize_struct(temp,pImageFormatInfo[ZeNdrVN]);
            }();
        }
        }();
VkImageFormatProperties2* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkImageFormatProperties2*)malloc(1*sizeof(VkImageFormatProperties2));
        auto& arr_wmAZzRc=json["pImageFormatProperties"].get_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].get_object();
            deserialize_struct(temp,pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceImageFormatProperties2");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=boost::json::array();
            return; }json["pImageFormatInfo"]=boost::json::array(1);
        auto& arr_MpVGyYe=json["pImageFormatInfo"].get_array();
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto& temp=arr_MpVGyYe[YAeYFEt].emplace_object();
            return serialize_struct(temp, pImageFormatInfo[YAeYFEt]);
            }();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(1);
        auto& arr_wmAZzRc=json["pImageFormatProperties"].get_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pQueueFamilyPropertyCount;
[&](){
            if (json["pQueueFamilyPropertyCount"].get_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }pQueueFamilyPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_uint64());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_int64());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_double());
            }
            }();
        }
        }();
VkQueueFamilyProperties2* pQueueFamilyProperties;
[&](){
            if (json["pQueueFamilyProperties"].get_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }pQueueFamilyProperties=(VkQueueFamilyProperties2*)malloc(*pQueueFamilyPropertyCount*sizeof(VkQueueFamilyProperties2));
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].get_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].get_object();
            deserialize_struct(temp,pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyProperties2");
    }  
    
{
call_function(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }json["pQueueFamilyPropertyCount"]=boost::json::array(1);
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }json["pQueueFamilyProperties"]=boost::json::array(*pQueueFamilyPropertyCount);
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].get_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMemoryProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkPhysicalDeviceMemoryProperties2* pMemoryProperties;
[&](){
            if (json["pMemoryProperties"].get_array().size()==0){
                pMemoryProperties=NULL;
            return; }pMemoryProperties=(VkPhysicalDeviceMemoryProperties2*)malloc(1*sizeof(VkPhysicalDeviceMemoryProperties2));
        auto& arr_nJXNYGt=json["pMemoryProperties"].get_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].get_object();
            deserialize_struct(temp,pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMemoryProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMemoryProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceMemoryProperties2");
    }  
    
{
call_function(physicalDevice, pMemoryProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }json["pMemoryProperties"]=boost::json::array(1);
        auto& arr_nJXNYGt=json["pMemoryProperties"].get_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].emplace_object();
            return serialize_struct(temp, pMemoryProperties[tFDFCkf]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSparseImageFormatProperties2(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo;
[&](){
            if (json["pFormatInfo"].get_array().size()==0){
                pFormatInfo=NULL;
            return; }pFormatInfo=(VkPhysicalDeviceSparseImageFormatInfo2*)malloc(1*sizeof(VkPhysicalDeviceSparseImageFormatInfo2));
        auto& arr_NQMYVvv=json["pFormatInfo"].get_array();
        for(int SsKlkUy=0; SsKlkUy < 1; SsKlkUy++){
            [&](){
            auto& temp=arr_NQMYVvv[SsKlkUy].get_object();
            deserialize_struct(temp,pFormatInfo[SsKlkUy]);
            }();
        }
        }();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkSparseImageFormatProperties2* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkSparseImageFormatProperties2*)malloc(*pPropertyCount*sizeof(VkSparseImageFormatProperties2));
        auto& arr_YaLkATe=json["pProperties"].get_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].get_object();
            deserialize_struct(temp,pProperties[lIrIGCv]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)get_device_proc_addr(parent,"vkGetPhysicalDeviceSparseImageFormatProperties2");
    }  
    
{
call_function(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=boost::json::array();
            return; }json["pFormatInfo"]=boost::json::array(1);
        auto& arr_nZOUWlt=json["pFormatInfo"].get_array();
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto& temp=arr_nZOUWlt[cvknnOe].emplace_object();
            return serialize_struct(temp, pFormatInfo[cvknnOe]);
            }();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_YaLkATe=json["pProperties"].get_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].emplace_object();
            return serialize_struct(temp, pProperties[lIrIGCv]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2;
        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();
uint32_t descriptorWriteCount;
[&](){
            if (json["descriptorWriteCount"].is_uint64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_uint64());
            }else if (json["descriptorWriteCount"].is_int64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_int64());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_double());
            }
            }();
 VkWriteDescriptorSet* pDescriptorWrites;
[&](){
            if (json["pDescriptorWrites"].get_array().size()==0){
                pDescriptorWrites=NULL;
            return; }pDescriptorWrites=(VkWriteDescriptorSet*)malloc(descriptorWriteCount*sizeof(VkWriteDescriptorSet));
        auto& arr_YJcGFpk=json["pDescriptorWrites"].get_array();
        for(int PyFuMgH=0; PyFuMgH < descriptorWriteCount; PyFuMgH++){
            [&](){
            auto& temp=arr_YJcGFpk[PyFuMgH].get_object();
            deserialize_struct(temp,pDescriptorWrites[PyFuMgH]);
            }();
        }
        }();

    PFN_vkCmdPushDescriptorSetKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushDescriptorSetKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetKHR");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }json["pDescriptorWrites"]=boost::json::array(descriptorWriteCount);
        auto& arr_AuOrFWk=json["pDescriptorWrites"].get_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();


        json["stream_type"]=VKCMDPUSHDESCRIPTORSETKHR;
        writeToConn(json);
    }

    void handle_vkTrimCommandPool(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCommandPool commandPool;
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
VkCommandPoolTrimFlags flags;
[&](){[&](){int temp_FGvozFl;[&](){
            if (json["flags"].is_uint64()){
                temp_FGvozFl=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_FGvozFl=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_FGvozFl=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

    PFN_vkTrimCommandPool call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkTrimCommandPool)get_instance_proc_addr(parent,"vkTrimCommandPool");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkTrimCommandPool)get_device_proc_addr(parent,"vkTrimCommandPool");
    }  
    
{
call_function(device, commandPool, flags);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();


        json["stream_type"]=VKTRIMCOMMANDPOOL;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalBufferProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo;
[&](){
            if (json["pExternalBufferInfo"].get_array().size()==0){
                pExternalBufferInfo=NULL;
            return; }pExternalBufferInfo=(VkPhysicalDeviceExternalBufferInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalBufferInfo));
        auto& arr_ISfKJVQ=json["pExternalBufferInfo"].get_array();
        for(int rmWnLWl=0; rmWnLWl < 1; rmWnLWl++){
            [&](){
            auto& temp=arr_ISfKJVQ[rmWnLWl].get_object();
            deserialize_struct(temp,pExternalBufferInfo[rmWnLWl]);
            }();
        }
        }();
VkExternalBufferProperties* pExternalBufferProperties;
[&](){
            if (json["pExternalBufferProperties"].get_array().size()==0){
                pExternalBufferProperties=NULL;
            return; }pExternalBufferProperties=(VkExternalBufferProperties*)malloc(1*sizeof(VkExternalBufferProperties));
        auto& arr_oXzExYk=json["pExternalBufferProperties"].get_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].get_object();
            deserialize_struct(temp,pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalBufferProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalBufferProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalBufferProperties");
    }  
    
{
call_function(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=boost::json::array();
            return; }json["pExternalBufferInfo"]=boost::json::array(1);
        auto& arr_VbIxQJg=json["pExternalBufferInfo"].get_array();
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto& temp=arr_VbIxQJg[XeSwNaV].emplace_object();
            return serialize_struct(temp, pExternalBufferInfo[XeSwNaV]);
            }();
        }
        }();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=boost::json::array();
            return; }json["pExternalBufferProperties"]=boost::json::array(1);
        auto& arr_oXzExYk=json["pExternalBufferProperties"].get_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].emplace_object();
            return serialize_struct(temp, pExternalBufferProperties[ufvutei]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetMemoryFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].get_array().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkMemoryGetFdInfoKHR*)malloc(1*sizeof(VkMemoryGetFdInfoKHR));
        auto& arr_YGnGiDl=json["pGetFdInfo"].get_array();
        for(int QwmRuDs=0; QwmRuDs < 1; QwmRuDs++){
            [&](){
            auto& temp=arr_YGnGiDl[QwmRuDs].get_object();
            deserialize_struct(temp,pGetFdInfo[QwmRuDs]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();

    PFN_vkGetMemoryFdKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryFdKHR)get_instance_proc_addr(parent,"vkGetMemoryFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryFdKHR)get_device_proc_addr(parent,"vkGetMemoryFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_imCbcqk=json["pGetFdInfo"].get_array();
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto& temp=arr_imCbcqk[oZoTEJx].emplace_object();
            return serialize_struct(temp, pGetFdInfo[oZoTEJx]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        json["stream_type"]=VKGETMEMORYFDKHR;
        writeToConn(json);
    }

    void handle_vkGetMemoryFdPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_uint64());
            }else if (json["handleType"].is_int64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_int64());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
int fd;
[&](){
            if (json["fd"].is_uint64()){
                fd=static_cast<int>(json["fd"].get_uint64());
            }else if (json["fd"].is_int64()){
                fd=static_cast<int>(json["fd"].get_int64());
            }else{
                fd=static_cast<int>(json["fd"].get_double());
            }
            }();
VkMemoryFdPropertiesKHR* pMemoryFdProperties;
[&](){
            if (json["pMemoryFdProperties"].get_array().size()==0){
                pMemoryFdProperties=NULL;
            return; }pMemoryFdProperties=(VkMemoryFdPropertiesKHR*)malloc(1*sizeof(VkMemoryFdPropertiesKHR));
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].get_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].get_object();
            deserialize_struct(temp,pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();

    PFN_vkGetMemoryFdPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_instance_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryFdPropertiesKHR)get_device_proc_addr(parent,"vkGetMemoryFdPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, handleType, fd, pMemoryFdProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){json["fd"]=fd;}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=boost::json::array();
            return; }json["pMemoryFdProperties"]=boost::json::array(1);
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].get_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].emplace_object();
            return serialize_struct(temp, pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();


        json["stream_type"]=VKGETMEMORYFDPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkGetMemoryRemoteAddressNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo;
[&](){
            if (json["pMemoryGetRemoteAddressInfo"].get_array().size()==0){
                pMemoryGetRemoteAddressInfo=NULL;
            return; }pMemoryGetRemoteAddressInfo=(VkMemoryGetRemoteAddressInfoNV*)malloc(1*sizeof(VkMemoryGetRemoteAddressInfoNV));
        auto& arr_qzVONyK=json["pMemoryGetRemoteAddressInfo"].get_array();
        for(int vBoigyh=0; vBoigyh < 1; vBoigyh++){
            [&](){
            auto& temp=arr_qzVONyK[vBoigyh].get_object();
            deserialize_struct(temp,pMemoryGetRemoteAddressInfo[vBoigyh]);
            }();
        }
        }();
VkRemoteAddressNV* pAddress;
[&](){
            if (json["pAddress"].get_array().size()==0){
                pAddress=NULL;
            return; }pAddress=(VkRemoteAddressNV*)malloc(1*sizeof(VkRemoteAddressNV));
        auto& arr_LTIxmQF=json["pAddress"].get_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].get_array().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].get_array().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].get_array().size()*sizeof(char));
        auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].get_array();
        for(int lBwzqzO=0; lBwzqzO < arr_LTIxmQF[LIvckbR].get_array().size(); lBwzqzO++){
            [&](){
            if (arr_FUzakvN[lBwzqzO].is_uint64()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_uint64());
            }else if (arr_FUzakvN[lBwzqzO].is_int64()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_int64());
            }else{
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_double());
            }
            }();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();

    PFN_vkGetMemoryRemoteAddressNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_instance_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryRemoteAddressNV)get_device_proc_addr(parent,"vkGetMemoryRemoteAddressNV");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryGetRemoteAddressInfo, pAddress);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=boost::json::array();
            return; }json["pMemoryGetRemoteAddressInfo"]=boost::json::array(1);
        auto& arr_JYmQngD=json["pMemoryGetRemoteAddressInfo"].get_array();
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto& temp=arr_JYmQngD[tlzypUU].emplace_object();
            return serialize_struct(temp, pMemoryGetRemoteAddressInfo[tlzypUU]);
            }();
        }
        }();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=boost::json::array();
            return; }json["pAddress"]=boost::json::array(1);
        auto& arr_LTIxmQF=json["pAddress"].get_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }arr_LTIxmQF[LIvckbR]=boost::json::array(strlen(((char*)(pAddress[LIvckbR])))+1);
        auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].get_array();
        for(int lBwzqzO=0; lBwzqzO < strlen(((char*)(pAddress[LIvckbR])))+1; lBwzqzO++){
            [&](){arr_FUzakvN[lBwzqzO]=((char*)(pAddress[LIvckbR]))[lBwzqzO];}();
        }
        }();}();}();
        }
        }();


        json["stream_type"]=VKGETMEMORYREMOTEADDRESSNV;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalSemaphoreProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo;
[&](){
            if (json["pExternalSemaphoreInfo"].get_array().size()==0){
                pExternalSemaphoreInfo=NULL;
            return; }pExternalSemaphoreInfo=(VkPhysicalDeviceExternalSemaphoreInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalSemaphoreInfo));
        auto& arr_giUwPMB=json["pExternalSemaphoreInfo"].get_array();
        for(int gtMcAOQ=0; gtMcAOQ < 1; gtMcAOQ++){
            [&](){
            auto& temp=arr_giUwPMB[gtMcAOQ].get_object();
            deserialize_struct(temp,pExternalSemaphoreInfo[gtMcAOQ]);
            }();
        }
        }();
VkExternalSemaphoreProperties* pExternalSemaphoreProperties;
[&](){
            if (json["pExternalSemaphoreProperties"].get_array().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }pExternalSemaphoreProperties=(VkExternalSemaphoreProperties*)malloc(1*sizeof(VkExternalSemaphoreProperties));
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].get_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].get_object();
            deserialize_struct(temp,pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalSemaphoreProperties");
    }  
    
{
call_function(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=boost::json::array();
            return; }json["pExternalSemaphoreInfo"]=boost::json::array(1);
        auto& arr_qgIgkyH=json["pExternalSemaphoreInfo"].get_array();
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto& temp=arr_qgIgkyH[VMbMUUS].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreInfo[VMbMUUS]);
            }();
        }
        }();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=boost::json::array();
            return; }json["pExternalSemaphoreProperties"]=boost::json::array(1);
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].get_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetSemaphoreFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].get_array().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkSemaphoreGetFdInfoKHR*)malloc(1*sizeof(VkSemaphoreGetFdInfoKHR));
        auto& arr_BVoUZWb=json["pGetFdInfo"].get_array();
        for(int BGuubyW=0; BGuubyW < 1; BGuubyW++){
            [&](){
            auto& temp=arr_BVoUZWb[BGuubyW].get_object();
            deserialize_struct(temp,pGetFdInfo[BGuubyW]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();

    PFN_vkGetSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSemaphoreFdKHR)get_instance_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSemaphoreFdKHR)get_device_proc_addr(parent,"vkGetSemaphoreFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_fyTHWII=json["pGetFdInfo"].get_array();
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto& temp=arr_fyTHWII[dBynwwO].emplace_object();
            return serialize_struct(temp, pGetFdInfo[dBynwwO]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        json["stream_type"]=VKGETSEMAPHOREFDKHR;
        writeToConn(json);
    }

    void handle_vkImportSemaphoreFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo;
[&](){
            if (json["pImportSemaphoreFdInfo"].get_array().size()==0){
                pImportSemaphoreFdInfo=NULL;
            return; }pImportSemaphoreFdInfo=(VkImportSemaphoreFdInfoKHR*)malloc(1*sizeof(VkImportSemaphoreFdInfoKHR));
        auto& arr_UrxNRxs=json["pImportSemaphoreFdInfo"].get_array();
        for(int QfVGtJH=0; QfVGtJH < 1; QfVGtJH++){
            [&](){
            auto& temp=arr_UrxNRxs[QfVGtJH].get_object();
            deserialize_struct(temp,pImportSemaphoreFdInfo[QfVGtJH]);
            }();
        }
        }();

    PFN_vkImportSemaphoreFdKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkImportSemaphoreFdKHR)get_instance_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkImportSemaphoreFdKHR)get_device_proc_addr(parent,"vkImportSemaphoreFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pImportSemaphoreFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=boost::json::array();
            return; }json["pImportSemaphoreFdInfo"]=boost::json::array(1);
        auto& arr_vWNEWeX=json["pImportSemaphoreFdInfo"].get_array();
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto& temp=arr_vWNEWeX[kfpLCyT].emplace_object();
            return serialize_struct(temp, pImportSemaphoreFdInfo[kfpLCyT]);
            }();
        }
        }();


        json["stream_type"]=VKIMPORTSEMAPHOREFDKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceExternalFenceProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo;
[&](){
            if (json["pExternalFenceInfo"].get_array().size()==0){
                pExternalFenceInfo=NULL;
            return; }pExternalFenceInfo=(VkPhysicalDeviceExternalFenceInfo*)malloc(1*sizeof(VkPhysicalDeviceExternalFenceInfo));
        auto& arr_cmsSEwq=json["pExternalFenceInfo"].get_array();
        for(int qxHSgjk=0; qxHSgjk < 1; qxHSgjk++){
            [&](){
            auto& temp=arr_cmsSEwq[qxHSgjk].get_object();
            deserialize_struct(temp,pExternalFenceInfo[qxHSgjk]);
            }();
        }
        }();
VkExternalFenceProperties* pExternalFenceProperties;
[&](){
            if (json["pExternalFenceProperties"].get_array().size()==0){
                pExternalFenceProperties=NULL;
            return; }pExternalFenceProperties=(VkExternalFenceProperties*)malloc(1*sizeof(VkExternalFenceProperties));
        auto& arr_nPbItsj=json["pExternalFenceProperties"].get_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].get_object();
            deserialize_struct(temp,pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceExternalFenceProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceExternalFenceProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceExternalFenceProperties");
    }  
    
{
call_function(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=boost::json::array();
            return; }json["pExternalFenceInfo"]=boost::json::array(1);
        auto& arr_DSVeGvM=json["pExternalFenceInfo"].get_array();
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto& temp=arr_DSVeGvM[ApMvCYQ].emplace_object();
            return serialize_struct(temp, pExternalFenceInfo[ApMvCYQ]);
            }();
        }
        }();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=boost::json::array();
            return; }json["pExternalFenceProperties"]=boost::json::array(1);
        auto& arr_nPbItsj=json["pExternalFenceProperties"].get_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].emplace_object();
            return serialize_struct(temp, pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES;
        writeToConn(json);
    }

    void handle_vkGetFenceFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkFenceGetFdInfoKHR* pGetFdInfo;
[&](){
            if (json["pGetFdInfo"].get_array().size()==0){
                pGetFdInfo=NULL;
            return; }pGetFdInfo=(VkFenceGetFdInfoKHR*)malloc(1*sizeof(VkFenceGetFdInfoKHR));
        auto& arr_xyswZQS=json["pGetFdInfo"].get_array();
        for(int pCVXTsZ=0; pCVXTsZ < 1; pCVXTsZ++){
            [&](){
            auto& temp=arr_xyswZQS[pCVXTsZ].get_object();
            deserialize_struct(temp,pGetFdInfo[pCVXTsZ]);
            }();
        }
        }();
int* pFd;
[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }pFd=(int*)malloc(1*sizeof(int));
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();

    PFN_vkGetFenceFdKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFenceFdKHR)get_instance_proc_addr(parent,"vkGetFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFenceFdKHR)get_device_proc_addr(parent,"vkGetFenceFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pGetFdInfo, pFd);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_mgmOmEV=json["pGetFdInfo"].get_array();
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto& temp=arr_mgmOmEV[DYSusBe].emplace_object();
            return serialize_struct(temp, pGetFdInfo[DYSusBe]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();


        json["stream_type"]=VKGETFENCEFDKHR;
        writeToConn(json);
    }

    void handle_vkImportFenceFdKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImportFenceFdInfoKHR* pImportFenceFdInfo;
[&](){
            if (json["pImportFenceFdInfo"].get_array().size()==0){
                pImportFenceFdInfo=NULL;
            return; }pImportFenceFdInfo=(VkImportFenceFdInfoKHR*)malloc(1*sizeof(VkImportFenceFdInfoKHR));
        auto& arr_fzWADTd=json["pImportFenceFdInfo"].get_array();
        for(int nbyOjBi=0; nbyOjBi < 1; nbyOjBi++){
            [&](){
            auto& temp=arr_fzWADTd[nbyOjBi].get_object();
            deserialize_struct(temp,pImportFenceFdInfo[nbyOjBi]);
            }();
        }
        }();

    PFN_vkImportFenceFdKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkImportFenceFdKHR)get_instance_proc_addr(parent,"vkImportFenceFdKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkImportFenceFdKHR)get_device_proc_addr(parent,"vkImportFenceFdKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pImportFenceFdInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=boost::json::array();
            return; }json["pImportFenceFdInfo"]=boost::json::array(1);
        auto& arr_PmxwQMO=json["pImportFenceFdInfo"].get_array();
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto& temp=arr_PmxwQMO[QSUnAUF].emplace_object();
            return serialize_struct(temp, pImportFenceFdInfo[QSUnAUF]);
            }();
        }
        }();


        json["stream_type"]=VKIMPORTFENCEFDKHR;
        writeToConn(json);
    }

    void handle_vkReleaseDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkReleaseDisplayEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseDisplayEXT)get_instance_proc_addr(parent,"vkReleaseDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseDisplayEXT)get_device_proc_addr(parent,"vkReleaseDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        json["stream_type"]=VKRELEASEDISPLAYEXT;
        writeToConn(json);
    }

    void handle_vkDisplayPowerControlEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayPowerInfoEXT* pDisplayPowerInfo;
[&](){
            if (json["pDisplayPowerInfo"].get_array().size()==0){
                pDisplayPowerInfo=NULL;
            return; }pDisplayPowerInfo=(VkDisplayPowerInfoEXT*)malloc(1*sizeof(VkDisplayPowerInfoEXT));
        auto& arr_VSwTzCL=json["pDisplayPowerInfo"].get_array();
        for(int KtsnURa=0; KtsnURa < 1; KtsnURa++){
            [&](){
            auto& temp=arr_VSwTzCL[KtsnURa].get_object();
            deserialize_struct(temp,pDisplayPowerInfo[KtsnURa]);
            }();
        }
        }();

    PFN_vkDisplayPowerControlEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDisplayPowerControlEXT)get_instance_proc_addr(parent,"vkDisplayPowerControlEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDisplayPowerControlEXT)get_device_proc_addr(parent,"vkDisplayPowerControlEXT");
    }  
    
VkResult  result;
{
result=call_function(device, display, pDisplayPowerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=boost::json::array();
            return; }json["pDisplayPowerInfo"]=boost::json::array(1);
        auto& arr_MrfcjyV=json["pDisplayPowerInfo"].get_array();
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto& temp=arr_MrfcjyV[xtIgTXd].emplace_object();
            return serialize_struct(temp, pDisplayPowerInfo[xtIgTXd]);
            }();
        }
        }();


        json["stream_type"]=VKDISPLAYPOWERCONTROLEXT;
        writeToConn(json);
    }

    void handle_vkRegisterDeviceEventEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceEventInfoEXT* pDeviceEventInfo;
[&](){
            if (json["pDeviceEventInfo"].get_array().size()==0){
                pDeviceEventInfo=NULL;
            return; }pDeviceEventInfo=(VkDeviceEventInfoEXT*)malloc(1*sizeof(VkDeviceEventInfoEXT));
        auto& arr_EoseEDE=json["pDeviceEventInfo"].get_array();
        for(int obNGZvs=0; obNGZvs < 1; obNGZvs++){
            [&](){
            auto& temp=arr_EoseEDE[obNGZvs].get_object();
            deserialize_struct(temp,pDeviceEventInfo[obNGZvs]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDeviceEventEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkRegisterDeviceEventEXT)get_instance_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkRegisterDeviceEventEXT)get_device_proc_addr(parent,"vkRegisterDeviceEventEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pDeviceEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=boost::json::array();
            return; }json["pDeviceEventInfo"]=boost::json::array(1);
        auto& arr_PBonFka=json["pDeviceEventInfo"].get_array();
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto& temp=arr_PBonFka[JNqwWzK].emplace_object();
            return serialize_struct(temp, pDeviceEventInfo[JNqwWzK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        json["stream_type"]=VKREGISTERDEVICEEVENTEXT;
        writeToConn(json);
    }

    void handle_vkRegisterDisplayEventEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
 VkDisplayEventInfoEXT* pDisplayEventInfo;
[&](){
            if (json["pDisplayEventInfo"].get_array().size()==0){
                pDisplayEventInfo=NULL;
            return; }pDisplayEventInfo=(VkDisplayEventInfoEXT*)malloc(1*sizeof(VkDisplayEventInfoEXT));
        auto& arr_dFojYev=json["pDisplayEventInfo"].get_array();
        for(int ABwoOha=0; ABwoOha < 1; ABwoOha++){
            [&](){
            auto& temp=arr_dFojYev[ABwoOha].get_object();
            deserialize_struct(temp,pDisplayEventInfo[ABwoOha]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkFence* pFence;
[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }pFence=(VkFence*)malloc(1*sizeof(VkFence));
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();

    PFN_vkRegisterDisplayEventEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkRegisterDisplayEventEXT)get_instance_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkRegisterDisplayEventEXT)get_device_proc_addr(parent,"vkRegisterDisplayEventEXT");
    }  
    
VkResult  result;
{
result=call_function(device, display, pDisplayEventInfo, pAllocator, pFence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=boost::json::array();
            return; }json["pDisplayEventInfo"]=boost::json::array(1);
        auto& arr_EEWRWgk=json["pDisplayEventInfo"].get_array();
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto& temp=arr_EEWRWgk[ZywgBIl].emplace_object();
            return serialize_struct(temp, pDisplayEventInfo[ZywgBIl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();


        json["stream_type"]=VKREGISTERDISPLAYEVENTEXT;
        writeToConn(json);
    }

    void handle_vkGetSwapchainCounterEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkSurfaceCounterFlagBitsEXT counter;
[&](){[&](){int temp_RusGBTK;[&](){
            if (json["counter"].is_uint64()){
                temp_RusGBTK=static_cast<int>(json["counter"].get_uint64());
            }else if (json["counter"].is_int64()){
                temp_RusGBTK=static_cast<int>(json["counter"].get_int64());
            }else{
                temp_RusGBTK=static_cast<int>(json["counter"].get_double());
            }
            }();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
uint64_t* pCounterValue;
[&](){
            if (json["pCounterValue"].get_array().size()==0){
                pCounterValue=NULL;
            return; }pCounterValue=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_VmPfCNz=json["pCounterValue"].get_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){
            if (arr_VmPfCNz[BVcpEyO].is_uint64()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_uint64());
            }else if (arr_VmPfCNz[BVcpEyO].is_int64()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_int64());
            }else{
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_double());
            }
            }();
        }
        }();

    PFN_vkGetSwapchainCounterEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainCounterEXT)get_instance_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainCounterEXT)get_device_proc_addr(parent,"vkGetSwapchainCounterEXT");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, counter, pCounterValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=counter;}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=boost::json::array();
            return; }json["pCounterValue"]=boost::json::array(1);
        auto& arr_VmPfCNz=json["pCounterValue"].get_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=pCounterValue[BVcpEyO];}();
        }
        }();


        json["stream_type"]=VKGETSWAPCHAINCOUNTEREXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2EXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkSurfaceCapabilities2EXT* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2EXT*)malloc(1*sizeof(VkSurfaceCapabilities2EXT));
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].get_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2EXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].get_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT;
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceGroups(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
uint32_t* pPhysicalDeviceGroupCount;
[&](){
            if (json["pPhysicalDeviceGroupCount"].get_array().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }pPhysicalDeviceGroupCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].get_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){
            if (arr_Cmahtvc[SYfwvYv].is_uint64()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_uint64());
            }else if (arr_Cmahtvc[SYfwvYv].is_int64()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_int64());
            }else{
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_double());
            }
            }();
        }
        }();
VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties;
[&](){
            if (json["pPhysicalDeviceGroupProperties"].get_array().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }pPhysicalDeviceGroupProperties=(VkPhysicalDeviceGroupProperties*)malloc(*pPhysicalDeviceGroupCount*sizeof(VkPhysicalDeviceGroupProperties));
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].get_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].get_object();
            deserialize_struct(temp,pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceGroups call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceGroups)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceGroups");
    }  
    
VkResult  result;
{
result=call_function(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=boost::json::array();
            return; }json["pPhysicalDeviceGroupCount"]=boost::json::array(1);
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].get_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=pPhysicalDeviceGroupCount[SYfwvYv];}();
        }
        }();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=boost::json::array();
            return; }json["pPhysicalDeviceGroupProperties"]=boost::json::array(*pPhysicalDeviceGroupCount);
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].get_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].emplace_object();
            return serialize_struct(temp, pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEPHYSICALDEVICEGROUPS;
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPeerMemoryFeatures(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t heapIndex;
[&](){
            if (json["heapIndex"].is_uint64()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_uint64());
            }else if (json["heapIndex"].is_int64()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_int64());
            }else{
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_double());
            }
            }();
uint32_t localDeviceIndex;
[&](){
            if (json["localDeviceIndex"].is_uint64()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_uint64());
            }else if (json["localDeviceIndex"].is_int64()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_int64());
            }else{
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_double());
            }
            }();
uint32_t remoteDeviceIndex;
[&](){
            if (json["remoteDeviceIndex"].is_uint64()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_uint64());
            }else if (json["remoteDeviceIndex"].is_int64()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_int64());
            }else{
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_double());
            }
            }();
VkPeerMemoryFeatureFlags* pPeerMemoryFeatures;
[&](){
            if (json["pPeerMemoryFeatures"].get_array().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }pPeerMemoryFeatures=(VkPeerMemoryFeatureFlags*)malloc(1*sizeof(VkPeerMemoryFeatureFlags));
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].get_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){
            if (arr_IMNDPVx[dvtpqQO].is_uint64()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_uint64());
            }else if (arr_IMNDPVx[dvtpqQO].is_int64()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_int64());
            }else{
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_double());
            }
            }();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

    PFN_vkGetDeviceGroupPeerMemoryFeatures call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_instance_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupPeerMemoryFeatures)get_device_proc_addr(parent,"vkGetDeviceGroupPeerMemoryFeatures");
    }  
    
{
call_function(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=heapIndex;}();
[&](){json["localDeviceIndex"]=localDeviceIndex;}();
[&](){json["remoteDeviceIndex"]=remoteDeviceIndex;}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=boost::json::array();
            return; }json["pPeerMemoryFeatures"]=boost::json::array(1);
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].get_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=pPeerMemoryFeatures[dvtpqQO];}();}();}();
        }
        }();


        json["stream_type"]=VKGETDEVICEGROUPPEERMEMORYFEATURES;
        writeToConn(json);
    }

    void handle_vkBindBufferMemory2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();
 VkBindBufferMemoryInfo* pBindInfos;
[&](){
            if (json["pBindInfos"].get_array().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindBufferMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindBufferMemoryInfo));
        auto& arr_KcaAJZC=json["pBindInfos"].get_array();
        for(int sAHPDKw=0; sAHPDKw < bindInfoCount; sAHPDKw++){
            [&](){
            auto& temp=arr_KcaAJZC[sAHPDKw].get_object();
            deserialize_struct(temp,pBindInfos[sAHPDKw]);
            }();
        }
        }();

    PFN_vkBindBufferMemory2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindBufferMemory2)get_instance_proc_addr(parent,"vkBindBufferMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindBufferMemory2)get_device_proc_addr(parent,"vkBindBufferMemory2");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_NWunNSr=json["pBindInfos"].get_array();
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto& temp=arr_NWunNSr[DbCSPHR].emplace_object();
            return serialize_struct(temp, pBindInfos[DbCSPHR]);
            }();
        }
        }();


        json["stream_type"]=VKBINDBUFFERMEMORY2;
        writeToConn(json);
    }

    void handle_vkBindImageMemory2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();
 VkBindImageMemoryInfo* pBindInfos;
[&](){
            if (json["pBindInfos"].get_array().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindImageMemoryInfo*)malloc(bindInfoCount*sizeof(VkBindImageMemoryInfo));
        auto& arr_OyrgWGZ=json["pBindInfos"].get_array();
        for(int jeBxOVo=0; jeBxOVo < bindInfoCount; jeBxOVo++){
            [&](){
            auto& temp=arr_OyrgWGZ[jeBxOVo].get_object();
            deserialize_struct(temp,pBindInfos[jeBxOVo]);
            }();
        }
        }();

    PFN_vkBindImageMemory2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindImageMemory2)get_instance_proc_addr(parent,"vkBindImageMemory2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindImageMemory2)get_device_proc_addr(parent,"vkBindImageMemory2");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_FifZmRy=json["pBindInfos"].get_array();
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto& temp=arr_FifZmRy[TInZfLo].emplace_object();
            return serialize_struct(temp, pBindInfos[TInZfLo]);
            }();
        }
        }();


        json["stream_type"]=VKBINDIMAGEMEMORY2;
        writeToConn(json);
    }

    void handle_vkCmdSetDeviceMask(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t deviceMask;
[&](){
            if (json["deviceMask"].is_uint64()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_uint64());
            }else if (json["deviceMask"].is_int64()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_int64());
            }else{
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_double());
            }
            }();

    PFN_vkCmdSetDeviceMask call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDeviceMask)get_instance_proc_addr(parent,"vkCmdSetDeviceMask");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDeviceMask)get_device_proc_addr(parent,"vkCmdSetDeviceMask");
    }  
    
{
call_function(commandBuffer, deviceMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=deviceMask;}();


        json["stream_type"]=VKCMDSETDEVICEMASK;
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupPresentCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities;
[&](){
            if (json["pDeviceGroupPresentCapabilities"].get_array().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }pDeviceGroupPresentCapabilities=(VkDeviceGroupPresentCapabilitiesKHR*)malloc(1*sizeof(VkDeviceGroupPresentCapabilitiesKHR));
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].get_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].get_object();
            deserialize_struct(temp,pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();

    PFN_vkGetDeviceGroupPresentCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupPresentCapabilitiesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupPresentCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pDeviceGroupPresentCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=boost::json::array();
            return; }json["pDeviceGroupPresentCapabilities"]=boost::json::array(1);
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].get_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].emplace_object();
            return serialize_struct(temp, pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEGROUPPRESENTCAPABILITIESKHR;
        writeToConn(json);
    }

    void handle_vkGetDeviceGroupSurfacePresentModesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
VkDeviceGroupPresentModeFlagsKHR* pModes;
[&](){
            if (json["pModes"].get_array().size()==0){
                pModes=NULL;
            return; }pModes=(VkDeviceGroupPresentModeFlagsKHR*)malloc(1*sizeof(VkDeviceGroupPresentModeFlagsKHR));
        auto& arr_RUtBuZy=json["pModes"].get_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){
            if (arr_RUtBuZy[OxSHrMn].is_uint64()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_uint64());
            }else if (arr_RUtBuZy[OxSHrMn].is_int64()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_int64());
            }else{
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_double());
            }
            }();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();

    PFN_vkGetDeviceGroupSurfacePresentModesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_instance_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceGroupSurfacePresentModesKHR)get_device_proc_addr(parent,"vkGetDeviceGroupSurfacePresentModesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, surface, pModes);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=boost::json::array();
            return; }json["pModes"]=boost::json::array(1);
        auto& arr_RUtBuZy=json["pModes"].get_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=pModes[OxSHrMn];}();}();}();
        }
        }();


        json["stream_type"]=VKGETDEVICEGROUPSURFACEPRESENTMODESKHR;
        writeToConn(json);
    }

    void handle_vkAcquireNextImage2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAcquireNextImageInfoKHR* pAcquireInfo;
[&](){
            if (json["pAcquireInfo"].get_array().size()==0){
                pAcquireInfo=NULL;
            return; }pAcquireInfo=(VkAcquireNextImageInfoKHR*)malloc(1*sizeof(VkAcquireNextImageInfoKHR));
        auto& arr_DnycGJU=json["pAcquireInfo"].get_array();
        for(int tNYAOen=0; tNYAOen < 1; tNYAOen++){
            [&](){
            auto& temp=arr_DnycGJU[tNYAOen].get_object();
            deserialize_struct(temp,pAcquireInfo[tNYAOen]);
            }();
        }
        }();
uint32_t* pImageIndex;
[&](){
            if (json["pImageIndex"].get_array().size()==0){
                pImageIndex=NULL;
            return; }pImageIndex=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_uint64());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_int64());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_double());
            }
            }();
        }
        }();

    PFN_vkAcquireNextImage2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireNextImage2KHR)get_instance_proc_addr(parent,"vkAcquireNextImage2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireNextImage2KHR)get_device_proc_addr(parent,"vkAcquireNextImage2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pAcquireInfo, pImageIndex);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }json["pAcquireInfo"]=boost::json::array(1);
        auto& arr_plPbild=json["pAcquireInfo"].get_array();
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto& temp=arr_plPbild[QzLRJum].emplace_object();
            return serialize_struct(temp, pAcquireInfo[QzLRJum]);
            }();
        }
        }();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }json["pImageIndex"]=boost::json::array(1);
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();


        json["stream_type"]=VKACQUIRENEXTIMAGE2KHR;
        writeToConn(json);
    }

    void handle_vkCmdDispatchBase(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t baseGroupX;
[&](){
            if (json["baseGroupX"].is_uint64()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_uint64());
            }else if (json["baseGroupX"].is_int64()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_int64());
            }else{
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_double());
            }
            }();
uint32_t baseGroupY;
[&](){
            if (json["baseGroupY"].is_uint64()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_uint64());
            }else if (json["baseGroupY"].is_int64()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_int64());
            }else{
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_double());
            }
            }();
uint32_t baseGroupZ;
[&](){
            if (json["baseGroupZ"].is_uint64()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_uint64());
            }else if (json["baseGroupZ"].is_int64()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_int64());
            }else{
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_double());
            }
            }();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

    PFN_vkCmdDispatchBase call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDispatchBase)get_instance_proc_addr(parent,"vkCmdDispatchBase");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDispatchBase)get_device_proc_addr(parent,"vkCmdDispatchBase");
    }  
    
{
call_function(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=baseGroupX;}();
[&](){json["baseGroupY"]=baseGroupY;}();
[&](){json["baseGroupZ"]=baseGroupZ;}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        json["stream_type"]=VKCMDDISPATCHBASE;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDevicePresentRectanglesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSurfaceKHR surface;
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
uint32_t* pRectCount;
[&](){
            if (json["pRectCount"].get_array().size()==0){
                pRectCount=NULL;
            return; }pRectCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_vsEoMvr=json["pRectCount"].get_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){
            if (arr_vsEoMvr[TgFYlRi].is_uint64()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_uint64());
            }else if (arr_vsEoMvr[TgFYlRi].is_int64()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_int64());
            }else{
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_double());
            }
            }();
        }
        }();
VkRect2D* pRects;
[&](){
            if (json["pRects"].get_array().size()==0){
                pRects=NULL;
            return; }pRects=(VkRect2D*)malloc(*pRectCount*sizeof(VkRect2D));
        auto& arr_BxIGDMm=json["pRects"].get_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].get_object();
            deserialize_struct(temp,pRects[LNnHsjT]);
            }();
        }
        }();

    PFN_vkGetPhysicalDevicePresentRectanglesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDevicePresentRectanglesKHR)get_device_proc_addr(parent,"vkGetPhysicalDevicePresentRectanglesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, surface, pRectCount, pRects);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=boost::json::array();
            return; }json["pRectCount"]=boost::json::array(1);
        auto& arr_vsEoMvr=json["pRectCount"].get_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=pRectCount[TgFYlRi];}();
        }
        }();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }json["pRects"]=boost::json::array(*pRectCount);
        auto& arr_BxIGDMm=json["pRects"].get_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].emplace_object();
            return serialize_struct(temp, pRects[LNnHsjT]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR;
        writeToConn(json);
    }

    void handle_vkCreateDescriptorUpdateTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorUpdateTemplateCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorUpdateTemplateCreateInfo*)malloc(1*sizeof(VkDescriptorUpdateTemplateCreateInfo));
        auto& arr_VGzFxGk=json["pCreateInfo"].get_array();
        for(int nfmnALE=0; nfmnALE < 1; nfmnALE++){
            [&](){
            auto& temp=arr_VGzFxGk[nfmnALE].get_object();
            deserialize_struct(temp,pCreateInfo[nfmnALE]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate;
[&](){
            if (json["pDescriptorUpdateTemplate"].get_array().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }pDescriptorUpdateTemplate=(VkDescriptorUpdateTemplate*)malloc(1*sizeof(VkDescriptorUpdateTemplate));
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].get_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();

    PFN_vkCreateDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkCreateDescriptorUpdateTemplate");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_GOaQfzV=json["pCreateInfo"].get_array();
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto& temp=arr_GOaQfzV[bDXkRSI].emplace_object();
            return serialize_struct(temp, pCreateInfo[bDXkRSI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=boost::json::array();
            return; }json["pDescriptorUpdateTemplate"]=boost::json::array(1);
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].get_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();


        json["stream_type"]=VKCREATEDESCRIPTORUPDATETEMPLATE;
        writeToConn(json);
    }

    void handle_vkDestroyDescriptorUpdateTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDescriptorUpdateTemplate call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_instance_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDescriptorUpdateTemplate)get_device_proc_addr(parent,"vkDestroyDescriptorUpdateTemplate");
    }  
    
{
call_function(device, descriptorUpdateTemplate, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDESCRIPTORUPDATETEMPLATE;
        writeToConn(json);
    }

    void handle_vkUpdateDescriptorSetWithTemplate(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
 void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].get_array().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_EOPGHRq=json["pData"].get_array();
        for(int ElrKHKH=0; ElrKHKH < json["pData"].get_array().size(); ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_uint64());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_int64());
            }else{
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_double());
            }
            }();
        }
        }();pData=temp_cNzVPDf;}();

    PFN_vkUpdateDescriptorSetWithTemplate call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_instance_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateDescriptorSetWithTemplate)get_device_proc_addr(parent,"vkUpdateDescriptorSetWithTemplate");
    }  
    
{
call_function(device, descriptorSet, descriptorUpdateTemplate, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();


        json["stream_type"]=VKUPDATEDESCRIPTORSETWITHTEMPLATE;
        writeToConn(json);
    }

    void handle_vkCmdPushDescriptorSetWithTemplateKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDescriptorUpdateTemplate descriptorUpdateTemplate;
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();
 void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_cNzVPDf;[&](){
            if (json["pData"].get_array().size()==0){
                temp_cNzVPDf=NULL;
            return; }temp_cNzVPDf=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_EOPGHRq=json["pData"].get_array();
        for(int ElrKHKH=0; ElrKHKH < json["pData"].get_array().size(); ElrKHKH++){
            [&](){
            if (arr_EOPGHRq[ElrKHKH].is_uint64()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_uint64());
            }else if (arr_EOPGHRq[ElrKHKH].is_int64()){
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_int64());
            }else{
                temp_cNzVPDf[ElrKHKH]=static_cast<char>(arr_EOPGHRq[ElrKHKH].get_double());
            }
            }();
        }
        }();pData=temp_cNzVPDf;}();

    PFN_vkCmdPushDescriptorSetWithTemplateKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_instance_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPushDescriptorSetWithTemplateKHR)get_device_proc_addr(parent,"vkCmdPushDescriptorSetWithTemplateKHR");
    }  
    
{
call_function(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();


        json["stream_type"]=VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR;
        writeToConn(json);
    }

    void handle_vkSetHdrMetadataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t swapchainCount;
[&](){
            if (json["swapchainCount"].is_uint64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_uint64());
            }else if (json["swapchainCount"].is_int64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_int64());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_double());
            }
            }();
 VkSwapchainKHR* pSwapchains;
[&](){
            if (json["pSwapchains"].get_array().size()==0){
                pSwapchains=NULL;
            return; }pSwapchains=(VkSwapchainKHR*)malloc(swapchainCount*sizeof(VkSwapchainKHR));
        auto& arr_iHlSrAW=json["pSwapchains"].get_array();
        for(int IasqrAl=0; IasqrAl < swapchainCount; IasqrAl++){
            [&](){deserialize_VkSwapchainKHR(arr_iHlSrAW[IasqrAl], pSwapchains[IasqrAl]);}();
        }
        }();
 VkHdrMetadataEXT* pMetadata;
[&](){
            if (json["pMetadata"].get_array().size()==0){
                pMetadata=NULL;
            return; }pMetadata=(VkHdrMetadataEXT*)malloc(swapchainCount*sizeof(VkHdrMetadataEXT));
        auto& arr_kUxcKTi=json["pMetadata"].get_array();
        for(int IpDaPDf=0; IpDaPDf < swapchainCount; IpDaPDf++){
            [&](){
            auto& temp=arr_kUxcKTi[IpDaPDf].get_object();
            deserialize_struct(temp,pMetadata[IpDaPDf]);
            }();
        }
        }();

    PFN_vkSetHdrMetadataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetHdrMetadataEXT)get_instance_proc_addr(parent,"vkSetHdrMetadataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetHdrMetadataEXT)get_device_proc_addr(parent,"vkSetHdrMetadataEXT");
    }  
    
{
call_function(device, swapchainCount, pSwapchains, pMetadata);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }json["pSwapchains"]=boost::json::array(swapchainCount);
        auto& arr_ItrwriJ=json["pSwapchains"].get_array();
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        }();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=boost::json::array();
            return; }json["pMetadata"]=boost::json::array(swapchainCount);
        auto& arr_gUCeGgy=json["pMetadata"].get_array();
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto& temp=arr_gUCeGgy[qGnEfca].emplace_object();
            return serialize_struct(temp, pMetadata[qGnEfca]);
            }();
        }
        }();


        json["stream_type"]=VKSETHDRMETADATAEXT;
        writeToConn(json);
    }

    void handle_vkGetSwapchainStatusKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();

    PFN_vkGetSwapchainStatusKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSwapchainStatusKHR)get_instance_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSwapchainStatusKHR)get_device_proc_addr(parent,"vkGetSwapchainStatusKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();


        json["stream_type"]=VKGETSWAPCHAINSTATUSKHR;
        writeToConn(json);
    }

    void handle_vkGetRefreshCycleDurationGOOGLE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties;
[&](){
            if (json["pDisplayTimingProperties"].get_array().size()==0){
                pDisplayTimingProperties=NULL;
            return; }pDisplayTimingProperties=(VkRefreshCycleDurationGOOGLE*)malloc(1*sizeof(VkRefreshCycleDurationGOOGLE));
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].get_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].get_object();
            deserialize_struct(temp,pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();

    PFN_vkGetRefreshCycleDurationGOOGLE call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_instance_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRefreshCycleDurationGOOGLE)get_device_proc_addr(parent,"vkGetRefreshCycleDurationGOOGLE");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pDisplayTimingProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=boost::json::array();
            return; }json["pDisplayTimingProperties"]=boost::json::array(1);
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].get_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].emplace_object();
            return serialize_struct(temp, pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();


        json["stream_type"]=VKGETREFRESHCYCLEDURATIONGOOGLE;
        writeToConn(json);
    }

    void handle_vkGetPastPresentationTimingGOOGLE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint32_t* pPresentationTimingCount;
[&](){
            if (json["pPresentationTimingCount"].get_array().size()==0){
                pPresentationTimingCount=NULL;
            return; }pPresentationTimingCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].get_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){
            if (arr_LiCpViZ[ihpxywU].is_uint64()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_uint64());
            }else if (arr_LiCpViZ[ihpxywU].is_int64()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_int64());
            }else{
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_double());
            }
            }();
        }
        }();
VkPastPresentationTimingGOOGLE* pPresentationTimings;
[&](){
            if (json["pPresentationTimings"].get_array().size()==0){
                pPresentationTimings=NULL;
            return; }pPresentationTimings=(VkPastPresentationTimingGOOGLE*)malloc(*pPresentationTimingCount*sizeof(VkPastPresentationTimingGOOGLE));
        auto& arr_CGvQjMK=json["pPresentationTimings"].get_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].get_object();
            deserialize_struct(temp,pPresentationTimings[CzbyDFb]);
            }();
        }
        }();

    PFN_vkGetPastPresentationTimingGOOGLE call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_instance_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPastPresentationTimingGOOGLE)get_device_proc_addr(parent,"vkGetPastPresentationTimingGOOGLE");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=boost::json::array();
            return; }json["pPresentationTimingCount"]=boost::json::array(1);
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].get_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=pPresentationTimingCount[ihpxywU];}();
        }
        }();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=boost::json::array();
            return; }json["pPresentationTimings"]=boost::json::array(*pPresentationTimingCount);
        auto& arr_CGvQjMK=json["pPresentationTimings"].get_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].emplace_object();
            return serialize_struct(temp, pPresentationTimings[CzbyDFb]);
            }();
        }
        }();


        json["stream_type"]=VKGETPASTPRESENTATIONTIMINGGOOGLE;
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();
 VkViewportWScalingNV* pViewportWScalings;
[&](){
            if (json["pViewportWScalings"].get_array().size()==0){
                pViewportWScalings=NULL;
            return; }pViewportWScalings=(VkViewportWScalingNV*)malloc(viewportCount*sizeof(VkViewportWScalingNV));
        auto& arr_mRBzXTN=json["pViewportWScalings"].get_array();
        for(int jZGgaiG=0; jZGgaiG < viewportCount; jZGgaiG++){
            [&](){
            auto& temp=arr_mRBzXTN[jZGgaiG].get_object();
            deserialize_struct(temp,pViewportWScalings[jZGgaiG]);
            }();
        }
        }();

    PFN_vkCmdSetViewportWScalingNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWScalingNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=boost::json::array();
            return; }json["pViewportWScalings"]=boost::json::array(viewportCount);
        auto& arr_gZVGKnq=json["pViewportWScalings"].get_array();
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto& temp=arr_gZVGKnq[GRZXlou].emplace_object();
            return serialize_struct(temp, pViewportWScalings[GRZXlou]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVIEWPORTWSCALINGNV;
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstDiscardRectangle;
[&](){
            if (json["firstDiscardRectangle"].is_uint64()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_uint64());
            }else if (json["firstDiscardRectangle"].is_int64()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_int64());
            }else{
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_double());
            }
            }();
uint32_t discardRectangleCount;
[&](){
            if (json["discardRectangleCount"].is_uint64()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_uint64());
            }else if (json["discardRectangleCount"].is_int64()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_int64());
            }else{
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_double());
            }
            }();
 VkRect2D* pDiscardRectangles;
[&](){
            if (json["pDiscardRectangles"].get_array().size()==0){
                pDiscardRectangles=NULL;
            return; }pDiscardRectangles=(VkRect2D*)malloc(discardRectangleCount*sizeof(VkRect2D));
        auto& arr_GRSsdXy=json["pDiscardRectangles"].get_array();
        for(int sWyneMb=0; sWyneMb < discardRectangleCount; sWyneMb++){
            [&](){
            auto& temp=arr_GRSsdXy[sWyneMb].get_object();
            deserialize_struct(temp,pDiscardRectangles[sWyneMb]);
            }();
        }
        }();

    PFN_vkCmdSetDiscardRectangleEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEXT");
    }  
    
{
call_function(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=firstDiscardRectangle;}();
[&](){json["discardRectangleCount"]=discardRectangleCount;}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=boost::json::array();
            return; }json["pDiscardRectangles"]=boost::json::array(discardRectangleCount);
        auto& arr_uUeweOj=json["pDiscardRectangles"].get_array();
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto& temp=arr_uUeweOj[WtUHHLW].emplace_object();
            return serialize_struct(temp, pDiscardRectangles[WtUHHLW]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETDISCARDRECTANGLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 discardRectangleEnable;
[&](){uint32_t temp_GnHxsqE;[&](){
            if (json["discardRectangleEnable"].is_uint64()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_uint64());
            }else if (json["discardRectangleEnable"].is_int64()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_int64());
            }else{
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_double());
            }
            }();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

    PFN_vkCmdSetDiscardRectangleEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleEnableEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleEnableEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=discardRectangleEnable;}();}();


        json["stream_type"]=VKCMDSETDISCARDRECTANGLEENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDiscardRectangleModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDiscardRectangleModeEXT discardRectangleMode;
[&](){[&](){int temp_iBxDvRc;[&](){
            if (json["discardRectangleMode"].is_uint64()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_uint64());
            }else if (json["discardRectangleMode"].is_int64()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_int64());
            }else{
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_double());
            }
            }();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

    PFN_vkCmdSetDiscardRectangleModeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_instance_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDiscardRectangleModeEXT)get_device_proc_addr(parent,"vkCmdSetDiscardRectangleModeEXT");
    }  
    
{
call_function(commandBuffer, discardRectangleMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=discardRectangleMode;}();}();}();


        json["stream_type"]=VKCMDSETDISCARDRECTANGLEMODEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSampleLocationsInfoEXT* pSampleLocationsInfo;
[&](){
            if (json["pSampleLocationsInfo"].get_array().size()==0){
                pSampleLocationsInfo=NULL;
            return; }pSampleLocationsInfo=(VkSampleLocationsInfoEXT*)malloc(1*sizeof(VkSampleLocationsInfoEXT));
        auto& arr_bqTfGpl=json["pSampleLocationsInfo"].get_array();
        for(int zJxCCYx=0; zJxCCYx < 1; zJxCCYx++){
            [&](){
            auto& temp=arr_bqTfGpl[zJxCCYx].get_object();
            deserialize_struct(temp,pSampleLocationsInfo[zJxCCYx]);
            }();
        }
        }();

    PFN_vkCmdSetSampleLocationsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleLocationsEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEXT");
    }  
    
{
call_function(commandBuffer, pSampleLocationsInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=boost::json::array();
            return; }json["pSampleLocationsInfo"]=boost::json::array(1);
        auto& arr_KfRxBlJ=json["pSampleLocationsInfo"].get_array();
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto& temp=arr_KfRxBlJ[XjGOezZ].emplace_object();
            return serialize_struct(temp, pSampleLocationsInfo[XjGOezZ]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETSAMPLELOCATIONSEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceMultisamplePropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
VkMultisamplePropertiesEXT* pMultisampleProperties;
[&](){
            if (json["pMultisampleProperties"].get_array().size()==0){
                pMultisampleProperties=NULL;
            return; }pMultisampleProperties=(VkMultisamplePropertiesEXT*)malloc(1*sizeof(VkMultisamplePropertiesEXT));
        auto& arr_IduiRHb=json["pMultisampleProperties"].get_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].get_object();
            deserialize_struct(temp,pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceMultisamplePropertiesEXT");
    }  
    
{
call_function(physicalDevice, samples, pMultisampleProperties);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=boost::json::array();
            return; }json["pMultisampleProperties"]=boost::json::array(1);
        auto& arr_IduiRHb=json["pMultisampleProperties"].get_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].emplace_object();
            return serialize_struct(temp, pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceCapabilities2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){
            if (json["pSurfaceInfo"].get_array().size()==0){
                pSurfaceInfo=NULL;
            return; }pSurfaceInfo=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
        auto& arr_wNHWsze=json["pSurfaceInfo"].get_array();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            auto& temp=arr_wNHWsze[lTfpfvZ].get_object();
            deserialize_struct(temp,pSurfaceInfo[lTfpfvZ]);
            }();
        }
        }();
VkSurfaceCapabilities2KHR* pSurfaceCapabilities;
[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }pSurfaceCapabilities=(VkSurfaceCapabilities2KHR*)malloc(1*sizeof(VkSurfaceCapabilities2KHR));
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].get_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }json["pSurfaceInfo"]=boost::json::array(1);
        auto& arr_kqlTDpj=json["pSurfaceInfo"].get_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].get_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSurfaceFormats2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo;
[&](){
            if (json["pSurfaceInfo"].get_array().size()==0){
                pSurfaceInfo=NULL;
            return; }pSurfaceInfo=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(1*sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
        auto& arr_wNHWsze=json["pSurfaceInfo"].get_array();
        for(int lTfpfvZ=0; lTfpfvZ < 1; lTfpfvZ++){
            [&](){
            auto& temp=arr_wNHWsze[lTfpfvZ].get_object();
            deserialize_struct(temp,pSurfaceInfo[lTfpfvZ]);
            }();
        }
        }();
uint32_t* pSurfaceFormatCount;
[&](){
            if (json["pSurfaceFormatCount"].get_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }pSurfaceFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_uint64());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_int64());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_double());
            }
            }();
        }
        }();
VkSurfaceFormat2KHR* pSurfaceFormats;
[&](){
            if (json["pSurfaceFormats"].get_array().size()==0){
                pSurfaceFormats=NULL;
            return; }pSurfaceFormats=(VkSurfaceFormat2KHR*)malloc(*pSurfaceFormatCount*sizeof(VkSurfaceFormat2KHR));
        auto& arr_AuCicsY=json["pSurfaceFormats"].get_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].get_object();
            deserialize_struct(temp,pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceSurfaceFormats2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }json["pSurfaceInfo"]=boost::json::array(1);
        auto& arr_kqlTDpj=json["pSurfaceInfo"].get_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }json["pSurfaceFormatCount"]=boost::json::array(1);
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }json["pSurfaceFormats"]=boost::json::array(*pSurfaceFormatCount);
        auto& arr_AuCicsY=json["pSurfaceFormats"].get_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESURFACEFORMATS2KHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayProperties2KHR));
        auto& arr_WgClQQW=json["pProperties"].get_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].get_object();
            deserialize_struct(temp,pProperties[IPCMyur]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayProperties2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_WgClQQW=json["pProperties"].get_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].emplace_object();
            return serialize_struct(temp, pProperties[IPCMyur]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayPlaneProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayPlaneProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayPlaneProperties2KHR));
        auto& arr_oqLTQEe=json["pProperties"].get_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].get_object();
            deserialize_struct(temp,pProperties[KJvijjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_oqLTQEe=json["pProperties"].get_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].emplace_object();
            return serialize_struct(temp, pProperties[KJvijjP]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR;
        writeToConn(json);
    }

    void handle_vkGetDisplayModeProperties2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkDisplayModeProperties2KHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkDisplayModeProperties2KHR*)malloc(*pPropertyCount*sizeof(VkDisplayModeProperties2KHR));
        auto& arr_LvUqkhm=json["pProperties"].get_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].get_object();
            deserialize_struct(temp,pProperties[gThvzcU]);
            }();
        }
        }();

    PFN_vkGetDisplayModeProperties2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_instance_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayModeProperties2KHR)get_device_proc_addr(parent,"vkGetDisplayModeProperties2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, display, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_LvUqkhm=json["pProperties"].get_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].emplace_object();
            return serialize_struct(temp, pProperties[gThvzcU]);
            }();
        }
        }();


        json["stream_type"]=VKGETDISPLAYMODEPROPERTIES2KHR;
        writeToConn(json);
    }

    void handle_vkGetDisplayPlaneCapabilities2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo;
[&](){
            if (json["pDisplayPlaneInfo"].get_array().size()==0){
                pDisplayPlaneInfo=NULL;
            return; }pDisplayPlaneInfo=(VkDisplayPlaneInfo2KHR*)malloc(1*sizeof(VkDisplayPlaneInfo2KHR));
        auto& arr_TBmwloa=json["pDisplayPlaneInfo"].get_array();
        for(int OOfQKMi=0; OOfQKMi < 1; OOfQKMi++){
            [&](){
            auto& temp=arr_TBmwloa[OOfQKMi].get_object();
            deserialize_struct(temp,pDisplayPlaneInfo[OOfQKMi]);
            }();
        }
        }();
VkDisplayPlaneCapabilities2KHR* pCapabilities;
[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkDisplayPlaneCapabilities2KHR*)malloc(1*sizeof(VkDisplayPlaneCapabilities2KHR));
        auto& arr_perBkIp=json["pCapabilities"].get_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].get_object();
            deserialize_struct(temp,pCapabilities[wDZGRHI]);
            }();
        }
        }();

    PFN_vkGetDisplayPlaneCapabilities2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_instance_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDisplayPlaneCapabilities2KHR)get_device_proc_addr(parent,"vkGetDisplayPlaneCapabilities2KHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=boost::json::array();
            return; }json["pDisplayPlaneInfo"]=boost::json::array(1);
        auto& arr_rwBYAlG=json["pDisplayPlaneInfo"].get_array();
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto& temp=arr_rwBYAlG[iEdZMtQ].emplace_object();
            return serialize_struct(temp, pDisplayPlaneInfo[iEdZMtQ]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_perBkIp=json["pCapabilities"].get_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].emplace_object();
            return serialize_struct(temp, pCapabilities[wDZGRHI]);
            }();
        }
        }();


        json["stream_type"]=VKGETDISPLAYPLANECAPABILITIES2KHR;
        writeToConn(json);
    }

    void handle_vkGetBufferMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferMemoryRequirementsInfo2*)malloc(1*sizeof(VkBufferMemoryRequirementsInfo2));
        auto& arr_ollhCFD=json["pInfo"].get_array();
        for(int XMajJXL=0; XMajJXL < 1; XMajJXL++){
            [&](){
            auto& temp=arr_ollhCFD[XMajJXL].get_object();
            deserialize_struct(temp,pInfo[XMajJXL]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetBufferMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_instance_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferMemoryRequirements2)get_device_proc_addr(parent,"vkGetBufferMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_xrBSgMU=json["pInfo"].get_array();
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto& temp=arr_xrBSgMU[XaVdoIX].emplace_object();
            return serialize_struct(temp, pInfo[XaVdoIX]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETBUFFERMEMORYREQUIREMENTS2;
        writeToConn(json);
    }

    void handle_vkGetImageMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageMemoryRequirementsInfo2));
        auto& arr_TCaTbMc=json["pInfo"].get_array();
        for(int fOqTthF=0; fOqTthF < 1; fOqTthF++){
            [&](){
            auto& temp=arr_TCaTbMc[fOqTthF].get_object();
            deserialize_struct(temp,pInfo[fOqTthF]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetImageMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_OVesMNt=json["pInfo"].get_array();
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto& temp=arr_OVesMNt[xSwhhlO].emplace_object();
            return serialize_struct(temp, pInfo[xSwhhlO]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGEMEMORYREQUIREMENTS2;
        writeToConn(json);
    }

    void handle_vkGetImageSparseMemoryRequirements2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageSparseMemoryRequirementsInfo2* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageSparseMemoryRequirementsInfo2*)malloc(1*sizeof(VkImageSparseMemoryRequirementsInfo2));
        auto& arr_lAUqSdP=json["pInfo"].get_array();
        for(int HzCSbsD=0; HzCSbsD < 1; HzCSbsD++){
            [&](){
            auto& temp=arr_lAUqSdP[HzCSbsD].get_object();
            deserialize_struct(temp,pInfo[HzCSbsD]);
            }();
        }
        }();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetImageSparseMemoryRequirements2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_instance_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSparseMemoryRequirements2)get_device_proc_addr(parent,"vkGetImageSparseMemoryRequirements2");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_frlqZZl=json["pInfo"].get_array();
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto& temp=arr_frlqZZl[DnuwqwS].emplace_object();
            return serialize_struct(temp, pInfo[DnuwqwS]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS2;
        writeToConn(json);
    }

    void handle_vkGetDeviceBufferMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceBufferMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceBufferMemoryRequirements*)malloc(1*sizeof(VkDeviceBufferMemoryRequirements));
        auto& arr_YweeoPK=json["pInfo"].get_array();
        for(int AxMxoFf=0; AxMxoFf < 1; AxMxoFf++){
            [&](){
            auto& temp=arr_YweeoPK[AxMxoFf].get_object();
            deserialize_struct(temp,pInfo[AxMxoFf]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceBufferMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceBufferMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceBufferMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LbYKRdp=json["pInfo"].get_array();
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto& temp=arr_LbYKRdp[sabbuKR].emplace_object();
            return serialize_struct(temp, pInfo[sabbuKR]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEBUFFERMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkGetDeviceImageMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));
        auto& arr_dPaAvfp=json["pInfo"].get_array();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            auto& temp=arr_dPaAvfp[xoxwYjr].get_object();
            deserialize_struct(temp,pInfo[xoxwYjr]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetDeviceImageMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_dGiJKQX=json["pInfo"].get_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEIMAGEMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkGetDeviceImageSparseMemoryRequirements(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageMemoryRequirements* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageMemoryRequirements*)malloc(1*sizeof(VkDeviceImageMemoryRequirements));
        auto& arr_dPaAvfp=json["pInfo"].get_array();
        for(int xoxwYjr=0; xoxwYjr < 1; xoxwYjr++){
            [&](){
            auto& temp=arr_dPaAvfp[xoxwYjr].get_object();
            deserialize_struct(temp,pInfo[xoxwYjr]);
            }();
        }
        }();
uint32_t* pSparseMemoryRequirementCount;
[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }pSparseMemoryRequirementCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
VkSparseImageMemoryRequirements2* pSparseMemoryRequirements;
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }pSparseMemoryRequirements=(VkSparseImageMemoryRequirements2*)malloc(*pSparseMemoryRequirementCount*sizeof(VkSparseImageMemoryRequirements2));
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSparseMemoryRequirements call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_instance_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageSparseMemoryRequirements)get_device_proc_addr(parent,"vkGetDeviceImageSparseMemoryRequirements");
    }  
    
{
call_function(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_dGiJKQX=json["pInfo"].get_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS;
        writeToConn(json);
    }

    void handle_vkCreateSamplerYcbcrConversion(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerYcbcrConversionCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkSamplerYcbcrConversionCreateInfo*)malloc(1*sizeof(VkSamplerYcbcrConversionCreateInfo));
        auto& arr_oCKmosw=json["pCreateInfo"].get_array();
        for(int LUUMfzS=0; LUUMfzS < 1; LUUMfzS++){
            [&](){
            auto& temp=arr_oCKmosw[LUUMfzS].get_object();
            deserialize_struct(temp,pCreateInfo[LUUMfzS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSamplerYcbcrConversion* pYcbcrConversion;
[&](){
            if (json["pYcbcrConversion"].get_array().size()==0){
                pYcbcrConversion=NULL;
            return; }pYcbcrConversion=(VkSamplerYcbcrConversion*)malloc(1*sizeof(VkSamplerYcbcrConversion));
        auto& arr_joRRIst=json["pYcbcrConversion"].get_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();

    PFN_vkCreateSamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_instance_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateSamplerYcbcrConversion)get_device_proc_addr(parent,"vkCreateSamplerYcbcrConversion");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_kLHhxUL=json["pCreateInfo"].get_array();
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto& temp=arr_kLHhxUL[zgqBgkX].emplace_object();
            return serialize_struct(temp, pCreateInfo[zgqBgkX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=boost::json::array();
            return; }json["pYcbcrConversion"]=boost::json::array(1);
        auto& arr_joRRIst=json["pYcbcrConversion"].get_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        }();


        json["stream_type"]=VKCREATESAMPLERYCBCRCONVERSION;
        writeToConn(json);
    }

    void handle_vkDestroySamplerYcbcrConversion(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSamplerYcbcrConversion ycbcrConversion;
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroySamplerYcbcrConversion call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_instance_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroySamplerYcbcrConversion)get_device_proc_addr(parent,"vkDestroySamplerYcbcrConversion");
    }  
    
{
call_function(device, ycbcrConversion, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSAMPLERYCBCRCONVERSION;
        writeToConn(json);
    }

    void handle_vkGetDeviceQueue2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceQueueInfo2* pQueueInfo;
[&](){
            if (json["pQueueInfo"].get_array().size()==0){
                pQueueInfo=NULL;
            return; }pQueueInfo=(VkDeviceQueueInfo2*)malloc(1*sizeof(VkDeviceQueueInfo2));
        auto& arr_GihFKhN=json["pQueueInfo"].get_array();
        for(int cWpAFXW=0; cWpAFXW < 1; cWpAFXW++){
            [&](){
            auto& temp=arr_GihFKhN[cWpAFXW].get_object();
            deserialize_struct(temp,pQueueInfo[cWpAFXW]);
            }();
        }
        }();
VkQueue* pQueue;
[&](){
            if (json["pQueue"].get_array().size()==0){
                pQueue=NULL;
            return; }pQueue=(VkQueue*)malloc(1*sizeof(VkQueue));
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

    PFN_vkGetDeviceQueue2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceQueue2)get_instance_proc_addr(parent,"vkGetDeviceQueue2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceQueue2)get_device_proc_addr(parent,"vkGetDeviceQueue2");
    }  
    
{
call_function(device, pQueueInfo, pQueue);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=boost::json::array();
            return; }json["pQueueInfo"]=boost::json::array(1);
        auto& arr_bNCRimR=json["pQueueInfo"].get_array();
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto& temp=arr_bNCRimR[ubuvbaB].emplace_object();
            return serialize_struct(temp, pQueueInfo[ubuvbaB]);
            }();
        }
        }();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }json["pQueue"]=boost::json::array(1);
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();


        json["stream_type"]=VKGETDEVICEQUEUE2;
        writeToConn(json);
    }

    void handle_vkCreateValidationCacheEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkValidationCacheCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkValidationCacheCreateInfoEXT*)malloc(1*sizeof(VkValidationCacheCreateInfoEXT));
        auto& arr_xouGZzH=json["pCreateInfo"].get_array();
        for(int kadSIIj=0; kadSIIj < 1; kadSIIj++){
            [&](){
            auto& temp=arr_xouGZzH[kadSIIj].get_object();
            deserialize_struct(temp,pCreateInfo[kadSIIj]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkValidationCacheEXT* pValidationCache;
[&](){
            if (json["pValidationCache"].get_array().size()==0){
                pValidationCache=NULL;
            return; }pValidationCache=(VkValidationCacheEXT*)malloc(1*sizeof(VkValidationCacheEXT));
        auto& arr_oYoDWhC=json["pValidationCache"].get_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();

    PFN_vkCreateValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateValidationCacheEXT)get_instance_proc_addr(parent,"vkCreateValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateValidationCacheEXT)get_device_proc_addr(parent,"vkCreateValidationCacheEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pValidationCache);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_ZCXiwLp=json["pCreateInfo"].get_array();
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto& temp=arr_ZCXiwLp[XeWuaSR].emplace_object();
            return serialize_struct(temp, pCreateInfo[XeWuaSR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=boost::json::array();
            return; }json["pValidationCache"]=boost::json::array(1);
        auto& arr_oYoDWhC=json["pValidationCache"].get_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        }();


        json["stream_type"]=VKCREATEVALIDATIONCACHEEXT;
        writeToConn(json);
    }

    void handle_vkDestroyValidationCacheEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyValidationCacheEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyValidationCacheEXT)get_instance_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyValidationCacheEXT)get_device_proc_addr(parent,"vkDestroyValidationCacheEXT");
    }  
    
{
call_function(device, validationCache, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYVALIDATIONCACHEEXT;
        writeToConn(json);
    }

    void handle_vkGetValidationCacheDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT validationCache;
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetValidationCacheDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetValidationCacheDataEXT)get_instance_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetValidationCacheDataEXT)get_device_proc_addr(parent,"vkGetValidationCacheDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, validationCache, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETVALIDATIONCACHEDATAEXT;
        writeToConn(json);
    }

    void handle_vkMergeValidationCachesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkValidationCacheEXT dstCache;
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
uint32_t srcCacheCount;
[&](){
            if (json["srcCacheCount"].is_uint64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_uint64());
            }else if (json["srcCacheCount"].is_int64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_int64());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_double());
            }
            }();
 VkValidationCacheEXT* pSrcCaches;
[&](){
            if (json["pSrcCaches"].get_array().size()==0){
                pSrcCaches=NULL;
            return; }pSrcCaches=(VkValidationCacheEXT*)malloc(srcCacheCount*sizeof(VkValidationCacheEXT));
        auto& arr_viZfWEe=json["pSrcCaches"].get_array();
        for(int svBdHjE=0; svBdHjE < srcCacheCount; svBdHjE++){
            [&](){deserialize_VkValidationCacheEXT(arr_viZfWEe[svBdHjE], pSrcCaches[svBdHjE]);}();
        }
        }();

    PFN_vkMergeValidationCachesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMergeValidationCachesEXT)get_instance_proc_addr(parent,"vkMergeValidationCachesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMergeValidationCachesEXT)get_device_proc_addr(parent,"vkMergeValidationCachesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, dstCache, srcCacheCount, pSrcCaches);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }json["pSrcCaches"]=boost::json::array(srcCacheCount);
        auto& arr_xXUlTaQ=json["pSrcCaches"].get_array();
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        }();


        json["stream_type"]=VKMERGEVALIDATIONCACHESEXT;
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSupport(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetLayoutCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDescriptorSetLayoutCreateInfo*)malloc(1*sizeof(VkDescriptorSetLayoutCreateInfo));
        auto& arr_oELBvJU=json["pCreateInfo"].get_array();
        for(int RmYFXzA=0; RmYFXzA < 1; RmYFXzA++){
            [&](){
            auto& temp=arr_oELBvJU[RmYFXzA].get_object();
            deserialize_struct(temp,pCreateInfo[RmYFXzA]);
            }();
        }
        }();
VkDescriptorSetLayoutSupport* pSupport;
[&](){
            if (json["pSupport"].get_array().size()==0){
                pSupport=NULL;
            return; }pSupport=(VkDescriptorSetLayoutSupport*)malloc(1*sizeof(VkDescriptorSetLayoutSupport));
        auto& arr_xgzGluH=json["pSupport"].get_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].get_object();
            deserialize_struct(temp,pSupport[UvZyHDI]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSupport call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSupport)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSupport");
    }  
    
{
call_function(device, pCreateInfo, pSupport);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dFRsqIW=json["pCreateInfo"].get_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=boost::json::array();
            return; }json["pSupport"]=boost::json::array(1);
        auto& arr_xgzGluH=json["pSupport"].get_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].emplace_object();
            return serialize_struct(temp, pSupport[UvZyHDI]);
            }();
        }
        }();


        json["stream_type"]=VKGETDESCRIPTORSETLAYOUTSUPPORT;
        writeToConn(json);
    }

    void handle_vkGetShaderInfoAMD(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
VkShaderStageFlagBits shaderStage;
[&](){[&](){int temp_nGZQHxq;[&](){
            if (json["shaderStage"].is_uint64()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_uint64());
            }else if (json["shaderStage"].is_int64()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_int64());
            }else{
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_double());
            }
            }();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
VkShaderInfoTypeAMD infoType;
[&](){[&](){int temp_nNfHNkf;[&](){
            if (json["infoType"].is_uint64()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_uint64());
            }else if (json["infoType"].is_int64()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_int64());
            }else{
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_double());
            }
            }();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
size_t* pInfoSize;
[&](){
            if (json["pInfoSize"].get_array().size()==0){
                pInfoSize=NULL;
            return; }pInfoSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_ouDPuUh=json["pInfoSize"].get_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){
            if (arr_ouDPuUh[wpUCmEy].is_uint64()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_uint64());
            }else if (arr_ouDPuUh[wpUCmEy].is_int64()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_int64());
            }else{
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_double());
            }
            }();
        }
        }();
void* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].get_array().size()==0){
                temp_ziBtDwK=NULL;
            return; }temp_ziBtDwK=(char*)malloc(*pInfoSize*sizeof(char));
        auto& arr_UHSCjHI=json["pInfo"].get_array();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){
            if (arr_UHSCjHI[rexTFCi].is_uint64()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_uint64());
            }else if (arr_UHSCjHI[rexTFCi].is_int64()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_int64());
            }else{
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_double());
            }
            }();
        }
        }();pInfo=temp_ziBtDwK;}();

    PFN_vkGetShaderInfoAMD call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderInfoAMD)get_instance_proc_addr(parent,"vkGetShaderInfoAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderInfoAMD)get_device_proc_addr(parent,"vkGetShaderInfoAMD");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=shaderStage;}();}();}();
[&](){[&](){[&](){json["infoType"]=infoType;}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=boost::json::array();
            return; }json["pInfoSize"]=boost::json::array(1);
        auto& arr_ouDPuUh=json["pInfoSize"].get_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=pInfoSize[wpUCmEy];}();
        }
        }();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(*pInfoSize);
        auto& arr_UHSCjHI=json["pInfo"].get_array();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){arr_UHSCjHI[rexTFCi]=((char*)(pInfo))[rexTFCi];}();
        }
        }();}();


        json["stream_type"]=VKGETSHADERINFOAMD;
        writeToConn(json);
    }

    void handle_vkSetLocalDimmingAMD(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapChain;
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
VkBool32 localDimmingEnable;
[&](){uint32_t temp_jfGMipq;[&](){
            if (json["localDimmingEnable"].is_uint64()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_uint64());
            }else if (json["localDimmingEnable"].is_int64()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_int64());
            }else{
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_double());
            }
            }();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

    PFN_vkSetLocalDimmingAMD call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetLocalDimmingAMD)get_instance_proc_addr(parent,"vkSetLocalDimmingAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetLocalDimmingAMD)get_device_proc_addr(parent,"vkSetLocalDimmingAMD");
    }  
    
{
call_function(device, swapChain, localDimmingEnable);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=localDimmingEnable;}();}();


        json["stream_type"]=VKSETLOCALDIMMINGAMD;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pTimeDomainCount;
[&](){
            if (json["pTimeDomainCount"].get_array().size()==0){
                pTimeDomainCount=NULL;
            return; }pTimeDomainCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_siSbERs=json["pTimeDomainCount"].get_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){
            if (arr_siSbERs[xFQhUzA].is_uint64()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_uint64());
            }else if (arr_siSbERs[xFQhUzA].is_int64()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_int64());
            }else{
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_double());
            }
            }();
        }
        }();
VkTimeDomainEXT* pTimeDomains;
[&](){
            if (json["pTimeDomains"].get_array().size()==0){
                pTimeDomains=NULL;
            return; }pTimeDomains=(VkTimeDomainEXT*)malloc(*pTimeDomainCount*sizeof(VkTimeDomainEXT));
        auto& arr_fMkUaJq=json["pTimeDomains"].get_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){
            if (arr_fMkUaJq[ZiXuFCL].is_uint64()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_uint64());
            }else if (arr_fMkUaJq[ZiXuFCL].is_int64()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_int64());
            }else{
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_double());
            }
            }();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();

    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)get_device_proc_addr(parent,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pTimeDomainCount, pTimeDomains);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=boost::json::array();
            return; }json["pTimeDomainCount"]=boost::json::array(1);
        auto& arr_siSbERs=json["pTimeDomainCount"].get_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=pTimeDomainCount[xFQhUzA];}();
        }
        }();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=boost::json::array();
            return; }json["pTimeDomains"]=boost::json::array(*pTimeDomainCount);
        auto& arr_fMkUaJq=json["pTimeDomains"].get_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=pTimeDomains[ZiXuFCL];}();}();}();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT;
        writeToConn(json);
    }

    void handle_vkGetCalibratedTimestampsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t timestampCount;
[&](){
            if (json["timestampCount"].is_uint64()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_uint64());
            }else if (json["timestampCount"].is_int64()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_int64());
            }else{
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_double());
            }
            }();
 VkCalibratedTimestampInfoEXT* pTimestampInfos;
[&](){
            if (json["pTimestampInfos"].get_array().size()==0){
                pTimestampInfos=NULL;
            return; }pTimestampInfos=(VkCalibratedTimestampInfoEXT*)malloc(timestampCount*sizeof(VkCalibratedTimestampInfoEXT));
        auto& arr_nEtDxWp=json["pTimestampInfos"].get_array();
        for(int GetmFjY=0; GetmFjY < timestampCount; GetmFjY++){
            [&](){
            auto& temp=arr_nEtDxWp[GetmFjY].get_object();
            deserialize_struct(temp,pTimestampInfos[GetmFjY]);
            }();
        }
        }();
uint64_t* pTimestamps;
[&](){
            if (json["pTimestamps"].get_array().size()==0){
                pTimestamps=NULL;
            return; }pTimestamps=(uint64_t*)malloc(timestampCount*sizeof(uint64_t));
        auto& arr_CHzcvgg=json["pTimestamps"].get_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){
            if (arr_CHzcvgg[ptqlrVt].is_uint64()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_uint64());
            }else if (arr_CHzcvgg[ptqlrVt].is_int64()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_int64());
            }else{
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_double());
            }
            }();
        }
        }();
uint64_t* pMaxDeviation;
[&](){
            if (json["pMaxDeviation"].get_array().size()==0){
                pMaxDeviation=NULL;
            return; }pMaxDeviation=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_zQmthvJ=json["pMaxDeviation"].get_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){
            if (arr_zQmthvJ[FUkBved].is_uint64()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_uint64());
            }else if (arr_zQmthvJ[FUkBved].is_int64()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_int64());
            }else{
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_double());
            }
            }();
        }
        }();

    PFN_vkGetCalibratedTimestampsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_instance_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetCalibratedTimestampsEXT)get_device_proc_addr(parent,"vkGetCalibratedTimestampsEXT");
    }  
    
VkResult  result;
{
result=call_function(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=timestampCount;}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=boost::json::array();
            return; }json["pTimestampInfos"]=boost::json::array(timestampCount);
        auto& arr_XQeyMsT=json["pTimestampInfos"].get_array();
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto& temp=arr_XQeyMsT[aXwwgcz].emplace_object();
            return serialize_struct(temp, pTimestampInfos[aXwwgcz]);
            }();
        }
        }();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=boost::json::array();
            return; }json["pTimestamps"]=boost::json::array(timestampCount);
        auto& arr_CHzcvgg=json["pTimestamps"].get_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=pTimestamps[ptqlrVt];}();
        }
        }();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=boost::json::array();
            return; }json["pMaxDeviation"]=boost::json::array(1);
        auto& arr_zQmthvJ=json["pMaxDeviation"].get_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=pMaxDeviation[FUkBved];}();
        }
        }();


        json["stream_type"]=VKGETCALIBRATEDTIMESTAMPSEXT;
        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectNameEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugUtilsObjectNameInfoEXT* pNameInfo;
[&](){
            if (json["pNameInfo"].get_array().size()==0){
                pNameInfo=NULL;
            return; }pNameInfo=(VkDebugUtilsObjectNameInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectNameInfoEXT));
        auto& arr_xezbRdt=json["pNameInfo"].get_array();
        for(int bpyMrKI=0; bpyMrKI < 1; bpyMrKI++){
            [&](){
            auto& temp=arr_xezbRdt[bpyMrKI].get_object();
            deserialize_struct(temp,pNameInfo[bpyMrKI]);
            }();
        }
        }();

    PFN_vkSetDebugUtilsObjectNameEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDebugUtilsObjectNameEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectNameEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pNameInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }json["pNameInfo"]=boost::json::array(1);
        auto& arr_gpHzyjV=json["pNameInfo"].get_array();
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto& temp=arr_gpHzyjV[sXDrIfX].emplace_object();
            return serialize_struct(temp, pNameInfo[sXDrIfX]);
            }();
        }
        }();


        json["stream_type"]=VKSETDEBUGUTILSOBJECTNAMEEXT;
        writeToConn(json);
    }

    void handle_vkSetDebugUtilsObjectTagEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDebugUtilsObjectTagInfoEXT* pTagInfo;
[&](){
            if (json["pTagInfo"].get_array().size()==0){
                pTagInfo=NULL;
            return; }pTagInfo=(VkDebugUtilsObjectTagInfoEXT*)malloc(1*sizeof(VkDebugUtilsObjectTagInfoEXT));
        auto& arr_Ltvhugt=json["pTagInfo"].get_array();
        for(int kYwKoxa=0; kYwKoxa < 1; kYwKoxa++){
            [&](){
            auto& temp=arr_Ltvhugt[kYwKoxa].get_object();
            deserialize_struct(temp,pTagInfo[kYwKoxa]);
            }();
        }
        }();

    PFN_vkSetDebugUtilsObjectTagEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_instance_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDebugUtilsObjectTagEXT)get_device_proc_addr(parent,"vkSetDebugUtilsObjectTagEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pTagInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }json["pTagInfo"]=boost::json::array(1);
        auto& arr_jMraQzd=json["pTagInfo"].get_array();
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto& temp=arr_jMraQzd[lQZzjnQ].emplace_object();
            return serialize_struct(temp, pTagInfo[lQZzjnQ]);
            }();
        }
        }();


        json["stream_type"]=VKSETDEBUGUTILSOBJECTTAGEXT;
        writeToConn(json);
    }

    void handle_vkQueueBeginDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].get_array().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].get_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].get_object();
            deserialize_struct(temp,pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkQueueBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        json["stream_type"]=VKQUEUEBEGINDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkQueueEndDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();

    PFN_vkQueueEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueEndDebugUtilsLabelEXT");
    }  
    
{
call_function(queue);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();


        json["stream_type"]=VKQUEUEENDDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkQueueInsertDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].get_array().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].get_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].get_object();
            deserialize_struct(temp,pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkQueueInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkQueueInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(queue, pLabelInfo);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        json["stream_type"]=VKQUEUEINSERTDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkCmdBeginDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].get_array().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].get_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].get_object();
            deserialize_struct(temp,pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkCmdBeginDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdBeginDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBEGINDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkCmdEndDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdEndDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDENDDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkCmdInsertDebugUtilsLabelEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDebugUtilsLabelEXT* pLabelInfo;
[&](){
            if (json["pLabelInfo"].get_array().size()==0){
                pLabelInfo=NULL;
            return; }pLabelInfo=(VkDebugUtilsLabelEXT*)malloc(1*sizeof(VkDebugUtilsLabelEXT));
        auto& arr_dixLKcm=json["pLabelInfo"].get_array();
        for(int lWNBzGj=0; lWNBzGj < 1; lWNBzGj++){
            [&](){
            auto& temp=arr_dixLKcm[lWNBzGj].get_object();
            deserialize_struct(temp,pLabelInfo[lWNBzGj]);
            }();
        }
        }();

    PFN_vkCmdInsertDebugUtilsLabelEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_instance_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdInsertDebugUtilsLabelEXT)get_device_proc_addr(parent,"vkCmdInsertDebugUtilsLabelEXT");
    }  
    
{
call_function(commandBuffer, pLabelInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();


        json["stream_type"]=VKCMDINSERTDEBUGUTILSLABELEXT;
        writeToConn(json);
    }

    void handle_vkCreateDebugUtilsMessengerEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkDebugUtilsMessengerCreateInfoEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCreateInfoEXT));
        auto& arr_kPYPRLp=json["pCreateInfo"].get_array();
        for(int XvRVXaf=0; XvRVXaf < 1; XvRVXaf++){
            [&](){
            auto& temp=arr_kPYPRLp[XvRVXaf].get_object();
            deserialize_struct(temp,pCreateInfo[XvRVXaf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDebugUtilsMessengerEXT* pMessenger;
[&](){
            if (json["pMessenger"].get_array().size()==0){
                pMessenger=NULL;
            return; }pMessenger=(VkDebugUtilsMessengerEXT*)malloc(1*sizeof(VkDebugUtilsMessengerEXT));
        auto& arr_INDwqtI=json["pMessenger"].get_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();

    PFN_vkCreateDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkCreateDebugUtilsMessengerEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pMessenger);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_alrnjyY=json["pCreateInfo"].get_array();
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto& temp=arr_alrnjyY[uDOYkhP].emplace_object();
            return serialize_struct(temp, pCreateInfo[uDOYkhP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=boost::json::array();
            return; }json["pMessenger"]=boost::json::array(1);
        auto& arr_INDwqtI=json["pMessenger"].get_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        }();


        json["stream_type"]=VKCREATEDEBUGUTILSMESSENGEREXT;
        writeToConn(json);
    }

    void handle_vkDestroyDebugUtilsMessengerEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessengerEXT messenger;
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDebugUtilsMessengerEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_instance_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDebugUtilsMessengerEXT)get_device_proc_addr(parent,"vkDestroyDebugUtilsMessengerEXT");
    }  
    
{
call_function(instance, messenger, pAllocator);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDEBUGUTILSMESSENGEREXT;
        writeToConn(json);
    }

    void handle_vkSubmitDebugUtilsMessageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
[&](){[&](){int temp_UpocUQR;[&](){
            if (json["messageSeverity"].is_uint64()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_uint64());
            }else if (json["messageSeverity"].is_int64()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_int64());
            }else{
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_double());
            }
            }();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
VkDebugUtilsMessageTypeFlagsEXT messageTypes;
[&](){[&](){int temp_vbjSEUE;[&](){
            if (json["messageTypes"].is_uint64()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_uint64());
            }else if (json["messageTypes"].is_int64()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_int64());
            }else{
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_double());
            }
            }();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();
 VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
[&](){
            if (json["pCallbackData"].get_array().size()==0){
                pCallbackData=NULL;
            return; }pCallbackData=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCallbackDataEXT));
        auto& arr_MlNAOAx=json["pCallbackData"].get_array();
        for(int EdtNsto=0; EdtNsto < 1; EdtNsto++){
            [&](){
            auto& temp=arr_MlNAOAx[EdtNsto].get_object();
            deserialize_struct(temp,pCallbackData[EdtNsto]);
            }();
        }
        }();

    PFN_vkSubmitDebugUtilsMessageEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_instance_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSubmitDebugUtilsMessageEXT)get_device_proc_addr(parent,"vkSubmitDebugUtilsMessageEXT");
    }  
    
{
call_function(instance, messageSeverity, messageTypes, pCallbackData);
}
json.clear();

[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_kahfHKb=json["pCallbackData"].get_array();
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto& temp=arr_kahfHKb[YuXULtv].emplace_object();
            return serialize_struct(temp, pCallbackData[YuXULtv]);
            }();
        }
        }();


        json["stream_type"]=VKSUBMITDEBUGUTILSMESSAGEEXT;
        writeToConn(json);
    }

    void handle_vkGetMemoryHostPointerPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkExternalMemoryHandleTypeFlagBits handleType;
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_uint64());
            }else if (json["handleType"].is_int64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_int64());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
 void* pHostPointer;
[&](){
            if (json["pHostPointer"].get_array().size()==0){
                pHostPointer=NULL;
            return; }char* temp_EiZqusU;[&](){
            if (json["pHostPointer"].get_array().size()==0){
                temp_EiZqusU=NULL;
            return; }temp_EiZqusU=(char*)malloc(json["pHostPointer"].get_array().size()*sizeof(char));
        auto& arr_FmrmuUL=json["pHostPointer"].get_array();
        for(int SfNZViD=0; SfNZViD < json["pHostPointer"].get_array().size(); SfNZViD++){
            [&](){
            if (arr_FmrmuUL[SfNZViD].is_uint64()){
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].get_uint64());
            }else if (arr_FmrmuUL[SfNZViD].is_int64()){
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].get_int64());
            }else{
                temp_EiZqusU[SfNZViD]=static_cast<char>(arr_FmrmuUL[SfNZViD].get_double());
            }
            }();
        }
        }();pHostPointer=temp_EiZqusU;}();
VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties;
[&](){
            if (json["pMemoryHostPointerProperties"].get_array().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }pMemoryHostPointerProperties=(VkMemoryHostPointerPropertiesEXT*)malloc(1*sizeof(VkMemoryHostPointerPropertiesEXT));
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].get_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].get_object();
            deserialize_struct(temp,pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();

    PFN_vkGetMemoryHostPointerPropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_instance_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMemoryHostPointerPropertiesEXT)get_device_proc_addr(parent,"vkGetMemoryHostPointerPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }json["pHostPointer"]=boost::json::array(strlen(((char*)(pHostPointer)))+1);
        auto& arr_iKHPNio=json["pHostPointer"].get_array();
        for(int UFxRrhm=0; UFxRrhm < strlen(((char*)(pHostPointer)))+1; UFxRrhm++){
            [&](){arr_iKHPNio[UFxRrhm]=((char*)(pHostPointer))[UFxRrhm];}();
        }
        }();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=boost::json::array();
            return; }json["pMemoryHostPointerProperties"]=boost::json::array(1);
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].get_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].emplace_object();
            return serialize_struct(temp, pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();


        json["stream_type"]=VKGETMEMORYHOSTPOINTERPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarkerAMD(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlagBits pipelineStage;
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_uint64());
            }else if (json["pipelineStage"].is_int64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_int64());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){
            if (json["marker"].is_uint64()){
                marker=static_cast<uint32_t>(json["marker"].get_uint64());
            }else if (json["marker"].is_int64()){
                marker=static_cast<uint32_t>(json["marker"].get_int64());
            }else{
                marker=static_cast<uint32_t>(json["marker"].get_double());
            }
            }();

    PFN_vkCmdWriteBufferMarkerAMD call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteBufferMarkerAMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarkerAMD");
    }  
    
{
call_function(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();


        json["stream_type"]=VKCMDWRITEBUFFERMARKERAMD;
        writeToConn(json);
    }

    void handle_vkCreateRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderPassCreateInfo2* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkRenderPassCreateInfo2*)malloc(1*sizeof(VkRenderPassCreateInfo2));
        auto& arr_wVuIjAr=json["pCreateInfo"].get_array();
        for(int LBnjMyA=0; LBnjMyA < 1; LBnjMyA++){
            [&](){
            auto& temp=arr_wVuIjAr[LBnjMyA].get_object();
            deserialize_struct(temp,pCreateInfo[LBnjMyA]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkRenderPass* pRenderPass;
[&](){
            if (json["pRenderPass"].get_array().size()==0){
                pRenderPass=NULL;
            return; }pRenderPass=(VkRenderPass*)malloc(1*sizeof(VkRenderPass));
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();

    PFN_vkCreateRenderPass2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRenderPass2)get_instance_proc_addr(parent,"vkCreateRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRenderPass2)get_device_proc_addr(parent,"vkCreateRenderPass2");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pRenderPass);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_cDssBor=json["pCreateInfo"].get_array();
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto& temp=arr_cDssBor[SgbVidQ].emplace_object();
            return serialize_struct(temp, pCreateInfo[SgbVidQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }json["pRenderPass"]=boost::json::array(1);
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();


        json["stream_type"]=VKCREATERENDERPASS2;
        writeToConn(json);
    }

    void handle_vkCmdBeginRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderPassBeginInfo* pRenderPassBegin;
[&](){
            if (json["pRenderPassBegin"].get_array().size()==0){
                pRenderPassBegin=NULL;
            return; }pRenderPassBegin=(VkRenderPassBeginInfo*)malloc(1*sizeof(VkRenderPassBeginInfo));
        auto& arr_DvmhBAI=json["pRenderPassBegin"].get_array();
        for(int MzTximI=0; MzTximI < 1; MzTximI++){
            [&](){
            auto& temp=arr_DvmhBAI[MzTximI].get_object();
            deserialize_struct(temp,pRenderPassBegin[MzTximI]);
            }();
        }
        }();
 VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){
            if (json["pSubpassBeginInfo"].get_array().size()==0){
                pSubpassBeginInfo=NULL;
            return; }pSubpassBeginInfo=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));
        auto& arr_EzXVEdi=json["pSubpassBeginInfo"].get_array();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            auto& temp=arr_EzXVEdi[nrSIqlz].get_object();
            deserialize_struct(temp,pSubpassBeginInfo[nrSIqlz]);
            }();
        }
        }();

    PFN_vkCmdBeginRenderPass2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRenderPass2)get_instance_proc_addr(parent,"vkCmdBeginRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRenderPass2)get_device_proc_addr(parent,"vkCmdBeginRenderPass2");
    }  
    
{
call_function(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }json["pRenderPassBegin"]=boost::json::array(1);
        auto& arr_XtnTubd=json["pRenderPassBegin"].get_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }json["pSubpassBeginInfo"]=boost::json::array(1);
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].get_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBEGINRENDERPASS2;
        writeToConn(json);
    }

    void handle_vkCmdNextSubpass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSubpassBeginInfo* pSubpassBeginInfo;
[&](){
            if (json["pSubpassBeginInfo"].get_array().size()==0){
                pSubpassBeginInfo=NULL;
            return; }pSubpassBeginInfo=(VkSubpassBeginInfo*)malloc(1*sizeof(VkSubpassBeginInfo));
        auto& arr_EzXVEdi=json["pSubpassBeginInfo"].get_array();
        for(int nrSIqlz=0; nrSIqlz < 1; nrSIqlz++){
            [&](){
            auto& temp=arr_EzXVEdi[nrSIqlz].get_object();
            deserialize_struct(temp,pSubpassBeginInfo[nrSIqlz]);
            }();
        }
        }();
 VkSubpassEndInfo* pSubpassEndInfo;
[&](){
            if (json["pSubpassEndInfo"].get_array().size()==0){
                pSubpassEndInfo=NULL;
            return; }pSubpassEndInfo=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));
        auto& arr_GcsVuns=json["pSubpassEndInfo"].get_array();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            auto& temp=arr_GcsVuns[rFLLcAK].get_object();
            deserialize_struct(temp,pSubpassEndInfo[rFLLcAK]);
            }();
        }
        }();

    PFN_vkCmdNextSubpass2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdNextSubpass2)get_instance_proc_addr(parent,"vkCmdNextSubpass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdNextSubpass2)get_device_proc_addr(parent,"vkCmdNextSubpass2");
    }  
    
{
call_function(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }json["pSubpassBeginInfo"]=boost::json::array(1);
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].get_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }json["pSubpassEndInfo"]=boost::json::array(1);
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].get_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();


        json["stream_type"]=VKCMDNEXTSUBPASS2;
        writeToConn(json);
    }

    void handle_vkCmdEndRenderPass2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkSubpassEndInfo* pSubpassEndInfo;
[&](){
            if (json["pSubpassEndInfo"].get_array().size()==0){
                pSubpassEndInfo=NULL;
            return; }pSubpassEndInfo=(VkSubpassEndInfo*)malloc(1*sizeof(VkSubpassEndInfo));
        auto& arr_GcsVuns=json["pSubpassEndInfo"].get_array();
        for(int rFLLcAK=0; rFLLcAK < 1; rFLLcAK++){
            [&](){
            auto& temp=arr_GcsVuns[rFLLcAK].get_object();
            deserialize_struct(temp,pSubpassEndInfo[rFLLcAK]);
            }();
        }
        }();

    PFN_vkCmdEndRenderPass2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRenderPass2)get_instance_proc_addr(parent,"vkCmdEndRenderPass2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRenderPass2)get_device_proc_addr(parent,"vkCmdEndRenderPass2");
    }  
    
{
call_function(commandBuffer, pSubpassEndInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }json["pSubpassEndInfo"]=boost::json::array(1);
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].get_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();


        json["stream_type"]=VKCMDENDRENDERPASS2;
        writeToConn(json);
    }

    void handle_vkGetSemaphoreCounterValue(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSemaphore semaphore;
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
uint64_t* pValue;
[&](){
            if (json["pValue"].get_array().size()==0){
                pValue=NULL;
            return; }pValue=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_xnMrErb=json["pValue"].get_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){
            if (arr_xnMrErb[fdUIVMD].is_uint64()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_uint64());
            }else if (arr_xnMrErb[fdUIVMD].is_int64()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_int64());
            }else{
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_double());
            }
            }();
        }
        }();

    PFN_vkGetSemaphoreCounterValue call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSemaphoreCounterValue)get_instance_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSemaphoreCounterValue)get_device_proc_addr(parent,"vkGetSemaphoreCounterValue");
    }  
    
VkResult  result;
{
result=call_function(device, semaphore, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }json["pValue"]=boost::json::array(1);
        auto& arr_xnMrErb=json["pValue"].get_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=pValue[fdUIVMD];}();
        }
        }();


        json["stream_type"]=VKGETSEMAPHORECOUNTERVALUE;
        writeToConn(json);
    }

    void handle_vkWaitSemaphores(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreWaitInfo* pWaitInfo;
[&](){
            if (json["pWaitInfo"].get_array().size()==0){
                pWaitInfo=NULL;
            return; }pWaitInfo=(VkSemaphoreWaitInfo*)malloc(1*sizeof(VkSemaphoreWaitInfo));
        auto& arr_saOfReP=json["pWaitInfo"].get_array();
        for(int PdcqhvB=0; PdcqhvB < 1; PdcqhvB++){
            [&](){
            auto& temp=arr_saOfReP[PdcqhvB].get_object();
            deserialize_struct(temp,pWaitInfo[PdcqhvB]);
            }();
        }
        }();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();

    PFN_vkWaitSemaphores call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitSemaphores)get_instance_proc_addr(parent,"vkWaitSemaphores");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitSemaphores)get_device_proc_addr(parent,"vkWaitSemaphores");
    }  
    
VkResult  result;
{
result=call_function(device, pWaitInfo, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=boost::json::array();
            return; }json["pWaitInfo"]=boost::json::array(1);
        auto& arr_xzakrWz=json["pWaitInfo"].get_array();
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto& temp=arr_xzakrWz[hsOLCWG].emplace_object();
            return serialize_struct(temp, pWaitInfo[hsOLCWG]);
            }();
        }
        }();
[&](){json["timeout"]=timeout;}();


        json["stream_type"]=VKWAITSEMAPHORES;
        writeToConn(json);
    }

    void handle_vkSignalSemaphore(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSemaphoreSignalInfo* pSignalInfo;
[&](){
            if (json["pSignalInfo"].get_array().size()==0){
                pSignalInfo=NULL;
            return; }pSignalInfo=(VkSemaphoreSignalInfo*)malloc(1*sizeof(VkSemaphoreSignalInfo));
        auto& arr_NpBehDR=json["pSignalInfo"].get_array();
        for(int AsjxdFQ=0; AsjxdFQ < 1; AsjxdFQ++){
            [&](){
            auto& temp=arr_NpBehDR[AsjxdFQ].get_object();
            deserialize_struct(temp,pSignalInfo[AsjxdFQ]);
            }();
        }
        }();

    PFN_vkSignalSemaphore call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSignalSemaphore)get_instance_proc_addr(parent,"vkSignalSemaphore");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSignalSemaphore)get_device_proc_addr(parent,"vkSignalSemaphore");
    }  
    
VkResult  result;
{
result=call_function(device, pSignalInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=boost::json::array();
            return; }json["pSignalInfo"]=boost::json::array(1);
        auto& arr_WdRQTJS=json["pSignalInfo"].get_array();
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto& temp=arr_WdRQTJS[MYLvJyX].emplace_object();
            return serialize_struct(temp, pSignalInfo[MYLvJyX]);
            }();
        }
        }();


        json["stream_type"]=VKSIGNALSEMAPHORE;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawIndirectCount call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWINDIRECTCOUNT;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndexedIndirectCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawIndexedIndirectCount call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_instance_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndexedIndirectCount)get_device_proc_addr(parent,"vkCmdDrawIndexedIndirectCount");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWINDEXEDINDIRECTCOUNT;
        writeToConn(json);
    }

    void handle_vkCmdSetCheckpointNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 void* pCheckpointMarker;
[&](){
            if (json["pCheckpointMarker"].get_array().size()==0){
                pCheckpointMarker=NULL;
            return; }char* temp_AspjKUC;[&](){
            if (json["pCheckpointMarker"].get_array().size()==0){
                temp_AspjKUC=NULL;
            return; }temp_AspjKUC=(char*)malloc(json["pCheckpointMarker"].get_array().size()*sizeof(char));
        auto& arr_xxgFDIv=json["pCheckpointMarker"].get_array();
        for(int ymeyWZR=0; ymeyWZR < json["pCheckpointMarker"].get_array().size(); ymeyWZR++){
            [&](){
            if (arr_xxgFDIv[ymeyWZR].is_uint64()){
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].get_uint64());
            }else if (arr_xxgFDIv[ymeyWZR].is_int64()){
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].get_int64());
            }else{
                temp_AspjKUC[ymeyWZR]=static_cast<char>(arr_xxgFDIv[ymeyWZR].get_double());
            }
            }();
        }
        }();pCheckpointMarker=temp_AspjKUC;}();

    PFN_vkCmdSetCheckpointNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCheckpointNV)get_instance_proc_addr(parent,"vkCmdSetCheckpointNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCheckpointNV)get_device_proc_addr(parent,"vkCmdSetCheckpointNV");
    }  
    
{
call_function(commandBuffer, pCheckpointMarker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }json["pCheckpointMarker"]=boost::json::array(strlen(((char*)(pCheckpointMarker)))+1);
        auto& arr_eBRjtYz=json["pCheckpointMarker"].get_array();
        for(int VYoknaS=0; VYoknaS < strlen(((char*)(pCheckpointMarker)))+1; VYoknaS++){
            [&](){arr_eBRjtYz[VYoknaS]=((char*)(pCheckpointMarker))[VYoknaS];}();
        }
        }();}();


        json["stream_type"]=VKCMDSETCHECKPOINTNV;
        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointDataNV(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].get_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_uint64());
            }else if (arr_LsYqVIK[lgasnOP].is_int64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_int64());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_double());
            }
            }();
        }
        }();
VkCheckpointDataNV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].get_array().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointDataNV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointDataNV));
        auto& arr_gxwhODc=json["pCheckpointData"].get_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].get_object();
            deserialize_struct(temp,pCheckpointData[TfFHlNo]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointDataNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_instance_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueueCheckpointDataNV)get_device_proc_addr(parent,"vkGetQueueCheckpointDataNV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }json["pCheckpointDataCount"]=boost::json::array(1);
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }json["pCheckpointData"]=boost::json::array(*pCheckpointDataCount);
        auto& arr_gxwhODc=json["pCheckpointData"].get_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].emplace_object();
            return serialize_struct(temp, pCheckpointData[TfFHlNo]);
            }();
        }
        }();


        json["stream_type"]=VKGETQUEUECHECKPOINTDATANV;
        writeToConn(json);
    }

    void handle_vkCmdBindTransformFeedbackBuffersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].get_array().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].get_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].get_array().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].get_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_uint64());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_int64());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();
 VkDeviceSize* pSizes;
[&](){
            if (json["pSizes"].get_array().size()==0){
                pSizes=NULL;
            return; }pSizes=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_cHIDMyb=json["pSizes"].get_array();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){
            if (arr_cHIDMyb[yLUmhkZ].is_uint64()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_uint64());
            }else if (arr_cHIDMyb[yLUmhkZ].is_int64()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_int64());
            }else{
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_double());
            }
            }();pSizes[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();

    PFN_vkCmdBindTransformFeedbackBuffersEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindTransformFeedbackBuffersEXT)get_device_proc_addr(parent,"vkCmdBindTransformFeedbackBuffersEXT");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }json["pSizes"]=boost::json::array(bindingCount);
        auto& arr_OwyEmcF=json["pSizes"].get_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();


        json["stream_type"]=VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT;
        writeToConn(json);
    }

    void handle_vkCmdBeginTransformFeedbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){
            if (json["firstCounterBuffer"].is_uint64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_uint64());
            }else if (json["firstCounterBuffer"].is_int64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_int64());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_double());
            }
            }();
uint32_t counterBufferCount;
[&](){
            if (json["counterBufferCount"].is_uint64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_uint64());
            }else if (json["counterBufferCount"].is_int64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_int64());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_double());
            }
            }();
 VkBuffer* pCounterBuffers;
[&](){
            if (json["pCounterBuffers"].get_array().size()==0){
                pCounterBuffers=NULL;
            return; }pCounterBuffers=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));
        auto& arr_BxMTckm=json["pCounterBuffers"].get_array();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], pCounterBuffers[TXsvtyB]);}();
        }
        }();
 VkDeviceSize* pCounterBufferOffsets;
[&](){
            if (json["pCounterBufferOffsets"].get_array().size()==0){
                pCounterBufferOffsets=NULL;
            return; }pCounterBufferOffsets=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));
        auto& arr_LrVQuLK=json["pCounterBufferOffsets"].get_array();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){
            if (arr_LrVQuLK[FmZEqMc].is_uint64()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_uint64());
            }else if (arr_LrVQuLK[FmZEqMc].is_int64()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_int64());
            }else{
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_double());
            }
            }();pCounterBufferOffsets[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();

    PFN_vkCmdBeginTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdBeginTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }json["pCounterBuffers"]=boost::json::array(counterBufferCount);
        auto& arr_eyGyJgR=json["pCounterBuffers"].get_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }json["pCounterBufferOffsets"]=boost::json::array(counterBufferCount);
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].get_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();


        json["stream_type"]=VKCMDBEGINTRANSFORMFEEDBACKEXT;
        writeToConn(json);
    }

    void handle_vkCmdEndTransformFeedbackEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstCounterBuffer;
[&](){
            if (json["firstCounterBuffer"].is_uint64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_uint64());
            }else if (json["firstCounterBuffer"].is_int64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_int64());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_double());
            }
            }();
uint32_t counterBufferCount;
[&](){
            if (json["counterBufferCount"].is_uint64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_uint64());
            }else if (json["counterBufferCount"].is_int64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_int64());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_double());
            }
            }();
 VkBuffer* pCounterBuffers;
[&](){
            if (json["pCounterBuffers"].get_array().size()==0){
                pCounterBuffers=NULL;
            return; }pCounterBuffers=(VkBuffer*)malloc(counterBufferCount*sizeof(VkBuffer));
        auto& arr_BxMTckm=json["pCounterBuffers"].get_array();
        for(int TXsvtyB=0; TXsvtyB < counterBufferCount; TXsvtyB++){
            [&](){deserialize_VkBuffer(arr_BxMTckm[TXsvtyB], pCounterBuffers[TXsvtyB]);}();
        }
        }();
 VkDeviceSize* pCounterBufferOffsets;
[&](){
            if (json["pCounterBufferOffsets"].get_array().size()==0){
                pCounterBufferOffsets=NULL;
            return; }pCounterBufferOffsets=(VkDeviceSize*)malloc(counterBufferCount*sizeof(VkDeviceSize));
        auto& arr_LrVQuLK=json["pCounterBufferOffsets"].get_array();
        for(int FmZEqMc=0; FmZEqMc < counterBufferCount; FmZEqMc++){
            [&](){uint64_t temp_LrVQuLK;[&](){
            if (arr_LrVQuLK[FmZEqMc].is_uint64()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_uint64());
            }else if (arr_LrVQuLK[FmZEqMc].is_int64()){
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_int64());
            }else{
                temp_LrVQuLK=static_cast<uint64_t>(arr_LrVQuLK[FmZEqMc].get_double());
            }
            }();pCounterBufferOffsets[FmZEqMc]=(VkDeviceSize)temp_LrVQuLK;}();
        }
        }();

    PFN_vkCmdEndTransformFeedbackEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_instance_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndTransformFeedbackEXT)get_device_proc_addr(parent,"vkCmdEndTransformFeedbackEXT");
    }  
    
{
call_function(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }json["pCounterBuffers"]=boost::json::array(counterBufferCount);
        auto& arr_eyGyJgR=json["pCounterBuffers"].get_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }json["pCounterBufferOffsets"]=boost::json::array(counterBufferCount);
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].get_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();


        json["stream_type"]=VKCMDENDTRANSFORMFEEDBACKEXT;
        writeToConn(json);
    }

    void handle_vkCmdBeginQueryIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
VkQueryControlFlags flags;
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
uint32_t index;
[&](){
            if (json["index"].is_uint64()){
                index=static_cast<uint32_t>(json["index"].get_uint64());
            }else if (json["index"].is_int64()){
                index=static_cast<uint32_t>(json["index"].get_int64());
            }else{
                index=static_cast<uint32_t>(json["index"].get_double());
            }
            }();

    PFN_vkCmdBeginQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdBeginQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, flags, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){json["index"]=index;}();


        json["stream_type"]=VKCMDBEGINQUERYINDEXEDEXT;
        writeToConn(json);
    }

    void handle_vkCmdEndQueryIndexedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
uint32_t index;
[&](){
            if (json["index"].is_uint64()){
                index=static_cast<uint32_t>(json["index"].get_uint64());
            }else if (json["index"].is_int64()){
                index=static_cast<uint32_t>(json["index"].get_int64());
            }else{
                index=static_cast<uint32_t>(json["index"].get_double());
            }
            }();

    PFN_vkCmdEndQueryIndexedEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_instance_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndQueryIndexedEXT)get_device_proc_addr(parent,"vkCmdEndQueryIndexedEXT");
    }  
    
{
call_function(commandBuffer, queryPool, query, index);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){json["index"]=index;}();


        json["stream_type"]=VKCMDENDQUERYINDEXEDEXT;
        writeToConn(json);
    }

    void handle_vkCmdDrawIndirectByteCountEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t instanceCount;
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
uint32_t firstInstance;
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
VkBuffer counterBuffer;
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
VkDeviceSize counterBufferOffset;
[&](){uint64_t temp_AQwWAlK;[&](){
            if (json["counterBufferOffset"].is_uint64()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_uint64());
            }else if (json["counterBufferOffset"].is_int64()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_int64());
            }else{
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_double());
            }
            }();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
uint32_t counterOffset;
[&](){
            if (json["counterOffset"].is_uint64()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_uint64());
            }else if (json["counterOffset"].is_int64()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_int64());
            }else{
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_double());
            }
            }();
uint32_t vertexStride;
[&](){
            if (json["vertexStride"].is_uint64()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_uint64());
            }else if (json["vertexStride"].is_int64()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_int64());
            }else{
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_double());
            }
            }();

    PFN_vkCmdDrawIndirectByteCountEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_instance_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawIndirectByteCountEXT)get_device_proc_addr(parent,"vkCmdDrawIndirectByteCountEXT");
    }  
    
{
call_function(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=counterBufferOffset;}();}();
[&](){json["counterOffset"]=counterOffset;}();
[&](){json["vertexStride"]=vertexStride;}();


        json["stream_type"]=VKCMDDRAWINDIRECTBYTECOUNTEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){
            if (json["firstExclusiveScissor"].is_uint64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_uint64());
            }else if (json["firstExclusiveScissor"].is_int64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_int64());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_double());
            }
            }();
uint32_t exclusiveScissorCount;
[&](){
            if (json["exclusiveScissorCount"].is_uint64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_uint64());
            }else if (json["exclusiveScissorCount"].is_int64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_int64());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_double());
            }
            }();
 VkRect2D* pExclusiveScissors;
[&](){
            if (json["pExclusiveScissors"].get_array().size()==0){
                pExclusiveScissors=NULL;
            return; }pExclusiveScissors=(VkRect2D*)malloc(exclusiveScissorCount*sizeof(VkRect2D));
        auto& arr_ZinqSQR=json["pExclusiveScissors"].get_array();
        for(int SkofLXN=0; SkofLXN < exclusiveScissorCount; SkofLXN++){
            [&](){
            auto& temp=arr_ZinqSQR[SkofLXN].get_object();
            deserialize_struct(temp,pExclusiveScissors[SkofLXN]);
            }();
        }
        }();

    PFN_vkCmdSetExclusiveScissorNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExclusiveScissorNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=boost::json::array();
            return; }json["pExclusiveScissors"]=boost::json::array(exclusiveScissorCount);
        auto& arr_aPFLQnr=json["pExclusiveScissors"].get_array();
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto& temp=arr_aPFLQnr[uoWCiOs].emplace_object();
            return serialize_struct(temp, pExclusiveScissors[uoWCiOs]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETEXCLUSIVESCISSORNV;
        writeToConn(json);
    }

    void handle_vkCmdSetExclusiveScissorEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstExclusiveScissor;
[&](){
            if (json["firstExclusiveScissor"].is_uint64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_uint64());
            }else if (json["firstExclusiveScissor"].is_int64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_int64());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_double());
            }
            }();
uint32_t exclusiveScissorCount;
[&](){
            if (json["exclusiveScissorCount"].is_uint64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_uint64());
            }else if (json["exclusiveScissorCount"].is_int64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_int64());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_double());
            }
            }();
 VkBool32* pExclusiveScissorEnables;
[&](){
            if (json["pExclusiveScissorEnables"].get_array().size()==0){
                pExclusiveScissorEnables=NULL;
            return; }pExclusiveScissorEnables=(VkBool32*)malloc(exclusiveScissorCount*sizeof(VkBool32));
        auto& arr_gutsiaF=json["pExclusiveScissorEnables"].get_array();
        for(int DJnjHfh=0; DJnjHfh < exclusiveScissorCount; DJnjHfh++){
            [&](){uint32_t temp_gutsiaF;[&](){
            if (arr_gutsiaF[DJnjHfh].is_uint64()){
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].get_uint64());
            }else if (arr_gutsiaF[DJnjHfh].is_int64()){
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].get_int64());
            }else{
                temp_gutsiaF=static_cast<uint32_t>(arr_gutsiaF[DJnjHfh].get_double());
            }
            }();pExclusiveScissorEnables[DJnjHfh]=(VkBool32)temp_gutsiaF;}();
        }
        }();

    PFN_vkCmdSetExclusiveScissorEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_instance_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExclusiveScissorEnableNV)get_device_proc_addr(parent,"vkCmdSetExclusiveScissorEnableNV");
    }  
    
{
call_function(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=boost::json::array();
            return; }json["pExclusiveScissorEnables"]=boost::json::array(exclusiveScissorCount);
        auto& arr_xqHCjsr=json["pExclusiveScissorEnables"].get_array();
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=pExclusiveScissorEnables[ZwZaOgk];}();}();
        }
        }();


        json["stream_type"]=VKCMDSETEXCLUSIVESCISSORENABLENV;
        writeToConn(json);
    }

    void handle_vkCmdBindShadingRateImageNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindShadingRateImageNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_instance_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindShadingRateImageNV)get_device_proc_addr(parent,"vkCmdBindShadingRateImageNV");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();


        json["stream_type"]=VKCMDBINDSHADINGRATEIMAGENV;
        writeToConn(json);
    }

    void handle_vkCmdSetViewportShadingRatePaletteNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();
 VkShadingRatePaletteNV* pShadingRatePalettes;
[&](){
            if (json["pShadingRatePalettes"].get_array().size()==0){
                pShadingRatePalettes=NULL;
            return; }pShadingRatePalettes=(VkShadingRatePaletteNV*)malloc(viewportCount*sizeof(VkShadingRatePaletteNV));
        auto& arr_wkMlexp=json["pShadingRatePalettes"].get_array();
        for(int SqzUOqM=0; SqzUOqM < viewportCount; SqzUOqM++){
            [&](){
            auto& temp=arr_wkMlexp[SqzUOqM].get_object();
            deserialize_struct(temp,pShadingRatePalettes[SqzUOqM]);
            }();
        }
        }();

    PFN_vkCmdSetViewportShadingRatePaletteNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_instance_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportShadingRatePaletteNV)get_device_proc_addr(parent,"vkCmdSetViewportShadingRatePaletteNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=boost::json::array();
            return; }json["pShadingRatePalettes"]=boost::json::array(viewportCount);
        auto& arr_QGCIyPL=json["pShadingRatePalettes"].get_array();
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto& temp=arr_QGCIyPL[iwmSeHU].emplace_object();
            return serialize_struct(temp, pShadingRatePalettes[iwmSeHU]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVIEWPORTSHADINGRATEPALETTENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoarseSampleOrderNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoarseSampleOrderTypeNV sampleOrderType;
[&](){[&](){int temp_iGYbmmy;[&](){
            if (json["sampleOrderType"].is_uint64()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_uint64());
            }else if (json["sampleOrderType"].is_int64()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_int64());
            }else{
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_double());
            }
            }();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
uint32_t customSampleOrderCount;
[&](){
            if (json["customSampleOrderCount"].is_uint64()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_uint64());
            }else if (json["customSampleOrderCount"].is_int64()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_int64());
            }else{
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_double());
            }
            }();
 VkCoarseSampleOrderCustomNV* pCustomSampleOrders;
[&](){
            if (json["pCustomSampleOrders"].get_array().size()==0){
                pCustomSampleOrders=NULL;
            return; }pCustomSampleOrders=(VkCoarseSampleOrderCustomNV*)malloc(customSampleOrderCount*sizeof(VkCoarseSampleOrderCustomNV));
        auto& arr_XDqsEzE=json["pCustomSampleOrders"].get_array();
        for(int MsAfwio=0; MsAfwio < customSampleOrderCount; MsAfwio++){
            [&](){
            auto& temp=arr_XDqsEzE[MsAfwio].get_object();
            deserialize_struct(temp,pCustomSampleOrders[MsAfwio]);
            }();
        }
        }();

    PFN_vkCmdSetCoarseSampleOrderNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_instance_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoarseSampleOrderNV)get_device_proc_addr(parent,"vkCmdSetCoarseSampleOrderNV");
    }  
    
{
call_function(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=sampleOrderType;}();}();}();
[&](){json["customSampleOrderCount"]=customSampleOrderCount;}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=boost::json::array();
            return; }json["pCustomSampleOrders"]=boost::json::array(customSampleOrderCount);
        auto& arr_UoJKhih=json["pCustomSampleOrders"].get_array();
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto& temp=arr_UoJKhih[nBPVlSV].emplace_object();
            return serialize_struct(temp, pCustomSampleOrders[nBPVlSV]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETCOARSESAMPLEORDERNV;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t taskCount;
[&](){
            if (json["taskCount"].is_uint64()){
                taskCount=static_cast<uint32_t>(json["taskCount"].get_uint64());
            }else if (json["taskCount"].is_int64()){
                taskCount=static_cast<uint32_t>(json["taskCount"].get_int64());
            }else{
                taskCount=static_cast<uint32_t>(json["taskCount"].get_double());
            }
            }();
uint32_t firstTask;
[&](){
            if (json["firstTask"].is_uint64()){
                firstTask=static_cast<uint32_t>(json["firstTask"].get_uint64());
            }else if (json["firstTask"].is_int64()){
                firstTask=static_cast<uint32_t>(json["firstTask"].get_int64());
            }else{
                firstTask=static_cast<uint32_t>(json["firstTask"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksNV");
    }  
    
{
call_function(commandBuffer, taskCount, firstTask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=taskCount;}();
[&](){json["firstTask"]=firstTask;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSNV;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTNV;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectCountNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountNV)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountNV");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTNV;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t groupCountX;
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
uint32_t groupCountY;
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
uint32_t groupCountZ;
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksEXT");
    }  
    
{
call_function(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSEXT;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
uint32_t drawCount;
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, drawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTEXT;
        writeToConn(json);
    }

    void handle_vkCmdDrawMeshTasksIndirectCountEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkBuffer countBuffer;
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
VkDeviceSize countBufferOffset;
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
uint32_t maxDrawCount;
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDrawMeshTasksIndirectCountEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_instance_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDrawMeshTasksIndirectCountEXT)get_device_proc_addr(parent,"vkCmdDrawMeshTasksIndirectCountEXT");
    }  
    
{
call_function(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT;
        writeToConn(json);
    }

    void handle_vkCompileDeferredNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t shader;
[&](){
            if (json["shader"].is_uint64()){
                shader=static_cast<uint32_t>(json["shader"].get_uint64());
            }else if (json["shader"].is_int64()){
                shader=static_cast<uint32_t>(json["shader"].get_int64());
            }else{
                shader=static_cast<uint32_t>(json["shader"].get_double());
            }
            }();

    PFN_vkCompileDeferredNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCompileDeferredNV)get_instance_proc_addr(parent,"vkCompileDeferredNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCompileDeferredNV)get_device_proc_addr(parent,"vkCompileDeferredNV");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, shader);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=shader;}();


        json["stream_type"]=VKCOMPILEDEFERREDNV;
        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkAccelerationStructureCreateInfoNV*)malloc(1*sizeof(VkAccelerationStructureCreateInfoNV));
        auto& arr_CZnEXLZ=json["pCreateInfo"].get_array();
        for(int HkuZrvQ=0; HkuZrvQ < 1; HkuZrvQ++){
            [&](){
            auto& temp=arr_CZnEXLZ[HkuZrvQ].get_object();
            deserialize_struct(temp,pCreateInfo[HkuZrvQ]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkAccelerationStructureNV* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].get_array().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureNV*)malloc(1*sizeof(VkAccelerationStructureNV));
        auto& arr_FUsucto=json["pAccelerationStructure"].get_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateAccelerationStructureNV)get_instance_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateAccelerationStructureNV)get_device_proc_addr(parent,"vkCreateAccelerationStructureNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_cRwwWhs=json["pCreateInfo"].get_array();
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto& temp=arr_cRwwWhs[oEOLGTm].emplace_object();
            return serialize_struct(temp, pCreateInfo[oEOLGTm]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }json["pAccelerationStructure"]=boost::json::array(1);
        auto& arr_FUsucto=json["pAccelerationStructure"].get_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        }();


        json["stream_type"]=VKCREATEACCELERATIONSTRUCTURENV;
        writeToConn(json);
    }

    void handle_vkCmdBindInvocationMaskHUAWEI(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageLayout imageLayout;
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

    PFN_vkCmdBindInvocationMaskHUAWEI call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_instance_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindInvocationMaskHUAWEI)get_device_proc_addr(parent,"vkCmdBindInvocationMaskHUAWEI");
    }  
    
{
call_function(commandBuffer, imageView, imageLayout);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();


        json["stream_type"]=VKCMDBINDINVOCATIONMASKHUAWEI;
        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureKHR accelerationStructure;
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyAccelerationStructureKHR)get_device_proc_addr(parent,"vkDestroyAccelerationStructureKHR");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkDestroyAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_instance_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyAccelerationStructureNV)get_device_proc_addr(parent,"vkDestroyAccelerationStructureNV");
    }  
    
{
call_function(device, accelerationStructure, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYACCELERATIONSTRUCTURENV;
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureMemoryRequirementsInfoNV* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureMemoryRequirementsInfoNV*)malloc(1*sizeof(VkAccelerationStructureMemoryRequirementsInfoNV));
        auto& arr_VDaHmqz=json["pInfo"].get_array();
        for(int wDTIoch=0; wDTIoch < 1; wDTIoch++){
            [&](){
            auto& temp=arr_VDaHmqz[wDTIoch].get_object();
            deserialize_struct(temp,pInfo[wDTIoch]);
            }();
        }
        }();
VkMemoryRequirements2KHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2KHR*)malloc(1*sizeof(VkMemoryRequirements2KHR));
        auto& arr_lzklPBG=json["pMemoryRequirements"].get_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].get_object();
            deserialize_struct(temp,pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetAccelerationStructureMemoryRequirementsNV");
    }  
    
{
call_function(device, pInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QKzjkmC=json["pInfo"].get_array();
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto& temp=arr_QKzjkmC[eEDmZTf].emplace_object();
            return serialize_struct(temp, pInfo[eEDmZTf]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_lzklPBG=json["pMemoryRequirements"].get_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();


        json["stream_type"]=VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV;
        writeToConn(json);
    }

    void handle_vkBindAccelerationStructureMemoryNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t bindInfoCount;
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();
 VkBindAccelerationStructureMemoryInfoNV* pBindInfos;
[&](){
            if (json["pBindInfos"].get_array().size()==0){
                pBindInfos=NULL;
            return; }pBindInfos=(VkBindAccelerationStructureMemoryInfoNV*)malloc(bindInfoCount*sizeof(VkBindAccelerationStructureMemoryInfoNV));
        auto& arr_AgWFhtE=json["pBindInfos"].get_array();
        for(int NpOYBOz=0; NpOYBOz < bindInfoCount; NpOYBOz++){
            [&](){
            auto& temp=arr_AgWFhtE[NpOYBOz].get_object();
            deserialize_struct(temp,pBindInfos[NpOYBOz]);
            }();
        }
        }();

    PFN_vkBindAccelerationStructureMemoryNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_instance_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindAccelerationStructureMemoryNV)get_device_proc_addr(parent,"vkBindAccelerationStructureMemoryNV");
    }  
    
VkResult  result;
{
result=call_function(device, bindInfoCount, pBindInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_rhzkvXd=json["pBindInfos"].get_array();
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto& temp=arr_rhzkvXd[tRvmYFr].emplace_object();
            return serialize_struct(temp, pBindInfos[tRvmYFr]);
            }();
        }
        }();


        json["stream_type"]=VKBINDACCELERATIONSTRUCTUREMEMORYNV;
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkCopyAccelerationStructureModeKHR mode;
[&](){[&](){int temp_KfOqWqs;[&](){
            if (json["mode"].is_uint64()){
                temp_KfOqWqs=static_cast<int>(json["mode"].get_uint64());
            }else if (json["mode"].is_int64()){
                temp_KfOqWqs=static_cast<int>(json["mode"].get_int64());
            }else{
                temp_KfOqWqs=static_cast<int>(json["mode"].get_double());
            }
            }();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

    PFN_vkCmdCopyAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, dst, src, mode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=mode;}();}();}();


        json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTURENV;
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));
        auto& arr_WSMeNoY=json["pInfo"].get_array();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            auto& temp=arr_WSMeNoY[qgjgiZh].get_object();
            deserialize_struct(temp,pInfo[qgjgiZh]);
            }();
        }
        }();

    PFN_vkCmdCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mSSajtp=json["pInfo"].get_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureInfoKHR));
        auto& arr_WSMeNoY=json["pInfo"].get_array();
        for(int qgjgiZh=0; qgjgiZh < 1; qgjgiZh++){
            [&](){
            auto& temp=arr_WSMeNoY[qgjgiZh].get_object();
            deserialize_struct(temp,pInfo[qgjgiZh]);
            }();
        }
        }();

    PFN_vkCopyAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mSSajtp=json["pInfo"].get_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkCmdCopyAccelerationStructureToMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
        auto& arr_lkaVawI=json["pInfo"].get_array();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            auto& temp=arr_lkaVawI[qcYcnXp].get_object();
            deserialize_struct(temp,pInfo[qcYcnXp]);
            }();
        }
        }();

    PFN_vkCmdCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCmdCopyAccelerationStructureToMemoryKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_MpzusRq=json["pInfo"].get_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
        writeToConn(json);
    }

    void handle_vkCopyAccelerationStructureToMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyAccelerationStructureToMemoryInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(1*sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
        auto& arr_lkaVawI=json["pInfo"].get_array();
        for(int qcYcnXp=0; qcYcnXp < 1; qcYcnXp++){
            [&](){
            auto& temp=arr_lkaVawI[qcYcnXp].get_object();
            deserialize_struct(temp,pInfo[qcYcnXp]);
            }();
        }
        }();

    PFN_vkCopyAccelerationStructureToMemoryKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_instance_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyAccelerationStructureToMemoryKHR)get_device_proc_addr(parent,"vkCopyAccelerationStructureToMemoryKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_MpzusRq=json["pInfo"].get_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
        auto& arr_bZDMHqg=json["pInfo"].get_array();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            auto& temp=arr_bZDMHqg[exexFjs].get_object();
            deserialize_struct(temp,pInfo[exexFjs]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCmdCopyMemoryToAccelerationStructureKHR");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_yRNSaUF=json["pInfo"].get_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkCopyMemoryToAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMemoryToAccelerationStructureInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(1*sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
        auto& arr_bZDMHqg=json["pInfo"].get_array();
        for(int exexFjs=0; exexFjs < 1; exexFjs++){
            [&](){
            auto& temp=arr_bZDMHqg[exexFjs].get_object();
            deserialize_struct(temp,pInfo[exexFjs]);
            }();
        }
        }();

    PFN_vkCopyMemoryToAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToAccelerationStructureKHR)get_device_proc_addr(parent,"vkCopyMemoryToAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_yRNSaUF=json["pInfo"].get_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();
 VkAccelerationStructureKHR* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].get_array().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto& arr_QDDZeVb=json["pAccelerationStructures"].get_array();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], pAccelerationStructures[dBhihII]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesKHR");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_oCGlcEh=json["pAccelerationStructures"].get_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        json["stream_type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkCmdWriteAccelerationStructuresPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();
 VkAccelerationStructureNV* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].get_array().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureNV*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureNV));
        auto& arr_jMdvwQK=json["pAccelerationStructures"].get_array();
        for(int lmeuIny=0; lmeuIny < accelerationStructureCount; lmeuIny++){
            [&](){deserialize_VkAccelerationStructureNV(arr_jMdvwQK[lmeuIny], pAccelerationStructures[lmeuIny]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

    PFN_vkCmdWriteAccelerationStructuresPropertiesNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_instance_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteAccelerationStructuresPropertiesNV)get_device_proc_addr(parent,"vkCmdWriteAccelerationStructuresPropertiesNV");
    }  
    
{
call_function(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_NSQEnJt=json["pAccelerationStructures"].get_array();
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        json["stream_type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV;
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructureNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkAccelerationStructureInfoNV* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureInfoNV*)malloc(1*sizeof(VkAccelerationStructureInfoNV));
        auto& arr_lerVBoc=json["pInfo"].get_array();
        for(int mMkuLVq=0; mMkuLVq < 1; mMkuLVq++){
            [&](){
            auto& temp=arr_lerVBoc[mMkuLVq].get_object();
            deserialize_struct(temp,pInfo[mMkuLVq]);
            }();
        }
        }();
VkBuffer instanceData;
[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
VkDeviceSize instanceOffset;
[&](){uint64_t temp_sEYJico;[&](){
            if (json["instanceOffset"].is_uint64()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_uint64());
            }else if (json["instanceOffset"].is_int64()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_int64());
            }else{
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_double());
            }
            }();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
VkBool32 update;
[&](){uint32_t temp_LpVZhJf;[&](){
            if (json["update"].is_uint64()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_uint64());
            }else if (json["update"].is_int64()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_int64());
            }else{
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_double());
            }
            }();update=(VkBool32)temp_LpVZhJf;}();
VkAccelerationStructureNV dst;
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
VkAccelerationStructureNV src;
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
VkBuffer scratch;
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
VkDeviceSize scratchOffset;
[&](){uint64_t temp_rbfZpmL;[&](){
            if (json["scratchOffset"].is_uint64()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_uint64());
            }else if (json["scratchOffset"].is_int64()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_int64());
            }else{
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_double());
            }
            }();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

    PFN_vkCmdBuildAccelerationStructureNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructureNV)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructureNV");
    }  
    
{
call_function(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_GYyRhgo=json["pInfo"].get_array();
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto& temp=arr_GYyRhgo[jJuvWAP].emplace_object();
            return serialize_struct(temp, pInfo[jJuvWAP]);
            }();
        }
        }();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=instanceOffset;}();}();
[&](){[&](){json["update"]=update;}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=scratchOffset;}();}();


        json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURENV;
        writeToConn(json);
    }

    void handle_vkWriteAccelerationStructuresPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t accelerationStructureCount;
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();
 VkAccelerationStructureKHR* pAccelerationStructures;
[&](){
            if (json["pAccelerationStructures"].get_array().size()==0){
                pAccelerationStructures=NULL;
            return; }pAccelerationStructures=(VkAccelerationStructureKHR*)malloc(accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto& arr_QDDZeVb=json["pAccelerationStructures"].get_array();
        for(int dBhihII=0; dBhihII < accelerationStructureCount; dBhihII++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_QDDZeVb[dBhihII], pAccelerationStructures[dBhihII]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<size_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<size_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<size_t>(json["stride"].get_double());
            }
            }();

    PFN_vkWriteAccelerationStructuresPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_instance_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWriteAccelerationStructuresPropertiesKHR)get_device_proc_addr(parent,"vkWriteAccelerationStructuresPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_oCGlcEh=json["pAccelerationStructures"].get_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){
            if (json["pRaygenShaderBindingTable"].get_array().size()==0){
                pRaygenShaderBindingTable=NULL;
            return; }pRaygenShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].get_array();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            auto& temp=arr_vmdxRLm[xvlAiIt].get_object();
            deserialize_struct(temp,pRaygenShaderBindingTable[xvlAiIt]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){
            if (json["pMissShaderBindingTable"].get_array().size()==0){
                pMissShaderBindingTable=NULL;
            return; }pMissShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_aiNBoIa=json["pMissShaderBindingTable"].get_array();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            auto& temp=arr_aiNBoIa[fjwDbNz].get_object();
            deserialize_struct(temp,pMissShaderBindingTable[fjwDbNz]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){
            if (json["pHitShaderBindingTable"].get_array().size()==0){
                pHitShaderBindingTable=NULL;
            return; }pHitShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_MsArahD=json["pHitShaderBindingTable"].get_array();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            auto& temp=arr_MsArahD[TYXtQRB].get_object();
            deserialize_struct(temp,pHitShaderBindingTable[TYXtQRB]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){
            if (json["pCallableShaderBindingTable"].get_array().size()==0){
                pCallableShaderBindingTable=NULL;
            return; }pCallableShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].get_array();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            auto& temp=arr_ZxEGCDr[rzAeWYt].get_object();
            deserialize_struct(temp,pCallableShaderBindingTable[rzAeWYt]);
            }();
        }
        }();
uint32_t width;
[&](){
            if (json["width"].is_uint64()){
                width=static_cast<uint32_t>(json["width"].get_uint64());
            }else if (json["width"].is_int64()){
                width=static_cast<uint32_t>(json["width"].get_int64());
            }else{
                width=static_cast<uint32_t>(json["width"].get_double());
            }
            }();
uint32_t height;
[&](){
            if (json["height"].is_uint64()){
                height=static_cast<uint32_t>(json["height"].get_uint64());
            }else if (json["height"].is_int64()){
                height=static_cast<uint32_t>(json["height"].get_int64());
            }else{
                height=static_cast<uint32_t>(json["height"].get_double());
            }
            }();
uint32_t depth;
[&](){
            if (json["depth"].is_uint64()){
                depth=static_cast<uint32_t>(json["depth"].get_uint64());
            }else if (json["depth"].is_int64()){
                depth=static_cast<uint32_t>(json["depth"].get_int64());
            }else{
                depth=static_cast<uint32_t>(json["depth"].get_double());
            }
            }();

    PFN_vkCmdTraceRaysKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysKHR)get_device_proc_addr(parent,"vkCmdTraceRaysKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }json["pRaygenShaderBindingTable"]=boost::json::array(1);
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].get_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }json["pMissShaderBindingTable"]=boost::json::array(1);
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].get_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }json["pHitShaderBindingTable"]=boost::json::array(1);
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].get_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }json["pCallableShaderBindingTable"]=boost::json::array(1);
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].get_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();


        json["stream_type"]=VKCMDTRACERAYSKHR;
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer raygenShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
VkDeviceSize raygenShaderBindingOffset;
[&](){uint64_t temp_nbAYEyt;[&](){
            if (json["raygenShaderBindingOffset"].is_uint64()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_uint64());
            }else if (json["raygenShaderBindingOffset"].is_int64()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_int64());
            }else{
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_double());
            }
            }();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
VkBuffer missShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
VkDeviceSize missShaderBindingOffset;
[&](){uint64_t temp_ORIaXGF;[&](){
            if (json["missShaderBindingOffset"].is_uint64()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_uint64());
            }else if (json["missShaderBindingOffset"].is_int64()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_int64());
            }else{
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_double());
            }
            }();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
VkDeviceSize missShaderBindingStride;
[&](){uint64_t temp_BOvfilr;[&](){
            if (json["missShaderBindingStride"].is_uint64()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_uint64());
            }else if (json["missShaderBindingStride"].is_int64()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_int64());
            }else{
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_double());
            }
            }();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
VkBuffer hitShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
VkDeviceSize hitShaderBindingOffset;
[&](){uint64_t temp_oKlCsJj;[&](){
            if (json["hitShaderBindingOffset"].is_uint64()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_uint64());
            }else if (json["hitShaderBindingOffset"].is_int64()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_int64());
            }else{
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_double());
            }
            }();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
VkDeviceSize hitShaderBindingStride;
[&](){uint64_t temp_qhwyGdu;[&](){
            if (json["hitShaderBindingStride"].is_uint64()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_uint64());
            }else if (json["hitShaderBindingStride"].is_int64()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_int64());
            }else{
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_double());
            }
            }();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
VkBuffer callableShaderBindingTableBuffer;
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
VkDeviceSize callableShaderBindingOffset;
[&](){uint64_t temp_WmjXZmz;[&](){
            if (json["callableShaderBindingOffset"].is_uint64()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_uint64());
            }else if (json["callableShaderBindingOffset"].is_int64()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_int64());
            }else{
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_double());
            }
            }();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
VkDeviceSize callableShaderBindingStride;
[&](){uint64_t temp_giLAAVF;[&](){
            if (json["callableShaderBindingStride"].is_uint64()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_uint64());
            }else if (json["callableShaderBindingStride"].is_int64()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_int64());
            }else{
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_double());
            }
            }();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
uint32_t width;
[&](){
            if (json["width"].is_uint64()){
                width=static_cast<uint32_t>(json["width"].get_uint64());
            }else if (json["width"].is_int64()){
                width=static_cast<uint32_t>(json["width"].get_int64());
            }else{
                width=static_cast<uint32_t>(json["width"].get_double());
            }
            }();
uint32_t height;
[&](){
            if (json["height"].is_uint64()){
                height=static_cast<uint32_t>(json["height"].get_uint64());
            }else if (json["height"].is_int64()){
                height=static_cast<uint32_t>(json["height"].get_int64());
            }else{
                height=static_cast<uint32_t>(json["height"].get_double());
            }
            }();
uint32_t depth;
[&](){
            if (json["depth"].is_uint64()){
                depth=static_cast<uint32_t>(json["depth"].get_uint64());
            }else if (json["depth"].is_int64()){
                depth=static_cast<uint32_t>(json["depth"].get_int64());
            }else{
                depth=static_cast<uint32_t>(json["depth"].get_double());
            }
            }();

    PFN_vkCmdTraceRaysNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysNV)get_instance_proc_addr(parent,"vkCmdTraceRaysNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysNV)get_device_proc_addr(parent,"vkCmdTraceRaysNV");
    }  
    
{
call_function(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=raygenShaderBindingOffset;}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=missShaderBindingOffset;}();}();
[&](){[&](){json["missShaderBindingStride"]=missShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=hitShaderBindingOffset;}();}();
[&](){[&](){json["hitShaderBindingStride"]=hitShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=callableShaderBindingOffset;}();}();
[&](){[&](){json["callableShaderBindingStride"]=callableShaderBindingStride;}();}();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();


        json["stream_type"]=VKCMDTRACERAYSNV;
        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupHandlesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){
            if (json["firstGroup"].is_uint64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_uint64());
            }else if (json["firstGroup"].is_int64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_int64());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_double());
            }
            }();
uint32_t groupCount;
[&](){
            if (json["groupCount"].is_uint64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_uint64());
            }else if (json["groupCount"].is_int64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_int64());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].get_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupHandlesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETRAYTRACINGSHADERGROUPHANDLESKHR;
        writeToConn(json);
    }

    void handle_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t firstGroup;
[&](){
            if (json["firstGroup"].is_uint64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_uint64());
            }else if (json["firstGroup"].is_int64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_int64());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_double());
            }
            }();
uint32_t groupCount;
[&](){
            if (json["groupCount"].is_uint64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_uint64());
            }else if (json["groupCount"].is_int64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_int64());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].get_double());
            }
            }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_instance_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)get_device_proc_addr(parent,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR;
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureHandleNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureNV accelerationStructure;
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();

    PFN_vkGetAccelerationStructureHandleNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_instance_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureHandleNV)get_device_proc_addr(parent,"vkGetAccelerationStructureHandleNV");
    }  
    
VkResult  result;
{
result=call_function(device, accelerationStructure, dataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETACCELERATIONSTRUCTUREHANDLENV;
        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();
 VkRayTracingPipelineCreateInfoNV* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkRayTracingPipelineCreateInfoNV*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoNV));
        auto& arr_XJbewcz=json["pCreateInfos"].get_array();
        for(int OYHdDIG=0; OYHdDIG < createInfoCount; OYHdDIG++){
            [&](){
            auto& temp=arr_XJbewcz[OYHdDIG].get_object();
            deserialize_struct(temp,pCreateInfos[OYHdDIG]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRayTracingPipelinesNV)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesNV");
    }  
    
VkResult  result;
{
result=call_function(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_bzMTsat=json["pCreateInfos"].get_array();
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto& temp=arr_bzMTsat[oRbABSQ].emplace_object();
            return serialize_struct(temp, pCreateInfos[oRbABSQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        json["stream_type"]=VKCREATERAYTRACINGPIPELINESNV;
        writeToConn(json);
    }

    void handle_vkCreateRayTracingPipelinesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
VkPipelineCache pipelineCache;
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();
 VkRayTracingPipelineCreateInfoKHR* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkRayTracingPipelineCreateInfoKHR*)malloc(createInfoCount*sizeof(VkRayTracingPipelineCreateInfoKHR));
        auto& arr_IiabYtV=json["pCreateInfos"].get_array();
        for(int NFMtVfO=0; NFMtVfO < createInfoCount; NFMtVfO++){
            [&](){
            auto& temp=arr_IiabYtV[NFMtVfO].get_object();
            deserialize_struct(temp,pCreateInfos[NFMtVfO]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPipeline* pPipelines;
[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }pPipelines=(VkPipeline*)malloc(createInfoCount*sizeof(VkPipeline));
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();

    PFN_vkCreateRayTracingPipelinesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_instance_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateRayTracingPipelinesKHR)get_device_proc_addr(parent,"vkCreateRayTracingPipelinesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_zltFjJj=json["pCreateInfos"].get_array();
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto& temp=arr_zltFjJj[Szqaxlk].emplace_object();
            return serialize_struct(temp, pCreateInfos[Szqaxlk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();


        json["stream_type"]=VKCREATERAYTRACINGPIPELINESKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkCooperativeMatrixPropertiesNV* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesNV*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesNV));
        auto& arr_kVfVVDF=json["pProperties"].get_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].get_object();
            deserialize_struct(temp,pProperties[WfgOgPA]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_kVfVVDF=json["pProperties"].get_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].emplace_object();
            return serialize_struct(temp, pProperties[WfgOgPA]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV;
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirectKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable;
[&](){
            if (json["pRaygenShaderBindingTable"].get_array().size()==0){
                pRaygenShaderBindingTable=NULL;
            return; }pRaygenShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_vmdxRLm=json["pRaygenShaderBindingTable"].get_array();
        for(int xvlAiIt=0; xvlAiIt < 1; xvlAiIt++){
            [&](){
            auto& temp=arr_vmdxRLm[xvlAiIt].get_object();
            deserialize_struct(temp,pRaygenShaderBindingTable[xvlAiIt]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable;
[&](){
            if (json["pMissShaderBindingTable"].get_array().size()==0){
                pMissShaderBindingTable=NULL;
            return; }pMissShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_aiNBoIa=json["pMissShaderBindingTable"].get_array();
        for(int fjwDbNz=0; fjwDbNz < 1; fjwDbNz++){
            [&](){
            auto& temp=arr_aiNBoIa[fjwDbNz].get_object();
            deserialize_struct(temp,pMissShaderBindingTable[fjwDbNz]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable;
[&](){
            if (json["pHitShaderBindingTable"].get_array().size()==0){
                pHitShaderBindingTable=NULL;
            return; }pHitShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_MsArahD=json["pHitShaderBindingTable"].get_array();
        for(int TYXtQRB=0; TYXtQRB < 1; TYXtQRB++){
            [&](){
            auto& temp=arr_MsArahD[TYXtQRB].get_object();
            deserialize_struct(temp,pHitShaderBindingTable[TYXtQRB]);
            }();
        }
        }();
 VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable;
[&](){
            if (json["pCallableShaderBindingTable"].get_array().size()==0){
                pCallableShaderBindingTable=NULL;
            return; }pCallableShaderBindingTable=(VkStridedDeviceAddressRegionKHR*)malloc(1*sizeof(VkStridedDeviceAddressRegionKHR));
        auto& arr_ZxEGCDr=json["pCallableShaderBindingTable"].get_array();
        for(int rzAeWYt=0; rzAeWYt < 1; rzAeWYt++){
            [&](){
            auto& temp=arr_ZxEGCDr[rzAeWYt].get_object();
            deserialize_struct(temp,pCallableShaderBindingTable[rzAeWYt]);
            }();
        }
        }();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_uint64());
            }else if (json["indirectDeviceAddress"].is_int64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_int64());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirectKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysIndirectKHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirectKHR");
    }  
    
{
call_function(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }json["pRaygenShaderBindingTable"]=boost::json::array(1);
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].get_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }json["pMissShaderBindingTable"]=boost::json::array(1);
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].get_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }json["pHitShaderBindingTable"]=boost::json::array(1);
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].get_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }json["pCallableShaderBindingTable"]=boost::json::array(1);
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].get_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();


        json["stream_type"]=VKCMDTRACERAYSINDIRECTKHR;
        writeToConn(json);
    }

    void handle_vkCmdTraceRaysIndirect2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectDeviceAddress;
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_uint64());
            }else if (json["indirectDeviceAddress"].is_int64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_int64());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

    PFN_vkCmdTraceRaysIndirect2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_instance_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdTraceRaysIndirect2KHR)get_device_proc_addr(parent,"vkCmdTraceRaysIndirect2KHR");
    }  
    
{
call_function(commandBuffer, indirectDeviceAddress);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();


        json["stream_type"]=VKCMDTRACERAYSINDIRECT2KHR;
        writeToConn(json);
    }

    void handle_vkGetDeviceAccelerationStructureCompatibilityKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureVersionInfoKHR* pVersionInfo;
[&](){
            if (json["pVersionInfo"].get_array().size()==0){
                pVersionInfo=NULL;
            return; }pVersionInfo=(VkAccelerationStructureVersionInfoKHR*)malloc(1*sizeof(VkAccelerationStructureVersionInfoKHR));
        auto& arr_aFpiHMk=json["pVersionInfo"].get_array();
        for(int hlcodPX=0; hlcodPX < 1; hlcodPX++){
            [&](){
            auto& temp=arr_aFpiHMk[hlcodPX].get_object();
            deserialize_struct(temp,pVersionInfo[hlcodPX]);
            }();
        }
        }();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].get_array().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_uint64());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_int64());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_instance_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)get_device_proc_addr(parent,"vkGetDeviceAccelerationStructureCompatibilityKHR");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }json["pVersionInfo"]=boost::json::array(1);
        auto& arr_wbhdpeb=json["pVersionInfo"].get_array();
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto& temp=arr_wbhdpeb[vhWWlwM].emplace_object();
            return serialize_struct(temp, pVersionInfo[vhWWlwM]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }json["pCompatibility"]=boost::json::array(1);
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();


        json["stream_type"]=VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR;
        writeToConn(json);
    }

    void handle_vkGetRayTracingShaderGroupStackSizeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPipeline pipeline;
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
uint32_t group;
[&](){
            if (json["group"].is_uint64()){
                group=static_cast<uint32_t>(json["group"].get_uint64());
            }else if (json["group"].is_int64()){
                group=static_cast<uint32_t>(json["group"].get_int64());
            }else{
                group=static_cast<uint32_t>(json["group"].get_double());
            }
            }();
VkShaderGroupShaderKHR groupShader;
[&](){[&](){int temp_EOWKSMj;[&](){
            if (json["groupShader"].is_uint64()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_uint64());
            }else if (json["groupShader"].is_int64()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_int64());
            }else{
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_double());
            }
            }();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();

    PFN_vkGetRayTracingShaderGroupStackSizeKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_instance_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetRayTracingShaderGroupStackSizeKHR)get_device_proc_addr(parent,"vkGetRayTracingShaderGroupStackSizeKHR");
    }  
    
VkDeviceSize  result;
{
result=call_function(device, pipeline, group, groupShader);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=group;}();
[&](){[&](){[&](){json["groupShader"]=groupShader;}();}();}();


        json["stream_type"]=VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR;
        writeToConn(json);
    }

    void handle_vkCmdSetRayTracingPipelineStackSizeKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t pipelineStackSize;
[&](){
            if (json["pipelineStackSize"].is_uint64()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_uint64());
            }else if (json["pipelineStackSize"].is_int64()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_int64());
            }else{
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_double());
            }
            }();

    PFN_vkCmdSetRayTracingPipelineStackSizeKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_instance_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRayTracingPipelineStackSizeKHR)get_device_proc_addr(parent,"vkCmdSetRayTracingPipelineStackSizeKHR");
    }  
    
{
call_function(commandBuffer, pipelineStackSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=pipelineStackSize;}();


        json["stream_type"]=VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR;
        writeToConn(json);
    }

    void handle_vkGetImageViewHandleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewHandleInfoNVX* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageViewHandleInfoNVX*)malloc(1*sizeof(VkImageViewHandleInfoNVX));
        auto& arr_WPyvhGm=json["pInfo"].get_array();
        for(int WwmPLiZ=0; WwmPLiZ < 1; WwmPLiZ++){
            [&](){
            auto& temp=arr_WPyvhGm[WwmPLiZ].get_object();
            deserialize_struct(temp,pInfo[WwmPLiZ]);
            }();
        }
        }();

    PFN_vkGetImageViewHandleNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewHandleNVX)get_instance_proc_addr(parent,"vkGetImageViewHandleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewHandleNVX)get_device_proc_addr(parent,"vkGetImageViewHandleNVX");
    }  
    
uint32_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mfMZJfb=json["pInfo"].get_array();
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto& temp=arr_mfMZJfb[dQabsff].emplace_object();
            return serialize_struct(temp, pInfo[dQabsff]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGEVIEWHANDLENVX;
        writeToConn(json);
    }

    void handle_vkGetImageViewAddressNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImageView imageView;
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
VkImageViewAddressPropertiesNVX* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageViewAddressPropertiesNVX*)malloc(1*sizeof(VkImageViewAddressPropertiesNVX));
        auto& arr_hveoAIn=json["pProperties"].get_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].get_object();
            deserialize_struct(temp,pProperties[FiVrJfn]);
            }();
        }
        }();

    PFN_vkGetImageViewAddressNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewAddressNVX)get_instance_proc_addr(parent,"vkGetImageViewAddressNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewAddressNVX)get_device_proc_addr(parent,"vkGetImageViewAddressNVX");
    }  
    
VkResult  result;
{
result=call_function(device, imageView, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_hveoAIn=json["pProperties"].get_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].emplace_object();
            return serialize_struct(temp, pProperties[FiVrJfn]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGEVIEWADDRESSNVX;
        writeToConn(json);
    }

    void handle_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t queueFamilyIndex;
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
uint32_t* pCounterCount;
[&](){
            if (json["pCounterCount"].get_array().size()==0){
                pCounterCount=NULL;
            return; }pCounterCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QuwxWHd=json["pCounterCount"].get_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){
            if (arr_QuwxWHd[HDbVSFc].is_uint64()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_uint64());
            }else if (arr_QuwxWHd[HDbVSFc].is_int64()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_int64());
            }else{
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_double());
            }
            }();
        }
        }();
VkPerformanceCounterKHR* pCounters;
[&](){
            if (json["pCounters"].get_array().size()==0){
                pCounters=NULL;
            return; }pCounters=(VkPerformanceCounterKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterKHR));
        auto& arr_vEVlsJt=json["pCounters"].get_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].get_object();
            deserialize_struct(temp,pCounters[WmftXku]);
            }();
        }
        }();
VkPerformanceCounterDescriptionKHR* pCounterDescriptions;
[&](){
            if (json["pCounterDescriptions"].get_array().size()==0){
                pCounterDescriptions=NULL;
            return; }pCounterDescriptions=(VkPerformanceCounterDescriptionKHR*)malloc(*pCounterCount*sizeof(VkPerformanceCounterDescriptionKHR));
        auto& arr_znRZkzO=json["pCounterDescriptions"].get_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].get_object();
            deserialize_struct(temp,pCounterDescriptions[GjxogPx]);
            }();
        }
        }();

    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_instance_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)get_device_proc_addr(parent,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=boost::json::array();
            return; }json["pCounterCount"]=boost::json::array(1);
        auto& arr_QuwxWHd=json["pCounterCount"].get_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=pCounterCount[HDbVSFc];}();
        }
        }();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=boost::json::array();
            return; }json["pCounters"]=boost::json::array(*pCounterCount);
        auto& arr_vEVlsJt=json["pCounters"].get_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].emplace_object();
            return serialize_struct(temp, pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=boost::json::array();
            return; }json["pCounterDescriptions"]=boost::json::array(*pCounterCount);
        auto& arr_znRZkzO=json["pCounterDescriptions"].get_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].emplace_object();
            return serialize_struct(temp, pCounterDescriptions[GjxogPx]);
            }();
        }
        }();


        json["stream_type"]=VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo;
[&](){
            if (json["pPerformanceQueryCreateInfo"].get_array().size()==0){
                pPerformanceQueryCreateInfo=NULL;
            return; }pPerformanceQueryCreateInfo=(VkQueryPoolPerformanceCreateInfoKHR*)malloc(1*sizeof(VkQueryPoolPerformanceCreateInfoKHR));
        auto& arr_WMdwLVX=json["pPerformanceQueryCreateInfo"].get_array();
        for(int wpxitrA=0; wpxitrA < 1; wpxitrA++){
            [&](){
            auto& temp=arr_WMdwLVX[wpxitrA].get_object();
            deserialize_struct(temp,pPerformanceQueryCreateInfo[wpxitrA]);
            }();
        }
        }();
uint32_t* pNumPasses;
[&](){
            if (json["pNumPasses"].get_array().size()==0){
                pNumPasses=NULL;
            return; }pNumPasses=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_QgclfwI=json["pNumPasses"].get_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){
            if (arr_QgclfwI[vyixxEg].is_uint64()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_uint64());
            }else if (arr_QgclfwI[vyixxEg].is_int64()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_int64());
            }else{
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_double());
            }
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    }  
    
{
call_function(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
json.clear();

[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=boost::json::array();
            return; }json["pPerformanceQueryCreateInfo"]=boost::json::array(1);
        auto& arr_HfbrSJi=json["pPerformanceQueryCreateInfo"].get_array();
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto& temp=arr_HfbrSJi[aEYwfht].emplace_object();
            return serialize_struct(temp, pPerformanceQueryCreateInfo[aEYwfht]);
            }();
        }
        }();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=boost::json::array();
            return; }json["pNumPasses"]=boost::json::array(1);
        auto& arr_QgclfwI=json["pNumPasses"].get_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=pNumPasses[vyixxEg];}();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR;
        writeToConn(json);
    }

    void handle_vkAcquireProfilingLockKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAcquireProfilingLockInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAcquireProfilingLockInfoKHR*)malloc(1*sizeof(VkAcquireProfilingLockInfoKHR));
        auto& arr_cbbacNs=json["pInfo"].get_array();
        for(int ykaKCfg=0; ykaKCfg < 1; ykaKCfg++){
            [&](){
            auto& temp=arr_cbbacNs[ykaKCfg].get_object();
            deserialize_struct(temp,pInfo[ykaKCfg]);
            }();
        }
        }();

    PFN_vkAcquireProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireProfilingLockKHR)get_instance_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireProfilingLockKHR)get_device_proc_addr(parent,"vkAcquireProfilingLockKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_BslWEPE=json["pInfo"].get_array();
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto& temp=arr_BslWEPE[ZgSmBLm].emplace_object();
            return serialize_struct(temp, pInfo[ZgSmBLm]);
            }();
        }
        }();


        json["stream_type"]=VKACQUIREPROFILINGLOCKKHR;
        writeToConn(json);
    }

    void handle_vkReleaseProfilingLockKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkReleaseProfilingLockKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseProfilingLockKHR)get_instance_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseProfilingLockKHR)get_device_proc_addr(parent,"vkReleaseProfilingLockKHR");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=VKRELEASEPROFILINGLOCKKHR;
        writeToConn(json);
    }

    void handle_vkGetImageDrmFormatModifierPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
VkImageDrmFormatModifierPropertiesEXT* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkImageDrmFormatModifierPropertiesEXT*)malloc(1*sizeof(VkImageDrmFormatModifierPropertiesEXT));
        auto& arr_oxSUmzu=json["pProperties"].get_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].get_object();
            deserialize_struct(temp,pProperties[JPWNMan]);
            }();
        }
        }();

    PFN_vkGetImageDrmFormatModifierPropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_instance_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageDrmFormatModifierPropertiesEXT)get_device_proc_addr(parent,"vkGetImageDrmFormatModifierPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, image, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_oxSUmzu=json["pProperties"].get_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].emplace_object();
            return serialize_struct(temp, pProperties[JPWNMan]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferDeviceAddressInfo* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));
        auto& arr_Dpwjlow=json["pInfo"].get_array();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            auto& temp=arr_Dpwjlow[htSgjqN].get_object();
            deserialize_struct(temp,pInfo[htSgjqN]);
            }();
        }
        }();

    PFN_vkGetBufferOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureAddress");
    }  
    
uint64_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LRSftdl=json["pInfo"].get_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();


        json["stream_type"]=VKGETBUFFEROPAQUECAPTUREADDRESS;
        writeToConn(json);
    }

    void handle_vkGetBufferDeviceAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferDeviceAddressInfo* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferDeviceAddressInfo*)malloc(1*sizeof(VkBufferDeviceAddressInfo));
        auto& arr_Dpwjlow=json["pInfo"].get_array();
        for(int htSgjqN=0; htSgjqN < 1; htSgjqN++){
            [&](){
            auto& temp=arr_Dpwjlow[htSgjqN].get_object();
            deserialize_struct(temp,pInfo[htSgjqN]);
            }();
        }
        }();

    PFN_vkGetBufferDeviceAddress call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferDeviceAddress)get_instance_proc_addr(parent,"vkGetBufferDeviceAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferDeviceAddress)get_device_proc_addr(parent,"vkGetBufferDeviceAddress");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LRSftdl=json["pInfo"].get_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();


        json["stream_type"]=VKGETBUFFERDEVICEADDRESS;
        writeToConn(json);
    }

    void handle_vkCreateHeadlessSurfaceEXT(boost::json::object& json){
    //Will only be called by the server
    
VkInstance instance;
[&](){deserialize_VkInstance(json["instance"], instance);}();
 VkHeadlessSurfaceCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkHeadlessSurfaceCreateInfoEXT*)malloc(1*sizeof(VkHeadlessSurfaceCreateInfoEXT));
        auto& arr_ZPTPwbX=json["pCreateInfo"].get_array();
        for(int zfADAts=0; zfADAts < 1; zfADAts++){
            [&](){
            auto& temp=arr_ZPTPwbX[zfADAts].get_object();
            deserialize_struct(temp,pCreateInfo[zfADAts]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkSurfaceKHR* pSurface;
[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }pSurface=(VkSurfaceKHR*)malloc(1*sizeof(VkSurfaceKHR));
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();

    PFN_vkCreateHeadlessSurfaceEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_instance_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateHeadlessSurfaceEXT)get_device_proc_addr(parent,"vkCreateHeadlessSurfaceEXT");
    }  
    
VkResult  result;
{
result=call_function(instance, pCreateInfo, pAllocator, pSurface);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_yHbnuDf=json["pCreateInfo"].get_array();
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto& temp=arr_yHbnuDf[CyHXDmy].emplace_object();
            return serialize_struct(temp, pCreateInfo[CyHXDmy]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();


        json["stream_type"]=VKCREATEHEADLESSSURFACEEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pCombinationCount;
[&](){
            if (json["pCombinationCount"].get_array().size()==0){
                pCombinationCount=NULL;
            return; }pCombinationCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_VrJxAqY=json["pCombinationCount"].get_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){
            if (arr_VrJxAqY[jKkiHUO].is_uint64()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_uint64());
            }else if (arr_VrJxAqY[jKkiHUO].is_int64()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_int64());
            }else{
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_double());
            }
            }();
        }
        }();
VkFramebufferMixedSamplesCombinationNV* pCombinations;
[&](){
            if (json["pCombinations"].get_array().size()==0){
                pCombinations=NULL;
            return; }pCombinations=(VkFramebufferMixedSamplesCombinationNV*)malloc(*pCombinationCount*sizeof(VkFramebufferMixedSamplesCombinationNV));
        auto& arr_aOIaDFM=json["pCombinations"].get_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].get_object();
            deserialize_struct(temp,pCombinations[oxJqbjP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pCombinationCount, pCombinations);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=boost::json::array();
            return; }json["pCombinationCount"]=boost::json::array(1);
        auto& arr_VrJxAqY=json["pCombinationCount"].get_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=pCombinationCount[jKkiHUO];}();
        }
        }();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=boost::json::array();
            return; }json["pCombinations"]=boost::json::array(*pCombinationCount);
        auto& arr_aOIaDFM=json["pCombinations"].get_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].emplace_object();
            return serialize_struct(temp, pCombinations[oxJqbjP]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV;
        writeToConn(json);
    }

    void handle_vkInitializePerformanceApiINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkInitializePerformanceApiInfoINTEL* pInitializeInfo;
[&](){
            if (json["pInitializeInfo"].get_array().size()==0){
                pInitializeInfo=NULL;
            return; }pInitializeInfo=(VkInitializePerformanceApiInfoINTEL*)malloc(1*sizeof(VkInitializePerformanceApiInfoINTEL));
        auto& arr_cpZIIic=json["pInitializeInfo"].get_array();
        for(int BZrUSpL=0; BZrUSpL < 1; BZrUSpL++){
            [&](){
            auto& temp=arr_cpZIIic[BZrUSpL].get_object();
            deserialize_struct(temp,pInitializeInfo[BZrUSpL]);
            }();
        }
        }();

    PFN_vkInitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkInitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkInitializePerformanceApiINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, pInitializeInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=boost::json::array();
            return; }json["pInitializeInfo"]=boost::json::array(1);
        auto& arr_BGIuPda=json["pInitializeInfo"].get_array();
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto& temp=arr_BGIuPda[pMSNyrD].emplace_object();
            return serialize_struct(temp, pInitializeInfo[pMSNyrD]);
            }();
        }
        }();


        json["stream_type"]=VKINITIALIZEPERFORMANCEAPIINTEL;
        writeToConn(json);
    }

    void handle_vkUninitializePerformanceApiINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();

    PFN_vkUninitializePerformanceApiINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_instance_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUninitializePerformanceApiINTEL)get_device_proc_addr(parent,"vkUninitializePerformanceApiINTEL");
    }  
    
{
call_function(device);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();


        json["stream_type"]=VKUNINITIALIZEPERFORMANCEAPIINTEL;
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceMarkerINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceMarkerInfoINTEL* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].get_array().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkPerformanceMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceMarkerInfoINTEL));
        auto& arr_mjbTuwx=json["pMarkerInfo"].get_array();
        for(int aadJAzE=0; aadJAzE < 1; aadJAzE++){
            [&](){
            auto& temp=arr_mjbTuwx[aadJAzE].get_object();
            deserialize_struct(temp,pMarkerInfo[aadJAzE]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceMarkerINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceMarkerINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_jnuNlGq=json["pMarkerInfo"].get_array();
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto& temp=arr_jnuNlGq[zTzAESc].emplace_object();
            return serialize_struct(temp, pMarkerInfo[zTzAESc]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETPERFORMANCEMARKERINTEL;
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceStreamMarkerINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo;
[&](){
            if (json["pMarkerInfo"].get_array().size()==0){
                pMarkerInfo=NULL;
            return; }pMarkerInfo=(VkPerformanceStreamMarkerInfoINTEL*)malloc(1*sizeof(VkPerformanceStreamMarkerInfoINTEL));
        auto& arr_QvDzNEm=json["pMarkerInfo"].get_array();
        for(int ylzDRXy=0; ylzDRXy < 1; ylzDRXy++){
            [&](){
            auto& temp=arr_QvDzNEm[ylzDRXy].get_object();
            deserialize_struct(temp,pMarkerInfo[ylzDRXy]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceStreamMarkerINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceStreamMarkerINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceStreamMarkerINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pMarkerInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_MVQnSpz=json["pMarkerInfo"].get_array();
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto& temp=arr_MVQnSpz[xfSMHfo].emplace_object();
            return serialize_struct(temp, pMarkerInfo[xfSMHfo]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETPERFORMANCESTREAMMARKERINTEL;
        writeToConn(json);
    }

    void handle_vkCmdSetPerformanceOverrideINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkPerformanceOverrideInfoINTEL* pOverrideInfo;
[&](){
            if (json["pOverrideInfo"].get_array().size()==0){
                pOverrideInfo=NULL;
            return; }pOverrideInfo=(VkPerformanceOverrideInfoINTEL*)malloc(1*sizeof(VkPerformanceOverrideInfoINTEL));
        auto& arr_ZThQunI=json["pOverrideInfo"].get_array();
        for(int VQeLutW=0; VQeLutW < 1; VQeLutW++){
            [&](){
            auto& temp=arr_ZThQunI[VQeLutW].get_object();
            deserialize_struct(temp,pOverrideInfo[VQeLutW]);
            }();
        }
        }();

    PFN_vkCmdSetPerformanceOverrideINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_instance_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPerformanceOverrideINTEL)get_device_proc_addr(parent,"vkCmdSetPerformanceOverrideINTEL");
    }  
    
VkResult  result;
{
result=call_function(commandBuffer, pOverrideInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=boost::json::array();
            return; }json["pOverrideInfo"]=boost::json::array(1);
        auto& arr_LHSFuEM=json["pOverrideInfo"].get_array();
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto& temp=arr_LHSFuEM[KZSCUHM].emplace_object();
            return serialize_struct(temp, pOverrideInfo[KZSCUHM]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETPERFORMANCEOVERRIDEINTEL;
        writeToConn(json);
    }

    void handle_vkAcquirePerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo;
[&](){
            if (json["pAcquireInfo"].get_array().size()==0){
                pAcquireInfo=NULL;
            return; }pAcquireInfo=(VkPerformanceConfigurationAcquireInfoINTEL*)malloc(1*sizeof(VkPerformanceConfigurationAcquireInfoINTEL));
        auto& arr_vfPlthd=json["pAcquireInfo"].get_array();
        for(int IYVMDgx=0; IYVMDgx < 1; IYVMDgx++){
            [&](){
            auto& temp=arr_vfPlthd[IYVMDgx].get_object();
            deserialize_struct(temp,pAcquireInfo[IYVMDgx]);
            }();
        }
        }();
VkPerformanceConfigurationINTEL* pConfiguration;
[&](){
            if (json["pConfiguration"].get_array().size()==0){
                pConfiguration=NULL;
            return; }pConfiguration=(VkPerformanceConfigurationINTEL*)malloc(1*sizeof(VkPerformanceConfigurationINTEL));
        auto& arr_zSRZrDS=json["pConfiguration"].get_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();

    PFN_vkAcquirePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquirePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkAcquirePerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, pAcquireInfo, pConfiguration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }json["pAcquireInfo"]=boost::json::array(1);
        auto& arr_ZyqvvlF=json["pAcquireInfo"].get_array();
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto& temp=arr_ZyqvvlF[RYEcOAO].emplace_object();
            return serialize_struct(temp, pAcquireInfo[RYEcOAO]);
            }();
        }
        }();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=boost::json::array();
            return; }json["pConfiguration"]=boost::json::array(1);
        auto& arr_zSRZrDS=json["pConfiguration"].get_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        }();


        json["stream_type"]=VKACQUIREPERFORMANCECONFIGURATIONINTEL;
        writeToConn(json);
    }

    void handle_vkReleasePerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkReleasePerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleasePerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkReleasePerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        json["stream_type"]=VKRELEASEPERFORMANCECONFIGURATIONINTEL;
        writeToConn(json);
    }

    void handle_vkQueueSetPerformanceConfigurationINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkPerformanceConfigurationINTEL configuration;
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();

    PFN_vkQueueSetPerformanceConfigurationINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_instance_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSetPerformanceConfigurationINTEL)get_device_proc_addr(parent,"vkQueueSetPerformanceConfigurationINTEL");
    }  
    
VkResult  result;
{
result=call_function(queue, configuration);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();


        json["stream_type"]=VKQUEUESETPERFORMANCECONFIGURATIONINTEL;
        writeToConn(json);
    }

    void handle_vkGetPerformanceParameterINTEL(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPerformanceParameterTypeINTEL parameter;
[&](){[&](){int temp_TQususa;[&](){
            if (json["parameter"].is_uint64()){
                temp_TQususa=static_cast<int>(json["parameter"].get_uint64());
            }else if (json["parameter"].is_int64()){
                temp_TQususa=static_cast<int>(json["parameter"].get_int64());
            }else{
                temp_TQususa=static_cast<int>(json["parameter"].get_double());
            }
            }();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
VkPerformanceValueINTEL* pValue;
[&](){
            if (json["pValue"].get_array().size()==0){
                pValue=NULL;
            return; }pValue=(VkPerformanceValueINTEL*)malloc(1*sizeof(VkPerformanceValueINTEL));
        auto& arr_hOmaGpc=json["pValue"].get_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].get_object();
            deserialize_struct(temp,pValue[lyxuUNd]);
            }();
        }
        }();

    PFN_vkGetPerformanceParameterINTEL call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_instance_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPerformanceParameterINTEL)get_device_proc_addr(parent,"vkGetPerformanceParameterINTEL");
    }  
    
VkResult  result;
{
result=call_function(device, parameter, pValue);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=parameter;}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }json["pValue"]=boost::json::array(1);
        auto& arr_hOmaGpc=json["pValue"].get_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].emplace_object();
            return serialize_struct(temp, pValue[lyxuUNd]);
            }();
        }
        }();


        json["stream_type"]=VKGETPERFORMANCEPARAMETERINTEL;
        writeToConn(json);
    }

    void handle_vkGetDeviceMemoryOpaqueCaptureAddress(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceMemoryOpaqueCaptureAddressInfo*)malloc(1*sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo));
        auto& arr_AaiLWsP=json["pInfo"].get_array();
        for(int PJKtAPm=0; PJKtAPm < 1; PJKtAPm++){
            [&](){
            auto& temp=arr_AaiLWsP[PJKtAPm].get_object();
            deserialize_struct(temp,pInfo[PJKtAPm]);
            }();
        }
        }();

    PFN_vkGetDeviceMemoryOpaqueCaptureAddress call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_instance_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMemoryOpaqueCaptureAddress)get_device_proc_addr(parent,"vkGetDeviceMemoryOpaqueCaptureAddress");
    }  
    
uint64_t  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_hjweGct=json["pInfo"].get_array();
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto& temp=arr_hjweGct[vcZpbuB].emplace_object();
            return serialize_struct(temp, pInfo[vcZpbuB]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS;
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutablePropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineInfoKHR* pPipelineInfo;
[&](){
            if (json["pPipelineInfo"].get_array().size()==0){
                pPipelineInfo=NULL;
            return; }pPipelineInfo=(VkPipelineInfoKHR*)malloc(1*sizeof(VkPipelineInfoKHR));
        auto& arr_TqFxxbV=json["pPipelineInfo"].get_array();
        for(int yiBzToE=0; yiBzToE < 1; yiBzToE++){
            [&](){
            auto& temp=arr_TqFxxbV[yiBzToE].get_object();
            deserialize_struct(temp,pPipelineInfo[yiBzToE]);
            }();
        }
        }();
uint32_t* pExecutableCount;
[&](){
            if (json["pExecutableCount"].get_array().size()==0){
                pExecutableCount=NULL;
            return; }pExecutableCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_tlXPSPh=json["pExecutableCount"].get_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){
            if (arr_tlXPSPh[ZFmbkCm].is_uint64()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_uint64());
            }else if (arr_tlXPSPh[ZFmbkCm].is_int64()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_int64());
            }else{
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_double());
            }
            }();
        }
        }();
VkPipelineExecutablePropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkPipelineExecutablePropertiesKHR*)malloc(*pExecutableCount*sizeof(VkPipelineExecutablePropertiesKHR));
        auto& arr_vtfdUfF=json["pProperties"].get_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].get_object();
            deserialize_struct(temp,pProperties[uPFqrVz]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutablePropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutablePropertiesKHR)get_device_proc_addr(parent,"vkGetPipelineExecutablePropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pPipelineInfo, pExecutableCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }json["pPipelineInfo"]=boost::json::array(1);
        auto& arr_SxuxUqw=json["pPipelineInfo"].get_array();
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto& temp=arr_SxuxUqw[mwoMxRp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[mwoMxRp]);
            }();
        }
        }();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=boost::json::array();
            return; }json["pExecutableCount"]=boost::json::array(1);
        auto& arr_tlXPSPh=json["pExecutableCount"].get_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=pExecutableCount[ZFmbkCm];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pExecutableCount);
        auto& arr_vtfdUfF=json["pProperties"].get_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].emplace_object();
            return serialize_struct(temp, pProperties[uPFqrVz]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEEXECUTABLEPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableStatisticsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){
            if (json["pExecutableInfo"].get_array().size()==0){
                pExecutableInfo=NULL;
            return; }pExecutableInfo=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));
        auto& arr_NilRUQP=json["pExecutableInfo"].get_array();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            auto& temp=arr_NilRUQP[bxhNcYs].get_object();
            deserialize_struct(temp,pExecutableInfo[bxhNcYs]);
            }();
        }
        }();
uint32_t* pStatisticCount;
[&](){
            if (json["pStatisticCount"].get_array().size()==0){
                pStatisticCount=NULL;
            return; }pStatisticCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_BIkbvee=json["pStatisticCount"].get_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){
            if (arr_BIkbvee[MiieuSo].is_uint64()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_uint64());
            }else if (arr_BIkbvee[MiieuSo].is_int64()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_int64());
            }else{
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_double());
            }
            }();
        }
        }();
VkPipelineExecutableStatisticKHR* pStatistics;
[&](){
            if (json["pStatistics"].get_array().size()==0){
                pStatistics=NULL;
            return; }pStatistics=(VkPipelineExecutableStatisticKHR*)malloc(*pStatisticCount*sizeof(VkPipelineExecutableStatisticKHR));
        auto& arr_cGybyJf=json["pStatistics"].get_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].get_object();
            deserialize_struct(temp,pStatistics[ktSOZGx]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableStatisticsKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutableStatisticsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableStatisticsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pExecutableInfo, pStatisticCount, pStatistics);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }json["pExecutableInfo"]=boost::json::array(1);
        auto& arr_xbHlsCc=json["pExecutableInfo"].get_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=boost::json::array();
            return; }json["pStatisticCount"]=boost::json::array(1);
        auto& arr_BIkbvee=json["pStatisticCount"].get_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=pStatisticCount[MiieuSo];}();
        }
        }();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=boost::json::array();
            return; }json["pStatistics"]=boost::json::array(*pStatisticCount);
        auto& arr_cGybyJf=json["pStatistics"].get_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].emplace_object();
            return serialize_struct(temp, pStatistics[ktSOZGx]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEEXECUTABLESTATISTICSKHR;
        writeToConn(json);
    }

    void handle_vkGetPipelineExecutableInternalRepresentationsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineExecutableInfoKHR* pExecutableInfo;
[&](){
            if (json["pExecutableInfo"].get_array().size()==0){
                pExecutableInfo=NULL;
            return; }pExecutableInfo=(VkPipelineExecutableInfoKHR*)malloc(1*sizeof(VkPipelineExecutableInfoKHR));
        auto& arr_NilRUQP=json["pExecutableInfo"].get_array();
        for(int bxhNcYs=0; bxhNcYs < 1; bxhNcYs++){
            [&](){
            auto& temp=arr_NilRUQP[bxhNcYs].get_object();
            deserialize_struct(temp,pExecutableInfo[bxhNcYs]);
            }();
        }
        }();
uint32_t* pInternalRepresentationCount;
[&](){
            if (json["pInternalRepresentationCount"].get_array().size()==0){
                pInternalRepresentationCount=NULL;
            return; }pInternalRepresentationCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].get_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){
            if (arr_bVgggzH[urjNjhc].is_uint64()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_uint64());
            }else if (arr_bVgggzH[urjNjhc].is_int64()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_int64());
            }else{
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_double());
            }
            }();
        }
        }();
VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations;
[&](){
            if (json["pInternalRepresentations"].get_array().size()==0){
                pInternalRepresentations=NULL;
            return; }pInternalRepresentations=(VkPipelineExecutableInternalRepresentationKHR*)malloc(*pInternalRepresentationCount*sizeof(VkPipelineExecutableInternalRepresentationKHR));
        auto& arr_yqajgdo=json["pInternalRepresentations"].get_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].get_object();
            deserialize_struct(temp,pInternalRepresentations[OdpgULc]);
            }();
        }
        }();

    PFN_vkGetPipelineExecutableInternalRepresentationsKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_instance_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineExecutableInternalRepresentationsKHR)get_device_proc_addr(parent,"vkGetPipelineExecutableInternalRepresentationsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }json["pExecutableInfo"]=boost::json::array(1);
        auto& arr_xbHlsCc=json["pExecutableInfo"].get_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=boost::json::array();
            return; }json["pInternalRepresentationCount"]=boost::json::array(1);
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].get_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=pInternalRepresentationCount[urjNjhc];}();
        }
        }();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=boost::json::array();
            return; }json["pInternalRepresentations"]=boost::json::array(*pInternalRepresentationCount);
        auto& arr_yqajgdo=json["pInternalRepresentations"].get_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].emplace_object();
            return serialize_struct(temp, pInternalRepresentations[OdpgULc]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR;
        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t lineStippleFactor;
[&](){
            if (json["lineStippleFactor"].is_uint64()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_uint64());
            }else if (json["lineStippleFactor"].is_int64()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_int64());
            }else{
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_double());
            }
            }();
uint16_t lineStipplePattern;
[&](){
            if (json["lineStipplePattern"].is_uint64()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_uint64());
            }else if (json["lineStipplePattern"].is_int64()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_int64());
            }else{
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_double());
            }
            }();

    PFN_vkCmdSetLineStippleEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineStippleEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineStippleEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEXT");
    }  
    
{
call_function(commandBuffer, lineStippleFactor, lineStipplePattern);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=lineStippleFactor;}();
[&](){json["lineStipplePattern"]=lineStipplePattern;}();


        json["stream_type"]=VKCMDSETLINESTIPPLEEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceToolProperties(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pToolCount;
[&](){
            if (json["pToolCount"].get_array().size()==0){
                pToolCount=NULL;
            return; }pToolCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_PNAKwfC=json["pToolCount"].get_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){
            if (arr_PNAKwfC[iRGIIgT].is_uint64()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_uint64());
            }else if (arr_PNAKwfC[iRGIIgT].is_int64()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_int64());
            }else{
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_double());
            }
            }();
        }
        }();
VkPhysicalDeviceToolProperties* pToolProperties;
[&](){
            if (json["pToolProperties"].get_array().size()==0){
                pToolProperties=NULL;
            return; }pToolProperties=(VkPhysicalDeviceToolProperties*)malloc(*pToolCount*sizeof(VkPhysicalDeviceToolProperties));
        auto& arr_OYowiCQ=json["pToolProperties"].get_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].get_object();
            deserialize_struct(temp,pToolProperties[dlPXJcQ]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceToolProperties call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_instance_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceToolProperties)get_device_proc_addr(parent,"vkGetPhysicalDeviceToolProperties");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pToolCount, pToolProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=boost::json::array();
            return; }json["pToolCount"]=boost::json::array(1);
        auto& arr_PNAKwfC=json["pToolCount"].get_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=pToolCount[iRGIIgT];}();
        }
        }();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=boost::json::array();
            return; }json["pToolProperties"]=boost::json::array(*pToolCount);
        auto& arr_OYowiCQ=json["pToolProperties"].get_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].emplace_object();
            return serialize_struct(temp, pToolProperties[dlPXJcQ]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICETOOLPROPERTIES;
        writeToConn(json);
    }

    void handle_vkCreateAccelerationStructureKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkAccelerationStructureCreateInfoKHR*)malloc(1*sizeof(VkAccelerationStructureCreateInfoKHR));
        auto& arr_rLnSCOE=json["pCreateInfo"].get_array();
        for(int tKisKdf=0; tKisKdf < 1; tKisKdf++){
            [&](){
            auto& temp=arr_rLnSCOE[tKisKdf].get_object();
            deserialize_struct(temp,pCreateInfo[tKisKdf]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkAccelerationStructureKHR* pAccelerationStructure;
[&](){
            if (json["pAccelerationStructure"].get_array().size()==0){
                pAccelerationStructure=NULL;
            return; }pAccelerationStructure=(VkAccelerationStructureKHR*)malloc(1*sizeof(VkAccelerationStructureKHR));
        auto& arr_vKbZGTA=json["pAccelerationStructure"].get_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();

    PFN_vkCreateAccelerationStructureKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_instance_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateAccelerationStructureKHR)get_device_proc_addr(parent,"vkCreateAccelerationStructureKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XoURuCS=json["pCreateInfo"].get_array();
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto& temp=arr_XoURuCS[bGUDBRC].emplace_object();
            return serialize_struct(temp, pCreateInfo[bGUDBRC]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }json["pAccelerationStructure"]=boost::json::array(1);
        auto& arr_vKbZGTA=json["pAccelerationStructure"].get_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        }();


        json["stream_type"]=VKCREATEACCELERATIONSTRUCTUREKHR;
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].get_array().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].get_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].get_object();
            deserialize_struct(temp,pInfos[iIAEWFy]);
            }();
        }
        }();
 VkAccelerationStructureBuildRangeInfoKHR* * ppBuildRangeInfos;
[&](){
            if (json["ppBuildRangeInfos"].get_array().size()==0){
                ppBuildRangeInfos=NULL;
            return; }ppBuildRangeInfos=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));
        auto& arr_LOFGJKx=json["ppBuildRangeInfos"].get_array();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].get_array().size()==0){
                ppBuildRangeInfos[gLEYTdh]=NULL;
            return; }ppBuildRangeInfos[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));
        auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].get_array();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            auto& temp=arr_HqQzokg[TwVqYHk].get_object();
            deserialize_struct(temp,ppBuildRangeInfos[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();

    PFN_vkCmdBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }json["ppBuildRangeInfos"]=boost::json::array(1);
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].get_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }arr_FMxYLmq[CRaOjpb]=boost::json::array(infoCount);
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].get_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();


        json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURESKHR;
        writeToConn(json);
    }

    void handle_vkCmdBuildAccelerationStructuresIndirectKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].get_array().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].get_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].get_object();
            deserialize_struct(temp,pInfos[iIAEWFy]);
            }();
        }
        }();
 VkDeviceAddress* pIndirectDeviceAddresses;
[&](){
            if (json["pIndirectDeviceAddresses"].get_array().size()==0){
                pIndirectDeviceAddresses=NULL;
            return; }pIndirectDeviceAddresses=(VkDeviceAddress*)malloc(infoCount*sizeof(VkDeviceAddress));
        auto& arr_qqxgmPw=json["pIndirectDeviceAddresses"].get_array();
        for(int mphFFLu=0; mphFFLu < infoCount; mphFFLu++){
            [&](){uint64_t temp_qqxgmPw;[&](){
            if (arr_qqxgmPw[mphFFLu].is_uint64()){
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].get_uint64());
            }else if (arr_qqxgmPw[mphFFLu].is_int64()){
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].get_int64());
            }else{
                temp_qqxgmPw=static_cast<uint64_t>(arr_qqxgmPw[mphFFLu].get_double());
            }
            }();pIndirectDeviceAddresses[mphFFLu]=(VkDeviceAddress)temp_qqxgmPw;}();
        }
        }();
 uint32_t* pIndirectStrides;
[&](){
            if (json["pIndirectStrides"].get_array().size()==0){
                pIndirectStrides=NULL;
            return; }pIndirectStrides=(uint32_t*)malloc(infoCount*sizeof(uint32_t));
        auto& arr_JoqNqic=json["pIndirectStrides"].get_array();
        for(int TCKTxsQ=0; TCKTxsQ < infoCount; TCKTxsQ++){
            [&](){
            if (arr_JoqNqic[TCKTxsQ].is_uint64()){
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].get_uint64());
            }else if (arr_JoqNqic[TCKTxsQ].is_int64()){
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].get_int64());
            }else{
                pIndirectStrides[TCKTxsQ]=static_cast<uint32_t>(arr_JoqNqic[TCKTxsQ].get_double());
            }
            }();
        }
        }();
 uint32_t* * ppMaxPrimitiveCounts;
[&](){
            if (json["ppMaxPrimitiveCounts"].get_array().size()==0){
                ppMaxPrimitiveCounts=NULL;
            return; }ppMaxPrimitiveCounts=(uint32_t**)malloc(1*sizeof(uint32_t*));
        auto& arr_lnbIzaN=json["ppMaxPrimitiveCounts"].get_array();
        for(int DtQfWPT=0; DtQfWPT < 1; DtQfWPT++){
            [&](){
            if (arr_lnbIzaN[DtQfWPT].get_array().size()==0){
                ppMaxPrimitiveCounts[DtQfWPT]=NULL;
            return; }ppMaxPrimitiveCounts[DtQfWPT]=(uint32_t*)malloc(infoCount*sizeof(uint32_t));
        auto& arr_RluStPH=arr_lnbIzaN[DtQfWPT].get_array();
        for(int SaLgIYu=0; SaLgIYu < infoCount; SaLgIYu++){
            [&](){
            if (arr_RluStPH[SaLgIYu].is_uint64()){
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].get_uint64());
            }else if (arr_RluStPH[SaLgIYu].is_int64()){
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].get_int64());
            }else{
                ppMaxPrimitiveCounts[DtQfWPT][SaLgIYu]=static_cast<uint32_t>(arr_RluStPH[SaLgIYu].get_double());
            }
            }();
        }
        }();
        }
        }();

    PFN_vkCmdBuildAccelerationStructuresIndirectKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_instance_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildAccelerationStructuresIndirectKHR)get_device_proc_addr(parent,"vkCmdBuildAccelerationStructuresIndirectKHR");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=boost::json::array();
            return; }json["pIndirectDeviceAddresses"]=boost::json::array(infoCount);
        auto& arr_YkBEqzj=json["pIndirectDeviceAddresses"].get_array();
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=pIndirectDeviceAddresses[tMAuxlx];}();}();
        }
        }();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=boost::json::array();
            return; }json["pIndirectStrides"]=boost::json::array(infoCount);
        auto& arr_Helprzq=json["pIndirectStrides"].get_array();
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=pIndirectStrides[IXUUYlr];}();
        }
        }();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=boost::json::array();
            return; }json["ppMaxPrimitiveCounts"]=boost::json::array(1);
        auto& arr_DfsqJWs=json["ppMaxPrimitiveCounts"].get_array();
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=boost::json::array();
            return; }arr_DfsqJWs[TyNkaSn]=boost::json::array(infoCount);
        auto& arr_kfQrDXL=arr_DfsqJWs[TyNkaSn].get_array();
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=ppMaxPrimitiveCounts[TyNkaSn][SABezVP];}();
        }
        }();
        }
        }();


        json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR;
        writeToConn(json);
    }

    void handle_vkBuildAccelerationStructuresKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();
 VkAccelerationStructureBuildGeometryInfoKHR* pInfos;
[&](){
            if (json["pInfos"].get_array().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_pLxHocT=json["pInfos"].get_array();
        for(int iIAEWFy=0; iIAEWFy < infoCount; iIAEWFy++){
            [&](){
            auto& temp=arr_pLxHocT[iIAEWFy].get_object();
            deserialize_struct(temp,pInfos[iIAEWFy]);
            }();
        }
        }();
 VkAccelerationStructureBuildRangeInfoKHR* * ppBuildRangeInfos;
[&](){
            if (json["ppBuildRangeInfos"].get_array().size()==0){
                ppBuildRangeInfos=NULL;
            return; }ppBuildRangeInfos=(VkAccelerationStructureBuildRangeInfoKHR**)malloc(1*sizeof(VkAccelerationStructureBuildRangeInfoKHR*));
        auto& arr_LOFGJKx=json["ppBuildRangeInfos"].get_array();
        for(int gLEYTdh=0; gLEYTdh < 1; gLEYTdh++){
            [&](){
            if (arr_LOFGJKx[gLEYTdh].get_array().size()==0){
                ppBuildRangeInfos[gLEYTdh]=NULL;
            return; }ppBuildRangeInfos[gLEYTdh]=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(infoCount*sizeof(VkAccelerationStructureBuildRangeInfoKHR));
        auto& arr_HqQzokg=arr_LOFGJKx[gLEYTdh].get_array();
        for(int TwVqYHk=0; TwVqYHk < infoCount; TwVqYHk++){
            [&](){
            auto& temp=arr_HqQzokg[TwVqYHk].get_object();
            deserialize_struct(temp,ppBuildRangeInfos[gLEYTdh][TwVqYHk]);
            }();
        }
        }();
        }
        }();

    PFN_vkBuildAccelerationStructuresKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_instance_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBuildAccelerationStructuresKHR)get_device_proc_addr(parent,"vkBuildAccelerationStructuresKHR");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }json["ppBuildRangeInfos"]=boost::json::array(1);
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].get_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }arr_FMxYLmq[CRaOjpb]=boost::json::array(infoCount);
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].get_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();


        json["stream_type"]=VKBUILDACCELERATIONSTRUCTURESKHR;
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureDeviceAddressKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureDeviceAddressInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureDeviceAddressInfoKHR*)malloc(1*sizeof(VkAccelerationStructureDeviceAddressInfoKHR));
        auto& arr_hewpWGr=json["pInfo"].get_array();
        for(int XQgcVWG=0; XQgcVWG < 1; XQgcVWG++){
            [&](){
            auto& temp=arr_hewpWGr[XQgcVWG].get_object();
            deserialize_struct(temp,pInfo[XQgcVWG]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureDeviceAddressKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureDeviceAddressKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureDeviceAddressKHR");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_CAfLmMn=json["pInfo"].get_array();
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto& temp=arr_CAfLmMn[DozYfEa].emplace_object();
            return serialize_struct(temp, pInfo[DozYfEa]);
            }();
        }
        }();


        json["stream_type"]=VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR;
        writeToConn(json);
    }

    void handle_vkCreateDeferredOperationKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkDeferredOperationKHR* pDeferredOperation;
[&](){
            if (json["pDeferredOperation"].get_array().size()==0){
                pDeferredOperation=NULL;
            return; }pDeferredOperation=(VkDeferredOperationKHR*)malloc(1*sizeof(VkDeferredOperationKHR));
        auto& arr_fPVilHH=json["pDeferredOperation"].get_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();

    PFN_vkCreateDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateDeferredOperationKHR)get_instance_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateDeferredOperationKHR)get_device_proc_addr(parent,"vkCreateDeferredOperationKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pAllocator, pDeferredOperation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=boost::json::array();
            return; }json["pDeferredOperation"]=boost::json::array(1);
        auto& arr_fPVilHH=json["pDeferredOperation"].get_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        }();


        json["stream_type"]=VKCREATEDEFERREDOPERATIONKHR;
        writeToConn(json);
    }

    void handle_vkDestroyDeferredOperationKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyDeferredOperationKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_instance_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyDeferredOperationKHR)get_device_proc_addr(parent,"vkDestroyDeferredOperationKHR");
    }  
    
{
call_function(device, operation, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYDEFERREDOPERATIONKHR;
        writeToConn(json);
    }

    void handle_vkGetDeferredOperationMaxConcurrencyKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationMaxConcurrencyKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeferredOperationMaxConcurrencyKHR)get_device_proc_addr(parent,"vkGetDeferredOperationMaxConcurrencyKHR");
    }  
    
uint32_t  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){json["result"]=result;}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR;
        writeToConn(json);
    }

    void handle_vkGetDeferredOperationResultKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkGetDeferredOperationResultKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_instance_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeferredOperationResultKHR)get_device_proc_addr(parent,"vkGetDeferredOperationResultKHR");
    }  
    
VkResult  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=VKGETDEFERREDOPERATIONRESULTKHR;
        writeToConn(json);
    }

    void handle_vkDeferredOperationJoinKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR operation;
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();

    PFN_vkDeferredOperationJoinKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDeferredOperationJoinKHR)get_instance_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDeferredOperationJoinKHR)get_device_proc_addr(parent,"vkDeferredOperationJoinKHR");
    }  
    
VkResult  result;
{
result=call_function(device, operation);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();


        json["stream_type"]=VKDEFERREDOPERATIONJOINKHR;
        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectMemoryRequirementsNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkComputePipelineCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkComputePipelineCreateInfo*)malloc(1*sizeof(VkComputePipelineCreateInfo));
        auto& arr_IIYnuXe=json["pCreateInfo"].get_array();
        for(int LOABkrY=0; LOABkrY < 1; LOABkrY++){
            [&](){
            auto& temp=arr_IIYnuXe[LOABkrY].get_object();
            deserialize_struct(temp,pCreateInfo[LOABkrY]);
            }();
        }
        }();
VkMemoryRequirements2* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkMemoryRequirements2*)malloc(1*sizeof(VkMemoryRequirements2));
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

    PFN_vkGetPipelineIndirectMemoryRequirementsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineIndirectMemoryRequirementsNV)get_device_proc_addr(parent,"vkGetPipelineIndirectMemoryRequirementsNV");
    }  
    
{
call_function(device, pCreateInfo, pMemoryRequirements);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XLStDVY=json["pCreateInfo"].get_array();
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto& temp=arr_XLStDVY[FoBxBjF].emplace_object();
            return serialize_struct(temp, pCreateInfo[FoBxBjF]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV;
        writeToConn(json);
    }

    void handle_vkGetPipelineIndirectDeviceAddressNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineIndirectDeviceAddressInfoNV* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkPipelineIndirectDeviceAddressInfoNV*)malloc(1*sizeof(VkPipelineIndirectDeviceAddressInfoNV));
        auto& arr_nyTOzHx=json["pInfo"].get_array();
        for(int fovHdtg=0; fovHdtg < 1; fovHdtg++){
            [&](){
            auto& temp=arr_nyTOzHx[fovHdtg].get_object();
            deserialize_struct(temp,pInfo[fovHdtg]);
            }();
        }
        }();

    PFN_vkGetPipelineIndirectDeviceAddressNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_instance_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelineIndirectDeviceAddressNV)get_device_proc_addr(parent,"vkGetPipelineIndirectDeviceAddressNV");
    }  
    
VkDeviceAddress  result;
{
result=call_function(device, pInfo);
}
json.clear();
[&](){[&](){json["result"]=result;}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_iNXSdlN=json["pInfo"].get_array();
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto& temp=arr_iNXSdlN[EeNdDDD].emplace_object();
            return serialize_struct(temp, pInfo[EeNdDDD]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEINDIRECTDEVICEADDRESSNV;
        writeToConn(json);
    }

    void handle_vkCmdSetCullMode(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCullModeFlags cullMode;
[&](){[&](){int temp_JocwJIC;[&](){
            if (json["cullMode"].is_uint64()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_uint64());
            }else if (json["cullMode"].is_int64()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_int64());
            }else{
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_double());
            }
            }();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

    PFN_vkCmdSetCullMode call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCullMode)get_instance_proc_addr(parent,"vkCmdSetCullMode");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCullMode)get_device_proc_addr(parent,"vkCmdSetCullMode");
    }  
    
{
call_function(commandBuffer, cullMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=cullMode;}();}();}();


        json["stream_type"]=VKCMDSETCULLMODE;
        writeToConn(json);
    }

    void handle_vkCmdSetFrontFace(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFrontFace frontFace;
[&](){[&](){int temp_ZBubEzp;[&](){
            if (json["frontFace"].is_uint64()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_uint64());
            }else if (json["frontFace"].is_int64()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_int64());
            }else{
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_double());
            }
            }();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

    PFN_vkCmdSetFrontFace call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFrontFace)get_instance_proc_addr(parent,"vkCmdSetFrontFace");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFrontFace)get_device_proc_addr(parent,"vkCmdSetFrontFace");
    }  
    
{
call_function(commandBuffer, frontFace);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=frontFace;}();}();}();


        json["stream_type"]=VKCMDSETFRONTFACE;
        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveTopology(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPrimitiveTopology primitiveTopology;
[&](){[&](){int temp_jzAnfAA;[&](){
            if (json["primitiveTopology"].is_uint64()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_uint64());
            }else if (json["primitiveTopology"].is_int64()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_int64());
            }else{
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_double());
            }
            }();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

    PFN_vkCmdSetPrimitiveTopology call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_instance_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPrimitiveTopology)get_device_proc_addr(parent,"vkCmdSetPrimitiveTopology");
    }  
    
{
call_function(commandBuffer, primitiveTopology);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=primitiveTopology;}();}();}();


        json["stream_type"]=VKCMDSETPRIMITIVETOPOLOGY;
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWithCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();
 VkViewport* pViewports;
[&](){
            if (json["pViewports"].get_array().size()==0){
                pViewports=NULL;
            return; }pViewports=(VkViewport*)malloc(viewportCount*sizeof(VkViewport));
        auto& arr_NYoDqxX=json["pViewports"].get_array();
        for(int SjlAQpy=0; SjlAQpy < viewportCount; SjlAQpy++){
            [&](){
            auto& temp=arr_NYoDqxX[SjlAQpy].get_object();
            deserialize_struct(temp,pViewports[SjlAQpy]);
            }();
        }
        }();

    PFN_vkCmdSetViewportWithCount call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWithCount)get_instance_proc_addr(parent,"vkCmdSetViewportWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWithCount)get_device_proc_addr(parent,"vkCmdSetViewportWithCount");
    }  
    
{
call_function(commandBuffer, viewportCount, pViewports);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }json["pViewports"]=boost::json::array(viewportCount);
        auto& arr_SyYryUE=json["pViewports"].get_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVIEWPORTWITHCOUNT;
        writeToConn(json);
    }

    void handle_vkCmdSetScissorWithCount(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t scissorCount;
[&](){
            if (json["scissorCount"].is_uint64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_uint64());
            }else if (json["scissorCount"].is_int64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_int64());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_double());
            }
            }();
 VkRect2D* pScissors;
[&](){
            if (json["pScissors"].get_array().size()==0){
                pScissors=NULL;
            return; }pScissors=(VkRect2D*)malloc(scissorCount*sizeof(VkRect2D));
        auto& arr_bIRAuhj=json["pScissors"].get_array();
        for(int QukNmCZ=0; QukNmCZ < scissorCount; QukNmCZ++){
            [&](){
            auto& temp=arr_bIRAuhj[QukNmCZ].get_object();
            deserialize_struct(temp,pScissors[QukNmCZ]);
            }();
        }
        }();

    PFN_vkCmdSetScissorWithCount call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetScissorWithCount)get_instance_proc_addr(parent,"vkCmdSetScissorWithCount");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetScissorWithCount)get_device_proc_addr(parent,"vkCmdSetScissorWithCount");
    }  
    
{
call_function(commandBuffer, scissorCount, pScissors);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }json["pScissors"]=boost::json::array(scissorCount);
        auto& arr_RpUaBcS=json["pScissors"].get_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETSCISSORWITHCOUNT;
        writeToConn(json);
    }

    void handle_vkCmdBindIndexBuffer2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBuffer buffer;
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
VkDeviceSize offset;
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
VkDeviceSize size;
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
VkIndexType indexType;
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_uint64());
            }else if (json["indexType"].is_int64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_int64());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

    PFN_vkCmdBindIndexBuffer2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_instance_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindIndexBuffer2KHR)get_device_proc_addr(parent,"vkCmdBindIndexBuffer2KHR");
    }  
    
{
call_function(commandBuffer, buffer, offset, size, indexType);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();


        json["stream_type"]=VKCMDBINDINDEXBUFFER2KHR;
        writeToConn(json);
    }

    void handle_vkCmdBindVertexBuffers2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstBinding;
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
uint32_t bindingCount;
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();
 VkBuffer* pBuffers;
[&](){
            if (json["pBuffers"].get_array().size()==0){
                pBuffers=NULL;
            return; }pBuffers=(VkBuffer*)malloc(bindingCount*sizeof(VkBuffer));
        auto& arr_ShVTBbp=json["pBuffers"].get_array();
        for(int loSrvWd=0; loSrvWd < bindingCount; loSrvWd++){
            [&](){deserialize_VkBuffer(arr_ShVTBbp[loSrvWd], pBuffers[loSrvWd]);}();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].get_array().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].get_array();
        for(int ELYQTNF=0; ELYQTNF < bindingCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_uint64());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_int64());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();
 VkDeviceSize* pSizes;
[&](){
            if (json["pSizes"].get_array().size()==0){
                pSizes=NULL;
            return; }pSizes=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_cHIDMyb=json["pSizes"].get_array();
        for(int yLUmhkZ=0; yLUmhkZ < bindingCount; yLUmhkZ++){
            [&](){uint64_t temp_cHIDMyb;[&](){
            if (arr_cHIDMyb[yLUmhkZ].is_uint64()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_uint64());
            }else if (arr_cHIDMyb[yLUmhkZ].is_int64()){
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_int64());
            }else{
                temp_cHIDMyb=static_cast<uint64_t>(arr_cHIDMyb[yLUmhkZ].get_double());
            }
            }();pSizes[yLUmhkZ]=(VkDeviceSize)temp_cHIDMyb;}();
        }
        }();
 VkDeviceSize* pStrides;
[&](){
            if (json["pStrides"].get_array().size()==0){
                pStrides=NULL;
            return; }pStrides=(VkDeviceSize*)malloc(bindingCount*sizeof(VkDeviceSize));
        auto& arr_FOKmrCn=json["pStrides"].get_array();
        for(int ByEZqEy=0; ByEZqEy < bindingCount; ByEZqEy++){
            [&](){uint64_t temp_FOKmrCn;[&](){
            if (arr_FOKmrCn[ByEZqEy].is_uint64()){
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].get_uint64());
            }else if (arr_FOKmrCn[ByEZqEy].is_int64()){
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].get_int64());
            }else{
                temp_FOKmrCn=static_cast<uint64_t>(arr_FOKmrCn[ByEZqEy].get_double());
            }
            }();pStrides[ByEZqEy]=(VkDeviceSize)temp_FOKmrCn;}();
        }
        }();

    PFN_vkCmdBindVertexBuffers2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindVertexBuffers2)get_instance_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindVertexBuffers2)get_device_proc_addr(parent,"vkCmdBindVertexBuffers2");
    }  
    
{
call_function(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }json["pSizes"]=boost::json::array(bindingCount);
        auto& arr_OwyEmcF=json["pSizes"].get_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=boost::json::array();
            return; }json["pStrides"]=boost::json::array(bindingCount);
        auto& arr_YFLMtWg=json["pStrides"].get_array();
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=pStrides[qlkJtZj];}();}();
        }
        }();


        json["stream_type"]=VKCMDBINDVERTEXBUFFERS2;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthTestEnable;
[&](){uint32_t temp_WLSKeYp;[&](){
            if (json["depthTestEnable"].is_uint64()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_uint64());
            }else if (json["depthTestEnable"].is_int64()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_int64());
            }else{
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_double());
            }
            }();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

    PFN_vkCmdSetDepthTestEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthTestEnable");
    }  
    
{
call_function(commandBuffer, depthTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=depthTestEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHTESTENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthWriteEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthWriteEnable;
[&](){uint32_t temp_qztdWhG;[&](){
            if (json["depthWriteEnable"].is_uint64()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_uint64());
            }else if (json["depthWriteEnable"].is_int64()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_int64());
            }else{
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_double());
            }
            }();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

    PFN_vkCmdSetDepthWriteEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_instance_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthWriteEnable)get_device_proc_addr(parent,"vkCmdSetDepthWriteEnable");
    }  
    
{
call_function(commandBuffer, depthWriteEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=depthWriteEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHWRITEENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthCompareOp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCompareOp depthCompareOp;
[&](){[&](){int temp_GommENv;[&](){
            if (json["depthCompareOp"].is_uint64()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_uint64());
            }else if (json["depthCompareOp"].is_int64()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_int64());
            }else{
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_double());
            }
            }();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

    PFN_vkCmdSetDepthCompareOp call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthCompareOp)get_instance_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthCompareOp)get_device_proc_addr(parent,"vkCmdSetDepthCompareOp");
    }  
    
{
call_function(commandBuffer, depthCompareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=depthCompareOp;}();}();}();


        json["stream_type"]=VKCMDSETDEPTHCOMPAREOP;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBoundsTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBoundsTestEnable;
[&](){uint32_t temp_qmudcyJ;[&](){
            if (json["depthBoundsTestEnable"].is_uint64()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_uint64());
            }else if (json["depthBoundsTestEnable"].is_int64()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_int64());
            }else{
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_double());
            }
            }();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

    PFN_vkCmdSetDepthBoundsTestEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBoundsTestEnable)get_device_proc_addr(parent,"vkCmdSetDepthBoundsTestEnable");
    }  
    
{
call_function(commandBuffer, depthBoundsTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=depthBoundsTestEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHBOUNDSTESTENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetStencilTestEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stencilTestEnable;
[&](){uint32_t temp_qPvOEDS;[&](){
            if (json["stencilTestEnable"].is_uint64()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_uint64());
            }else if (json["stencilTestEnable"].is_int64()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_int64());
            }else{
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_double());
            }
            }();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

    PFN_vkCmdSetStencilTestEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilTestEnable)get_instance_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilTestEnable)get_device_proc_addr(parent,"vkCmdSetStencilTestEnable");
    }  
    
{
call_function(commandBuffer, stencilTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=stencilTestEnable;}();}();


        json["stream_type"]=VKCMDSETSTENCILTESTENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetStencilOp(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkStencilFaceFlags faceMask;
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
VkStencilOp failOp;
[&](){[&](){int temp_lKXncFy;[&](){
            if (json["failOp"].is_uint64()){
                temp_lKXncFy=static_cast<int>(json["failOp"].get_uint64());
            }else if (json["failOp"].is_int64()){
                temp_lKXncFy=static_cast<int>(json["failOp"].get_int64());
            }else{
                temp_lKXncFy=static_cast<int>(json["failOp"].get_double());
            }
            }();failOp=(VkStencilOp)temp_lKXncFy;}();}();
VkStencilOp passOp;
[&](){[&](){int temp_SPMLjKg;[&](){
            if (json["passOp"].is_uint64()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_uint64());
            }else if (json["passOp"].is_int64()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_int64());
            }else{
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_double());
            }
            }();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
VkStencilOp depthFailOp;
[&](){[&](){int temp_TdIKNtG;[&](){
            if (json["depthFailOp"].is_uint64()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_uint64());
            }else if (json["depthFailOp"].is_int64()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_int64());
            }else{
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_double());
            }
            }();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
VkCompareOp compareOp;
[&](){[&](){int temp_NLoCySV;[&](){
            if (json["compareOp"].is_uint64()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_uint64());
            }else if (json["compareOp"].is_int64()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_int64());
            }else{
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_double());
            }
            }();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

    PFN_vkCmdSetStencilOp call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetStencilOp)get_instance_proc_addr(parent,"vkCmdSetStencilOp");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetStencilOp)get_device_proc_addr(parent,"vkCmdSetStencilOp");
    }  
    
{
call_function(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){[&](){[&](){json["failOp"]=failOp;}();}();}();
[&](){[&](){[&](){json["passOp"]=passOp;}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=depthFailOp;}();}();}();
[&](){[&](){[&](){json["compareOp"]=compareOp;}();}();}();


        json["stream_type"]=VKCMDSETSTENCILOP;
        writeToConn(json);
    }

    void handle_vkCmdSetPatchControlPointsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t patchControlPoints;
[&](){
            if (json["patchControlPoints"].is_uint64()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_uint64());
            }else if (json["patchControlPoints"].is_int64()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_int64());
            }else{
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_double());
            }
            }();

    PFN_vkCmdSetPatchControlPointsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_instance_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPatchControlPointsEXT)get_device_proc_addr(parent,"vkCmdSetPatchControlPointsEXT");
    }  
    
{
call_function(commandBuffer, patchControlPoints);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=patchControlPoints;}();


        json["stream_type"]=VKCMDSETPATCHCONTROLPOINTSEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizerDiscardEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 rasterizerDiscardEnable;
[&](){uint32_t temp_bdbWnok;[&](){
            if (json["rasterizerDiscardEnable"].is_uint64()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_uint64());
            }else if (json["rasterizerDiscardEnable"].is_int64()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_int64());
            }else{
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_double());
            }
            }();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

    PFN_vkCmdSetRasterizerDiscardEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_instance_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizerDiscardEnable)get_device_proc_addr(parent,"vkCmdSetRasterizerDiscardEnable");
    }  
    
{
call_function(commandBuffer, rasterizerDiscardEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=rasterizerDiscardEnable;}();}();


        json["stream_type"]=VKCMDSETRASTERIZERDISCARDENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBiasEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthBiasEnable;
[&](){uint32_t temp_ewcVkBi;[&](){
            if (json["depthBiasEnable"].is_uint64()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_uint64());
            }else if (json["depthBiasEnable"].is_int64()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_int64());
            }else{
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_double());
            }
            }();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

    PFN_vkCmdSetDepthBiasEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_instance_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBiasEnable)get_device_proc_addr(parent,"vkCmdSetDepthBiasEnable");
    }  
    
{
call_function(commandBuffer, depthBiasEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=depthBiasEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHBIASENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLogicOp logicOp;
[&](){[&](){int temp_KRaggtp;[&](){
            if (json["logicOp"].is_uint64()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_uint64());
            }else if (json["logicOp"].is_int64()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_int64());
            }else{
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_double());
            }
            }();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

    PFN_vkCmdSetLogicOpEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLogicOpEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLogicOpEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEXT");
    }  
    
{
call_function(commandBuffer, logicOp);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=logicOp;}();}();}();


        json["stream_type"]=VKCMDSETLOGICOPEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetPrimitiveRestartEnable(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 primitiveRestartEnable;
[&](){uint32_t temp_mDszbuh;[&](){
            if (json["primitiveRestartEnable"].is_uint64()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_uint64());
            }else if (json["primitiveRestartEnable"].is_int64()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_int64());
            }else{
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_double());
            }
            }();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

    PFN_vkCmdSetPrimitiveRestartEnable call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_instance_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPrimitiveRestartEnable)get_device_proc_addr(parent,"vkCmdSetPrimitiveRestartEnable");
    }  
    
{
call_function(commandBuffer, primitiveRestartEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=primitiveRestartEnable;}();}();


        json["stream_type"]=VKCMDSETPRIMITIVERESTARTENABLE;
        writeToConn(json);
    }

    void handle_vkCmdSetTessellationDomainOriginEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkTessellationDomainOrigin domainOrigin;
[&](){[&](){int temp_MhaRSZf;[&](){
            if (json["domainOrigin"].is_uint64()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_uint64());
            }else if (json["domainOrigin"].is_int64()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_int64());
            }else{
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_double());
            }
            }();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

    PFN_vkCmdSetTessellationDomainOriginEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_instance_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetTessellationDomainOriginEXT)get_device_proc_addr(parent,"vkCmdSetTessellationDomainOriginEXT");
    }  
    
{
call_function(commandBuffer, domainOrigin);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=domainOrigin;}();}();}();


        json["stream_type"]=VKCMDSETTESSELLATIONDOMAINORIGINEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClampEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClampEnable;
[&](){uint32_t temp_DzsSqgr;[&](){
            if (json["depthClampEnable"].is_uint64()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_uint64());
            }else if (json["depthClampEnable"].is_int64()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_int64());
            }else{
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_double());
            }
            }();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

    PFN_vkCmdSetDepthClampEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClampEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClampEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClampEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=depthClampEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHCLAMPENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetPolygonModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPolygonMode polygonMode;
[&](){[&](){int temp_XzCpfxJ;[&](){
            if (json["polygonMode"].is_uint64()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_uint64());
            }else if (json["polygonMode"].is_int64()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_int64());
            }else{
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_double());
            }
            }();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

    PFN_vkCmdSetPolygonModeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_instance_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetPolygonModeEXT)get_device_proc_addr(parent,"vkCmdSetPolygonModeEXT");
    }  
    
{
call_function(commandBuffer, polygonMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=polygonMode;}();}();}();


        json["stream_type"]=VKCMDSETPOLYGONMODEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationSamplesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits rasterizationSamples;
[&](){[&](){int temp_YCyLybT;[&](){
            if (json["rasterizationSamples"].is_uint64()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_uint64());
            }else if (json["rasterizationSamples"].is_int64()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_int64());
            }else{
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_double());
            }
            }();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

    PFN_vkCmdSetRasterizationSamplesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizationSamplesEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationSamplesEXT");
    }  
    
{
call_function(commandBuffer, rasterizationSamples);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=rasterizationSamples;}();}();}();


        json["stream_type"]=VKCMDSETRASTERIZATIONSAMPLESEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetSampleMaskEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkSampleCountFlagBits samples;
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
 VkSampleMask* pSampleMask;
[&](){
            if (json["pSampleMask"].get_array().size()==0){
                pSampleMask=NULL;
            return; }pSampleMask=(VkSampleMask*)malloc((samples + 31) / 32*sizeof(VkSampleMask));
        auto& arr_FGuLlff=json["pSampleMask"].get_array();
        for(int BCMPGHn=0; BCMPGHn < (samples + 31) / 32; BCMPGHn++){
            [&](){uint32_t temp_FGuLlff;[&](){
            if (arr_FGuLlff[BCMPGHn].is_uint64()){
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].get_uint64());
            }else if (arr_FGuLlff[BCMPGHn].is_int64()){
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].get_int64());
            }else{
                temp_FGuLlff=static_cast<uint32_t>(arr_FGuLlff[BCMPGHn].get_double());
            }
            }();pSampleMask[BCMPGHn]=(VkSampleMask)temp_FGuLlff;}();
        }
        }();

    PFN_vkCmdSetSampleMaskEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_instance_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleMaskEXT)get_device_proc_addr(parent,"vkCmdSetSampleMaskEXT");
    }  
    
{
call_function(commandBuffer, samples, pSampleMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=boost::json::array();
            return; }json["pSampleMask"]=boost::json::array((samples + 31) / 32);
        auto& arr_nepOVVF=json["pSampleMask"].get_array();
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=pSampleMask[ASCUBEW];}();}();
        }
        }();


        json["stream_type"]=VKCMDSETSAMPLEMASKEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToCoverageEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToCoverageEnable;
[&](){uint32_t temp_GXlPpxl;[&](){
            if (json["alphaToCoverageEnable"].is_uint64()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_uint64());
            }else if (json["alphaToCoverageEnable"].is_int64()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_int64());
            }else{
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_double());
            }
            }();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

    PFN_vkCmdSetAlphaToCoverageEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAlphaToCoverageEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToCoverageEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToCoverageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=alphaToCoverageEnable;}();}();


        json["stream_type"]=VKCMDSETALPHATOCOVERAGEENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetAlphaToOneEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 alphaToOneEnable;
[&](){uint32_t temp_vIViDmy;[&](){
            if (json["alphaToOneEnable"].is_uint64()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_uint64());
            }else if (json["alphaToOneEnable"].is_int64()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_int64());
            }else{
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_double());
            }
            }();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

    PFN_vkCmdSetAlphaToOneEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_instance_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetAlphaToOneEnableEXT)get_device_proc_addr(parent,"vkCmdSetAlphaToOneEnableEXT");
    }  
    
{
call_function(commandBuffer, alphaToOneEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=alphaToOneEnable;}();}();


        json["stream_type"]=VKCMDSETALPHATOONEENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetLogicOpEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 logicOpEnable;
[&](){uint32_t temp_efIIzNf;[&](){
            if (json["logicOpEnable"].is_uint64()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_uint64());
            }else if (json["logicOpEnable"].is_int64()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_int64());
            }else{
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_double());
            }
            }();logicOpEnable=(VkBool32)temp_efIIzNf;}();

    PFN_vkCmdSetLogicOpEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLogicOpEnableEXT)get_device_proc_addr(parent,"vkCmdSetLogicOpEnableEXT");
    }  
    
{
call_function(commandBuffer, logicOpEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=logicOpEnable;}();}();


        json["stream_type"]=VKCMDSETLOGICOPENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkBool32* pColorBlendEnables;
[&](){
            if (json["pColorBlendEnables"].get_array().size()==0){
                pColorBlendEnables=NULL;
            return; }pColorBlendEnables=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));
        auto& arr_lHzNiUd=json["pColorBlendEnables"].get_array();
        for(int wbANAKE=0; wbANAKE < attachmentCount; wbANAKE++){
            [&](){uint32_t temp_lHzNiUd;[&](){
            if (arr_lHzNiUd[wbANAKE].is_uint64()){
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].get_uint64());
            }else if (arr_lHzNiUd[wbANAKE].is_int64()){
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].get_int64());
            }else{
                temp_lHzNiUd=static_cast<uint32_t>(arr_lHzNiUd[wbANAKE].get_double());
            }
            }();pColorBlendEnables[wbANAKE]=(VkBool32)temp_lHzNiUd;}();
        }
        }();

    PFN_vkCmdSetColorBlendEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEnableEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=boost::json::array();
            return; }json["pColorBlendEnables"]=boost::json::array(attachmentCount);
        auto& arr_saqDhTV=json["pColorBlendEnables"].get_array();
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=pColorBlendEnables[VGuJXMd];}();}();
        }
        }();


        json["stream_type"]=VKCMDSETCOLORBLENDENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendEquationEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkColorBlendEquationEXT* pColorBlendEquations;
[&](){
            if (json["pColorBlendEquations"].get_array().size()==0){
                pColorBlendEquations=NULL;
            return; }pColorBlendEquations=(VkColorBlendEquationEXT*)malloc(attachmentCount*sizeof(VkColorBlendEquationEXT));
        auto& arr_EqkVhnu=json["pColorBlendEquations"].get_array();
        for(int fbdCMaT=0; fbdCMaT < attachmentCount; fbdCMaT++){
            [&](){
            auto& temp=arr_EqkVhnu[fbdCMaT].get_object();
            deserialize_struct(temp,pColorBlendEquations[fbdCMaT]);
            }();
        }
        }();

    PFN_vkCmdSetColorBlendEquationEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendEquationEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendEquationEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=boost::json::array();
            return; }json["pColorBlendEquations"]=boost::json::array(attachmentCount);
        auto& arr_hKUQljx=json["pColorBlendEquations"].get_array();
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto& temp=arr_hKUQljx[EHggOtN].emplace_object();
            return serialize_struct(temp, pColorBlendEquations[EHggOtN]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETCOLORBLENDEQUATIONEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteMaskEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkColorComponentFlags* pColorWriteMasks;
[&](){
            if (json["pColorWriteMasks"].get_array().size()==0){
                pColorWriteMasks=NULL;
            return; }pColorWriteMasks=(VkColorComponentFlags*)malloc(attachmentCount*sizeof(VkColorComponentFlags));
        auto& arr_EqZFwIM=json["pColorWriteMasks"].get_array();
        for(int ieFAddx=0; ieFAddx < attachmentCount; ieFAddx++){
            [&](){[&](){int temp_eGfaWyY;[&](){
            if (arr_EqZFwIM[ieFAddx].is_uint64()){
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].get_uint64());
            }else if (arr_EqZFwIM[ieFAddx].is_int64()){
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].get_int64());
            }else{
                temp_eGfaWyY=static_cast<int>(arr_EqZFwIM[ieFAddx].get_double());
            }
            }();pColorWriteMasks[ieFAddx]=(VkColorComponentFlags)temp_eGfaWyY;}();}();
        }
        }();

    PFN_vkCmdSetColorWriteMaskEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorWriteMaskEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteMaskEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=boost::json::array();
            return; }json["pColorWriteMasks"]=boost::json::array(attachmentCount);
        auto& arr_VFhepws=json["pColorWriteMasks"].get_array();
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=pColorWriteMasks[PbQLtdZ];}();}();}();
        }
        }();


        json["stream_type"]=VKCMDSETCOLORWRITEMASKEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetRasterizationStreamEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t rasterizationStream;
[&](){
            if (json["rasterizationStream"].is_uint64()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_uint64());
            }else if (json["rasterizationStream"].is_int64()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_int64());
            }else{
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_double());
            }
            }();

    PFN_vkCmdSetRasterizationStreamEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_instance_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRasterizationStreamEXT)get_device_proc_addr(parent,"vkCmdSetRasterizationStreamEXT");
    }  
    
{
call_function(commandBuffer, rasterizationStream);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=rasterizationStream;}();


        json["stream_type"]=VKCMDSETRASTERIZATIONSTREAMEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetConservativeRasterizationModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkConservativeRasterizationModeEXT conservativeRasterizationMode;
[&](){[&](){int temp_foXltQC;[&](){
            if (json["conservativeRasterizationMode"].is_uint64()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_uint64());
            }else if (json["conservativeRasterizationMode"].is_int64()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_int64());
            }else{
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_double());
            }
            }();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

    PFN_vkCmdSetConservativeRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetConservativeRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetConservativeRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, conservativeRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=conservativeRasterizationMode;}();}();}();


        json["stream_type"]=VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetExtraPrimitiveOverestimationSizeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
float extraPrimitiveOverestimationSize;
[&](){
            if (json["extraPrimitiveOverestimationSize"].is_uint64()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_uint64());
            }else if (json["extraPrimitiveOverestimationSize"].is_int64()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_int64());
            }else{
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_double());
            }
            }();

    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_instance_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)get_device_proc_addr(parent,"vkCmdSetExtraPrimitiveOverestimationSizeEXT");
    }  
    
{
call_function(commandBuffer, extraPrimitiveOverestimationSize);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=extraPrimitiveOverestimationSize;}();


        json["stream_type"]=VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 depthClipEnable;
[&](){uint32_t temp_xexuvpr;[&](){
            if (json["depthClipEnable"].is_uint64()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_uint64());
            }else if (json["depthClipEnable"].is_int64()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_int64());
            }else{
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_double());
            }
            }();depthClipEnable=(VkBool32)temp_xexuvpr;}();

    PFN_vkCmdSetDepthClipEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClipEnableEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipEnableEXT");
    }  
    
{
call_function(commandBuffer, depthClipEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=depthClipEnable;}();}();


        json["stream_type"]=VKCMDSETDEPTHCLIPENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetSampleLocationsEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 sampleLocationsEnable;
[&](){uint32_t temp_dFVPXvO;[&](){
            if (json["sampleLocationsEnable"].is_uint64()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_uint64());
            }else if (json["sampleLocationsEnable"].is_int64()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_int64());
            }else{
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_double());
            }
            }();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

    PFN_vkCmdSetSampleLocationsEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_instance_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetSampleLocationsEnableEXT)get_device_proc_addr(parent,"vkCmdSetSampleLocationsEnableEXT");
    }  
    
{
call_function(commandBuffer, sampleLocationsEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=sampleLocationsEnable;}();}();


        json["stream_type"]=VKCMDSETSAMPLELOCATIONSENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetColorBlendAdvancedEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstAttachment;
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkColorBlendAdvancedEXT* pColorBlendAdvanced;
[&](){
            if (json["pColorBlendAdvanced"].get_array().size()==0){
                pColorBlendAdvanced=NULL;
            return; }pColorBlendAdvanced=(VkColorBlendAdvancedEXT*)malloc(attachmentCount*sizeof(VkColorBlendAdvancedEXT));
        auto& arr_CGYbnEQ=json["pColorBlendAdvanced"].get_array();
        for(int apDMrcx=0; apDMrcx < attachmentCount; apDMrcx++){
            [&](){
            auto& temp=arr_CGYbnEQ[apDMrcx].get_object();
            deserialize_struct(temp,pColorBlendAdvanced[apDMrcx]);
            }();
        }
        }();

    PFN_vkCmdSetColorBlendAdvancedEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_instance_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorBlendAdvancedEXT)get_device_proc_addr(parent,"vkCmdSetColorBlendAdvancedEXT");
    }  
    
{
call_function(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=boost::json::array();
            return; }json["pColorBlendAdvanced"]=boost::json::array(attachmentCount);
        auto& arr_VhJvkCW=json["pColorBlendAdvanced"].get_array();
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto& temp=arr_VhJvkCW[rBcMzuv].emplace_object();
            return serialize_struct(temp, pColorBlendAdvanced[rBcMzuv]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETCOLORBLENDADVANCEDEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetProvokingVertexModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkProvokingVertexModeEXT provokingVertexMode;
[&](){[&](){int temp_unvGJcm;[&](){
            if (json["provokingVertexMode"].is_uint64()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_uint64());
            }else if (json["provokingVertexMode"].is_int64()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_int64());
            }else{
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_double());
            }
            }();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

    PFN_vkCmdSetProvokingVertexModeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_instance_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetProvokingVertexModeEXT)get_device_proc_addr(parent,"vkCmdSetProvokingVertexModeEXT");
    }  
    
{
call_function(commandBuffer, provokingVertexMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=provokingVertexMode;}();}();}();


        json["stream_type"]=VKCMDSETPROVOKINGVERTEXMODEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetLineRasterizationModeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkLineRasterizationModeEXT lineRasterizationMode;
[&](){[&](){int temp_TzHFAEB;[&](){
            if (json["lineRasterizationMode"].is_uint64()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_uint64());
            }else if (json["lineRasterizationMode"].is_int64()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_int64());
            }else{
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_double());
            }
            }();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

    PFN_vkCmdSetLineRasterizationModeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_instance_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineRasterizationModeEXT)get_device_proc_addr(parent,"vkCmdSetLineRasterizationModeEXT");
    }  
    
{
call_function(commandBuffer, lineRasterizationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=lineRasterizationMode;}();}();}();


        json["stream_type"]=VKCMDSETLINERASTERIZATIONMODEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetLineStippleEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 stippledLineEnable;
[&](){uint32_t temp_lOgURYj;[&](){
            if (json["stippledLineEnable"].is_uint64()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_uint64());
            }else if (json["stippledLineEnable"].is_int64()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_int64());
            }else{
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_double());
            }
            }();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

    PFN_vkCmdSetLineStippleEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_instance_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetLineStippleEnableEXT)get_device_proc_addr(parent,"vkCmdSetLineStippleEnableEXT");
    }  
    
{
call_function(commandBuffer, stippledLineEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=stippledLineEnable;}();}();


        json["stream_type"]=VKCMDSETLINESTIPPLEENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthClipNegativeOneToOneEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 negativeOneToOne;
[&](){uint32_t temp_KbgfkEI;[&](){
            if (json["negativeOneToOne"].is_uint64()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_uint64());
            }else if (json["negativeOneToOne"].is_int64()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_int64());
            }else{
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_double());
            }
            }();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

    PFN_vkCmdSetDepthClipNegativeOneToOneEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_instance_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthClipNegativeOneToOneEXT)get_device_proc_addr(parent,"vkCmdSetDepthClipNegativeOneToOneEXT");
    }  
    
{
call_function(commandBuffer, negativeOneToOne);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=negativeOneToOne;}();}();


        json["stream_type"]=VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetViewportWScalingEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 viewportWScalingEnable;
[&](){uint32_t temp_FBvKoOa;[&](){
            if (json["viewportWScalingEnable"].is_uint64()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_uint64());
            }else if (json["viewportWScalingEnable"].is_int64()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_int64());
            }else{
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_double());
            }
            }();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

    PFN_vkCmdSetViewportWScalingEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_instance_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportWScalingEnableNV)get_device_proc_addr(parent,"vkCmdSetViewportWScalingEnableNV");
    }  
    
{
call_function(commandBuffer, viewportWScalingEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=viewportWScalingEnable;}();}();


        json["stream_type"]=VKCMDSETVIEWPORTWSCALINGENABLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetViewportSwizzleNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t firstViewport;
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
uint32_t viewportCount;
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();
 VkViewportSwizzleNV* pViewportSwizzles;
[&](){
            if (json["pViewportSwizzles"].get_array().size()==0){
                pViewportSwizzles=NULL;
            return; }pViewportSwizzles=(VkViewportSwizzleNV*)malloc(viewportCount*sizeof(VkViewportSwizzleNV));
        auto& arr_ZPCbbeZ=json["pViewportSwizzles"].get_array();
        for(int dONOTlj=0; dONOTlj < viewportCount; dONOTlj++){
            [&](){
            auto& temp=arr_ZPCbbeZ[dONOTlj].get_object();
            deserialize_struct(temp,pViewportSwizzles[dONOTlj]);
            }();
        }
        }();

    PFN_vkCmdSetViewportSwizzleNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_instance_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetViewportSwizzleNV)get_device_proc_addr(parent,"vkCmdSetViewportSwizzleNV");
    }  
    
{
call_function(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=boost::json::array();
            return; }json["pViewportSwizzles"]=boost::json::array(viewportCount);
        auto& arr_mlTjeMw=json["pViewportSwizzles"].get_array();
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto& temp=arr_mlTjeMw[jvBpVNx].emplace_object();
            return serialize_struct(temp, pViewportSwizzles[jvBpVNx]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVIEWPORTSWIZZLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageToColorEnable;
[&](){uint32_t temp_StrBHxz;[&](){
            if (json["coverageToColorEnable"].is_uint64()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_uint64());
            }else if (json["coverageToColorEnable"].is_int64()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_int64());
            }else{
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_double());
            }
            }();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

    PFN_vkCmdSetCoverageToColorEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageToColorEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorEnableNV");
    }  
    
{
call_function(commandBuffer, coverageToColorEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=coverageToColorEnable;}();}();


        json["stream_type"]=VKCMDSETCOVERAGETOCOLORENABLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageToColorLocationNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageToColorLocation;
[&](){
            if (json["coverageToColorLocation"].is_uint64()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_uint64());
            }else if (json["coverageToColorLocation"].is_int64()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_int64());
            }else{
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_double());
            }
            }();

    PFN_vkCmdSetCoverageToColorLocationNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_instance_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageToColorLocationNV)get_device_proc_addr(parent,"vkCmdSetCoverageToColorLocationNV");
    }  
    
{
call_function(commandBuffer, coverageToColorLocation);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=coverageToColorLocation;}();


        json["stream_type"]=VKCMDSETCOVERAGETOCOLORLOCATIONNV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationModeNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageModulationModeNV coverageModulationMode;
[&](){[&](){int temp_BTSRuJL;[&](){
            if (json["coverageModulationMode"].is_uint64()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_uint64());
            }else if (json["coverageModulationMode"].is_int64()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_int64());
            }else{
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_double());
            }
            }();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

    PFN_vkCmdSetCoverageModulationModeNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationModeNV");
    }  
    
{
call_function(commandBuffer, coverageModulationMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=coverageModulationMode;}();}();}();


        json["stream_type"]=VKCMDSETCOVERAGEMODULATIONMODENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 coverageModulationTableEnable;
[&](){uint32_t temp_lmSvUmH;[&](){
            if (json["coverageModulationTableEnable"].is_uint64()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_uint64());
            }else if (json["coverageModulationTableEnable"].is_int64()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_int64());
            }else{
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_double());
            }
            }();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

    PFN_vkCmdSetCoverageModulationTableEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableEnableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableEnableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=coverageModulationTableEnable;}();}();


        json["stream_type"]=VKCMDSETCOVERAGEMODULATIONTABLEENABLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageModulationTableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t coverageModulationTableCount;
[&](){
            if (json["coverageModulationTableCount"].is_uint64()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_uint64());
            }else if (json["coverageModulationTableCount"].is_int64()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_int64());
            }else{
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_double());
            }
            }();
 float* pCoverageModulationTable;
[&](){
            if (json["pCoverageModulationTable"].get_array().size()==0){
                pCoverageModulationTable=NULL;
            return; }pCoverageModulationTable=(float*)malloc(coverageModulationTableCount*sizeof(float));
        auto& arr_PUYynJq=json["pCoverageModulationTable"].get_array();
        for(int uNkPtIy=0; uNkPtIy < coverageModulationTableCount; uNkPtIy++){
            [&](){
            if (arr_PUYynJq[uNkPtIy].is_uint64()){
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].get_uint64());
            }else if (arr_PUYynJq[uNkPtIy].is_int64()){
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].get_int64());
            }else{
                pCoverageModulationTable[uNkPtIy]=static_cast<float>(arr_PUYynJq[uNkPtIy].get_double());
            }
            }();
        }
        }();

    PFN_vkCmdSetCoverageModulationTableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_instance_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageModulationTableNV)get_device_proc_addr(parent,"vkCmdSetCoverageModulationTableNV");
    }  
    
{
call_function(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=coverageModulationTableCount;}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=boost::json::array();
            return; }json["pCoverageModulationTable"]=boost::json::array(coverageModulationTableCount);
        auto& arr_FKEHfYD=json["pCoverageModulationTable"].get_array();
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=pCoverageModulationTable[pMqhQqL];}();
        }
        }();


        json["stream_type"]=VKCMDSETCOVERAGEMODULATIONTABLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetShadingRateImageEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 shadingRateImageEnable;
[&](){uint32_t temp_BQfvSQF;[&](){
            if (json["shadingRateImageEnable"].is_uint64()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_uint64());
            }else if (json["shadingRateImageEnable"].is_int64()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_int64());
            }else{
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_double());
            }
            }();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

    PFN_vkCmdSetShadingRateImageEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_instance_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetShadingRateImageEnableNV)get_device_proc_addr(parent,"vkCmdSetShadingRateImageEnableNV");
    }  
    
{
call_function(commandBuffer, shadingRateImageEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=shadingRateImageEnable;}();}();


        json["stream_type"]=VKCMDSETSHADINGRATEIMAGEENABLENV;
        writeToConn(json);
    }

    void handle_vkCmdSetCoverageReductionModeNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkCoverageReductionModeNV coverageReductionMode;
[&](){[&](){int temp_MbjGgOv;[&](){
            if (json["coverageReductionMode"].is_uint64()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_uint64());
            }else if (json["coverageReductionMode"].is_int64()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_int64());
            }else{
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_double());
            }
            }();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

    PFN_vkCmdSetCoverageReductionModeNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_instance_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetCoverageReductionModeNV)get_device_proc_addr(parent,"vkCmdSetCoverageReductionModeNV");
    }  
    
{
call_function(commandBuffer, coverageReductionMode);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=coverageReductionMode;}();}();}();


        json["stream_type"]=VKCMDSETCOVERAGEREDUCTIONMODENV;
        writeToConn(json);
    }

    void handle_vkCmdSetRepresentativeFragmentTestEnableNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkBool32 representativeFragmentTestEnable;
[&](){uint32_t temp_VmtUEuY;[&](){
            if (json["representativeFragmentTestEnable"].is_uint64()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_uint64());
            }else if (json["representativeFragmentTestEnable"].is_int64()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_int64());
            }else{
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_double());
            }
            }();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

    PFN_vkCmdSetRepresentativeFragmentTestEnableNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_instance_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetRepresentativeFragmentTestEnableNV)get_device_proc_addr(parent,"vkCmdSetRepresentativeFragmentTestEnableNV");
    }  
    
{
call_function(commandBuffer, representativeFragmentTestEnable);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=representativeFragmentTestEnable;}();}();


        json["stream_type"]=VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV;
        writeToConn(json);
    }

    void handle_vkCreatePrivateDataSlot(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPrivateDataSlotCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkPrivateDataSlotCreateInfo*)malloc(1*sizeof(VkPrivateDataSlotCreateInfo));
        auto& arr_NidbGih=json["pCreateInfo"].get_array();
        for(int ZNynneh=0; ZNynneh < 1; ZNynneh++){
            [&](){
            auto& temp=arr_NidbGih[ZNynneh].get_object();
            deserialize_struct(temp,pCreateInfo[ZNynneh]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkPrivateDataSlot* pPrivateDataSlot;
[&](){
            if (json["pPrivateDataSlot"].get_array().size()==0){
                pPrivateDataSlot=NULL;
            return; }pPrivateDataSlot=(VkPrivateDataSlot*)malloc(1*sizeof(VkPrivateDataSlot));
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].get_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();

    PFN_vkCreatePrivateDataSlot call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreatePrivateDataSlot)get_instance_proc_addr(parent,"vkCreatePrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreatePrivateDataSlot)get_device_proc_addr(parent,"vkCreatePrivateDataSlot");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_OhzuPlW=json["pCreateInfo"].get_array();
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto& temp=arr_OhzuPlW[KUjUcQv].emplace_object();
            return serialize_struct(temp, pCreateInfo[KUjUcQv]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=boost::json::array();
            return; }json["pPrivateDataSlot"]=boost::json::array(1);
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].get_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        }();


        json["stream_type"]=VKCREATEPRIVATEDATASLOT;
        writeToConn(json);
    }

    void handle_vkDestroyPrivateDataSlot(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyPrivateDataSlot call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyPrivateDataSlot)get_instance_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyPrivateDataSlot)get_device_proc_addr(parent,"vkDestroyPrivateDataSlot");
    }  
    
{
call_function(device, privateDataSlot, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYPRIVATEDATASLOT;
        writeToConn(json);
    }

    void handle_vkSetPrivateData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){
            if (json["objectHandle"].is_uint64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_uint64());
            }else if (json["objectHandle"].is_int64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_int64());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_double());
            }
            }();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t data;
[&](){
            if (json["data"].is_uint64()){
                data=static_cast<uint64_t>(json["data"].get_uint64());
            }else if (json["data"].is_int64()){
                data=static_cast<uint64_t>(json["data"].get_int64());
            }else{
                data=static_cast<uint64_t>(json["data"].get_double());
            }
            }();

    PFN_vkSetPrivateData call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetPrivateData)get_instance_proc_addr(parent,"vkSetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetPrivateData)get_device_proc_addr(parent,"vkSetPrivateData");
    }  
    
VkResult  result;
{
result=call_function(device, objectType, objectHandle, privateDataSlot, data);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=data;}();


        json["stream_type"]=VKSETPRIVATEDATA;
        writeToConn(json);
    }

    void handle_vkGetPrivateData(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkObjectType objectType;
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
uint64_t objectHandle;
[&](){
            if (json["objectHandle"].is_uint64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_uint64());
            }else if (json["objectHandle"].is_int64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_int64());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_double());
            }
            }();
VkPrivateDataSlot privateDataSlot;
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
uint64_t* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }pData=(uint64_t*)malloc(1*sizeof(uint64_t));
        auto& arr_niIcbqy=json["pData"].get_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){
            if (arr_niIcbqy[rXHtNoy].is_uint64()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_uint64());
            }else if (arr_niIcbqy[rXHtNoy].is_int64()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_int64());
            }else{
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_double());
            }
            }();
        }
        }();

    PFN_vkGetPrivateData call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPrivateData)get_instance_proc_addr(parent,"vkGetPrivateData");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPrivateData)get_device_proc_addr(parent,"vkGetPrivateData");
    }  
    
{
call_function(device, objectType, objectHandle, privateDataSlot, pData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(1);
        auto& arr_niIcbqy=json["pData"].get_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=pData[rXHtNoy];}();
        }
        }();


        json["stream_type"]=VKGETPRIVATEDATA;
        writeToConn(json);
    }

    void handle_vkCmdCopyBuffer2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyBufferInfo2* pCopyBufferInfo;
[&](){
            if (json["pCopyBufferInfo"].get_array().size()==0){
                pCopyBufferInfo=NULL;
            return; }pCopyBufferInfo=(VkCopyBufferInfo2*)malloc(1*sizeof(VkCopyBufferInfo2));
        auto& arr_zibazFk=json["pCopyBufferInfo"].get_array();
        for(int BLWMzyy=0; BLWMzyy < 1; BLWMzyy++){
            [&](){
            auto& temp=arr_zibazFk[BLWMzyy].get_object();
            deserialize_struct(temp,pCopyBufferInfo[BLWMzyy]);
            }();
        }
        }();

    PFN_vkCmdCopyBuffer2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBuffer2)get_instance_proc_addr(parent,"vkCmdCopyBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBuffer2)get_device_proc_addr(parent,"vkCmdCopyBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=boost::json::array();
            return; }json["pCopyBufferInfo"]=boost::json::array(1);
        auto& arr_RrXlJAO=json["pCopyBufferInfo"].get_array();
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto& temp=arr_RrXlJAO[tCibIjb].emplace_object();
            return serialize_struct(temp, pCopyBufferInfo[tCibIjb]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYBUFFER2;
        writeToConn(json);
    }

    void handle_vkCmdCopyImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyImageInfo2* pCopyImageInfo;
[&](){
            if (json["pCopyImageInfo"].get_array().size()==0){
                pCopyImageInfo=NULL;
            return; }pCopyImageInfo=(VkCopyImageInfo2*)malloc(1*sizeof(VkCopyImageInfo2));
        auto& arr_QunWVoT=json["pCopyImageInfo"].get_array();
        for(int aRJdnXE=0; aRJdnXE < 1; aRJdnXE++){
            [&](){
            auto& temp=arr_QunWVoT[aRJdnXE].get_object();
            deserialize_struct(temp,pCopyImageInfo[aRJdnXE]);
            }();
        }
        }();

    PFN_vkCmdCopyImage2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImage2)get_instance_proc_addr(parent,"vkCmdCopyImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImage2)get_device_proc_addr(parent,"vkCmdCopyImage2");
    }  
    
{
call_function(commandBuffer, pCopyImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=boost::json::array();
            return; }json["pCopyImageInfo"]=boost::json::array(1);
        auto& arr_fhmwDMM=json["pCopyImageInfo"].get_array();
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto& temp=arr_fhmwDMM[vtScDqF].emplace_object();
            return serialize_struct(temp, pCopyImageInfo[vtScDqF]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYIMAGE2;
        writeToConn(json);
    }

    void handle_vkCmdBlitImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkBlitImageInfo2* pBlitImageInfo;
[&](){
            if (json["pBlitImageInfo"].get_array().size()==0){
                pBlitImageInfo=NULL;
            return; }pBlitImageInfo=(VkBlitImageInfo2*)malloc(1*sizeof(VkBlitImageInfo2));
        auto& arr_WcZAFFY=json["pBlitImageInfo"].get_array();
        for(int ippZCip=0; ippZCip < 1; ippZCip++){
            [&](){
            auto& temp=arr_WcZAFFY[ippZCip].get_object();
            deserialize_struct(temp,pBlitImageInfo[ippZCip]);
            }();
        }
        }();

    PFN_vkCmdBlitImage2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBlitImage2)get_instance_proc_addr(parent,"vkCmdBlitImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBlitImage2)get_device_proc_addr(parent,"vkCmdBlitImage2");
    }  
    
{
call_function(commandBuffer, pBlitImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=boost::json::array();
            return; }json["pBlitImageInfo"]=boost::json::array(1);
        auto& arr_uMZBSOh=json["pBlitImageInfo"].get_array();
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto& temp=arr_uMZBSOh[mMDYqpe].emplace_object();
            return serialize_struct(temp, pBlitImageInfo[mMDYqpe]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBLITIMAGE2;
        writeToConn(json);
    }

    void handle_vkCmdCopyBufferToImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyBufferToImageInfo2* pCopyBufferToImageInfo;
[&](){
            if (json["pCopyBufferToImageInfo"].get_array().size()==0){
                pCopyBufferToImageInfo=NULL;
            return; }pCopyBufferToImageInfo=(VkCopyBufferToImageInfo2*)malloc(1*sizeof(VkCopyBufferToImageInfo2));
        auto& arr_HtvMvbo=json["pCopyBufferToImageInfo"].get_array();
        for(int tWBWvbF=0; tWBWvbF < 1; tWBWvbF++){
            [&](){
            auto& temp=arr_HtvMvbo[tWBWvbF].get_object();
            deserialize_struct(temp,pCopyBufferToImageInfo[tWBWvbF]);
            }();
        }
        }();

    PFN_vkCmdCopyBufferToImage2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyBufferToImage2)get_instance_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyBufferToImage2)get_device_proc_addr(parent,"vkCmdCopyBufferToImage2");
    }  
    
{
call_function(commandBuffer, pCopyBufferToImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=boost::json::array();
            return; }json["pCopyBufferToImageInfo"]=boost::json::array(1);
        auto& arr_GgxIzVF=json["pCopyBufferToImageInfo"].get_array();
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto& temp=arr_GgxIzVF[kZlUXOa].emplace_object();
            return serialize_struct(temp, pCopyBufferToImageInfo[kZlUXOa]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYBUFFERTOIMAGE2;
        writeToConn(json);
    }

    void handle_vkCmdCopyImageToBuffer2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyImageToBufferInfo2* pCopyImageToBufferInfo;
[&](){
            if (json["pCopyImageToBufferInfo"].get_array().size()==0){
                pCopyImageToBufferInfo=NULL;
            return; }pCopyImageToBufferInfo=(VkCopyImageToBufferInfo2*)malloc(1*sizeof(VkCopyImageToBufferInfo2));
        auto& arr_NyCJVfx=json["pCopyImageToBufferInfo"].get_array();
        for(int NLyWULP=0; NLyWULP < 1; NLyWULP++){
            [&](){
            auto& temp=arr_NyCJVfx[NLyWULP].get_object();
            deserialize_struct(temp,pCopyImageToBufferInfo[NLyWULP]);
            }();
        }
        }();

    PFN_vkCmdCopyImageToBuffer2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_instance_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyImageToBuffer2)get_device_proc_addr(parent,"vkCmdCopyImageToBuffer2");
    }  
    
{
call_function(commandBuffer, pCopyImageToBufferInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=boost::json::array();
            return; }json["pCopyImageToBufferInfo"]=boost::json::array(1);
        auto& arr_dKwPEQq=json["pCopyImageToBufferInfo"].get_array();
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto& temp=arr_dKwPEQq[SXwhnUi].emplace_object();
            return serialize_struct(temp, pCopyImageToBufferInfo[SXwhnUi]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYIMAGETOBUFFER2;
        writeToConn(json);
    }

    void handle_vkCmdResolveImage2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkResolveImageInfo2* pResolveImageInfo;
[&](){
            if (json["pResolveImageInfo"].get_array().size()==0){
                pResolveImageInfo=NULL;
            return; }pResolveImageInfo=(VkResolveImageInfo2*)malloc(1*sizeof(VkResolveImageInfo2));
        auto& arr_IZrxKgk=json["pResolveImageInfo"].get_array();
        for(int LpoaGzd=0; LpoaGzd < 1; LpoaGzd++){
            [&](){
            auto& temp=arr_IZrxKgk[LpoaGzd].get_object();
            deserialize_struct(temp,pResolveImageInfo[LpoaGzd]);
            }();
        }
        }();

    PFN_vkCmdResolveImage2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResolveImage2)get_instance_proc_addr(parent,"vkCmdResolveImage2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResolveImage2)get_device_proc_addr(parent,"vkCmdResolveImage2");
    }  
    
{
call_function(commandBuffer, pResolveImageInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=boost::json::array();
            return; }json["pResolveImageInfo"]=boost::json::array(1);
        auto& arr_WXEMxut=json["pResolveImageInfo"].get_array();
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto& temp=arr_WXEMxut[oSccZaz].emplace_object();
            return serialize_struct(temp, pResolveImageInfo[oSccZaz]);
            }();
        }
        }();


        json["stream_type"]=VKCMDRESOLVEIMAGE2;
        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkExtent2D* pFragmentSize;
[&](){
            if (json["pFragmentSize"].get_array().size()==0){
                pFragmentSize=NULL;
            return; }pFragmentSize=(VkExtent2D*)malloc(1*sizeof(VkExtent2D));
        auto& arr_eIGxtNV=json["pFragmentSize"].get_array();
        for(int eByenzl=0; eByenzl < 1; eByenzl++){
            [&](){
            auto& temp=arr_eIGxtNV[eByenzl].get_object();
            deserialize_struct(temp,pFragmentSize[eByenzl]);
            }();
        }
        }();
 VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){
        auto& arr_ogoToWI=json["combinerOps"].get_array();
        for(int uWKWXJp=0; uWKWXJp < 2; uWKWXJp++){
            [&](){[&](){int temp_rKrWEKx;[&](){
            if (arr_ogoToWI[uWKWXJp].is_uint64()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_uint64());
            }else if (arr_ogoToWI[uWKWXJp].is_int64()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_int64());
            }else{
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_double());
            }
            }();combinerOps[uWKWXJp]=(VkFragmentShadingRateCombinerOpKHR)temp_rKrWEKx;}();}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateKHR)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateKHR");
    }  
    
{
call_function(commandBuffer, pFragmentSize, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=boost::json::array();
            return; }json["pFragmentSize"]=boost::json::array(1);
        auto& arr_RBQYqfx=json["pFragmentSize"].get_array();
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto& temp=arr_RBQYqfx[rHAqvQQ].emplace_object();
            return serialize_struct(temp, pFragmentSize[rHAqvQQ]);
            }();
        }
        }();
[&](){json["combinerOps"]=boost::json::array(2);
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();


        json["stream_type"]=VKCMDSETFRAGMENTSHADINGRATEKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceFragmentShadingRatesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pFragmentShadingRateCount;
[&](){
            if (json["pFragmentShadingRateCount"].get_array().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }pFragmentShadingRateCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].get_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){
            if (arr_CjAZByp[vQwTqIV].is_uint64()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_uint64());
            }else if (arr_CjAZByp[vQwTqIV].is_int64()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_int64());
            }else{
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_double());
            }
            }();
        }
        }();
VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates;
[&](){
            if (json["pFragmentShadingRates"].get_array().size()==0){
                pFragmentShadingRates=NULL;
            return; }pFragmentShadingRates=(VkPhysicalDeviceFragmentShadingRateKHR*)malloc(*pFragmentShadingRateCount*sizeof(VkPhysicalDeviceFragmentShadingRateKHR));
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].get_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].get_object();
            deserialize_struct(temp,pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceFragmentShadingRatesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=boost::json::array();
            return; }json["pFragmentShadingRateCount"]=boost::json::array(1);
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].get_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=pFragmentShadingRateCount[vQwTqIV];}();
        }
        }();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=boost::json::array();
            return; }json["pFragmentShadingRates"]=boost::json::array(*pFragmentShadingRateCount);
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].get_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].emplace_object();
            return serialize_struct(temp, pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR;
        writeToConn(json);
    }

    void handle_vkCmdSetFragmentShadingRateEnumNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkFragmentShadingRateNV shadingRate;
[&](){[&](){int temp_CqLMxeN;[&](){
            if (json["shadingRate"].is_uint64()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_uint64());
            }else if (json["shadingRate"].is_int64()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_int64());
            }else{
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_double());
            }
            }();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
 VkFragmentShadingRateCombinerOpKHR combinerOps[2];
[&](){
        auto& arr_ogoToWI=json["combinerOps"].get_array();
        for(int uWKWXJp=0; uWKWXJp < 2; uWKWXJp++){
            [&](){[&](){int temp_rKrWEKx;[&](){
            if (arr_ogoToWI[uWKWXJp].is_uint64()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_uint64());
            }else if (arr_ogoToWI[uWKWXJp].is_int64()){
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_int64());
            }else{
                temp_rKrWEKx=static_cast<int>(arr_ogoToWI[uWKWXJp].get_double());
            }
            }();combinerOps[uWKWXJp]=(VkFragmentShadingRateCombinerOpKHR)temp_rKrWEKx;}();}();
        }
        }();

    PFN_vkCmdSetFragmentShadingRateEnumNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_instance_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetFragmentShadingRateEnumNV)get_device_proc_addr(parent,"vkCmdSetFragmentShadingRateEnumNV");
    }  
    
{
call_function(commandBuffer, shadingRate, combinerOps);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=shadingRate;}();}();}();
[&](){json["combinerOps"]=boost::json::array(2);
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();


        json["stream_type"]=VKCMDSETFRAGMENTSHADINGRATEENUMNV;
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureBuildSizesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_uint64());
            }else if (json["buildType"].is_int64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_int64());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].get_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
 VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo;
[&](){
            if (json["pBuildInfo"].get_array().size()==0){
                pBuildInfo=NULL;
            return; }pBuildInfo=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto& arr_plZlnwA=json["pBuildInfo"].get_array();
        for(int PtWSBOy=0; PtWSBOy < 1; PtWSBOy++){
            [&](){
            auto& temp=arr_plZlnwA[PtWSBOy].get_object();
            deserialize_struct(temp,pBuildInfo[PtWSBOy]);
            }();
        }
        }();
 uint32_t* pMaxPrimitiveCounts;
[&](){
            if (json["pMaxPrimitiveCounts"].get_array().size()==0){
                pMaxPrimitiveCounts=NULL;
            return; }pMaxPrimitiveCounts=(uint32_t*)malloc(pBuildInfo->geometryCount*sizeof(uint32_t));
        auto& arr_crHuORX=json["pMaxPrimitiveCounts"].get_array();
        for(int JfSxsJb=0; JfSxsJb < pBuildInfo->geometryCount; JfSxsJb++){
            [&](){
            if (arr_crHuORX[JfSxsJb].is_uint64()){
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].get_uint64());
            }else if (arr_crHuORX[JfSxsJb].is_int64()){
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].get_int64());
            }else{
                pMaxPrimitiveCounts[JfSxsJb]=static_cast<uint32_t>(arr_crHuORX[JfSxsJb].get_double());
            }
            }();
        }
        }();
VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo;
[&](){
            if (json["pSizeInfo"].get_array().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkAccelerationStructureBuildSizesInfoKHR*)malloc(1*sizeof(VkAccelerationStructureBuildSizesInfoKHR));
        auto& arr_aJATMZS=json["pSizeInfo"].get_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].get_object();
            deserialize_struct(temp,pSizeInfo[pwtSWhd]);
            }();
        }
        }();

    PFN_vkGetAccelerationStructureBuildSizesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_instance_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureBuildSizesKHR)get_device_proc_addr(parent,"vkGetAccelerationStructureBuildSizesKHR");
    }  
    
{
call_function(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }json["pBuildInfo"]=boost::json::array(1);
        auto& arr_rNWxDog=json["pBuildInfo"].get_array();
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto& temp=arr_rNWxDog[DpqeGQs].emplace_object();
            return serialize_struct(temp, pBuildInfo[DpqeGQs]);
            }();
        }
        }();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=boost::json::array();
            return; }json["pMaxPrimitiveCounts"]=boost::json::array(pBuildInfo->geometryCount);
        auto& arr_vNFCnZs=json["pMaxPrimitiveCounts"].get_array();
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=pMaxPrimitiveCounts[KHWuVmo];}();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }json["pSizeInfo"]=boost::json::array(1);
        auto& arr_aJATMZS=json["pSizeInfo"].get_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].emplace_object();
            return serialize_struct(temp, pSizeInfo[pwtSWhd]);
            }();
        }
        }();


        json["stream_type"]=VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR;
        writeToConn(json);
    }

    void handle_vkCmdSetVertexInputEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t vertexBindingDescriptionCount;
[&](){
            if (json["vertexBindingDescriptionCount"].is_uint64()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_uint64());
            }else if (json["vertexBindingDescriptionCount"].is_int64()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_int64());
            }else{
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_double());
            }
            }();
 VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions;
[&](){
            if (json["pVertexBindingDescriptions"].get_array().size()==0){
                pVertexBindingDescriptions=NULL;
            return; }pVertexBindingDescriptions=(VkVertexInputBindingDescription2EXT*)malloc(vertexBindingDescriptionCount*sizeof(VkVertexInputBindingDescription2EXT));
        auto& arr_ZGQrPce=json["pVertexBindingDescriptions"].get_array();
        for(int RbuAKHw=0; RbuAKHw < vertexBindingDescriptionCount; RbuAKHw++){
            [&](){
            auto& temp=arr_ZGQrPce[RbuAKHw].get_object();
            deserialize_struct(temp,pVertexBindingDescriptions[RbuAKHw]);
            }();
        }
        }();
uint32_t vertexAttributeDescriptionCount;
[&](){
            if (json["vertexAttributeDescriptionCount"].is_uint64()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_uint64());
            }else if (json["vertexAttributeDescriptionCount"].is_int64()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_int64());
            }else{
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_double());
            }
            }();
 VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions;
[&](){
            if (json["pVertexAttributeDescriptions"].get_array().size()==0){
                pVertexAttributeDescriptions=NULL;
            return; }pVertexAttributeDescriptions=(VkVertexInputAttributeDescription2EXT*)malloc(vertexAttributeDescriptionCount*sizeof(VkVertexInputAttributeDescription2EXT));
        auto& arr_CiNLRoW=json["pVertexAttributeDescriptions"].get_array();
        for(int OKcAyyi=0; OKcAyyi < vertexAttributeDescriptionCount; OKcAyyi++){
            [&](){
            auto& temp=arr_CiNLRoW[OKcAyyi].get_object();
            deserialize_struct(temp,pVertexAttributeDescriptions[OKcAyyi]);
            }();
        }
        }();

    PFN_vkCmdSetVertexInputEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetVertexInputEXT)get_instance_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetVertexInputEXT)get_device_proc_addr(parent,"vkCmdSetVertexInputEXT");
    }  
    
{
call_function(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=vertexBindingDescriptionCount;}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=boost::json::array();
            return; }json["pVertexBindingDescriptions"]=boost::json::array(vertexBindingDescriptionCount);
        auto& arr_CLcpEBv=json["pVertexBindingDescriptions"].get_array();
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto& temp=arr_CLcpEBv[BlSYyCp].emplace_object();
            return serialize_struct(temp, pVertexBindingDescriptions[BlSYyCp]);
            }();
        }
        }();
[&](){json["vertexAttributeDescriptionCount"]=vertexAttributeDescriptionCount;}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=boost::json::array();
            return; }json["pVertexAttributeDescriptions"]=boost::json::array(vertexAttributeDescriptionCount);
        auto& arr_nigNRkL=json["pVertexAttributeDescriptions"].get_array();
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto& temp=arr_nigNRkL[UWEyBUU].emplace_object();
            return serialize_struct(temp, pVertexAttributeDescriptions[UWEyBUU]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETVERTEXINPUTEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetColorWriteEnableEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t attachmentCount;
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();
 VkBool32* pColorWriteEnables;
[&](){
            if (json["pColorWriteEnables"].get_array().size()==0){
                pColorWriteEnables=NULL;
            return; }pColorWriteEnables=(VkBool32*)malloc(attachmentCount*sizeof(VkBool32));
        auto& arr_KEXhgIr=json["pColorWriteEnables"].get_array();
        for(int vEjtLXo=0; vEjtLXo < attachmentCount; vEjtLXo++){
            [&](){uint32_t temp_KEXhgIr;[&](){
            if (arr_KEXhgIr[vEjtLXo].is_uint64()){
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].get_uint64());
            }else if (arr_KEXhgIr[vEjtLXo].is_int64()){
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].get_int64());
            }else{
                temp_KEXhgIr=static_cast<uint32_t>(arr_KEXhgIr[vEjtLXo].get_double());
            }
            }();pColorWriteEnables[vEjtLXo]=(VkBool32)temp_KEXhgIr;}();
        }
        }();

    PFN_vkCmdSetColorWriteEnableEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_instance_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetColorWriteEnableEXT)get_device_proc_addr(parent,"vkCmdSetColorWriteEnableEXT");
    }  
    
{
call_function(commandBuffer, attachmentCount, pColorWriteEnables);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=boost::json::array();
            return; }json["pColorWriteEnables"]=boost::json::array(attachmentCount);
        auto& arr_jmtmyTP=json["pColorWriteEnables"].get_array();
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=pColorWriteEnables[yHXwpvy];}();}();
        }
        }();


        json["stream_type"]=VKCMDSETCOLORWRITEENABLEEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetEvent2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
 VkDependencyInfo* pDependencyInfo;
[&](){
            if (json["pDependencyInfo"].get_array().size()==0){
                pDependencyInfo=NULL;
            return; }pDependencyInfo=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));
        auto& arr_rdDuAVo=json["pDependencyInfo"].get_array();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            auto& temp=arr_rdDuAVo[WSueWEw].get_object();
            deserialize_struct(temp,pDependencyInfo[WSueWEw]);
            }();
        }
        }();

    PFN_vkCmdSetEvent2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetEvent2)get_instance_proc_addr(parent,"vkCmdSetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetEvent2)get_device_proc_addr(parent,"vkCmdSetEvent2");
    }  
    
{
call_function(commandBuffer, event, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }json["pDependencyInfo"]=boost::json::array(1);
        auto& arr_RUiZhht=json["pDependencyInfo"].get_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETEVENT2;
        writeToConn(json);
    }

    void handle_vkCmdResetEvent2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkEvent event;
[&](){deserialize_VkEvent(json["event"], event);}();
VkPipelineStageFlags2 stageMask;
[&](){[&](){int temp_bRKcCBq;[&](){
            if (json["stageMask"].is_uint64()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

    PFN_vkCmdResetEvent2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdResetEvent2)get_instance_proc_addr(parent,"vkCmdResetEvent2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdResetEvent2)get_device_proc_addr(parent,"vkCmdResetEvent2");
    }  
    
{
call_function(commandBuffer, event, stageMask);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();


        json["stream_type"]=VKCMDRESETEVENT2;
        writeToConn(json);
    }

    void handle_vkCmdWaitEvents2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t eventCount;
[&](){
            if (json["eventCount"].is_uint64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_uint64());
            }else if (json["eventCount"].is_int64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_int64());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].get_double());
            }
            }();
 VkEvent* pEvents;
[&](){
            if (json["pEvents"].get_array().size()==0){
                pEvents=NULL;
            return; }pEvents=(VkEvent*)malloc(eventCount*sizeof(VkEvent));
        auto& arr_QYtHNne=json["pEvents"].get_array();
        for(int RuhNVwi=0; RuhNVwi < eventCount; RuhNVwi++){
            [&](){deserialize_VkEvent(arr_QYtHNne[RuhNVwi], pEvents[RuhNVwi]);}();
        }
        }();
 VkDependencyInfo* pDependencyInfos;
[&](){
            if (json["pDependencyInfos"].get_array().size()==0){
                pDependencyInfos=NULL;
            return; }pDependencyInfos=(VkDependencyInfo*)malloc(eventCount*sizeof(VkDependencyInfo));
        auto& arr_ldOSlic=json["pDependencyInfos"].get_array();
        for(int aTqXMab=0; aTqXMab < eventCount; aTqXMab++){
            [&](){
            auto& temp=arr_ldOSlic[aTqXMab].get_object();
            deserialize_struct(temp,pDependencyInfos[aTqXMab]);
            }();
        }
        }();

    PFN_vkCmdWaitEvents2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWaitEvents2)get_instance_proc_addr(parent,"vkCmdWaitEvents2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWaitEvents2)get_device_proc_addr(parent,"vkCmdWaitEvents2");
    }  
    
{
call_function(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }json["pEvents"]=boost::json::array(eventCount);
        auto& arr_tUuyOPJ=json["pEvents"].get_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=boost::json::array();
            return; }json["pDependencyInfos"]=boost::json::array(eventCount);
        auto& arr_ZVkfhDe=json["pDependencyInfos"].get_array();
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto& temp=arr_ZVkfhDe[jvYalYw].emplace_object();
            return serialize_struct(temp, pDependencyInfos[jvYalYw]);
            }();
        }
        }();


        json["stream_type"]=VKCMDWAITEVENTS2;
        writeToConn(json);
    }

    void handle_vkCmdPipelineBarrier2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDependencyInfo* pDependencyInfo;
[&](){
            if (json["pDependencyInfo"].get_array().size()==0){
                pDependencyInfo=NULL;
            return; }pDependencyInfo=(VkDependencyInfo*)malloc(1*sizeof(VkDependencyInfo));
        auto& arr_rdDuAVo=json["pDependencyInfo"].get_array();
        for(int WSueWEw=0; WSueWEw < 1; WSueWEw++){
            [&](){
            auto& temp=arr_rdDuAVo[WSueWEw].get_object();
            deserialize_struct(temp,pDependencyInfo[WSueWEw]);
            }();
        }
        }();

    PFN_vkCmdPipelineBarrier2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdPipelineBarrier2)get_instance_proc_addr(parent,"vkCmdPipelineBarrier2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdPipelineBarrier2)get_device_proc_addr(parent,"vkCmdPipelineBarrier2");
    }  
    
{
call_function(commandBuffer, pDependencyInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }json["pDependencyInfo"]=boost::json::array(1);
        auto& arr_RUiZhht=json["pDependencyInfo"].get_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();


        json["stream_type"]=VKCMDPIPELINEBARRIER2;
        writeToConn(json);
    }

    void handle_vkQueueSubmit2(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t submitCount;
[&](){
            if (json["submitCount"].is_uint64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_uint64());
            }else if (json["submitCount"].is_int64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_int64());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].get_double());
            }
            }();
 VkSubmitInfo2* pSubmits;
[&](){
            if (json["pSubmits"].get_array().size()==0){
                pSubmits=NULL;
            return; }pSubmits=(VkSubmitInfo2*)malloc(submitCount*sizeof(VkSubmitInfo2));
        auto& arr_mzfyWou=json["pSubmits"].get_array();
        for(int ozkbIJW=0; ozkbIJW < submitCount; ozkbIJW++){
            [&](){
            auto& temp=arr_mzfyWou[ozkbIJW].get_object();
            deserialize_struct(temp,pSubmits[ozkbIJW]);
            }();
        }
        }();
VkFence fence;
[&](){deserialize_VkFence(json["fence"], fence);}();

    PFN_vkQueueSubmit2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkQueueSubmit2)get_instance_proc_addr(parent,"vkQueueSubmit2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkQueueSubmit2)get_device_proc_addr(parent,"vkQueueSubmit2");
    }  
    
VkResult  result;
{
result=call_function(queue, submitCount, pSubmits, fence);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }json["pSubmits"]=boost::json::array(submitCount);
        auto& arr_shQKWeV=json["pSubmits"].get_array();
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto& temp=arr_shQKWeV[uwYUklT].emplace_object();
            return serialize_struct(temp, pSubmits[uwYUklT]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();


        json["stream_type"]=VKQUEUESUBMIT2;
        writeToConn(json);
    }

    void handle_vkCmdWriteTimestamp2(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_uint64());
            }else if (json["stage"].is_int64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_int64());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t query;
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

    PFN_vkCmdWriteTimestamp2 call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteTimestamp2)get_instance_proc_addr(parent,"vkCmdWriteTimestamp2");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteTimestamp2)get_device_proc_addr(parent,"vkCmdWriteTimestamp2");
    }  
    
{
call_function(commandBuffer, stage, queryPool, query);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();


        json["stream_type"]=VKCMDWRITETIMESTAMP2;
        writeToConn(json);
    }

    void handle_vkCmdWriteBufferMarker2AMD(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineStageFlags2 stage;
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_uint64());
            }else if (json["stage"].is_int64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_int64());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
VkBuffer dstBuffer;
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
VkDeviceSize dstOffset;
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
uint32_t marker;
[&](){
            if (json["marker"].is_uint64()){
                marker=static_cast<uint32_t>(json["marker"].get_uint64());
            }else if (json["marker"].is_int64()){
                marker=static_cast<uint32_t>(json["marker"].get_int64());
            }else{
                marker=static_cast<uint32_t>(json["marker"].get_double());
            }
            }();

    PFN_vkCmdWriteBufferMarker2AMD call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_instance_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteBufferMarker2AMD)get_device_proc_addr(parent,"vkCmdWriteBufferMarker2AMD");
    }  
    
{
call_function(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();


        json["stream_type"]=VKCMDWRITEBUFFERMARKER2AMD;
        writeToConn(json);
    }

    void handle_vkGetQueueCheckpointData2NV(boost::json::object& json){
    //Will only be called by the server
    
VkQueue queue;
[&](){deserialize_VkQueue(json["queue"], queue);}();
uint32_t* pCheckpointDataCount;
[&](){
            if (json["pCheckpointDataCount"].get_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }pCheckpointDataCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_uint64());
            }else if (arr_LsYqVIK[lgasnOP].is_int64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_int64());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_double());
            }
            }();
        }
        }();
VkCheckpointData2NV* pCheckpointData;
[&](){
            if (json["pCheckpointData"].get_array().size()==0){
                pCheckpointData=NULL;
            return; }pCheckpointData=(VkCheckpointData2NV*)malloc(*pCheckpointDataCount*sizeof(VkCheckpointData2NV));
        auto& arr_jIvYyZg=json["pCheckpointData"].get_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].get_object();
            deserialize_struct(temp,pCheckpointData[yGwfptp]);
            }();
        }
        }();

    PFN_vkGetQueueCheckpointData2NV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_instance_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetQueueCheckpointData2NV)get_device_proc_addr(parent,"vkGetQueueCheckpointData2NV");
    }  
    
{
call_function(queue, pCheckpointDataCount, pCheckpointData);
}
json.clear();

[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }json["pCheckpointDataCount"]=boost::json::array(1);
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }json["pCheckpointData"]=boost::json::array(*pCheckpointDataCount);
        auto& arr_jIvYyZg=json["pCheckpointData"].get_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].emplace_object();
            return serialize_struct(temp, pCheckpointData[yGwfptp]);
            }();
        }
        }();


        json["stream_type"]=VKGETQUEUECHECKPOINTDATA2NV;
        writeToConn(json);
    }

    void handle_vkCopyMemoryToImageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo;
[&](){
            if (json["pCopyMemoryToImageInfo"].get_array().size()==0){
                pCopyMemoryToImageInfo=NULL;
            return; }pCopyMemoryToImageInfo=(VkCopyMemoryToImageInfoEXT*)malloc(1*sizeof(VkCopyMemoryToImageInfoEXT));
        auto& arr_uGpCetH=json["pCopyMemoryToImageInfo"].get_array();
        for(int LeBHPTF=0; LeBHPTF < 1; LeBHPTF++){
            [&](){
            auto& temp=arr_uGpCetH[LeBHPTF].get_object();
            deserialize_struct(temp,pCopyMemoryToImageInfo[LeBHPTF]);
            }();
        }
        }();

    PFN_vkCopyMemoryToImageEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToImageEXT)get_instance_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToImageEXT)get_device_proc_addr(parent,"vkCopyMemoryToImageEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyMemoryToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=boost::json::array();
            return; }json["pCopyMemoryToImageInfo"]=boost::json::array(1);
        auto& arr_VVrQQGW=json["pCopyMemoryToImageInfo"].get_array();
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto& temp=arr_VVrQQGW[pVINPWa].emplace_object();
            return serialize_struct(temp, pCopyMemoryToImageInfo[pVINPWa]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYMEMORYTOIMAGEEXT;
        writeToConn(json);
    }

    void handle_vkCopyImageToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo;
[&](){
            if (json["pCopyImageToMemoryInfo"].get_array().size()==0){
                pCopyImageToMemoryInfo=NULL;
            return; }pCopyImageToMemoryInfo=(VkCopyImageToMemoryInfoEXT*)malloc(1*sizeof(VkCopyImageToMemoryInfoEXT));
        auto& arr_JjXseiq=json["pCopyImageToMemoryInfo"].get_array();
        for(int zMfiotL=0; zMfiotL < 1; zMfiotL++){
            [&](){
            auto& temp=arr_JjXseiq[zMfiotL].get_object();
            deserialize_struct(temp,pCopyImageToMemoryInfo[zMfiotL]);
            }();
        }
        }();

    PFN_vkCopyImageToMemoryEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyImageToMemoryEXT)get_instance_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyImageToMemoryEXT)get_device_proc_addr(parent,"vkCopyImageToMemoryEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyImageToMemoryInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=boost::json::array();
            return; }json["pCopyImageToMemoryInfo"]=boost::json::array(1);
        auto& arr_uAVSOVI=json["pCopyImageToMemoryInfo"].get_array();
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto& temp=arr_uAVSOVI[vveMAPG].emplace_object();
            return serialize_struct(temp, pCopyImageToMemoryInfo[vveMAPG]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYIMAGETOMEMORYEXT;
        writeToConn(json);
    }

    void handle_vkCopyImageToImageEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCopyImageToImageInfoEXT* pCopyImageToImageInfo;
[&](){
            if (json["pCopyImageToImageInfo"].get_array().size()==0){
                pCopyImageToImageInfo=NULL;
            return; }pCopyImageToImageInfo=(VkCopyImageToImageInfoEXT*)malloc(1*sizeof(VkCopyImageToImageInfoEXT));
        auto& arr_WKQiAFF=json["pCopyImageToImageInfo"].get_array();
        for(int kaVefuU=0; kaVefuU < 1; kaVefuU++){
            [&](){
            auto& temp=arr_WKQiAFF[kaVefuU].get_object();
            deserialize_struct(temp,pCopyImageToImageInfo[kaVefuU]);
            }();
        }
        }();

    PFN_vkCopyImageToImageEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyImageToImageEXT)get_instance_proc_addr(parent,"vkCopyImageToImageEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyImageToImageEXT)get_device_proc_addr(parent,"vkCopyImageToImageEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCopyImageToImageInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=boost::json::array();
            return; }json["pCopyImageToImageInfo"]=boost::json::array(1);
        auto& arr_mMvIKFh=json["pCopyImageToImageInfo"].get_array();
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto& temp=arr_mMvIKFh[vOMFrGb].emplace_object();
            return serialize_struct(temp, pCopyImageToImageInfo[vOMFrGb]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYIMAGETOIMAGEEXT;
        writeToConn(json);
    }

    void handle_vkTransitionImageLayoutEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t transitionCount;
[&](){
            if (json["transitionCount"].is_uint64()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_uint64());
            }else if (json["transitionCount"].is_int64()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_int64());
            }else{
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_double());
            }
            }();
 VkHostImageLayoutTransitionInfoEXT* pTransitions;
[&](){
            if (json["pTransitions"].get_array().size()==0){
                pTransitions=NULL;
            return; }pTransitions=(VkHostImageLayoutTransitionInfoEXT*)malloc(transitionCount*sizeof(VkHostImageLayoutTransitionInfoEXT));
        auto& arr_kGKdcAG=json["pTransitions"].get_array();
        for(int mCqQGEL=0; mCqQGEL < transitionCount; mCqQGEL++){
            [&](){
            auto& temp=arr_kGKdcAG[mCqQGEL].get_object();
            deserialize_struct(temp,pTransitions[mCqQGEL]);
            }();
        }
        }();

    PFN_vkTransitionImageLayoutEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkTransitionImageLayoutEXT)get_instance_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkTransitionImageLayoutEXT)get_device_proc_addr(parent,"vkTransitionImageLayoutEXT");
    }  
    
VkResult  result;
{
result=call_function(device, transitionCount, pTransitions);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=transitionCount;}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=boost::json::array();
            return; }json["pTransitions"]=boost::json::array(transitionCount);
        auto& arr_KQaENWu=json["pTransitions"].get_array();
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto& temp=arr_KQaENWu[EeppCgm].emplace_object();
            return serialize_struct(temp, pTransitions[EeppCgm]);
            }();
        }
        }();


        json["stream_type"]=VKTRANSITIONIMAGELAYOUTEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoCapabilitiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkVideoProfileInfoKHR* pVideoProfile;
[&](){
            if (json["pVideoProfile"].get_array().size()==0){
                pVideoProfile=NULL;
            return; }pVideoProfile=(VkVideoProfileInfoKHR*)malloc(1*sizeof(VkVideoProfileInfoKHR));
        auto& arr_LQJyXAW=json["pVideoProfile"].get_array();
        for(int AyTOixj=0; AyTOixj < 1; AyTOixj++){
            [&](){
            auto& temp=arr_LQJyXAW[AyTOixj].get_object();
            deserialize_struct(temp,pVideoProfile[AyTOixj]);
            }();
        }
        }();
VkVideoCapabilitiesKHR* pCapabilities;
[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }pCapabilities=(VkVideoCapabilitiesKHR*)malloc(1*sizeof(VkVideoCapabilitiesKHR));
        auto& arr_rprZzlH=json["pCapabilities"].get_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].get_object();
            deserialize_struct(temp,pCapabilities[NPLkdlm]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoCapabilitiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pVideoProfile, pCapabilities);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=boost::json::array();
            return; }json["pVideoProfile"]=boost::json::array(1);
        auto& arr_eFObkVe=json["pVideoProfile"].get_array();
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto& temp=arr_eFObkVe[YJbJtas].emplace_object();
            return serialize_struct(temp, pVideoProfile[YJbJtas]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_rprZzlH=json["pCapabilities"].get_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].emplace_object();
            return serialize_struct(temp, pCapabilities[NPLkdlm]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceVideoFormatPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo;
[&](){
            if (json["pVideoFormatInfo"].get_array().size()==0){
                pVideoFormatInfo=NULL;
            return; }pVideoFormatInfo=(VkPhysicalDeviceVideoFormatInfoKHR*)malloc(1*sizeof(VkPhysicalDeviceVideoFormatInfoKHR));
        auto& arr_JCeubLO=json["pVideoFormatInfo"].get_array();
        for(int aVxBrFp=0; aVxBrFp < 1; aVxBrFp++){
            [&](){
            auto& temp=arr_JCeubLO[aVxBrFp].get_object();
            deserialize_struct(temp,pVideoFormatInfo[aVxBrFp]);
            }();
        }
        }();
uint32_t* pVideoFormatPropertyCount;
[&](){
            if (json["pVideoFormatPropertyCount"].get_array().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }pVideoFormatPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].get_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){
            if (arr_kJoqfTP[hCeCDXk].is_uint64()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_uint64());
            }else if (arr_kJoqfTP[hCeCDXk].is_int64()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_int64());
            }else{
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_double());
            }
            }();
        }
        }();
VkVideoFormatPropertiesKHR* pVideoFormatProperties;
[&](){
            if (json["pVideoFormatProperties"].get_array().size()==0){
                pVideoFormatProperties=NULL;
            return; }pVideoFormatProperties=(VkVideoFormatPropertiesKHR*)malloc(*pVideoFormatPropertyCount*sizeof(VkVideoFormatPropertiesKHR));
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].get_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].get_object();
            deserialize_struct(temp,pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceVideoFormatPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=boost::json::array();
            return; }json["pVideoFormatInfo"]=boost::json::array(1);
        auto& arr_JJWKnHz=json["pVideoFormatInfo"].get_array();
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto& temp=arr_JJWKnHz[FIocPZR].emplace_object();
            return serialize_struct(temp, pVideoFormatInfo[FIocPZR]);
            }();
        }
        }();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=boost::json::array();
            return; }json["pVideoFormatPropertyCount"]=boost::json::array(1);
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].get_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=pVideoFormatPropertyCount[hCeCDXk];}();
        }
        }();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=boost::json::array();
            return; }json["pVideoFormatProperties"]=boost::json::array(*pVideoFormatPropertyCount);
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].get_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].emplace_object();
            return serialize_struct(temp, pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR;
        writeToConn(json);
    }

    void handle_vkCreateVideoSessionKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkVideoSessionCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkVideoSessionCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionCreateInfoKHR));
        auto& arr_wPbwQCK=json["pCreateInfo"].get_array();
        for(int YSXcLgo=0; YSXcLgo < 1; YSXcLgo++){
            [&](){
            auto& temp=arr_wPbwQCK[YSXcLgo].get_object();
            deserialize_struct(temp,pCreateInfo[YSXcLgo]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkVideoSessionKHR* pVideoSession;
[&](){
            if (json["pVideoSession"].get_array().size()==0){
                pVideoSession=NULL;
            return; }pVideoSession=(VkVideoSessionKHR*)malloc(1*sizeof(VkVideoSessionKHR));
        auto& arr_YUuHYdT=json["pVideoSession"].get_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();

    PFN_vkCreateVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateVideoSessionKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateVideoSessionKHR)get_device_proc_addr(parent,"vkCreateVideoSessionKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pVideoSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_mCuZMrp=json["pCreateInfo"].get_array();
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto& temp=arr_mCuZMrp[tsYbFnY].emplace_object();
            return serialize_struct(temp, pCreateInfo[tsYbFnY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=boost::json::array();
            return; }json["pVideoSession"]=boost::json::array(1);
        auto& arr_YUuHYdT=json["pVideoSession"].get_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        }();


        json["stream_type"]=VKCREATEVIDEOSESSIONKHR;
        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyVideoSessionKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyVideoSessionKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyVideoSessionKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionKHR");
    }  
    
{
call_function(device, videoSession, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYVIDEOSESSIONKHR;
        writeToConn(json);
    }

    void handle_vkCreateVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkVideoSessionParametersCreateInfoKHR* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkVideoSessionParametersCreateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersCreateInfoKHR));
        auto& arr_orBbBzS=json["pCreateInfo"].get_array();
        for(int BFSvJhy=0; BFSvJhy < 1; BFSvJhy++){
            [&](){
            auto& temp=arr_orBbBzS[BFSvJhy].get_object();
            deserialize_struct(temp,pCreateInfo[BFSvJhy]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkVideoSessionParametersKHR* pVideoSessionParameters;
[&](){
            if (json["pVideoSessionParameters"].get_array().size()==0){
                pVideoSessionParameters=NULL;
            return; }pVideoSessionParameters=(VkVideoSessionParametersKHR*)malloc(1*sizeof(VkVideoSessionParametersKHR));
        auto& arr_drxJQhO=json["pVideoSessionParameters"].get_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();

    PFN_vkCreateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkCreateVideoSessionParametersKHR");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_PbbIaMM=json["pCreateInfo"].get_array();
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto& temp=arr_PbbIaMM[uFIOrHK].emplace_object();
            return serialize_struct(temp, pCreateInfo[uFIOrHK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=boost::json::array();
            return; }json["pVideoSessionParameters"]=boost::json::array(1);
        auto& arr_drxJQhO=json["pVideoSessionParameters"].get_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        }();


        json["stream_type"]=VKCREATEVIDEOSESSIONPARAMETERSKHR;
        writeToConn(json);
    }

    void handle_vkUpdateVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
 VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo;
[&](){
            if (json["pUpdateInfo"].get_array().size()==0){
                pUpdateInfo=NULL;
            return; }pUpdateInfo=(VkVideoSessionParametersUpdateInfoKHR*)malloc(1*sizeof(VkVideoSessionParametersUpdateInfoKHR));
        auto& arr_ErkRXpw=json["pUpdateInfo"].get_array();
        for(int wrcSXFx=0; wrcSXFx < 1; wrcSXFx++){
            [&](){
            auto& temp=arr_ErkRXpw[wrcSXFx].get_object();
            deserialize_struct(temp,pUpdateInfo[wrcSXFx]);
            }();
        }
        }();

    PFN_vkUpdateVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUpdateVideoSessionParametersKHR)get_device_proc_addr(parent,"vkUpdateVideoSessionParametersKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSessionParameters, pUpdateInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=boost::json::array();
            return; }json["pUpdateInfo"]=boost::json::array(1);
        auto& arr_miOYaCQ=json["pUpdateInfo"].get_array();
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto& temp=arr_miOYaCQ[gnypMkA].emplace_object();
            return serialize_struct(temp, pUpdateInfo[gnypMkA]);
            }();
        }
        }();


        json["stream_type"]=VKUPDATEVIDEOSESSIONPARAMETERSKHR;
        writeToConn(json);
    }

    void handle_vkDestroyVideoSessionParametersKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionParametersKHR videoSessionParameters;
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyVideoSessionParametersKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_instance_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyVideoSessionParametersKHR)get_device_proc_addr(parent,"vkDestroyVideoSessionParametersKHR");
    }  
    
{
call_function(device, videoSessionParameters, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYVIDEOSESSIONPARAMETERSKHR;
        writeToConn(json);
    }

    void handle_vkGetVideoSessionMemoryRequirementsKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t* pMemoryRequirementsCount;
[&](){
            if (json["pMemoryRequirementsCount"].get_array().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }pMemoryRequirementsCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].get_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){
            if (arr_pJPineF[NMpDmPR].is_uint64()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_uint64());
            }else if (arr_pJPineF[NMpDmPR].is_int64()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_int64());
            }else{
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_double());
            }
            }();
        }
        }();
VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements;
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }pMemoryRequirements=(VkVideoSessionMemoryRequirementsKHR*)malloc(*pMemoryRequirementsCount*sizeof(VkVideoSessionMemoryRequirementsKHR));
        auto& arr_UuJQZUu=json["pMemoryRequirements"].get_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].get_object();
            deserialize_struct(temp,pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();

    PFN_vkGetVideoSessionMemoryRequirementsKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_instance_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetVideoSessionMemoryRequirementsKHR)get_device_proc_addr(parent,"vkGetVideoSessionMemoryRequirementsKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=boost::json::array();
            return; }json["pMemoryRequirementsCount"]=boost::json::array(1);
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].get_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=pMemoryRequirementsCount[NMpDmPR];}();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(*pMemoryRequirementsCount);
        auto& arr_UuJQZUu=json["pMemoryRequirements"].get_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();


        json["stream_type"]=VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR;
        writeToConn(json);
    }

    void handle_vkBindVideoSessionMemoryKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkVideoSessionKHR videoSession;
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
uint32_t bindSessionMemoryInfoCount;
[&](){
            if (json["bindSessionMemoryInfoCount"].is_uint64()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_uint64());
            }else if (json["bindSessionMemoryInfoCount"].is_int64()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_int64());
            }else{
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_double());
            }
            }();
 VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos;
[&](){
            if (json["pBindSessionMemoryInfos"].get_array().size()==0){
                pBindSessionMemoryInfos=NULL;
            return; }pBindSessionMemoryInfos=(VkBindVideoSessionMemoryInfoKHR*)malloc(bindSessionMemoryInfoCount*sizeof(VkBindVideoSessionMemoryInfoKHR));
        auto& arr_TbzDfjI=json["pBindSessionMemoryInfos"].get_array();
        for(int XHgqGRS=0; XHgqGRS < bindSessionMemoryInfoCount; XHgqGRS++){
            [&](){
            auto& temp=arr_TbzDfjI[XHgqGRS].get_object();
            deserialize_struct(temp,pBindSessionMemoryInfos[XHgqGRS]);
            }();
        }
        }();

    PFN_vkBindVideoSessionMemoryKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_instance_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindVideoSessionMemoryKHR)get_device_proc_addr(parent,"vkBindVideoSessionMemoryKHR");
    }  
    
VkResult  result;
{
result=call_function(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=bindSessionMemoryInfoCount;}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=boost::json::array();
            return; }json["pBindSessionMemoryInfos"]=boost::json::array(bindSessionMemoryInfoCount);
        auto& arr_XamFtca=json["pBindSessionMemoryInfos"].get_array();
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto& temp=arr_XamFtca[bWiRCGV].emplace_object();
            return serialize_struct(temp, pBindSessionMemoryInfos[bWiRCGV]);
            }();
        }
        }();


        json["stream_type"]=VKBINDVIDEOSESSIONMEMORYKHR;
        writeToConn(json);
    }

    void handle_vkCmdDecodeVideoKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoDecodeInfoKHR* pDecodeInfo;
[&](){
            if (json["pDecodeInfo"].get_array().size()==0){
                pDecodeInfo=NULL;
            return; }pDecodeInfo=(VkVideoDecodeInfoKHR*)malloc(1*sizeof(VkVideoDecodeInfoKHR));
        auto& arr_ewdOprb=json["pDecodeInfo"].get_array();
        for(int PPOqwvx=0; PPOqwvx < 1; PPOqwvx++){
            [&](){
            auto& temp=arr_ewdOprb[PPOqwvx].get_object();
            deserialize_struct(temp,pDecodeInfo[PPOqwvx]);
            }();
        }
        }();

    PFN_vkCmdDecodeVideoKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecodeVideoKHR)get_instance_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecodeVideoKHR)get_device_proc_addr(parent,"vkCmdDecodeVideoKHR");
    }  
    
{
call_function(commandBuffer, pDecodeInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=boost::json::array();
            return; }json["pDecodeInfo"]=boost::json::array(1);
        auto& arr_FUuNCSo=json["pDecodeInfo"].get_array();
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto& temp=arr_FUuNCSo[jmrOltD].emplace_object();
            return serialize_struct(temp, pDecodeInfo[jmrOltD]);
            }();
        }
        }();


        json["stream_type"]=VKCMDDECODEVIDEOKHR;
        writeToConn(json);
    }

    void handle_vkCmdBeginVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoBeginCodingInfoKHR* pBeginInfo;
[&](){
            if (json["pBeginInfo"].get_array().size()==0){
                pBeginInfo=NULL;
            return; }pBeginInfo=(VkVideoBeginCodingInfoKHR*)malloc(1*sizeof(VkVideoBeginCodingInfoKHR));
        auto& arr_YgojtMV=json["pBeginInfo"].get_array();
        for(int gEGjmEh=0; gEGjmEh < 1; gEGjmEh++){
            [&](){
            auto& temp=arr_YgojtMV[gEGjmEh].get_object();
            deserialize_struct(temp,pBeginInfo[gEGjmEh]);
            }();
        }
        }();

    PFN_vkCmdBeginVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginVideoCodingKHR)get_device_proc_addr(parent,"vkCmdBeginVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pBeginInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }json["pBeginInfo"]=boost::json::array(1);
        auto& arr_pSWbqZw=json["pBeginInfo"].get_array();
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto& temp=arr_pSWbqZw[tVSxYNW].emplace_object();
            return serialize_struct(temp, pBeginInfo[tVSxYNW]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBEGINVIDEOCODINGKHR;
        writeToConn(json);
    }

    void handle_vkCmdControlVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoCodingControlInfoKHR* pCodingControlInfo;
[&](){
            if (json["pCodingControlInfo"].get_array().size()==0){
                pCodingControlInfo=NULL;
            return; }pCodingControlInfo=(VkVideoCodingControlInfoKHR*)malloc(1*sizeof(VkVideoCodingControlInfoKHR));
        auto& arr_QVObPIP=json["pCodingControlInfo"].get_array();
        for(int LMgTacT=0; LMgTacT < 1; LMgTacT++){
            [&](){
            auto& temp=arr_QVObPIP[LMgTacT].get_object();
            deserialize_struct(temp,pCodingControlInfo[LMgTacT]);
            }();
        }
        }();

    PFN_vkCmdControlVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdControlVideoCodingKHR)get_device_proc_addr(parent,"vkCmdControlVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pCodingControlInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=boost::json::array();
            return; }json["pCodingControlInfo"]=boost::json::array(1);
        auto& arr_vJmaWsp=json["pCodingControlInfo"].get_array();
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto& temp=arr_vJmaWsp[MLwaMsn].emplace_object();
            return serialize_struct(temp, pCodingControlInfo[MLwaMsn]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCONTROLVIDEOCODINGKHR;
        writeToConn(json);
    }

    void handle_vkCmdEndVideoCodingKHR(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkVideoEndCodingInfoKHR* pEndCodingInfo;
[&](){
            if (json["pEndCodingInfo"].get_array().size()==0){
                pEndCodingInfo=NULL;
            return; }pEndCodingInfo=(VkVideoEndCodingInfoKHR*)malloc(1*sizeof(VkVideoEndCodingInfoKHR));
        auto& arr_ErbGsyK=json["pEndCodingInfo"].get_array();
        for(int QjqRiFV=0; QjqRiFV < 1; QjqRiFV++){
            [&](){
            auto& temp=arr_ErbGsyK[QjqRiFV].get_object();
            deserialize_struct(temp,pEndCodingInfo[QjqRiFV]);
            }();
        }
        }();

    PFN_vkCmdEndVideoCodingKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_instance_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndVideoCodingKHR)get_device_proc_addr(parent,"vkCmdEndVideoCodingKHR");
    }  
    
{
call_function(commandBuffer, pEndCodingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=boost::json::array();
            return; }json["pEndCodingInfo"]=boost::json::array(1);
        auto& arr_OpexQSo=json["pEndCodingInfo"].get_array();
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto& temp=arr_OpexQSo[KxwYkSG].emplace_object();
            return serialize_struct(temp, pEndCodingInfo[KxwYkSG]);
            }();
        }
        }();


        json["stream_type"]=VKCMDENDVIDEOCODINGKHR;
        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t decompressRegionCount;
[&](){
            if (json["decompressRegionCount"].is_uint64()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_uint64());
            }else if (json["decompressRegionCount"].is_int64()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_int64());
            }else{
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_double());
            }
            }();
 VkDecompressMemoryRegionNV* pDecompressMemoryRegions;
[&](){
            if (json["pDecompressMemoryRegions"].get_array().size()==0){
                pDecompressMemoryRegions=NULL;
            return; }pDecompressMemoryRegions=(VkDecompressMemoryRegionNV*)malloc(decompressRegionCount*sizeof(VkDecompressMemoryRegionNV));
        auto& arr_VAyqSbG=json["pDecompressMemoryRegions"].get_array();
        for(int EZVrxlF=0; EZVrxlF < decompressRegionCount; EZVrxlF++){
            [&](){
            auto& temp=arr_VAyqSbG[EZVrxlF].get_object();
            deserialize_struct(temp,pDecompressMemoryRegions[EZVrxlF]);
            }();
        }
        }();

    PFN_vkCmdDecompressMemoryNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecompressMemoryNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecompressMemoryNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryNV");
    }  
    
{
call_function(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=decompressRegionCount;}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=boost::json::array();
            return; }json["pDecompressMemoryRegions"]=boost::json::array(decompressRegionCount);
        auto& arr_oMszjDS=json["pDecompressMemoryRegions"].get_array();
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto& temp=arr_oMszjDS[PnFzdhd].emplace_object();
            return serialize_struct(temp, pDecompressMemoryRegions[PnFzdhd]);
            }();
        }
        }();


        json["stream_type"]=VKCMDDECOMPRESSMEMORYNV;
        writeToConn(json);
    }

    void handle_vkCmdDecompressMemoryIndirectCountNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkDeviceAddress indirectCommandsAddress;
[&](){uint64_t temp_nwmsRdL;[&](){
            if (json["indirectCommandsAddress"].is_uint64()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_uint64());
            }else if (json["indirectCommandsAddress"].is_int64()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_int64());
            }else{
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_double());
            }
            }();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
VkDeviceAddress indirectCommandsCountAddress;
[&](){uint64_t temp_TcxQHrV;[&](){
            if (json["indirectCommandsCountAddress"].is_uint64()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_uint64());
            }else if (json["indirectCommandsCountAddress"].is_int64()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_int64());
            }else{
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_double());
            }
            }();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
uint32_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

    PFN_vkCmdDecompressMemoryIndirectCountNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_instance_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdDecompressMemoryIndirectCountNV)get_device_proc_addr(parent,"vkCmdDecompressMemoryIndirectCountNV");
    }  
    
{
call_function(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=indirectCommandsAddress;}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=indirectCommandsCountAddress;}();}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV;
        writeToConn(json);
    }

    void handle_vkCreateCuModuleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCuModuleCreateInfoNVX* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCuModuleCreateInfoNVX*)malloc(1*sizeof(VkCuModuleCreateInfoNVX));
        auto& arr_hMoVXkn=json["pCreateInfo"].get_array();
        for(int cihZnwL=0; cihZnwL < 1; cihZnwL++){
            [&](){
            auto& temp=arr_hMoVXkn[cihZnwL].get_object();
            deserialize_struct(temp,pCreateInfo[cihZnwL]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkCuModuleNVX* pModule;
[&](){
            if (json["pModule"].get_array().size()==0){
                pModule=NULL;
            return; }pModule=(VkCuModuleNVX*)malloc(1*sizeof(VkCuModuleNVX));
        auto& arr_FnQIexZ=json["pModule"].get_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();

    PFN_vkCreateCuModuleNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCuModuleNVX)get_instance_proc_addr(parent,"vkCreateCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCuModuleNVX)get_device_proc_addr(parent,"vkCreateCuModuleNVX");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pModule);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_FjdqPXh=json["pCreateInfo"].get_array();
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto& temp=arr_FjdqPXh[TUVhIjf].emplace_object();
            return serialize_struct(temp, pCreateInfo[TUVhIjf]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pModule==NULL){
                json["pModule"]=boost::json::array();
            return; }json["pModule"]=boost::json::array(1);
        auto& arr_FnQIexZ=json["pModule"].get_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        }();


        json["stream_type"]=VKCREATECUMODULENVX;
        writeToConn(json);
    }

    void handle_vkCreateCuFunctionNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkCuFunctionCreateInfoNVX* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkCuFunctionCreateInfoNVX*)malloc(1*sizeof(VkCuFunctionCreateInfoNVX));
        auto& arr_gHmsOsA=json["pCreateInfo"].get_array();
        for(int EbWStVn=0; EbWStVn < 1; EbWStVn++){
            [&](){
            auto& temp=arr_gHmsOsA[EbWStVn].get_object();
            deserialize_struct(temp,pCreateInfo[EbWStVn]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkCuFunctionNVX* pFunction;
[&](){
            if (json["pFunction"].get_array().size()==0){
                pFunction=NULL;
            return; }pFunction=(VkCuFunctionNVX*)malloc(1*sizeof(VkCuFunctionNVX));
        auto& arr_TrIYEcP=json["pFunction"].get_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();

    PFN_vkCreateCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateCuFunctionNVX)get_instance_proc_addr(parent,"vkCreateCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateCuFunctionNVX)get_device_proc_addr(parent,"vkCreateCuFunctionNVX");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pFunction);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XkBojZi=json["pCreateInfo"].get_array();
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto& temp=arr_XkBojZi[twsSgji].emplace_object();
            return serialize_struct(temp, pCreateInfo[twsSgji]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=boost::json::array();
            return; }json["pFunction"]=boost::json::array(1);
        auto& arr_TrIYEcP=json["pFunction"].get_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        }();


        json["stream_type"]=VKCREATECUFUNCTIONNVX;
        writeToConn(json);
    }

    void handle_vkDestroyCuModuleNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuModuleNVX module;
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCuModuleNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCuModuleNVX)get_instance_proc_addr(parent,"vkDestroyCuModuleNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCuModuleNVX)get_device_proc_addr(parent,"vkDestroyCuModuleNVX");
    }  
    
{
call_function(device, module, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYCUMODULENVX;
        writeToConn(json);
    }

    void handle_vkDestroyCuFunctionNVX(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkCuFunctionNVX function;
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyCuFunctionNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyCuFunctionNVX)get_instance_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyCuFunctionNVX)get_device_proc_addr(parent,"vkDestroyCuFunctionNVX");
    }  
    
{
call_function(device, function, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYCUFUNCTIONNVX;
        writeToConn(json);
    }

    void handle_vkCmdCuLaunchKernelNVX(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCuLaunchInfoNVX* pLaunchInfo;
[&](){
            if (json["pLaunchInfo"].get_array().size()==0){
                pLaunchInfo=NULL;
            return; }pLaunchInfo=(VkCuLaunchInfoNVX*)malloc(1*sizeof(VkCuLaunchInfoNVX));
        auto& arr_KytmXlj=json["pLaunchInfo"].get_array();
        for(int TnDRcbg=0; TnDRcbg < 1; TnDRcbg++){
            [&](){
            auto& temp=arr_KytmXlj[TnDRcbg].get_object();
            deserialize_struct(temp,pLaunchInfo[TnDRcbg]);
            }();
        }
        }();

    PFN_vkCmdCuLaunchKernelNVX call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_instance_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCuLaunchKernelNVX)get_device_proc_addr(parent,"vkCmdCuLaunchKernelNVX");
    }  
    
{
call_function(commandBuffer, pLaunchInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=boost::json::array();
            return; }json["pLaunchInfo"]=boost::json::array(1);
        auto& arr_UKYVund=json["pLaunchInfo"].get_array();
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto& temp=arr_UKYVund[eUSpbRB].emplace_object();
            return serialize_struct(temp, pLaunchInfo[eUSpbRB]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCULAUNCHKERNELNVX;
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutSizeEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
VkDeviceSize* pLayoutSizeInBytes;
[&](){
            if (json["pLayoutSizeInBytes"].get_array().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }pLayoutSizeInBytes=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].get_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){
            if (arr_xOYiCiO[QcQjmSi].is_uint64()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_uint64());
            }else if (arr_xOYiCiO[QcQjmSi].is_int64()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_int64());
            }else{
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_double());
            }
            }();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutSizeEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutSizeEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutSizeEXT");
    }  
    
{
call_function(device, layout, pLayoutSizeInBytes);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=boost::json::array();
            return; }json["pLayoutSizeInBytes"]=boost::json::array(1);
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].get_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=pLayoutSizeInBytes[QcQjmSi];}();}();
        }
        }();


        json["stream_type"]=VKGETDESCRIPTORSETLAYOUTSIZEEXT;
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutBindingOffsetEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSetLayout layout;
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
uint32_t binding;
[&](){
            if (json["binding"].is_uint64()){
                binding=static_cast<uint32_t>(json["binding"].get_uint64());
            }else if (json["binding"].is_int64()){
                binding=static_cast<uint32_t>(json["binding"].get_int64());
            }else{
                binding=static_cast<uint32_t>(json["binding"].get_double());
            }
            }();
VkDeviceSize* pOffset;
[&](){
            if (json["pOffset"].get_array().size()==0){
                pOffset=NULL;
            return; }pOffset=(VkDeviceSize*)malloc(1*sizeof(VkDeviceSize));
        auto& arr_dquZgZN=json["pOffset"].get_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){
            if (arr_dquZgZN[LNetLnu].is_uint64()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_uint64());
            }else if (arr_dquZgZN[LNetLnu].is_int64()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_int64());
            }else{
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_double());
            }
            }();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutBindingOffsetEXT");
    }  
    
{
call_function(device, layout, binding, pOffset);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=binding;}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=boost::json::array();
            return; }json["pOffset"]=boost::json::array(1);
        auto& arr_dquZgZN=json["pOffset"].get_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=pOffset[LNetLnu];}();}();
        }
        }();


        json["stream_type"]=VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT;
        writeToConn(json);
    }

    void handle_vkGetDescriptorEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorGetInfoEXT* pDescriptorInfo;
[&](){
            if (json["pDescriptorInfo"].get_array().size()==0){
                pDescriptorInfo=NULL;
            return; }pDescriptorInfo=(VkDescriptorGetInfoEXT*)malloc(1*sizeof(VkDescriptorGetInfoEXT));
        auto& arr_PhsrvQH=json["pDescriptorInfo"].get_array();
        for(int HBOsibB=0; HBOsibB < 1; HBOsibB++){
            [&](){
            auto& temp=arr_PhsrvQH[HBOsibB].get_object();
            deserialize_struct(temp,pDescriptorInfo[HBOsibB]);
            }();
        }
        }();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pDescriptor;
[&](){
            if (json["pDescriptor"].get_array().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].get_array().size()==0){
                temp_mEHYUhJ=NULL;
            return; }temp_mEHYUhJ=(char*)malloc(dataSize*sizeof(char));
        auto& arr_NUAdiYW=json["pDescriptor"].get_array();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){
            if (arr_NUAdiYW[skXTLXg].is_uint64()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_uint64());
            }else if (arr_NUAdiYW[skXTLXg].is_int64()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_int64());
            }else{
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_double());
            }
            }();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

    PFN_vkGetDescriptorEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorEXT)get_instance_proc_addr(parent,"vkGetDescriptorEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorEXT)get_device_proc_addr(parent,"vkGetDescriptorEXT");
    }  
    
{
call_function(device, pDescriptorInfo, dataSize, pDescriptor);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=boost::json::array();
            return; }json["pDescriptorInfo"]=boost::json::array(1);
        auto& arr_RGgHhwd=json["pDescriptorInfo"].get_array();
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto& temp=arr_RGgHhwd[cdcTeyn].emplace_object();
            return serialize_struct(temp, pDescriptorInfo[cdcTeyn]);
            }();
        }
        }();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }json["pDescriptor"]=boost::json::array(dataSize);
        auto& arr_NUAdiYW=json["pDescriptor"].get_array();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){arr_NUAdiYW[skXTLXg]=((char*)(pDescriptor))[skXTLXg];}();
        }
        }();}();


        json["stream_type"]=VKGETDESCRIPTOREXT;
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBuffersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t bufferCount;
[&](){
            if (json["bufferCount"].is_uint64()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_uint64());
            }else if (json["bufferCount"].is_int64()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_int64());
            }else{
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_double());
            }
            }();
 VkDescriptorBufferBindingInfoEXT* pBindingInfos;
[&](){
            if (json["pBindingInfos"].get_array().size()==0){
                pBindingInfos=NULL;
            return; }pBindingInfos=(VkDescriptorBufferBindingInfoEXT*)malloc(bufferCount*sizeof(VkDescriptorBufferBindingInfoEXT));
        auto& arr_xBOCrqU=json["pBindingInfos"].get_array();
        for(int VnwAoIb=0; VnwAoIb < bufferCount; VnwAoIb++){
            [&](){
            auto& temp=arr_xBOCrqU[VnwAoIb].get_object();
            deserialize_struct(temp,pBindingInfos[VnwAoIb]);
            }();
        }
        }();

    PFN_vkCmdBindDescriptorBuffersEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorBuffersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBuffersEXT");
    }  
    
{
call_function(commandBuffer, bufferCount, pBindingInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=bufferCount;}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=boost::json::array();
            return; }json["pBindingInfos"]=boost::json::array(bufferCount);
        auto& arr_guwgqGC=json["pBindingInfos"].get_array();
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto& temp=arr_guwgqGC[btgeqwi].emplace_object();
            return serialize_struct(temp, pBindingInfos[btgeqwi]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBINDDESCRIPTORBUFFERSEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDescriptorBufferOffsetsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t firstSet;
[&](){
            if (json["firstSet"].is_uint64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_uint64());
            }else if (json["firstSet"].is_int64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_int64());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].get_double());
            }
            }();
uint32_t setCount;
[&](){
            if (json["setCount"].is_uint64()){
                setCount=static_cast<uint32_t>(json["setCount"].get_uint64());
            }else if (json["setCount"].is_int64()){
                setCount=static_cast<uint32_t>(json["setCount"].get_int64());
            }else{
                setCount=static_cast<uint32_t>(json["setCount"].get_double());
            }
            }();
 uint32_t* pBufferIndices;
[&](){
            if (json["pBufferIndices"].get_array().size()==0){
                pBufferIndices=NULL;
            return; }pBufferIndices=(uint32_t*)malloc(setCount*sizeof(uint32_t));
        auto& arr_PTuYzHc=json["pBufferIndices"].get_array();
        for(int sDNFOkx=0; sDNFOkx < setCount; sDNFOkx++){
            [&](){
            if (arr_PTuYzHc[sDNFOkx].is_uint64()){
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].get_uint64());
            }else if (arr_PTuYzHc[sDNFOkx].is_int64()){
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].get_int64());
            }else{
                pBufferIndices[sDNFOkx]=static_cast<uint32_t>(arr_PTuYzHc[sDNFOkx].get_double());
            }
            }();
        }
        }();
 VkDeviceSize* pOffsets;
[&](){
            if (json["pOffsets"].get_array().size()==0){
                pOffsets=NULL;
            return; }pOffsets=(VkDeviceSize*)malloc(setCount*sizeof(VkDeviceSize));
        auto& arr_uWdiGtF=json["pOffsets"].get_array();
        for(int ELYQTNF=0; ELYQTNF < setCount; ELYQTNF++){
            [&](){uint64_t temp_uWdiGtF;[&](){
            if (arr_uWdiGtF[ELYQTNF].is_uint64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_uint64());
            }else if (arr_uWdiGtF[ELYQTNF].is_int64()){
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_int64());
            }else{
                temp_uWdiGtF=static_cast<uint64_t>(arr_uWdiGtF[ELYQTNF].get_double());
            }
            }();pOffsets[ELYQTNF]=(VkDeviceSize)temp_uWdiGtF;}();
        }
        }();

    PFN_vkCmdSetDescriptorBufferOffsetsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_instance_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDescriptorBufferOffsetsEXT)get_device_proc_addr(parent,"vkCmdSetDescriptorBufferOffsetsEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["setCount"]=setCount;}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=boost::json::array();
            return; }json["pBufferIndices"]=boost::json::array(setCount);
        auto& arr_zejaAgt=json["pBufferIndices"].get_array();
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=pBufferIndices[tuuKbsL];}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(setCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();


        json["stream_type"]=VKCMDSETDESCRIPTORBUFFEROFFSETSEXT;
        writeToConn(json);
    }

    void handle_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkPipelineBindPoint pipelineBindPoint;
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
VkPipelineLayout layout;
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
uint32_t set;
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();

    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_instance_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)get_device_proc_addr(parent,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
    }  
    
{
call_function(commandBuffer, pipelineBindPoint, layout, set);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();


        json["stream_type"]=VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT;
        writeToConn(json);
    }

    void handle_vkGetBufferOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkBufferCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkBufferCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkBufferCaptureDescriptorDataInfoEXT));
        auto& arr_VqsZREG=json["pInfo"].get_array();
        for(int dxQHpNQ=0; dxQHpNQ < 1; dxQHpNQ++){
            [&](){
            auto& temp=arr_VqsZREG[dxQHpNQ].get_object();
            deserialize_struct(temp,pInfo[dxQHpNQ]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetBufferOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_Hxvezrr=json["pInfo"].get_array();
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto& temp=arr_Hxvezrr[VgzeNwX].emplace_object();
            return serialize_struct(temp, pInfo[VgzeNwX]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT;
        writeToConn(json);
    }

    void handle_vkGetImageOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageCaptureDescriptorDataInfoEXT));
        auto& arr_YRCGcVr=json["pInfo"].get_array();
        for(int VOFqAJf=0; VOFqAJf < 1; VOFqAJf++){
            [&](){
            auto& temp=arr_YRCGcVr[VOFqAJf].get_object();
            deserialize_struct(temp,pInfo[VOFqAJf]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_vrxBIsi=json["pInfo"].get_array();
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto& temp=arr_vrxBIsi[swRpuDc].emplace_object();
            return serialize_struct(temp, pInfo[swRpuDc]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT;
        writeToConn(json);
    }

    void handle_vkGetImageViewOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkImageViewCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkImageViewCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkImageViewCaptureDescriptorDataInfoEXT));
        auto& arr_eRxFxUj=json["pInfo"].get_array();
        for(int QcuObSb=0; QcuObSb < 1; QcuObSb++){
            [&](){
            auto& temp=arr_eRxFxUj[QcuObSb].get_object();
            deserialize_struct(temp,pInfo[QcuObSb]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetImageViewOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_CYlSaQv=json["pInfo"].get_array();
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto& temp=arr_CYlSaQv[pmdADqD].emplace_object();
            return serialize_struct(temp, pInfo[pmdADqD]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT;
        writeToConn(json);
    }

    void handle_vkGetSamplerOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkSamplerCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkSamplerCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkSamplerCaptureDescriptorDataInfoEXT));
        auto& arr_MRsSLnb=json["pInfo"].get_array();
        for(int VTYniUZ=0; VTYniUZ < 1; VTYniUZ++){
            [&](){
            auto& temp=arr_MRsSLnb[VTYniUZ].get_object();
            deserialize_struct(temp,pInfo[VTYniUZ]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetSamplerOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_RMPxsVS=json["pInfo"].get_array();
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto& temp=arr_RMPxsVS[SScNLQN].emplace_object();
            return serialize_struct(temp, pInfo[SScNLQN]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT;
        writeToConn(json);
    }

    void handle_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkAccelerationStructureCaptureDescriptorDataInfoEXT*)malloc(1*sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT));
        auto& arr_IpvCogf=json["pInfo"].get_array();
        for(int rufTsHO=0; rufTsHO < 1; rufTsHO++){
            [&](){
            auto& temp=arr_IpvCogf[rufTsHO].get_object();
            deserialize_struct(temp,pInfo[rufTsHO]);
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();

    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_instance_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)get_device_proc_addr(parent,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pInfo, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_iLnHGmk=json["pInfo"].get_array();
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto& temp=arr_iLnHGmk[kbTuVMH].emplace_object();
            return serialize_struct(temp, pInfo[kbTuVMH]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT;
        writeToConn(json);
    }

    void handle_vkSetDeviceMemoryPriorityEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceMemory memory;
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
float priority;
[&](){
            if (json["priority"].is_uint64()){
                priority=static_cast<float>(json["priority"].get_uint64());
            }else if (json["priority"].is_int64()){
                priority=static_cast<float>(json["priority"].get_int64());
            }else{
                priority=static_cast<float>(json["priority"].get_double());
            }
            }();

    PFN_vkSetDeviceMemoryPriorityEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_instance_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkSetDeviceMemoryPriorityEXT)get_device_proc_addr(parent,"vkSetDeviceMemoryPriorityEXT");
    }  
    
{
call_function(device, memory, priority);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=priority;}();


        json["stream_type"]=VKSETDEVICEMEMORYPRIORITYEXT;
        writeToConn(json);
    }

    void handle_vkAcquireDrmDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){
            if (json["drmFd"].is_uint64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_uint64());
            }else if (json["drmFd"].is_int64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_int64());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].get_double());
            }
            }();
VkDisplayKHR display;
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

    PFN_vkAcquireDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_instance_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkAcquireDrmDisplayEXT)get_device_proc_addr(parent,"vkAcquireDrmDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, drmFd, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();


        json["stream_type"]=VKACQUIREDRMDISPLAYEXT;
        writeToConn(json);
    }

    void handle_vkGetDrmDisplayEXT(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
int32_t drmFd;
[&](){
            if (json["drmFd"].is_uint64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_uint64());
            }else if (json["drmFd"].is_int64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_int64());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].get_double());
            }
            }();
uint32_t connectorId;
[&](){
            if (json["connectorId"].is_uint64()){
                connectorId=static_cast<uint32_t>(json["connectorId"].get_uint64());
            }else if (json["connectorId"].is_int64()){
                connectorId=static_cast<uint32_t>(json["connectorId"].get_int64());
            }else{
                connectorId=static_cast<uint32_t>(json["connectorId"].get_double());
            }
            }();
VkDisplayKHR* display;
[&](){
            if (json["display"].get_array().size()==0){
                display=NULL;
            return; }display=(VkDisplayKHR*)malloc(1*sizeof(VkDisplayKHR));
        auto& arr_DpFHFgI=json["display"].get_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();

    PFN_vkGetDrmDisplayEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDrmDisplayEXT)get_instance_proc_addr(parent,"vkGetDrmDisplayEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDrmDisplayEXT)get_device_proc_addr(parent,"vkGetDrmDisplayEXT");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, drmFd, connectorId, display);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){json["connectorId"]=connectorId;}();
[&](){
            if (display==NULL){
                json["display"]=boost::json::array();
            return; }json["display"]=boost::json::array(1);
        auto& arr_DpFHFgI=json["display"].get_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        }();


        json["stream_type"]=VKGETDRMDISPLAYEXT;
        writeToConn(json);
    }

    void handle_vkWaitForPresentKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkSwapchainKHR swapchain;
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
uint64_t presentId;
[&](){
            if (json["presentId"].is_uint64()){
                presentId=static_cast<uint64_t>(json["presentId"].get_uint64());
            }else if (json["presentId"].is_int64()){
                presentId=static_cast<uint64_t>(json["presentId"].get_int64());
            }else{
                presentId=static_cast<uint64_t>(json["presentId"].get_double());
            }
            }();
uint64_t timeout;
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();

    PFN_vkWaitForPresentKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWaitForPresentKHR)get_instance_proc_addr(parent,"vkWaitForPresentKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWaitForPresentKHR)get_device_proc_addr(parent,"vkWaitForPresentKHR");
    }  
    
VkResult  result;
{
result=call_function(device, swapchain, presentId, timeout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=presentId;}();
[&](){json["timeout"]=timeout;}();


        json["stream_type"]=VKWAITFORPRESENTKHR;
        writeToConn(json);
    }

    void handle_vkCmdBeginRendering(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkRenderingInfo* pRenderingInfo;
[&](){
            if (json["pRenderingInfo"].get_array().size()==0){
                pRenderingInfo=NULL;
            return; }pRenderingInfo=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));
        auto& arr_IEHUXzQ=json["pRenderingInfo"].get_array();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            auto& temp=arr_IEHUXzQ[oIBIqTv].get_object();
            deserialize_struct(temp,pRenderingInfo[oIBIqTv]);
            }();
        }
        }();

    PFN_vkCmdBeginRendering call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBeginRendering)get_instance_proc_addr(parent,"vkCmdBeginRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBeginRendering)get_device_proc_addr(parent,"vkCmdBeginRendering");
    }  
    
{
call_function(commandBuffer, pRenderingInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }json["pRenderingInfo"]=boost::json::array(1);
        auto& arr_DOEgrev=json["pRenderingInfo"].get_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBEGINRENDERING;
        writeToConn(json);
    }

    void handle_vkCmdEndRendering(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

    PFN_vkCmdEndRendering call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdEndRendering)get_instance_proc_addr(parent,"vkCmdEndRendering");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdEndRendering)get_device_proc_addr(parent,"vkCmdEndRendering");
    }  
    
{
call_function(commandBuffer);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();


        json["stream_type"]=VKCMDENDRENDERING;
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetLayoutHostMappingInfoVALVE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDescriptorSetBindingReferenceVALVE* pBindingReference;
[&](){
            if (json["pBindingReference"].get_array().size()==0){
                pBindingReference=NULL;
            return; }pBindingReference=(VkDescriptorSetBindingReferenceVALVE*)malloc(1*sizeof(VkDescriptorSetBindingReferenceVALVE));
        auto& arr_swAzjIz=json["pBindingReference"].get_array();
        for(int dYYQsmf=0; dYYQsmf < 1; dYYQsmf++){
            [&](){
            auto& temp=arr_swAzjIz[dYYQsmf].get_object();
            deserialize_struct(temp,pBindingReference[dYYQsmf]);
            }();
        }
        }();
VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping;
[&](){
            if (json["pHostMapping"].get_array().size()==0){
                pHostMapping=NULL;
            return; }pHostMapping=(VkDescriptorSetLayoutHostMappingInfoVALVE*)malloc(1*sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE));
        auto& arr_zODJzpL=json["pHostMapping"].get_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].get_object();
            deserialize_struct(temp,pHostMapping[jHGvhna]);
            }();
        }
        }();

    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetLayoutHostMappingInfoVALVE");
    }  
    
{
call_function(device, pBindingReference, pHostMapping);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=boost::json::array();
            return; }json["pBindingReference"]=boost::json::array(1);
        auto& arr_JTmPGZt=json["pBindingReference"].get_array();
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto& temp=arr_JTmPGZt[OEumPxJ].emplace_object();
            return serialize_struct(temp, pBindingReference[OEumPxJ]);
            }();
        }
        }();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=boost::json::array();
            return; }json["pHostMapping"]=boost::json::array(1);
        auto& arr_zODJzpL=json["pHostMapping"].get_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].emplace_object();
            return serialize_struct(temp, pHostMapping[jHGvhna]);
            }();
        }
        }();


        json["stream_type"]=VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE;
        writeToConn(json);
    }

    void handle_vkGetDescriptorSetHostMappingVALVE(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDescriptorSet descriptorSet;
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
void** ppData;
[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].get_array().size()*sizeof(char));
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].get_array().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkGetDescriptorSetHostMappingVALVE call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_instance_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDescriptorSetHostMappingVALVE)get_device_proc_addr(parent,"vkGetDescriptorSetHostMappingVALVE");
    }  
    
{
call_function(device, descriptorSet, ppData);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }arr_JgRLJSK[NsRFkBj]=boost::json::array(strlen(((char*)(ppData[NsRFkBj])))+1);
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[NsRFkBj]))[jYdchEs];}();
        }
        }();}();
        }
        }();


        json["stream_type"]=VKGETDESCRIPTORSETHOSTMAPPINGVALVE;
        writeToConn(json);
    }

    void handle_vkCreateMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMicromapCreateInfoEXT* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkMicromapCreateInfoEXT*)malloc(1*sizeof(VkMicromapCreateInfoEXT));
        auto& arr_XnWTHFD=json["pCreateInfo"].get_array();
        for(int SlvdLyP=0; SlvdLyP < 1; SlvdLyP++){
            [&](){
            auto& temp=arr_XnWTHFD[SlvdLyP].get_object();
            deserialize_struct(temp,pCreateInfo[SlvdLyP]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkMicromapEXT* pMicromap;
[&](){
            if (json["pMicromap"].get_array().size()==0){
                pMicromap=NULL;
            return; }pMicromap=(VkMicromapEXT*)malloc(1*sizeof(VkMicromapEXT));
        auto& arr_mHmzwPX=json["pMicromap"].get_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();

    PFN_vkCreateMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateMicromapEXT)get_instance_proc_addr(parent,"vkCreateMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateMicromapEXT)get_device_proc_addr(parent,"vkCreateMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pMicromap);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_vrQtrYo=json["pCreateInfo"].get_array();
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto& temp=arr_vrQtrYo[cfhYIUK].emplace_object();
            return serialize_struct(temp, pCreateInfo[cfhYIUK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=boost::json::array();
            return; }json["pMicromap"]=boost::json::array(1);
        auto& arr_mHmzwPX=json["pMicromap"].get_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        }();


        json["stream_type"]=VKCREATEMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCmdBuildMicromapsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();
 VkMicromapBuildInfoEXT* pInfos;
[&](){
            if (json["pInfos"].get_array().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_pOhxygW=json["pInfos"].get_array();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            auto& temp=arr_pOhxygW[UnBcPOz].get_object();
            deserialize_struct(temp,pInfos[UnBcPOz]);
            }();
        }
        }();

    PFN_vkCmdBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_instance_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBuildMicromapsEXT)get_device_proc_addr(parent,"vkCmdBuildMicromapsEXT");
    }  
    
{
call_function(commandBuffer, infoCount, pInfos);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_KdoluBZ=json["pInfos"].get_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();


        json["stream_type"]=VKCMDBUILDMICROMAPSEXT;
        writeToConn(json);
    }

    void handle_vkBuildMicromapsEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
uint32_t infoCount;
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();
 VkMicromapBuildInfoEXT* pInfos;
[&](){
            if (json["pInfos"].get_array().size()==0){
                pInfos=NULL;
            return; }pInfos=(VkMicromapBuildInfoEXT*)malloc(infoCount*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_pOhxygW=json["pInfos"].get_array();
        for(int UnBcPOz=0; UnBcPOz < infoCount; UnBcPOz++){
            [&](){
            auto& temp=arr_pOhxygW[UnBcPOz].get_object();
            deserialize_struct(temp,pInfos[UnBcPOz]);
            }();
        }
        }();

    PFN_vkBuildMicromapsEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBuildMicromapsEXT)get_instance_proc_addr(parent,"vkBuildMicromapsEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBuildMicromapsEXT)get_device_proc_addr(parent,"vkBuildMicromapsEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, infoCount, pInfos);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_KdoluBZ=json["pInfos"].get_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();


        json["stream_type"]=VKBUILDMICROMAPSEXT;
        writeToConn(json);
    }

    void handle_vkDestroyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkMicromapEXT micromap;
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyMicromapEXT)get_instance_proc_addr(parent,"vkDestroyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyMicromapEXT)get_device_proc_addr(parent,"vkDestroyMicromapEXT");
    }  
    
{
call_function(device, micromap, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));
        auto& arr_JTPzqPn=json["pInfo"].get_array();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            auto& temp=arr_JTPzqPn[rzDjQUu].get_object();
            deserialize_struct(temp,pInfo[rzDjQUu]);
            }();
        }
        }();

    PFN_vkCmdCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_UIlbXxp=json["pInfo"].get_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCopyMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapInfoEXT*)malloc(1*sizeof(VkCopyMicromapInfoEXT));
        auto& arr_JTPzqPn=json["pInfo"].get_array();
        for(int rzDjQUu=0; rzDjQUu < 1; rzDjQUu++){
            [&](){
            auto& temp=arr_JTPzqPn[rzDjQUu].get_object();
            deserialize_struct(temp,pInfo[rzDjQUu]);
            }();
        }
        }();

    PFN_vkCopyMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMicromapEXT)get_instance_proc_addr(parent,"vkCopyMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMicromapEXT)get_device_proc_addr(parent,"vkCopyMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_UIlbXxp=json["pInfo"].get_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCmdCopyMicromapToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));
        auto& arr_yvWkCxr=json["pInfo"].get_array();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            auto& temp=arr_yvWkCxr[LolGOkG].get_object();
            deserialize_struct(temp,pInfo[LolGOkG]);
            }();
        }
        }();

    PFN_vkCmdCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCmdCopyMicromapToMemoryEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_EiLirbT=json["pInfo"].get_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYMICROMAPTOMEMORYEXT;
        writeToConn(json);
    }

    void handle_vkCopyMicromapToMemoryEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMicromapToMemoryInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMicromapToMemoryInfoEXT*)malloc(1*sizeof(VkCopyMicromapToMemoryInfoEXT));
        auto& arr_yvWkCxr=json["pInfo"].get_array();
        for(int LolGOkG=0; LolGOkG < 1; LolGOkG++){
            [&](){
            auto& temp=arr_yvWkCxr[LolGOkG].get_object();
            deserialize_struct(temp,pInfo[LolGOkG]);
            }();
        }
        }();

    PFN_vkCopyMicromapToMemoryEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_instance_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMicromapToMemoryEXT)get_device_proc_addr(parent,"vkCopyMicromapToMemoryEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_EiLirbT=json["pInfo"].get_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYMICROMAPTOMEMORYEXT;
        writeToConn(json);
    }

    void handle_vkCmdCopyMemoryToMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));
        auto& arr_JkoWJSQ=json["pInfo"].get_array();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            auto& temp=arr_JkoWJSQ[HyJmoQR].get_object();
            deserialize_struct(temp,pInfo[HyJmoQR]);
            }();
        }
        }();

    PFN_vkCmdCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCmdCopyMemoryToMicromapEXT");
    }  
    
{
call_function(commandBuffer, pInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QufOGLT=json["pInfo"].get_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();


        json["stream_type"]=VKCMDCOPYMEMORYTOMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCopyMemoryToMicromapEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeferredOperationKHR deferredOperation;
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
 VkCopyMemoryToMicromapInfoEXT* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkCopyMemoryToMicromapInfoEXT*)malloc(1*sizeof(VkCopyMemoryToMicromapInfoEXT));
        auto& arr_JkoWJSQ=json["pInfo"].get_array();
        for(int HyJmoQR=0; HyJmoQR < 1; HyJmoQR++){
            [&](){
            auto& temp=arr_JkoWJSQ[HyJmoQR].get_object();
            deserialize_struct(temp,pInfo[HyJmoQR]);
            }();
        }
        }();

    PFN_vkCopyMemoryToMicromapEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_instance_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCopyMemoryToMicromapEXT)get_device_proc_addr(parent,"vkCopyMemoryToMicromapEXT");
    }  
    
VkResult  result;
{
result=call_function(device, deferredOperation, pInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QufOGLT=json["pInfo"].get_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();


        json["stream_type"]=VKCOPYMEMORYTOMICROMAPEXT;
        writeToConn(json);
    }

    void handle_vkCmdWriteMicromapsPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t micromapCount;
[&](){
            if (json["micromapCount"].is_uint64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_uint64());
            }else if (json["micromapCount"].is_int64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_int64());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_double());
            }
            }();
 VkMicromapEXT* pMicromaps;
[&](){
            if (json["pMicromaps"].get_array().size()==0){
                pMicromaps=NULL;
            return; }pMicromaps=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));
        auto& arr_gjzjRBu=json["pMicromaps"].get_array();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], pMicromaps[XuxNkjt]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
VkQueryPool queryPool;
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
uint32_t firstQuery;
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

    PFN_vkCmdWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkCmdWriteMicromapsPropertiesEXT");
    }  
    
{
call_function(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }json["pMicromaps"]=boost::json::array(micromapCount);
        auto& arr_NriAFXg=json["pMicromaps"].get_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();


        json["stream_type"]=VKCMDWRITEMICROMAPSPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkWriteMicromapsPropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t micromapCount;
[&](){
            if (json["micromapCount"].is_uint64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_uint64());
            }else if (json["micromapCount"].is_int64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_int64());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_double());
            }
            }();
 VkMicromapEXT* pMicromaps;
[&](){
            if (json["pMicromaps"].get_array().size()==0){
                pMicromaps=NULL;
            return; }pMicromaps=(VkMicromapEXT*)malloc(micromapCount*sizeof(VkMicromapEXT));
        auto& arr_gjzjRBu=json["pMicromaps"].get_array();
        for(int XuxNkjt=0; XuxNkjt < micromapCount; XuxNkjt++){
            [&](){deserialize_VkMicromapEXT(arr_gjzjRBu[XuxNkjt], pMicromaps[XuxNkjt]);}();
        }
        }();
VkQueryType queryType;
[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
size_t dataSize;
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
size_t stride;
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<size_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<size_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<size_t>(json["stride"].get_double());
            }
            }();

    PFN_vkWriteMicromapsPropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_instance_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkWriteMicromapsPropertiesEXT)get_device_proc_addr(parent,"vkWriteMicromapsPropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }json["pMicromaps"]=boost::json::array(micromapCount);
        auto& arr_NriAFXg=json["pMicromaps"].get_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){json["stride"]=stride;}();


        json["stream_type"]=VKWRITEMICROMAPSPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkGetDeviceMicromapCompatibilityEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMicromapVersionInfoEXT* pVersionInfo;
[&](){
            if (json["pVersionInfo"].get_array().size()==0){
                pVersionInfo=NULL;
            return; }pVersionInfo=(VkMicromapVersionInfoEXT*)malloc(1*sizeof(VkMicromapVersionInfoEXT));
        auto& arr_FlJdkUQ=json["pVersionInfo"].get_array();
        for(int GMLSjyq=0; GMLSjyq < 1; GMLSjyq++){
            [&](){
            auto& temp=arr_FlJdkUQ[GMLSjyq].get_object();
            deserialize_struct(temp,pVersionInfo[GMLSjyq]);
            }();
        }
        }();
VkAccelerationStructureCompatibilityKHR* pCompatibility;
[&](){
            if (json["pCompatibility"].get_array().size()==0){
                pCompatibility=NULL;
            return; }pCompatibility=(VkAccelerationStructureCompatibilityKHR*)malloc(1*sizeof(VkAccelerationStructureCompatibilityKHR));
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_uint64());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_int64());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

    PFN_vkGetDeviceMicromapCompatibilityEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_instance_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceMicromapCompatibilityEXT)get_device_proc_addr(parent,"vkGetDeviceMicromapCompatibilityEXT");
    }  
    
{
call_function(device, pVersionInfo, pCompatibility);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }json["pVersionInfo"]=boost::json::array(1);
        auto& arr_PYqUGEM=json["pVersionInfo"].get_array();
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto& temp=arr_PYqUGEM[odfXDEI].emplace_object();
            return serialize_struct(temp, pVersionInfo[odfXDEI]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }json["pCompatibility"]=boost::json::array(1);
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();


        json["stream_type"]=VKGETDEVICEMICROMAPCOMPATIBILITYEXT;
        writeToConn(json);
    }

    void handle_vkGetMicromapBuildSizesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkAccelerationStructureBuildTypeKHR buildType;
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_uint64());
            }else if (json["buildType"].is_int64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_int64());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].get_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();
 VkMicromapBuildInfoEXT* pBuildInfo;
[&](){
            if (json["pBuildInfo"].get_array().size()==0){
                pBuildInfo=NULL;
            return; }pBuildInfo=(VkMicromapBuildInfoEXT*)malloc(1*sizeof(VkMicromapBuildInfoEXT));
        auto& arr_oNQjwLj=json["pBuildInfo"].get_array();
        for(int ALWsyDT=0; ALWsyDT < 1; ALWsyDT++){
            [&](){
            auto& temp=arr_oNQjwLj[ALWsyDT].get_object();
            deserialize_struct(temp,pBuildInfo[ALWsyDT]);
            }();
        }
        }();
VkMicromapBuildSizesInfoEXT* pSizeInfo;
[&](){
            if (json["pSizeInfo"].get_array().size()==0){
                pSizeInfo=NULL;
            return; }pSizeInfo=(VkMicromapBuildSizesInfoEXT*)malloc(1*sizeof(VkMicromapBuildSizesInfoEXT));
        auto& arr_fJKSsZw=json["pSizeInfo"].get_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].get_object();
            deserialize_struct(temp,pSizeInfo[XgjgtXU]);
            }();
        }
        }();

    PFN_vkGetMicromapBuildSizesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_instance_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetMicromapBuildSizesEXT)get_device_proc_addr(parent,"vkGetMicromapBuildSizesEXT");
    }  
    
{
call_function(device, buildType, pBuildInfo, pSizeInfo);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }json["pBuildInfo"]=boost::json::array(1);
        auto& arr_lREHNwp=json["pBuildInfo"].get_array();
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto& temp=arr_lREHNwp[nPItxru].emplace_object();
            return serialize_struct(temp, pBuildInfo[nPItxru]);
            }();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }json["pSizeInfo"]=boost::json::array(1);
        auto& arr_fJKSsZw=json["pSizeInfo"].get_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].emplace_object();
            return serialize_struct(temp, pSizeInfo[XgjgtXU]);
            }();
        }
        }();


        json["stream_type"]=VKGETMICROMAPBUILDSIZESEXT;
        writeToConn(json);
    }

    void handle_vkGetShaderModuleIdentifierEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderModule shaderModule;
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].get_array().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].get_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleIdentifierEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderModuleIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleIdentifierEXT");
    }  
    
{
call_function(device, shaderModule, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }json["pIdentifier"]=boost::json::array(1);
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();


        json["stream_type"]=VKGETSHADERMODULEIDENTIFIEREXT;
        writeToConn(json);
    }

    void handle_vkGetShaderModuleCreateInfoIdentifierEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkShaderModuleCreateInfo* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkShaderModuleCreateInfo*)malloc(1*sizeof(VkShaderModuleCreateInfo));
        auto& arr_GtIQgds=json["pCreateInfo"].get_array();
        for(int PbmosKP=0; PbmosKP < 1; PbmosKP++){
            [&](){
            auto& temp=arr_GtIQgds[PbmosKP].get_object();
            deserialize_struct(temp,pCreateInfo[PbmosKP]);
            }();
        }
        }();
VkShaderModuleIdentifierEXT* pIdentifier;
[&](){
            if (json["pIdentifier"].get_array().size()==0){
                pIdentifier=NULL;
            return; }pIdentifier=(VkShaderModuleIdentifierEXT*)malloc(1*sizeof(VkShaderModuleIdentifierEXT));
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].get_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

    PFN_vkGetShaderModuleCreateInfoIdentifierEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_instance_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderModuleCreateInfoIdentifierEXT)get_device_proc_addr(parent,"vkGetShaderModuleCreateInfoIdentifierEXT");
    }  
    
{
call_function(device, pCreateInfo, pIdentifier);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iSZUILM=json["pCreateInfo"].get_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }json["pIdentifier"]=boost::json::array(1);
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();


        json["stream_type"]=VKGETSHADERMODULECREATEINFOIDENTIFIEREXT;
        writeToConn(json);
    }

    void handle_vkGetImageSubresourceLayout2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkImage image;
[&](){deserialize_VkImage(json["image"], image);}();
 VkImageSubresource2KHR* pSubresource;
[&](){
            if (json["pSubresource"].get_array().size()==0){
                pSubresource=NULL;
            return; }pSubresource=(VkImageSubresource2KHR*)malloc(1*sizeof(VkImageSubresource2KHR));
        auto& arr_oUQSxrb=json["pSubresource"].get_array();
        for(int HhQHZaA=0; HhQHZaA < 1; HhQHZaA++){
            [&](){
            auto& temp=arr_oUQSxrb[HhQHZaA].get_object();
            deserialize_struct(temp,pSubresource[HhQHZaA]);
            }();
        }
        }();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].get_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetImageSubresourceLayout2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_instance_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetImageSubresourceLayout2KHR)get_device_proc_addr(parent,"vkGetImageSubresourceLayout2KHR");
    }  
    
{
call_function(device, image, pSubresource, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }json["pSubresource"]=boost::json::array(1);
        auto& arr_xtdYssI=json["pSubresource"].get_array();
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto& temp=arr_xtdYssI[HvvKvoL].emplace_object();
            return serialize_struct(temp, pSubresource[HvvKvoL]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();


        json["stream_type"]=VKGETIMAGESUBRESOURCELAYOUT2KHR;
        writeToConn(json);
    }

    void handle_vkGetPipelinePropertiesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkPipelineInfoEXT* pPipelineInfo;
[&](){
            if (json["pPipelineInfo"].get_array().size()==0){
                pPipelineInfo=NULL;
            return; }pPipelineInfo=(VkPipelineInfoEXT*)malloc(1*sizeof(VkPipelineInfoEXT));
        auto& arr_PhjfoeL=json["pPipelineInfo"].get_array();
        for(int tiAojvv=0; tiAojvv < 1; tiAojvv++){
            [&](){
            auto& temp=arr_PhjfoeL[tiAojvv].get_object();
            deserialize_struct(temp,pPipelineInfo[tiAojvv]);
            }();
        }
        }();
VkBaseOutStructure* pPipelineProperties;
[&](){
            if (json["pPipelineProperties"].get_array().size()==0){
                pPipelineProperties=NULL;
            return; }pPipelineProperties=(VkBaseOutStructure*)malloc(1*sizeof(VkBaseOutStructure));
        auto& arr_eMgMlNc=json["pPipelineProperties"].get_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].get_object();
            deserialize_struct(temp,pPipelineProperties[cJpCXwz]);
            }();
        }
        }();

    PFN_vkGetPipelinePropertiesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_instance_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPipelinePropertiesEXT)get_device_proc_addr(parent,"vkGetPipelinePropertiesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pPipelineInfo, pPipelineProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }json["pPipelineInfo"]=boost::json::array(1);
        auto& arr_eGbOPJq=json["pPipelineInfo"].get_array();
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto& temp=arr_eGbOPJq[iUjmOrp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[iUjmOrp]);
            }();
        }
        }();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=boost::json::array();
            return; }json["pPipelineProperties"]=boost::json::array(1);
        auto& arr_eMgMlNc=json["pPipelineProperties"].get_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].emplace_object();
            return serialize_struct(temp, pPipelineProperties[cJpCXwz]);
            }();
        }
        }();


        json["stream_type"]=VKGETPIPELINEPROPERTIESEXT;
        writeToConn(json);
    }

    void handle_vkGetFramebufferTilePropertiesQCOM(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkFramebuffer framebuffer;
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
uint32_t* pPropertiesCount;
[&](){
            if (json["pPropertiesCount"].get_array().size()==0){
                pPropertiesCount=NULL;
            return; }pPropertiesCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_vUkyKfO=json["pPropertiesCount"].get_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){
            if (arr_vUkyKfO[YhfeqPW].is_uint64()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_uint64());
            }else if (arr_vUkyKfO[YhfeqPW].is_int64()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_int64());
            }else{
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_double());
            }
            }();
        }
        }();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(*pPropertiesCount*sizeof(VkTilePropertiesQCOM));
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].get_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetFramebufferTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetFramebufferTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetFramebufferTilePropertiesQCOM");
    }  
    
VkResult  result;
{
result=call_function(device, framebuffer, pPropertiesCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=boost::json::array();
            return; }json["pPropertiesCount"]=boost::json::array(1);
        auto& arr_vUkyKfO=json["pPropertiesCount"].get_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=pPropertiesCount[YhfeqPW];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertiesCount);
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();


        json["stream_type"]=VKGETFRAMEBUFFERTILEPROPERTIESQCOM;
        writeToConn(json);
    }

    void handle_vkGetDynamicRenderingTilePropertiesQCOM(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkRenderingInfo* pRenderingInfo;
[&](){
            if (json["pRenderingInfo"].get_array().size()==0){
                pRenderingInfo=NULL;
            return; }pRenderingInfo=(VkRenderingInfo*)malloc(1*sizeof(VkRenderingInfo));
        auto& arr_IEHUXzQ=json["pRenderingInfo"].get_array();
        for(int oIBIqTv=0; oIBIqTv < 1; oIBIqTv++){
            [&](){
            auto& temp=arr_IEHUXzQ[oIBIqTv].get_object();
            deserialize_struct(temp,pRenderingInfo[oIBIqTv]);
            }();
        }
        }();
VkTilePropertiesQCOM* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkTilePropertiesQCOM*)malloc(1*sizeof(VkTilePropertiesQCOM));
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].get_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();

    PFN_vkGetDynamicRenderingTilePropertiesQCOM call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_instance_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDynamicRenderingTilePropertiesQCOM)get_device_proc_addr(parent,"vkGetDynamicRenderingTilePropertiesQCOM");
    }  
    
VkResult  result;
{
result=call_function(device, pRenderingInfo, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }json["pRenderingInfo"]=boost::json::array(1);
        auto& arr_DOEgrev=json["pRenderingInfo"].get_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();


        json["stream_type"]=VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
 VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo;
[&](){
            if (json["pOpticalFlowImageFormatInfo"].get_array().size()==0){
                pOpticalFlowImageFormatInfo=NULL;
            return; }pOpticalFlowImageFormatInfo=(VkOpticalFlowImageFormatInfoNV*)malloc(1*sizeof(VkOpticalFlowImageFormatInfoNV));
        auto& arr_bHRLrfx=json["pOpticalFlowImageFormatInfo"].get_array();
        for(int oBdVYyf=0; oBdVYyf < 1; oBdVYyf++){
            [&](){
            auto& temp=arr_bHRLrfx[oBdVYyf].get_object();
            deserialize_struct(temp,pOpticalFlowImageFormatInfo[oBdVYyf]);
            }();
        }
        }();
uint32_t* pFormatCount;
[&](){
            if (json["pFormatCount"].get_array().size()==0){
                pFormatCount=NULL;
            return; }pFormatCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_OWVxAsX=json["pFormatCount"].get_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){
            if (arr_OWVxAsX[AvMKjKj].is_uint64()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_uint64());
            }else if (arr_OWVxAsX[AvMKjKj].is_int64()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_int64());
            }else{
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_double());
            }
            }();
        }
        }();
VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties;
[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }pImageFormatProperties=(VkOpticalFlowImageFormatPropertiesNV*)malloc(*pFormatCount*sizeof(VkOpticalFlowImageFormatPropertiesNV));
        auto& arr_oZncgpa=json["pImageFormatProperties"].get_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].get_object();
            deserialize_struct(temp,pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_instance_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)get_device_proc_addr(parent,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=boost::json::array();
            return; }json["pOpticalFlowImageFormatInfo"]=boost::json::array(1);
        auto& arr_oyPfnWV=json["pOpticalFlowImageFormatInfo"].get_array();
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto& temp=arr_oyPfnWV[HqzITOl].emplace_object();
            return serialize_struct(temp, pOpticalFlowImageFormatInfo[HqzITOl]);
            }();
        }
        }();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=boost::json::array();
            return; }json["pFormatCount"]=boost::json::array(1);
        auto& arr_OWVxAsX=json["pFormatCount"].get_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=pFormatCount[AvMKjKj];}();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(*pFormatCount);
        auto& arr_oZncgpa=json["pImageFormatProperties"].get_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV;
        writeToConn(json);
    }

    void handle_vkCreateOpticalFlowSessionNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkOpticalFlowSessionCreateInfoNV* pCreateInfo;
[&](){
            if (json["pCreateInfo"].get_array().size()==0){
                pCreateInfo=NULL;
            return; }pCreateInfo=(VkOpticalFlowSessionCreateInfoNV*)malloc(1*sizeof(VkOpticalFlowSessionCreateInfoNV));
        auto& arr_sIplIPh=json["pCreateInfo"].get_array();
        for(int OLjhukd=0; OLjhukd < 1; OLjhukd++){
            [&](){
            auto& temp=arr_sIplIPh[OLjhukd].get_object();
            deserialize_struct(temp,pCreateInfo[OLjhukd]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkOpticalFlowSessionNV* pSession;
[&](){
            if (json["pSession"].get_array().size()==0){
                pSession=NULL;
            return; }pSession=(VkOpticalFlowSessionNV*)malloc(1*sizeof(VkOpticalFlowSessionNV));
        auto& arr_PyNQerY=json["pSession"].get_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();

    PFN_vkCreateOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateOpticalFlowSessionNV)get_device_proc_addr(parent,"vkCreateOpticalFlowSessionNV");
    }  
    
VkResult  result;
{
result=call_function(device, pCreateInfo, pAllocator, pSession);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dKVOiZE=json["pCreateInfo"].get_array();
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto& temp=arr_dKVOiZE[LaeeodD].emplace_object();
            return serialize_struct(temp, pCreateInfo[LaeeodD]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSession==NULL){
                json["pSession"]=boost::json::array();
            return; }json["pSession"]=boost::json::array(1);
        auto& arr_PyNQerY=json["pSession"].get_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        }();


        json["stream_type"]=VKCREATEOPTICALFLOWSESSIONNV;
        writeToConn(json);
    }

    void handle_vkDestroyOpticalFlowSessionNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyOpticalFlowSessionNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_instance_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyOpticalFlowSessionNV)get_device_proc_addr(parent,"vkDestroyOpticalFlowSessionNV");
    }  
    
{
call_function(device, session, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYOPTICALFLOWSESSIONNV;
        writeToConn(json);
    }

    void handle_vkBindOpticalFlowSessionImageNV(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
VkOpticalFlowSessionBindingPointNV bindingPoint;
[&](){[&](){int temp_dqYOkbF;[&](){
            if (json["bindingPoint"].is_uint64()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_uint64());
            }else if (json["bindingPoint"].is_int64()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_int64());
            }else{
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_double());
            }
            }();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
VkImageView view;
[&](){deserialize_VkImageView(json["view"], view);}();
VkImageLayout layout;
[&](){[&](){int temp_IaQZtFR;[&](){
            if (json["layout"].is_uint64()){
                temp_IaQZtFR=static_cast<int>(json["layout"].get_uint64());
            }else if (json["layout"].is_int64()){
                temp_IaQZtFR=static_cast<int>(json["layout"].get_int64());
            }else{
                temp_IaQZtFR=static_cast<int>(json["layout"].get_double());
            }
            }();layout=(VkImageLayout)temp_IaQZtFR;}();}();

    PFN_vkBindOpticalFlowSessionImageNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_instance_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkBindOpticalFlowSessionImageNV)get_device_proc_addr(parent,"vkBindOpticalFlowSessionImageNV");
    }  
    
VkResult  result;
{
result=call_function(device, session, bindingPoint, view, layout);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=bindingPoint;}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=layout;}();}();}();


        json["stream_type"]=VKBINDOPTICALFLOWSESSIONIMAGENV;
        writeToConn(json);
    }

    void handle_vkCmdOpticalFlowExecuteNV(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkOpticalFlowSessionNV session;
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
 VkOpticalFlowExecuteInfoNV* pExecuteInfo;
[&](){
            if (json["pExecuteInfo"].get_array().size()==0){
                pExecuteInfo=NULL;
            return; }pExecuteInfo=(VkOpticalFlowExecuteInfoNV*)malloc(1*sizeof(VkOpticalFlowExecuteInfoNV));
        auto& arr_tbUOmHi=json["pExecuteInfo"].get_array();
        for(int HcarBbt=0; HcarBbt < 1; HcarBbt++){
            [&](){
            auto& temp=arr_tbUOmHi[HcarBbt].get_object();
            deserialize_struct(temp,pExecuteInfo[HcarBbt]);
            }();
        }
        }();

    PFN_vkCmdOpticalFlowExecuteNV call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_instance_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdOpticalFlowExecuteNV)get_device_proc_addr(parent,"vkCmdOpticalFlowExecuteNV");
    }  
    
{
call_function(commandBuffer, session, pExecuteInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=boost::json::array();
            return; }json["pExecuteInfo"]=boost::json::array(1);
        auto& arr_CyySpro=json["pExecuteInfo"].get_array();
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto& temp=arr_CyySpro[XLHKKBA].emplace_object();
            return serialize_struct(temp, pExecuteInfo[XLHKKBA]);
            }();
        }
        }();


        json["stream_type"]=VKCMDOPTICALFLOWEXECUTENV;
        writeToConn(json);
    }

    void handle_vkGetDeviceFaultInfoEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkDeviceFaultCountsEXT* pFaultCounts;
[&](){
            if (json["pFaultCounts"].get_array().size()==0){
                pFaultCounts=NULL;
            return; }pFaultCounts=(VkDeviceFaultCountsEXT*)malloc(1*sizeof(VkDeviceFaultCountsEXT));
        auto& arr_LWLqmdd=json["pFaultCounts"].get_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].get_object();
            deserialize_struct(temp,pFaultCounts[RexMRxZ]);
            }();
        }
        }();
VkDeviceFaultInfoEXT* pFaultInfo;
[&](){
            if (json["pFaultInfo"].get_array().size()==0){
                pFaultInfo=NULL;
            return; }pFaultInfo=(VkDeviceFaultInfoEXT*)malloc(1*sizeof(VkDeviceFaultInfoEXT));
        auto& arr_CRNBZxs=json["pFaultInfo"].get_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].get_object();
            deserialize_struct(temp,pFaultInfo[AHHHhvb]);
            }();
        }
        }();

    PFN_vkGetDeviceFaultInfoEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_instance_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceFaultInfoEXT)get_device_proc_addr(parent,"vkGetDeviceFaultInfoEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pFaultCounts, pFaultInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=boost::json::array();
            return; }json["pFaultCounts"]=boost::json::array(1);
        auto& arr_LWLqmdd=json["pFaultCounts"].get_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].emplace_object();
            return serialize_struct(temp, pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=boost::json::array();
            return; }json["pFaultInfo"]=boost::json::array(1);
        auto& arr_CRNBZxs=json["pFaultInfo"].get_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].emplace_object();
            return serialize_struct(temp, pFaultInfo[AHHHhvb]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEFAULTINFOEXT;
        writeToConn(json);
    }

    void handle_vkCmdSetDepthBias2EXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
 VkDepthBiasInfoEXT* pDepthBiasInfo;
[&](){
            if (json["pDepthBiasInfo"].get_array().size()==0){
                pDepthBiasInfo=NULL;
            return; }pDepthBiasInfo=(VkDepthBiasInfoEXT*)malloc(1*sizeof(VkDepthBiasInfoEXT));
        auto& arr_DfdCGqY=json["pDepthBiasInfo"].get_array();
        for(int xSRWdSz=0; xSRWdSz < 1; xSRWdSz++){
            [&](){
            auto& temp=arr_DfdCGqY[xSRWdSz].get_object();
            deserialize_struct(temp,pDepthBiasInfo[xSRWdSz]);
            }();
        }
        }();

    PFN_vkCmdSetDepthBias2EXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_instance_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdSetDepthBias2EXT)get_device_proc_addr(parent,"vkCmdSetDepthBias2EXT");
    }  
    
{
call_function(commandBuffer, pDepthBiasInfo);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=boost::json::array();
            return; }json["pDepthBiasInfo"]=boost::json::array(1);
        auto& arr_AKZgFGf=json["pDepthBiasInfo"].get_array();
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto& temp=arr_AKZgFGf[kGsXYsB].emplace_object();
            return serialize_struct(temp, pDepthBiasInfo[kGsXYsB]);
            }();
        }
        }();


        json["stream_type"]=VKCMDSETDEPTHBIAS2EXT;
        writeToConn(json);
    }

    void handle_vkReleaseSwapchainImagesEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkReleaseSwapchainImagesInfoEXT* pReleaseInfo;
[&](){
            if (json["pReleaseInfo"].get_array().size()==0){
                pReleaseInfo=NULL;
            return; }pReleaseInfo=(VkReleaseSwapchainImagesInfoEXT*)malloc(1*sizeof(VkReleaseSwapchainImagesInfoEXT));
        auto& arr_jqKJdwU=json["pReleaseInfo"].get_array();
        for(int fqZXHcz=0; fqZXHcz < 1; fqZXHcz++){
            [&](){
            auto& temp=arr_jqKJdwU[fqZXHcz].get_object();
            deserialize_struct(temp,pReleaseInfo[fqZXHcz]);
            }();
        }
        }();

    PFN_vkReleaseSwapchainImagesEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_instance_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkReleaseSwapchainImagesEXT)get_device_proc_addr(parent,"vkReleaseSwapchainImagesEXT");
    }  
    
VkResult  result;
{
result=call_function(device, pReleaseInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=boost::json::array();
            return; }json["pReleaseInfo"]=boost::json::array(1);
        auto& arr_jcnZDBn=json["pReleaseInfo"].get_array();
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto& temp=arr_jcnZDBn[dRtPqPF].emplace_object();
            return serialize_struct(temp, pReleaseInfo[dRtPqPF]);
            }();
        }
        }();


        json["stream_type"]=VKRELEASESWAPCHAINIMAGESEXT;
        writeToConn(json);
    }

    void handle_vkGetDeviceImageSubresourceLayoutKHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkDeviceImageSubresourceInfoKHR* pInfo;
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }pInfo=(VkDeviceImageSubresourceInfoKHR*)malloc(1*sizeof(VkDeviceImageSubresourceInfoKHR));
        auto& arr_TDGjppd=json["pInfo"].get_array();
        for(int irOmazS=0; irOmazS < 1; irOmazS++){
            [&](){
            auto& temp=arr_TDGjppd[irOmazS].get_object();
            deserialize_struct(temp,pInfo[irOmazS]);
            }();
        }
        }();
VkSubresourceLayout2KHR* pLayout;
[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }pLayout=(VkSubresourceLayout2KHR*)malloc(1*sizeof(VkSubresourceLayout2KHR));
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].get_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

    PFN_vkGetDeviceImageSubresourceLayoutKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_instance_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetDeviceImageSubresourceLayoutKHR)get_device_proc_addr(parent,"vkGetDeviceImageSubresourceLayoutKHR");
    }  
    
{
call_function(device, pInfo, pLayout);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_SwRDgPP=json["pInfo"].get_array();
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto& temp=arr_SwRDgPP[wxoktPv].emplace_object();
            return serialize_struct(temp, pInfo[wxoktPv]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();


        json["stream_type"]=VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR;
        writeToConn(json);
    }

    void handle_vkMapMemory2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryMapInfoKHR* pMemoryMapInfo;
[&](){
            if (json["pMemoryMapInfo"].get_array().size()==0){
                pMemoryMapInfo=NULL;
            return; }pMemoryMapInfo=(VkMemoryMapInfoKHR*)malloc(1*sizeof(VkMemoryMapInfoKHR));
        auto& arr_RTzyDuY=json["pMemoryMapInfo"].get_array();
        for(int cnbdFzc=0; cnbdFzc < 1; cnbdFzc++){
            [&](){
            auto& temp=arr_RTzyDuY[cnbdFzc].get_object();
            deserialize_struct(temp,pMemoryMapInfo[cnbdFzc]);
            }();
        }
        }();
void** ppData;
[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }ppData=(void**)malloc(1*sizeof(void*));
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].get_array().size()*sizeof(char));
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].get_array().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

    PFN_vkMapMemory2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkMapMemory2KHR)get_instance_proc_addr(parent,"vkMapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkMapMemory2KHR)get_device_proc_addr(parent,"vkMapMemory2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryMapInfo, ppData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=boost::json::array();
            return; }json["pMemoryMapInfo"]=boost::json::array(1);
        auto& arr_udcndbe=json["pMemoryMapInfo"].get_array();
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto& temp=arr_udcndbe[iwSaLAe].emplace_object();
            return serialize_struct(temp, pMemoryMapInfo[iwSaLAe]);
            }();
        }
        }();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }arr_JgRLJSK[NsRFkBj]=boost::json::array(strlen(((char*)(ppData[NsRFkBj])))+1);
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[NsRFkBj]))[jYdchEs];}();
        }
        }();}();
        }
        }();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,(uintptr_t)(*ppData));
        
        #ifndef CLIENT
            json["mem"]=(uintptr_t)(*ppData);
        #endif
        

        json["stream_type"]=VKMAPMEMORY2KHR;
        writeToConn(json);
    }

    void handle_vkUnmapMemory2KHR(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
 VkMemoryUnmapInfoKHR* pMemoryUnmapInfo;
[&](){
            if (json["pMemoryUnmapInfo"].get_array().size()==0){
                pMemoryUnmapInfo=NULL;
            return; }pMemoryUnmapInfo=(VkMemoryUnmapInfoKHR*)malloc(1*sizeof(VkMemoryUnmapInfoKHR));
        auto& arr_bpXegaD=json["pMemoryUnmapInfo"].get_array();
        for(int cntXsPf=0; cntXsPf < 1; cntXsPf++){
            [&](){
            auto& temp=arr_bpXegaD[cntXsPf].get_object();
            deserialize_struct(temp,pMemoryUnmapInfo[cntXsPf]);
            }();
        }
        }();

    PFN_vkUnmapMemory2KHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkUnmapMemory2KHR)get_instance_proc_addr(parent,"vkUnmapMemory2KHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkUnmapMemory2KHR)get_device_proc_addr(parent,"vkUnmapMemory2KHR");
    }  
    
VkResult  result;
{
result=call_function(device, pMemoryUnmapInfo);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=boost::json::array();
            return; }json["pMemoryUnmapInfo"]=boost::json::array(1);
        auto& arr_hZlnXPf=json["pMemoryUnmapInfo"].get_array();
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto& temp=arr_hZlnXPf[caczdhq].emplace_object();
            return serialize_struct(temp, pMemoryUnmapInfo[caczdhq]);
            }();
        }
        }();


        json["stream_type"]=VKUNMAPMEMORY2KHR;
        writeToConn(json);
    }

    void handle_vkCreateShadersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
uint32_t createInfoCount;
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();
 VkShaderCreateInfoEXT* pCreateInfos;
[&](){
            if (json["pCreateInfos"].get_array().size()==0){
                pCreateInfos=NULL;
            return; }pCreateInfos=(VkShaderCreateInfoEXT*)malloc(createInfoCount*sizeof(VkShaderCreateInfoEXT));
        auto& arr_aNFxtFM=json["pCreateInfos"].get_array();
        for(int IEFkbzS=0; IEFkbzS < createInfoCount; IEFkbzS++){
            [&](){
            auto& temp=arr_aNFxtFM[IEFkbzS].get_object();
            deserialize_struct(temp,pCreateInfos[IEFkbzS]);
            }();
        }
        }();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();
VkShaderEXT* pShaders;
[&](){
            if (json["pShaders"].get_array().size()==0){
                pShaders=NULL;
            return; }pShaders=(VkShaderEXT*)malloc(createInfoCount*sizeof(VkShaderEXT));
        auto& arr_ndnxxFm=json["pShaders"].get_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();

    PFN_vkCreateShadersEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCreateShadersEXT)get_instance_proc_addr(parent,"vkCreateShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCreateShadersEXT)get_device_proc_addr(parent,"vkCreateShadersEXT");
    }  
    
VkResult  result;
{
result=call_function(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_mOfZnnW=json["pCreateInfos"].get_array();
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto& temp=arr_mOfZnnW[bOiKywR].emplace_object();
            return serialize_struct(temp, pCreateInfos[bOiKywR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }json["pShaders"]=boost::json::array(createInfoCount);
        auto& arr_ndnxxFm=json["pShaders"].get_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        }();


        json["stream_type"]=VKCREATESHADERSEXT;
        writeToConn(json);
    }

    void handle_vkDestroyShaderEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
 VkAllocationCallbacks* pAllocator;
[&](){
            if (json["pAllocator"].get_array().size()==0){
                pAllocator=NULL;
            return; }pAllocator=(VkAllocationCallbacks*)malloc(1*sizeof(VkAllocationCallbacks));
        auto& arr_Zyucmmb=json["pAllocator"].get_array();
        for(int YRPmyai=0; YRPmyai < 1; YRPmyai++){
            [&](){
            auto& temp=arr_Zyucmmb[YRPmyai].get_object();
            deserialize_struct(temp,pAllocator[YRPmyai]);
            }();
        }
        }();

    PFN_vkDestroyShaderEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkDestroyShaderEXT)get_instance_proc_addr(parent,"vkDestroyShaderEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkDestroyShaderEXT)get_device_proc_addr(parent,"vkDestroyShaderEXT");
    }  
    
{
call_function(device, shader, pAllocator);
}
json.clear();

[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();


        json["stream_type"]=VKDESTROYSHADEREXT;
        writeToConn(json);
    }

    void handle_vkGetShaderBinaryDataEXT(boost::json::object& json){
    //Will only be called by the server
    
VkDevice device;
[&](){deserialize_VkDevice(json["device"], device);}();
VkShaderEXT shader;
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
size_t* pDataSize;
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }pDataSize=(size_t*)malloc(1*sizeof(size_t));
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
void* pData;
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();

    PFN_vkGetShaderBinaryDataEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_instance_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetShaderBinaryDataEXT)get_device_proc_addr(parent,"vkGetShaderBinaryDataEXT");
    }  
    
VkResult  result;
{
result=call_function(device, shader, pDataSize, pData);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();


        json["stream_type"]=VKGETSHADERBINARYDATAEXT;
        writeToConn(json);
    }

    void handle_vkCmdBindShadersEXT(boost::json::object& json){
    //Will only be called by the server
    
VkCommandBuffer commandBuffer;
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
uint32_t stageCount;
[&](){
            if (json["stageCount"].is_uint64()){
                stageCount=static_cast<uint32_t>(json["stageCount"].get_uint64());
            }else if (json["stageCount"].is_int64()){
                stageCount=static_cast<uint32_t>(json["stageCount"].get_int64());
            }else{
                stageCount=static_cast<uint32_t>(json["stageCount"].get_double());
            }
            }();
 VkShaderStageFlagBits* pStages;
[&](){
            if (json["pStages"].get_array().size()==0){
                pStages=NULL;
            return; }pStages=(VkShaderStageFlagBits*)malloc(stageCount*sizeof(VkShaderStageFlagBits));
        auto& arr_qbDLWnb=json["pStages"].get_array();
        for(int FzJYCiP=0; FzJYCiP < stageCount; FzJYCiP++){
            [&](){[&](){int temp_IwfnGxi;[&](){
            if (arr_qbDLWnb[FzJYCiP].is_uint64()){
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].get_uint64());
            }else if (arr_qbDLWnb[FzJYCiP].is_int64()){
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].get_int64());
            }else{
                temp_IwfnGxi=static_cast<int>(arr_qbDLWnb[FzJYCiP].get_double());
            }
            }();pStages[FzJYCiP]=(VkShaderStageFlagBits)temp_IwfnGxi;}();}();
        }
        }();
 VkShaderEXT* pShaders;
[&](){
            if (json["pShaders"].get_array().size()==0){
                pShaders=NULL;
            return; }pShaders=(VkShaderEXT*)malloc(stageCount*sizeof(VkShaderEXT));
        auto& arr_lXkCGqI=json["pShaders"].get_array();
        for(int DXMUrFp=0; DXMUrFp < stageCount; DXMUrFp++){
            [&](){deserialize_VkShaderEXT(arr_lXkCGqI[DXMUrFp], pShaders[DXMUrFp]);}();
        }
        }();

    PFN_vkCmdBindShadersEXT call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkCmdBindShadersEXT)get_instance_proc_addr(parent,"vkCmdBindShadersEXT");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkCmdBindShadersEXT)get_device_proc_addr(parent,"vkCmdBindShadersEXT");
    }  
    
{
call_function(commandBuffer, stageCount, pStages, pShaders);
}
json.clear();

[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=stageCount;}();
[&](){
            if (pStages==NULL){
                json["pStages"]=boost::json::array();
            return; }json["pStages"]=boost::json::array(stageCount);
        auto& arr_phXrzxO=json["pStages"].get_array();
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=pStages[uFucfxh];}();}();}();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }json["pShaders"]=boost::json::array(stageCount);
        auto& arr_ZjERyql=json["pShaders"].get_array();
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        }();


        json["stream_type"]=VKCMDBINDSHADERSEXT;
        writeToConn(json);
    }

    void handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(boost::json::object& json){
    //Will only be called by the server
    
VkPhysicalDevice physicalDevice;
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
uint32_t* pPropertyCount;
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }pPropertyCount=(uint32_t*)malloc(1*sizeof(uint32_t));
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
VkCooperativeMatrixPropertiesKHR* pProperties;
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }pProperties=(VkCooperativeMatrixPropertiesKHR*)malloc(*pPropertyCount*sizeof(VkCooperativeMatrixPropertiesKHR));
        auto& arr_PEzgESc=json["pProperties"].get_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].get_object();
            deserialize_struct(temp,pProperties[iTGjLCh]);
            }();
        }
        }();

    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR call_function;
    
    auto parent_json=json["parent"].get_object();
    if(parent_json.contains("instance")){
        VkInstance parent;
        deserialize_VkInstance(parent_json["instance"],parent);
        
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_instance_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }else if(parent_json.contains("device")){
        VkDevice parent;
        deserialize_VkDevice(parent_json["device"],parent);
        call_function=(PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)get_device_proc_addr(parent,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
    }  
    
VkResult  result;
{
result=call_function(physicalDevice, pPropertyCount, pProperties);
}
json.clear();
[&](){[&](){[&](){json["result"]=result;}();}();}();
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_PEzgESc=json["pProperties"].get_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].emplace_object();
            return serialize_struct(temp, pProperties[iTGjLCh]);
            }();
        }
        }();


        json["stream_type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR;
        writeToConn(json);
    }

void handle_command(boost::json::object json){
//Will only be called by the server

switch (static_cast<StreamType>(value_to<int>(json["stream_type"]))){


        case (VKCREATEINSTANCE):
            handle_vkCreateInstance(json);
            return;
    

        case (VKDESTROYINSTANCE):
            handle_vkDestroyInstance(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICES):
            handle_vkEnumeratePhysicalDevices(json);
            return;
    

        case (VKGETDEVICEPROCADDR):
            handle_vkGetDeviceProcAddr(json);
            return;
    

        case (VKGETINSTANCEPROCADDR):
            handle_vkGetInstanceProcAddr(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES):
            handle_vkGetPhysicalDeviceProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
            handle_vkGetPhysicalDeviceQueueFamilyProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
            handle_vkGetPhysicalDeviceMemoryProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES):
            handle_vkGetPhysicalDeviceFeatures(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceFormatProperties(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceImageFormatProperties(json);
            return;
    

        case (VKCREATEDEVICE):
            handle_vkCreateDevice(json);
            return;
    

        case (VKDESTROYDEVICE):
            handle_vkDestroyDevice(json);
            return;
    

        case (VKENUMERATEINSTANCEVERSION):
            handle_vkEnumerateInstanceVersion(json);
            return;
    

        case (VKENUMERATEINSTANCELAYERPROPERTIES):
            handle_vkEnumerateInstanceLayerProperties(json);
            return;
    

        case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
            handle_vkEnumerateInstanceExtensionProperties(json);
            return;
    

        case (VKENUMERATEDEVICELAYERPROPERTIES):
            handle_vkEnumerateDeviceLayerProperties(json);
            return;
    

        case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
            handle_vkEnumerateDeviceExtensionProperties(json);
            return;
    

        case (VKGETDEVICEQUEUE):
            handle_vkGetDeviceQueue(json);
            return;
    

        case (VKQUEUESUBMIT):
            handle_vkQueueSubmit(json);
            return;
    

        case (VKQUEUEWAITIDLE):
            handle_vkQueueWaitIdle(json);
            return;
    

        case (VKDEVICEWAITIDLE):
            handle_vkDeviceWaitIdle(json);
            return;
    

        case (VKALLOCATEMEMORY):
            handle_vkAllocateMemory(json);
            return;
    

        case (VKFREEMEMORY):
            handle_vkFreeMemory(json);
            return;
    

        case (VKMAPMEMORY):
            handle_vkMapMemory(json);
            return;
    

        case (VKUNMAPMEMORY):
            handle_vkUnmapMemory(json);
            return;
    

        case (VKFLUSHMAPPEDMEMORYRANGES):
            handle_vkFlushMappedMemoryRanges(json);
            return;
    

        case (VKINVALIDATEMAPPEDMEMORYRANGES):
            handle_vkInvalidateMappedMemoryRanges(json);
            return;
    

        case (VKGETDEVICEMEMORYCOMMITMENT):
            handle_vkGetDeviceMemoryCommitment(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS):
            handle_vkGetBufferMemoryRequirements(json);
            return;
    

        case (VKBINDBUFFERMEMORY):
            handle_vkBindBufferMemory(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS):
            handle_vkGetImageMemoryRequirements(json);
            return;
    

        case (VKBINDIMAGEMEMORY):
            handle_vkBindImageMemory(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
            handle_vkGetImageSparseMemoryRequirements(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
            handle_vkGetPhysicalDeviceSparseImageFormatProperties(json);
            return;
    

        case (VKQUEUEBINDSPARSE):
            handle_vkQueueBindSparse(json);
            return;
    

        case (VKCREATEFENCE):
            handle_vkCreateFence(json);
            return;
    

        case (VKDESTROYFENCE):
            handle_vkDestroyFence(json);
            return;
    

        case (VKRESETFENCES):
            handle_vkResetFences(json);
            return;
    

        case (VKGETFENCESTATUS):
            handle_vkGetFenceStatus(json);
            return;
    

        case (VKWAITFORFENCES):
            handle_vkWaitForFences(json);
            return;
    

        case (VKCREATESEMAPHORE):
            handle_vkCreateSemaphore(json);
            return;
    

        case (VKDESTROYSEMAPHORE):
            handle_vkDestroySemaphore(json);
            return;
    

        case (VKCREATEEVENT):
            handle_vkCreateEvent(json);
            return;
    

        case (VKDESTROYEVENT):
            handle_vkDestroyEvent(json);
            return;
    

        case (VKGETEVENTSTATUS):
            handle_vkGetEventStatus(json);
            return;
    

        case (VKSETEVENT):
            handle_vkSetEvent(json);
            return;
    

        case (VKRESETEVENT):
            handle_vkResetEvent(json);
            return;
    

        case (VKCREATEQUERYPOOL):
            handle_vkCreateQueryPool(json);
            return;
    

        case (VKDESTROYQUERYPOOL):
            handle_vkDestroyQueryPool(json);
            return;
    

        case (VKGETQUERYPOOLRESULTS):
            handle_vkGetQueryPoolResults(json);
            return;
    

        case (VKRESETQUERYPOOL):
            handle_vkResetQueryPool(json);
            return;
    

        case (VKCREATEBUFFER):
            handle_vkCreateBuffer(json);
            return;
    

        case (VKDESTROYBUFFER):
            handle_vkDestroyBuffer(json);
            return;
    

        case (VKCREATEBUFFERVIEW):
            handle_vkCreateBufferView(json);
            return;
    

        case (VKDESTROYBUFFERVIEW):
            handle_vkDestroyBufferView(json);
            return;
    

        case (VKCREATEIMAGE):
            handle_vkCreateImage(json);
            return;
    

        case (VKDESTROYIMAGE):
            handle_vkDestroyImage(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT):
            handle_vkGetImageSubresourceLayout(json);
            return;
    

        case (VKCREATEIMAGEVIEW):
            handle_vkCreateImageView(json);
            return;
    

        case (VKDESTROYIMAGEVIEW):
            handle_vkDestroyImageView(json);
            return;
    

        case (VKCREATESHADERMODULE):
            handle_vkCreateShaderModule(json);
            return;
    

        case (VKDESTROYSHADERMODULE):
            handle_vkDestroyShaderModule(json);
            return;
    

        case (VKCREATEPIPELINECACHE):
            handle_vkCreatePipelineCache(json);
            return;
    

        case (VKDESTROYPIPELINECACHE):
            handle_vkDestroyPipelineCache(json);
            return;
    

        case (VKGETPIPELINECACHEDATA):
            handle_vkGetPipelineCacheData(json);
            return;
    

        case (VKMERGEPIPELINECACHES):
            handle_vkMergePipelineCaches(json);
            return;
    

        case (VKCREATEGRAPHICSPIPELINES):
            handle_vkCreateGraphicsPipelines(json);
            return;
    

        case (VKCREATECOMPUTEPIPELINES):
            handle_vkCreateComputePipelines(json);
            return;
    

        case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
            handle_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(json);
            return;
    

        case (VKDESTROYPIPELINE):
            handle_vkDestroyPipeline(json);
            return;
    

        case (VKCREATEPIPELINELAYOUT):
            handle_vkCreatePipelineLayout(json);
            return;
    

        case (VKDESTROYPIPELINELAYOUT):
            handle_vkDestroyPipelineLayout(json);
            return;
    

        case (VKCREATESAMPLER):
            handle_vkCreateSampler(json);
            return;
    

        case (VKDESTROYSAMPLER):
            handle_vkDestroySampler(json);
            return;
    

        case (VKCREATEDESCRIPTORSETLAYOUT):
            handle_vkCreateDescriptorSetLayout(json);
            return;
    

        case (VKDESTROYDESCRIPTORSETLAYOUT):
            handle_vkDestroyDescriptorSetLayout(json);
            return;
    

        case (VKCREATEDESCRIPTORPOOL):
            handle_vkCreateDescriptorPool(json);
            return;
    

        case (VKDESTROYDESCRIPTORPOOL):
            handle_vkDestroyDescriptorPool(json);
            return;
    

        case (VKRESETDESCRIPTORPOOL):
            handle_vkResetDescriptorPool(json);
            return;
    

        case (VKALLOCATEDESCRIPTORSETS):
            handle_vkAllocateDescriptorSets(json);
            return;
    

        case (VKFREEDESCRIPTORSETS):
            handle_vkFreeDescriptorSets(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETS):
            handle_vkUpdateDescriptorSets(json);
            return;
    

        case (VKCREATEFRAMEBUFFER):
            handle_vkCreateFramebuffer(json);
            return;
    

        case (VKDESTROYFRAMEBUFFER):
            handle_vkDestroyFramebuffer(json);
            return;
    

        case (VKCREATERENDERPASS):
            handle_vkCreateRenderPass(json);
            return;
    

        case (VKDESTROYRENDERPASS):
            handle_vkDestroyRenderPass(json);
            return;
    

        case (VKGETRENDERAREAGRANULARITY):
            handle_vkGetRenderAreaGranularity(json);
            return;
    

        case (VKGETRENDERINGAREAGRANULARITYKHR):
            handle_vkGetRenderingAreaGranularityKHR(json);
            return;
    

        case (VKCREATECOMMANDPOOL):
            handle_vkCreateCommandPool(json);
            return;
    

        case (VKDESTROYCOMMANDPOOL):
            handle_vkDestroyCommandPool(json);
            return;
    

        case (VKRESETCOMMANDPOOL):
            handle_vkResetCommandPool(json);
            return;
    

        case (VKALLOCATECOMMANDBUFFERS):
            handle_vkAllocateCommandBuffers(json);
            return;
    

        case (VKFREECOMMANDBUFFERS):
            handle_vkFreeCommandBuffers(json);
            return;
    

        case (VKBEGINCOMMANDBUFFER):
            handle_vkBeginCommandBuffer(json);
            return;
    

        case (VKENDCOMMANDBUFFER):
            handle_vkEndCommandBuffer(json);
            return;
    

        case (VKRESETCOMMANDBUFFER):
            handle_vkResetCommandBuffer(json);
            return;
    

        case (VKCMDBINDPIPELINE):
            handle_vkCmdBindPipeline(json);
            return;
    

        case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
            handle_vkCmdSetAttachmentFeedbackLoopEnableEXT(json);
            return;
    

        case (VKCMDSETVIEWPORT):
            handle_vkCmdSetViewport(json);
            return;
    

        case (VKCMDSETSCISSOR):
            handle_vkCmdSetScissor(json);
            return;
    

        case (VKCMDSETLINEWIDTH):
            handle_vkCmdSetLineWidth(json);
            return;
    

        case (VKCMDSETDEPTHBIAS):
            handle_vkCmdSetDepthBias(json);
            return;
    

        case (VKCMDSETBLENDCONSTANTS):
            handle_vkCmdSetBlendConstants(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDS):
            handle_vkCmdSetDepthBounds(json);
            return;
    

        case (VKCMDSETSTENCILCOMPAREMASK):
            handle_vkCmdSetStencilCompareMask(json);
            return;
    

        case (VKCMDSETSTENCILWRITEMASK):
            handle_vkCmdSetStencilWriteMask(json);
            return;
    

        case (VKCMDSETSTENCILREFERENCE):
            handle_vkCmdSetStencilReference(json);
            return;
    

        case (VKCMDBINDDESCRIPTORSETS):
            handle_vkCmdBindDescriptorSets(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER):
            handle_vkCmdBindIndexBuffer(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS):
            handle_vkCmdBindVertexBuffers(json);
            return;
    

        case (VKCMDDRAW):
            handle_vkCmdDraw(json);
            return;
    

        case (VKCMDDRAWINDEXED):
            handle_vkCmdDrawIndexed(json);
            return;
    

        case (VKCMDDRAWMULTIEXT):
            handle_vkCmdDrawMultiEXT(json);
            return;
    

        case (VKCMDDRAWMULTIINDEXEDEXT):
            handle_vkCmdDrawMultiIndexedEXT(json);
            return;
    

        case (VKCMDDRAWINDIRECT):
            handle_vkCmdDrawIndirect(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECT):
            handle_vkCmdDrawIndexedIndirect(json);
            return;
    

        case (VKCMDDISPATCH):
            handle_vkCmdDispatch(json);
            return;
    

        case (VKCMDDISPATCHINDIRECT):
            handle_vkCmdDispatchIndirect(json);
            return;
    

        case (VKCMDSUBPASSSHADINGHUAWEI):
            handle_vkCmdSubpassShadingHUAWEI(json);
            return;
    

        case (VKCMDDRAWCLUSTERHUAWEI):
            handle_vkCmdDrawClusterHUAWEI(json);
            return;
    

        case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
            handle_vkCmdDrawClusterIndirectHUAWEI(json);
            return;
    

        case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
            handle_vkCmdUpdatePipelineIndirectBufferNV(json);
            return;
    

        case (VKCMDCOPYBUFFER):
            handle_vkCmdCopyBuffer(json);
            return;
    

        case (VKCMDCOPYIMAGE):
            handle_vkCmdCopyImage(json);
            return;
    

        case (VKCMDBLITIMAGE):
            handle_vkCmdBlitImage(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE):
            handle_vkCmdCopyBufferToImage(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER):
            handle_vkCmdCopyImageToBuffer(json);
            return;
    

        case (VKCMDCOPYMEMORYINDIRECTNV):
            handle_vkCmdCopyMemoryIndirectNV(json);
            return;
    

        case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
            handle_vkCmdCopyMemoryToImageIndirectNV(json);
            return;
    

        case (VKCMDUPDATEBUFFER):
            handle_vkCmdUpdateBuffer(json);
            return;
    

        case (VKCMDFILLBUFFER):
            handle_vkCmdFillBuffer(json);
            return;
    

        case (VKCMDCLEARCOLORIMAGE):
            handle_vkCmdClearColorImage(json);
            return;
    

        case (VKCMDCLEARDEPTHSTENCILIMAGE):
            handle_vkCmdClearDepthStencilImage(json);
            return;
    

        case (VKCMDCLEARATTACHMENTS):
            handle_vkCmdClearAttachments(json);
            return;
    

        case (VKCMDRESOLVEIMAGE):
            handle_vkCmdResolveImage(json);
            return;
    

        case (VKCMDSETEVENT):
            handle_vkCmdSetEvent(json);
            return;
    

        case (VKCMDRESETEVENT):
            handle_vkCmdResetEvent(json);
            return;
    

        case (VKCMDWAITEVENTS):
            handle_vkCmdWaitEvents(json);
            return;
    

        case (VKCMDPIPELINEBARRIER):
            handle_vkCmdPipelineBarrier(json);
            return;
    

        case (VKCMDBEGINQUERY):
            handle_vkCmdBeginQuery(json);
            return;
    

        case (VKCMDENDQUERY):
            handle_vkCmdEndQuery(json);
            return;
    

        case (VKCMDBEGINCONDITIONALRENDERINGEXT):
            handle_vkCmdBeginConditionalRenderingEXT(json);
            return;
    

        case (VKCMDENDCONDITIONALRENDERINGEXT):
            handle_vkCmdEndConditionalRenderingEXT(json);
            return;
    

        case (VKCMDRESETQUERYPOOL):
            handle_vkCmdResetQueryPool(json);
            return;
    

        case (VKCMDWRITETIMESTAMP):
            handle_vkCmdWriteTimestamp(json);
            return;
    

        case (VKCMDCOPYQUERYPOOLRESULTS):
            handle_vkCmdCopyQueryPoolResults(json);
            return;
    

        case (VKCMDPUSHCONSTANTS):
            handle_vkCmdPushConstants(json);
            return;
    

        case (VKCMDBEGINRENDERPASS):
            handle_vkCmdBeginRenderPass(json);
            return;
    

        case (VKCMDNEXTSUBPASS):
            handle_vkCmdNextSubpass(json);
            return;
    

        case (VKCMDENDRENDERPASS):
            handle_vkCmdEndRenderPass(json);
            return;
    

        case (VKCMDEXECUTECOMMANDS):
            handle_vkCmdExecuteCommands(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
            handle_vkGetPhysicalDeviceDisplayPropertiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
            handle_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(json);
            return;
    

        case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
            handle_vkGetDisplayPlaneSupportedDisplaysKHR(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIESKHR):
            handle_vkGetDisplayModePropertiesKHR(json);
            return;
    

        case (VKCREATEDISPLAYMODEKHR):
            handle_vkCreateDisplayModeKHR(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIESKHR):
            handle_vkGetDisplayPlaneCapabilitiesKHR(json);
            return;
    

        case (VKCREATEDISPLAYPLANESURFACEKHR):
            handle_vkCreateDisplayPlaneSurfaceKHR(json);
            return;
    

        case (VKCREATESHAREDSWAPCHAINSKHR):
            handle_vkCreateSharedSwapchainsKHR(json);
            return;
    

        case (VKDESTROYSURFACEKHR):
            handle_vkDestroySurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
            handle_vkGetPhysicalDeviceSurfaceSupportKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
            handle_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
            handle_vkGetPhysicalDeviceSurfaceFormatsKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
            handle_vkGetPhysicalDeviceSurfacePresentModesKHR(json);
            return;
    

        case (VKCREATESWAPCHAINKHR):
            handle_vkCreateSwapchainKHR(json);
            return;
    

        case (VKDESTROYSWAPCHAINKHR):
            handle_vkDestroySwapchainKHR(json);
            return;
    

        case (VKGETSWAPCHAINIMAGESKHR):
            handle_vkGetSwapchainImagesKHR(json);
            return;
    

        case (VKACQUIRENEXTIMAGEKHR):
            handle_vkAcquireNextImageKHR(json);
            return;
    

        case (VKQUEUEPRESENTKHR):
            handle_vkQueuePresentKHR(json);
            return;
    

        case (VKCREATEXLIBSURFACEKHR):
            handle_vkCreateXlibSurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
            handle_vkGetPhysicalDeviceXlibPresentationSupportKHR(json);
            return;
    

        case (VKCREATEXCBSURFACEKHR):
            handle_vkCreateXcbSurfaceKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
            handle_vkGetPhysicalDeviceXcbPresentationSupportKHR(json);
            return;
    

        case (VKCREATEDEBUGREPORTCALLBACKEXT):
            handle_vkCreateDebugReportCallbackEXT(json);
            return;
    

        case (VKDESTROYDEBUGREPORTCALLBACKEXT):
            handle_vkDestroyDebugReportCallbackEXT(json);
            return;
    

        case (VKDEBUGREPORTMESSAGEEXT):
            handle_vkDebugReportMessageEXT(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTNAMEEXT):
            handle_vkDebugMarkerSetObjectNameEXT(json);
            return;
    

        case (VKDEBUGMARKERSETOBJECTTAGEXT):
            handle_vkDebugMarkerSetObjectTagEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERBEGINEXT):
            handle_vkCmdDebugMarkerBeginEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERENDEXT):
            handle_vkCmdDebugMarkerEndEXT(json);
            return;
    

        case (VKCMDDEBUGMARKERINSERTEXT):
            handle_vkCmdDebugMarkerInsertEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
            handle_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(json);
            return;
    

        case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
            handle_vkCmdExecuteGeneratedCommandsNV(json);
            return;
    

        case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
            handle_vkCmdPreprocessGeneratedCommandsNV(json);
            return;
    

        case (VKCMDBINDPIPELINESHADERGROUPNV):
            handle_vkCmdBindPipelineShaderGroupNV(json);
            return;
    

        case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
            handle_vkGetGeneratedCommandsMemoryRequirementsNV(json);
            return;
    

        case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
            handle_vkCreateIndirectCommandsLayoutNV(json);
            return;
    

        case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
            handle_vkDestroyIndirectCommandsLayoutNV(json);
            return;
    

        case (VKGETPHYSICALDEVICEFEATURES2):
            handle_vkGetPhysicalDeviceFeatures2(json);
            return;
    

        case (VKGETPHYSICALDEVICEPROPERTIES2):
            handle_vkGetPhysicalDeviceProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceFormatProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceImageFormatProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
            handle_vkGetPhysicalDeviceQueueFamilyProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
            handle_vkGetPhysicalDeviceMemoryProperties2(json);
            return;
    

        case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
            handle_vkGetPhysicalDeviceSparseImageFormatProperties2(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETKHR):
            handle_vkCmdPushDescriptorSetKHR(json);
            return;
    

        case (VKTRIMCOMMANDPOOL):
            handle_vkTrimCommandPool(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
            handle_vkGetPhysicalDeviceExternalBufferProperties(json);
            return;
    

        case (VKGETMEMORYFDKHR):
            handle_vkGetMemoryFdKHR(json);
            return;
    

        case (VKGETMEMORYFDPROPERTIESKHR):
            handle_vkGetMemoryFdPropertiesKHR(json);
            return;
    

        case (VKGETMEMORYREMOTEADDRESSNV):
            handle_vkGetMemoryRemoteAddressNV(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
            handle_vkGetPhysicalDeviceExternalSemaphoreProperties(json);
            return;
    

        case (VKGETSEMAPHOREFDKHR):
            handle_vkGetSemaphoreFdKHR(json);
            return;
    

        case (VKIMPORTSEMAPHOREFDKHR):
            handle_vkImportSemaphoreFdKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
            handle_vkGetPhysicalDeviceExternalFenceProperties(json);
            return;
    

        case (VKGETFENCEFDKHR):
            handle_vkGetFenceFdKHR(json);
            return;
    

        case (VKIMPORTFENCEFDKHR):
            handle_vkImportFenceFdKHR(json);
            return;
    

        case (VKRELEASEDISPLAYEXT):
            handle_vkReleaseDisplayEXT(json);
            return;
    

        case (VKDISPLAYPOWERCONTROLEXT):
            handle_vkDisplayPowerControlEXT(json);
            return;
    

        case (VKREGISTERDEVICEEVENTEXT):
            handle_vkRegisterDeviceEventEXT(json);
            return;
    

        case (VKREGISTERDISPLAYEVENTEXT):
            handle_vkRegisterDisplayEventEXT(json);
            return;
    

        case (VKGETSWAPCHAINCOUNTEREXT):
            handle_vkGetSwapchainCounterEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
            handle_vkGetPhysicalDeviceSurfaceCapabilities2EXT(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEGROUPS):
            handle_vkEnumeratePhysicalDeviceGroups(json);
            return;
    

        case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
            handle_vkGetDeviceGroupPeerMemoryFeatures(json);
            return;
    

        case (VKBINDBUFFERMEMORY2):
            handle_vkBindBufferMemory2(json);
            return;
    

        case (VKBINDIMAGEMEMORY2):
            handle_vkBindImageMemory2(json);
            return;
    

        case (VKCMDSETDEVICEMASK):
            handle_vkCmdSetDeviceMask(json);
            return;
    

        case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
            handle_vkGetDeviceGroupPresentCapabilitiesKHR(json);
            return;
    

        case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
            handle_vkGetDeviceGroupSurfacePresentModesKHR(json);
            return;
    

        case (VKACQUIRENEXTIMAGE2KHR):
            handle_vkAcquireNextImage2KHR(json);
            return;
    

        case (VKCMDDISPATCHBASE):
            handle_vkCmdDispatchBase(json);
            return;
    

        case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
            handle_vkGetPhysicalDevicePresentRectanglesKHR(json);
            return;
    

        case (VKCREATEDESCRIPTORUPDATETEMPLATE):
            handle_vkCreateDescriptorUpdateTemplate(json);
            return;
    

        case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
            handle_vkDestroyDescriptorUpdateTemplate(json);
            return;
    

        case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
            handle_vkUpdateDescriptorSetWithTemplate(json);
            return;
    

        case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
            handle_vkCmdPushDescriptorSetWithTemplateKHR(json);
            return;
    

        case (VKSETHDRMETADATAEXT):
            handle_vkSetHdrMetadataEXT(json);
            return;
    

        case (VKGETSWAPCHAINSTATUSKHR):
            handle_vkGetSwapchainStatusKHR(json);
            return;
    

        case (VKGETREFRESHCYCLEDURATIONGOOGLE):
            handle_vkGetRefreshCycleDurationGOOGLE(json);
            return;
    

        case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
            handle_vkGetPastPresentationTimingGOOGLE(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGNV):
            handle_vkCmdSetViewportWScalingNV(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEEXT):
            handle_vkCmdSetDiscardRectangleEXT(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
            handle_vkCmdSetDiscardRectangleEnableEXT(json);
            return;
    

        case (VKCMDSETDISCARDRECTANGLEMODEEXT):
            handle_vkCmdSetDiscardRectangleModeEXT(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSEXT):
            handle_vkCmdSetSampleLocationsEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
            handle_vkGetPhysicalDeviceMultisamplePropertiesEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
            handle_vkGetPhysicalDeviceSurfaceCapabilities2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
            handle_vkGetPhysicalDeviceSurfaceFormats2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
            handle_vkGetPhysicalDeviceDisplayProperties2KHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
            handle_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(json);
            return;
    

        case (VKGETDISPLAYMODEPROPERTIES2KHR):
            handle_vkGetDisplayModeProperties2KHR(json);
            return;
    

        case (VKGETDISPLAYPLANECAPABILITIES2KHR):
            handle_vkGetDisplayPlaneCapabilities2KHR(json);
            return;
    

        case (VKGETBUFFERMEMORYREQUIREMENTS2):
            handle_vkGetBufferMemoryRequirements2(json);
            return;
    

        case (VKGETIMAGEMEMORYREQUIREMENTS2):
            handle_vkGetImageMemoryRequirements2(json);
            return;
    

        case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
            handle_vkGetImageSparseMemoryRequirements2(json);
            return;
    

        case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
            handle_vkGetDeviceBufferMemoryRequirements(json);
            return;
    

        case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
            handle_vkGetDeviceImageMemoryRequirements(json);
            return;
    

        case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
            handle_vkGetDeviceImageSparseMemoryRequirements(json);
            return;
    

        case (VKCREATESAMPLERYCBCRCONVERSION):
            handle_vkCreateSamplerYcbcrConversion(json);
            return;
    

        case (VKDESTROYSAMPLERYCBCRCONVERSION):
            handle_vkDestroySamplerYcbcrConversion(json);
            return;
    

        case (VKGETDEVICEQUEUE2):
            handle_vkGetDeviceQueue2(json);
            return;
    

        case (VKCREATEVALIDATIONCACHEEXT):
            handle_vkCreateValidationCacheEXT(json);
            return;
    

        case (VKDESTROYVALIDATIONCACHEEXT):
            handle_vkDestroyValidationCacheEXT(json);
            return;
    

        case (VKGETVALIDATIONCACHEDATAEXT):
            handle_vkGetValidationCacheDataEXT(json);
            return;
    

        case (VKMERGEVALIDATIONCACHESEXT):
            handle_vkMergeValidationCachesEXT(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
            handle_vkGetDescriptorSetLayoutSupport(json);
            return;
    

        case (VKGETSHADERINFOAMD):
            handle_vkGetShaderInfoAMD(json);
            return;
    

        case (VKSETLOCALDIMMINGAMD):
            handle_vkSetLocalDimmingAMD(json);
            return;
    

        case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
            handle_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(json);
            return;
    

        case (VKGETCALIBRATEDTIMESTAMPSEXT):
            handle_vkGetCalibratedTimestampsEXT(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTNAMEEXT):
            handle_vkSetDebugUtilsObjectNameEXT(json);
            return;
    

        case (VKSETDEBUGUTILSOBJECTTAGEXT):
            handle_vkSetDebugUtilsObjectTagEXT(json);
            return;
    

        case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
            handle_vkQueueBeginDebugUtilsLabelEXT(json);
            return;
    

        case (VKQUEUEENDDEBUGUTILSLABELEXT):
            handle_vkQueueEndDebugUtilsLabelEXT(json);
            return;
    

        case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
            handle_vkQueueInsertDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDBEGINDEBUGUTILSLABELEXT):
            handle_vkCmdBeginDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDENDDEBUGUTILSLABELEXT):
            handle_vkCmdEndDebugUtilsLabelEXT(json);
            return;
    

        case (VKCMDINSERTDEBUGUTILSLABELEXT):
            handle_vkCmdInsertDebugUtilsLabelEXT(json);
            return;
    

        case (VKCREATEDEBUGUTILSMESSENGEREXT):
            handle_vkCreateDebugUtilsMessengerEXT(json);
            return;
    

        case (VKDESTROYDEBUGUTILSMESSENGEREXT):
            handle_vkDestroyDebugUtilsMessengerEXT(json);
            return;
    

        case (VKSUBMITDEBUGUTILSMESSAGEEXT):
            handle_vkSubmitDebugUtilsMessageEXT(json);
            return;
    

        case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
            handle_vkGetMemoryHostPointerPropertiesEXT(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKERAMD):
            handle_vkCmdWriteBufferMarkerAMD(json);
            return;
    

        case (VKCREATERENDERPASS2):
            handle_vkCreateRenderPass2(json);
            return;
    

        case (VKCMDBEGINRENDERPASS2):
            handle_vkCmdBeginRenderPass2(json);
            return;
    

        case (VKCMDNEXTSUBPASS2):
            handle_vkCmdNextSubpass2(json);
            return;
    

        case (VKCMDENDRENDERPASS2):
            handle_vkCmdEndRenderPass2(json);
            return;
    

        case (VKGETSEMAPHORECOUNTERVALUE):
            handle_vkGetSemaphoreCounterValue(json);
            return;
    

        case (VKWAITSEMAPHORES):
            handle_vkWaitSemaphores(json);
            return;
    

        case (VKSIGNALSEMAPHORE):
            handle_vkSignalSemaphore(json);
            return;
    

        case (VKCMDDRAWINDIRECTCOUNT):
            handle_vkCmdDrawIndirectCount(json);
            return;
    

        case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
            handle_vkCmdDrawIndexedIndirectCount(json);
            return;
    

        case (VKCMDSETCHECKPOINTNV):
            handle_vkCmdSetCheckpointNV(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATANV):
            handle_vkGetQueueCheckpointDataNV(json);
            return;
    

        case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
            handle_vkCmdBindTransformFeedbackBuffersEXT(json);
            return;
    

        case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
            handle_vkCmdBeginTransformFeedbackEXT(json);
            return;
    

        case (VKCMDENDTRANSFORMFEEDBACKEXT):
            handle_vkCmdEndTransformFeedbackEXT(json);
            return;
    

        case (VKCMDBEGINQUERYINDEXEDEXT):
            handle_vkCmdBeginQueryIndexedEXT(json);
            return;
    

        case (VKCMDENDQUERYINDEXEDEXT):
            handle_vkCmdEndQueryIndexedEXT(json);
            return;
    

        case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
            handle_vkCmdDrawIndirectByteCountEXT(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORNV):
            handle_vkCmdSetExclusiveScissorNV(json);
            return;
    

        case (VKCMDSETEXCLUSIVESCISSORENABLENV):
            handle_vkCmdSetExclusiveScissorEnableNV(json);
            return;
    

        case (VKCMDBINDSHADINGRATEIMAGENV):
            handle_vkCmdBindShadingRateImageNV(json);
            return;
    

        case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
            handle_vkCmdSetViewportShadingRatePaletteNV(json);
            return;
    

        case (VKCMDSETCOARSESAMPLEORDERNV):
            handle_vkCmdSetCoarseSampleOrderNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSNV):
            handle_vkCmdDrawMeshTasksNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTNV):
            handle_vkCmdDrawMeshTasksIndirectNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
            handle_vkCmdDrawMeshTasksIndirectCountNV(json);
            return;
    

        case (VKCMDDRAWMESHTASKSEXT):
            handle_vkCmdDrawMeshTasksEXT(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTEXT):
            handle_vkCmdDrawMeshTasksIndirectEXT(json);
            return;
    

        case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
            handle_vkCmdDrawMeshTasksIndirectCountEXT(json);
            return;
    

        case (VKCOMPILEDEFERREDNV):
            handle_vkCompileDeferredNV(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTURENV):
            handle_vkCreateAccelerationStructureNV(json);
            return;
    

        case (VKCMDBINDINVOCATIONMASKHUAWEI):
            handle_vkCmdBindInvocationMaskHUAWEI(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTUREKHR):
            handle_vkDestroyAccelerationStructureKHR(json);
            return;
    

        case (VKDESTROYACCELERATIONSTRUCTURENV):
            handle_vkDestroyAccelerationStructureNV(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
            handle_vkGetAccelerationStructureMemoryRequirementsNV(json);
            return;
    

        case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
            handle_vkBindAccelerationStructureMemoryNV(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURENV):
            handle_vkCmdCopyAccelerationStructureNV(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
            handle_vkCmdCopyAccelerationStructureKHR(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTUREKHR):
            handle_vkCopyAccelerationStructureKHR(json);
            return;
    

        case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_vkCmdCopyAccelerationStructureToMemoryKHR(json);
            return;
    

        case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
            handle_vkCopyAccelerationStructureToMemoryKHR(json);
            return;
    

        case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_vkCmdCopyMemoryToAccelerationStructureKHR(json);
            return;
    

        case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
            handle_vkCopyMemoryToAccelerationStructureKHR(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_vkCmdWriteAccelerationStructuresPropertiesKHR(json);
            return;
    

        case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
            handle_vkCmdWriteAccelerationStructuresPropertiesNV(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURENV):
            handle_vkCmdBuildAccelerationStructureNV(json);
            return;
    

        case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
            handle_vkWriteAccelerationStructuresPropertiesKHR(json);
            return;
    

        case (VKCMDTRACERAYSKHR):
            handle_vkCmdTraceRaysKHR(json);
            return;
    

        case (VKCMDTRACERAYSNV):
            handle_vkCmdTraceRaysNV(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
            handle_vkGetRayTracingShaderGroupHandlesKHR(json);
            return;
    

        case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
            handle_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREHANDLENV):
            handle_vkGetAccelerationStructureHandleNV(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESNV):
            handle_vkCreateRayTracingPipelinesNV(json);
            return;
    

        case (VKCREATERAYTRACINGPIPELINESKHR):
            handle_vkCreateRayTracingPipelinesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
            handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECTKHR):
            handle_vkCmdTraceRaysIndirectKHR(json);
            return;
    

        case (VKCMDTRACERAYSINDIRECT2KHR):
            handle_vkCmdTraceRaysIndirect2KHR(json);
            return;
    

        case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
            handle_vkGetDeviceAccelerationStructureCompatibilityKHR(json);
            return;
    

        case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
            handle_vkGetRayTracingShaderGroupStackSizeKHR(json);
            return;
    

        case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
            handle_vkCmdSetRayTracingPipelineStackSizeKHR(json);
            return;
    

        case (VKGETIMAGEVIEWHANDLENVX):
            handle_vkGetImageViewHandleNVX(json);
            return;
    

        case (VKGETIMAGEVIEWADDRESSNVX):
            handle_vkGetImageViewAddressNVX(json);
            return;
    

        case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
            handle_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
            handle_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(json);
            return;
    

        case (VKACQUIREPROFILINGLOCKKHR):
            handle_vkAcquireProfilingLockKHR(json);
            return;
    

        case (VKRELEASEPROFILINGLOCKKHR):
            handle_vkReleaseProfilingLockKHR(json);
            return;
    

        case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
            handle_vkGetImageDrmFormatModifierPropertiesEXT(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREADDRESS):
            handle_vkGetBufferOpaqueCaptureAddress(json);
            return;
    

        case (VKGETBUFFERDEVICEADDRESS):
            handle_vkGetBufferDeviceAddress(json);
            return;
    

        case (VKCREATEHEADLESSSURFACEEXT):
            handle_vkCreateHeadlessSurfaceEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
            handle_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(json);
            return;
    

        case (VKINITIALIZEPERFORMANCEAPIINTEL):
            handle_vkInitializePerformanceApiINTEL(json);
            return;
    

        case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
            handle_vkUninitializePerformanceApiINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCEMARKERINTEL):
            handle_vkCmdSetPerformanceMarkerINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
            handle_vkCmdSetPerformanceStreamMarkerINTEL(json);
            return;
    

        case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
            handle_vkCmdSetPerformanceOverrideINTEL(json);
            return;
    

        case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
            handle_vkAcquirePerformanceConfigurationINTEL(json);
            return;
    

        case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
            handle_vkReleasePerformanceConfigurationINTEL(json);
            return;
    

        case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
            handle_vkQueueSetPerformanceConfigurationINTEL(json);
            return;
    

        case (VKGETPERFORMANCEPARAMETERINTEL):
            handle_vkGetPerformanceParameterINTEL(json);
            return;
    

        case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
            handle_vkGetDeviceMemoryOpaqueCaptureAddress(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
            handle_vkGetPipelineExecutablePropertiesKHR(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
            handle_vkGetPipelineExecutableStatisticsKHR(json);
            return;
    

        case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
            handle_vkGetPipelineExecutableInternalRepresentationsKHR(json);
            return;
    

        case (VKCMDSETLINESTIPPLEEXT):
            handle_vkCmdSetLineStippleEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICETOOLPROPERTIES):
            handle_vkGetPhysicalDeviceToolProperties(json);
            return;
    

        case (VKCREATEACCELERATIONSTRUCTUREKHR):
            handle_vkCreateAccelerationStructureKHR(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
            handle_vkCmdBuildAccelerationStructuresKHR(json);
            return;
    

        case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
            handle_vkCmdBuildAccelerationStructuresIndirectKHR(json);
            return;
    

        case (VKBUILDACCELERATIONSTRUCTURESKHR):
            handle_vkBuildAccelerationStructuresKHR(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
            handle_vkGetAccelerationStructureDeviceAddressKHR(json);
            return;
    

        case (VKCREATEDEFERREDOPERATIONKHR):
            handle_vkCreateDeferredOperationKHR(json);
            return;
    

        case (VKDESTROYDEFERREDOPERATIONKHR):
            handle_vkDestroyDeferredOperationKHR(json);
            return;
    

        case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
            handle_vkGetDeferredOperationMaxConcurrencyKHR(json);
            return;
    

        case (VKGETDEFERREDOPERATIONRESULTKHR):
            handle_vkGetDeferredOperationResultKHR(json);
            return;
    

        case (VKDEFERREDOPERATIONJOINKHR):
            handle_vkDeferredOperationJoinKHR(json);
            return;
    

        case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
            handle_vkGetPipelineIndirectMemoryRequirementsNV(json);
            return;
    

        case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
            handle_vkGetPipelineIndirectDeviceAddressNV(json);
            return;
    

        case (VKCMDSETCULLMODE):
            handle_vkCmdSetCullMode(json);
            return;
    

        case (VKCMDSETFRONTFACE):
            handle_vkCmdSetFrontFace(json);
            return;
    

        case (VKCMDSETPRIMITIVETOPOLOGY):
            handle_vkCmdSetPrimitiveTopology(json);
            return;
    

        case (VKCMDSETVIEWPORTWITHCOUNT):
            handle_vkCmdSetViewportWithCount(json);
            return;
    

        case (VKCMDSETSCISSORWITHCOUNT):
            handle_vkCmdSetScissorWithCount(json);
            return;
    

        case (VKCMDBINDINDEXBUFFER2KHR):
            handle_vkCmdBindIndexBuffer2KHR(json);
            return;
    

        case (VKCMDBINDVERTEXBUFFERS2):
            handle_vkCmdBindVertexBuffers2(json);
            return;
    

        case (VKCMDSETDEPTHTESTENABLE):
            handle_vkCmdSetDepthTestEnable(json);
            return;
    

        case (VKCMDSETDEPTHWRITEENABLE):
            handle_vkCmdSetDepthWriteEnable(json);
            return;
    

        case (VKCMDSETDEPTHCOMPAREOP):
            handle_vkCmdSetDepthCompareOp(json);
            return;
    

        case (VKCMDSETDEPTHBOUNDSTESTENABLE):
            handle_vkCmdSetDepthBoundsTestEnable(json);
            return;
    

        case (VKCMDSETSTENCILTESTENABLE):
            handle_vkCmdSetStencilTestEnable(json);
            return;
    

        case (VKCMDSETSTENCILOP):
            handle_vkCmdSetStencilOp(json);
            return;
    

        case (VKCMDSETPATCHCONTROLPOINTSEXT):
            handle_vkCmdSetPatchControlPointsEXT(json);
            return;
    

        case (VKCMDSETRASTERIZERDISCARDENABLE):
            handle_vkCmdSetRasterizerDiscardEnable(json);
            return;
    

        case (VKCMDSETDEPTHBIASENABLE):
            handle_vkCmdSetDepthBiasEnable(json);
            return;
    

        case (VKCMDSETLOGICOPEXT):
            handle_vkCmdSetLogicOpEXT(json);
            return;
    

        case (VKCMDSETPRIMITIVERESTARTENABLE):
            handle_vkCmdSetPrimitiveRestartEnable(json);
            return;
    

        case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
            handle_vkCmdSetTessellationDomainOriginEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLAMPENABLEEXT):
            handle_vkCmdSetDepthClampEnableEXT(json);
            return;
    

        case (VKCMDSETPOLYGONMODEEXT):
            handle_vkCmdSetPolygonModeEXT(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSAMPLESEXT):
            handle_vkCmdSetRasterizationSamplesEXT(json);
            return;
    

        case (VKCMDSETSAMPLEMASKEXT):
            handle_vkCmdSetSampleMaskEXT(json);
            return;
    

        case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
            handle_vkCmdSetAlphaToCoverageEnableEXT(json);
            return;
    

        case (VKCMDSETALPHATOONEENABLEEXT):
            handle_vkCmdSetAlphaToOneEnableEXT(json);
            return;
    

        case (VKCMDSETLOGICOPENABLEEXT):
            handle_vkCmdSetLogicOpEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDENABLEEXT):
            handle_vkCmdSetColorBlendEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDEQUATIONEXT):
            handle_vkCmdSetColorBlendEquationEXT(json);
            return;
    

        case (VKCMDSETCOLORWRITEMASKEXT):
            handle_vkCmdSetColorWriteMaskEXT(json);
            return;
    

        case (VKCMDSETRASTERIZATIONSTREAMEXT):
            handle_vkCmdSetRasterizationStreamEXT(json);
            return;
    

        case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
            handle_vkCmdSetConservativeRasterizationModeEXT(json);
            return;
    

        case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
            handle_vkCmdSetExtraPrimitiveOverestimationSizeEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLIPENABLEEXT):
            handle_vkCmdSetDepthClipEnableEXT(json);
            return;
    

        case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
            handle_vkCmdSetSampleLocationsEnableEXT(json);
            return;
    

        case (VKCMDSETCOLORBLENDADVANCEDEXT):
            handle_vkCmdSetColorBlendAdvancedEXT(json);
            return;
    

        case (VKCMDSETPROVOKINGVERTEXMODEEXT):
            handle_vkCmdSetProvokingVertexModeEXT(json);
            return;
    

        case (VKCMDSETLINERASTERIZATIONMODEEXT):
            handle_vkCmdSetLineRasterizationModeEXT(json);
            return;
    

        case (VKCMDSETLINESTIPPLEENABLEEXT):
            handle_vkCmdSetLineStippleEnableEXT(json);
            return;
    

        case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
            handle_vkCmdSetDepthClipNegativeOneToOneEXT(json);
            return;
    

        case (VKCMDSETVIEWPORTWSCALINGENABLENV):
            handle_vkCmdSetViewportWScalingEnableNV(json);
            return;
    

        case (VKCMDSETVIEWPORTSWIZZLENV):
            handle_vkCmdSetViewportSwizzleNV(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORENABLENV):
            handle_vkCmdSetCoverageToColorEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
            handle_vkCmdSetCoverageToColorLocationNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONMODENV):
            handle_vkCmdSetCoverageModulationModeNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
            handle_vkCmdSetCoverageModulationTableEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGEMODULATIONTABLENV):
            handle_vkCmdSetCoverageModulationTableNV(json);
            return;
    

        case (VKCMDSETSHADINGRATEIMAGEENABLENV):
            handle_vkCmdSetShadingRateImageEnableNV(json);
            return;
    

        case (VKCMDSETCOVERAGEREDUCTIONMODENV):
            handle_vkCmdSetCoverageReductionModeNV(json);
            return;
    

        case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
            handle_vkCmdSetRepresentativeFragmentTestEnableNV(json);
            return;
    

        case (VKCREATEPRIVATEDATASLOT):
            handle_vkCreatePrivateDataSlot(json);
            return;
    

        case (VKDESTROYPRIVATEDATASLOT):
            handle_vkDestroyPrivateDataSlot(json);
            return;
    

        case (VKSETPRIVATEDATA):
            handle_vkSetPrivateData(json);
            return;
    

        case (VKGETPRIVATEDATA):
            handle_vkGetPrivateData(json);
            return;
    

        case (VKCMDCOPYBUFFER2):
            handle_vkCmdCopyBuffer2(json);
            return;
    

        case (VKCMDCOPYIMAGE2):
            handle_vkCmdCopyImage2(json);
            return;
    

        case (VKCMDBLITIMAGE2):
            handle_vkCmdBlitImage2(json);
            return;
    

        case (VKCMDCOPYBUFFERTOIMAGE2):
            handle_vkCmdCopyBufferToImage2(json);
            return;
    

        case (VKCMDCOPYIMAGETOBUFFER2):
            handle_vkCmdCopyImageToBuffer2(json);
            return;
    

        case (VKCMDRESOLVEIMAGE2):
            handle_vkCmdResolveImage2(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEKHR):
            handle_vkCmdSetFragmentShadingRateKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
            handle_vkGetPhysicalDeviceFragmentShadingRatesKHR(json);
            return;
    

        case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
            handle_vkCmdSetFragmentShadingRateEnumNV(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
            handle_vkGetAccelerationStructureBuildSizesKHR(json);
            return;
    

        case (VKCMDSETVERTEXINPUTEXT):
            handle_vkCmdSetVertexInputEXT(json);
            return;
    

        case (VKCMDSETCOLORWRITEENABLEEXT):
            handle_vkCmdSetColorWriteEnableEXT(json);
            return;
    

        case (VKCMDSETEVENT2):
            handle_vkCmdSetEvent2(json);
            return;
    

        case (VKCMDRESETEVENT2):
            handle_vkCmdResetEvent2(json);
            return;
    

        case (VKCMDWAITEVENTS2):
            handle_vkCmdWaitEvents2(json);
            return;
    

        case (VKCMDPIPELINEBARRIER2):
            handle_vkCmdPipelineBarrier2(json);
            return;
    

        case (VKQUEUESUBMIT2):
            handle_vkQueueSubmit2(json);
            return;
    

        case (VKCMDWRITETIMESTAMP2):
            handle_vkCmdWriteTimestamp2(json);
            return;
    

        case (VKCMDWRITEBUFFERMARKER2AMD):
            handle_vkCmdWriteBufferMarker2AMD(json);
            return;
    

        case (VKGETQUEUECHECKPOINTDATA2NV):
            handle_vkGetQueueCheckpointData2NV(json);
            return;
    

        case (VKCOPYMEMORYTOIMAGEEXT):
            handle_vkCopyMemoryToImageEXT(json);
            return;
    

        case (VKCOPYIMAGETOMEMORYEXT):
            handle_vkCopyImageToMemoryEXT(json);
            return;
    

        case (VKCOPYIMAGETOIMAGEEXT):
            handle_vkCopyImageToImageEXT(json);
            return;
    

        case (VKTRANSITIONIMAGELAYOUTEXT):
            handle_vkTransitionImageLayoutEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
            handle_vkGetPhysicalDeviceVideoCapabilitiesKHR(json);
            return;
    

        case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
            handle_vkGetPhysicalDeviceVideoFormatPropertiesKHR(json);
            return;
    

        case (VKCREATEVIDEOSESSIONKHR):
            handle_vkCreateVideoSessionKHR(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONKHR):
            handle_vkDestroyVideoSessionKHR(json);
            return;
    

        case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
            handle_vkCreateVideoSessionParametersKHR(json);
            return;
    

        case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
            handle_vkUpdateVideoSessionParametersKHR(json);
            return;
    

        case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
            handle_vkDestroyVideoSessionParametersKHR(json);
            return;
    

        case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
            handle_vkGetVideoSessionMemoryRequirementsKHR(json);
            return;
    

        case (VKBINDVIDEOSESSIONMEMORYKHR):
            handle_vkBindVideoSessionMemoryKHR(json);
            return;
    

        case (VKCMDDECODEVIDEOKHR):
            handle_vkCmdDecodeVideoKHR(json);
            return;
    

        case (VKCMDBEGINVIDEOCODINGKHR):
            handle_vkCmdBeginVideoCodingKHR(json);
            return;
    

        case (VKCMDCONTROLVIDEOCODINGKHR):
            handle_vkCmdControlVideoCodingKHR(json);
            return;
    

        case (VKCMDENDVIDEOCODINGKHR):
            handle_vkCmdEndVideoCodingKHR(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYNV):
            handle_vkCmdDecompressMemoryNV(json);
            return;
    

        case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
            handle_vkCmdDecompressMemoryIndirectCountNV(json);
            return;
    

        case (VKCREATECUMODULENVX):
            handle_vkCreateCuModuleNVX(json);
            return;
    

        case (VKCREATECUFUNCTIONNVX):
            handle_vkCreateCuFunctionNVX(json);
            return;
    

        case (VKDESTROYCUMODULENVX):
            handle_vkDestroyCuModuleNVX(json);
            return;
    

        case (VKDESTROYCUFUNCTIONNVX):
            handle_vkDestroyCuFunctionNVX(json);
            return;
    

        case (VKCMDCULAUNCHKERNELNVX):
            handle_vkCmdCuLaunchKernelNVX(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
            handle_vkGetDescriptorSetLayoutSizeEXT(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
            handle_vkGetDescriptorSetLayoutBindingOffsetEXT(json);
            return;
    

        case (VKGETDESCRIPTOREXT):
            handle_vkGetDescriptorEXT(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFERSEXT):
            handle_vkCmdBindDescriptorBuffersEXT(json);
            return;
    

        case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
            handle_vkCmdSetDescriptorBufferOffsetsEXT(json);
            return;
    

        case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
            handle_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(json);
            return;
    

        case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetBufferOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetImageOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetImageViewOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetSamplerOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
            handle_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(json);
            return;
    

        case (VKSETDEVICEMEMORYPRIORITYEXT):
            handle_vkSetDeviceMemoryPriorityEXT(json);
            return;
    

        case (VKACQUIREDRMDISPLAYEXT):
            handle_vkAcquireDrmDisplayEXT(json);
            return;
    

        case (VKGETDRMDISPLAYEXT):
            handle_vkGetDrmDisplayEXT(json);
            return;
    

        case (VKWAITFORPRESENTKHR):
            handle_vkWaitForPresentKHR(json);
            return;
    

        case (VKCMDBEGINRENDERING):
            handle_vkCmdBeginRendering(json);
            return;
    

        case (VKCMDENDRENDERING):
            handle_vkCmdEndRendering(json);
            return;
    

        case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
            handle_vkGetDescriptorSetLayoutHostMappingInfoVALVE(json);
            return;
    

        case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
            handle_vkGetDescriptorSetHostMappingVALVE(json);
            return;
    

        case (VKCREATEMICROMAPEXT):
            handle_vkCreateMicromapEXT(json);
            return;
    

        case (VKCMDBUILDMICROMAPSEXT):
            handle_vkCmdBuildMicromapsEXT(json);
            return;
    

        case (VKBUILDMICROMAPSEXT):
            handle_vkBuildMicromapsEXT(json);
            return;
    

        case (VKDESTROYMICROMAPEXT):
            handle_vkDestroyMicromapEXT(json);
            return;
    

        case (VKCMDCOPYMICROMAPEXT):
            handle_vkCmdCopyMicromapEXT(json);
            return;
    

        case (VKCOPYMICROMAPEXT):
            handle_vkCopyMicromapEXT(json);
            return;
    

        case (VKCMDCOPYMICROMAPTOMEMORYEXT):
            handle_vkCmdCopyMicromapToMemoryEXT(json);
            return;
    

        case (VKCOPYMICROMAPTOMEMORYEXT):
            handle_vkCopyMicromapToMemoryEXT(json);
            return;
    

        case (VKCMDCOPYMEMORYTOMICROMAPEXT):
            handle_vkCmdCopyMemoryToMicromapEXT(json);
            return;
    

        case (VKCOPYMEMORYTOMICROMAPEXT):
            handle_vkCopyMemoryToMicromapEXT(json);
            return;
    

        case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
            handle_vkCmdWriteMicromapsPropertiesEXT(json);
            return;
    

        case (VKWRITEMICROMAPSPROPERTIESEXT):
            handle_vkWriteMicromapsPropertiesEXT(json);
            return;
    

        case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
            handle_vkGetDeviceMicromapCompatibilityEXT(json);
            return;
    

        case (VKGETMICROMAPBUILDSIZESEXT):
            handle_vkGetMicromapBuildSizesEXT(json);
            return;
    

        case (VKGETSHADERMODULEIDENTIFIEREXT):
            handle_vkGetShaderModuleIdentifierEXT(json);
            return;
    

        case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
            handle_vkGetShaderModuleCreateInfoIdentifierEXT(json);
            return;
    

        case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
            handle_vkGetImageSubresourceLayout2KHR(json);
            return;
    

        case (VKGETPIPELINEPROPERTIESEXT):
            handle_vkGetPipelinePropertiesEXT(json);
            return;
    

        case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
            handle_vkGetFramebufferTilePropertiesQCOM(json);
            return;
    

        case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
            handle_vkGetDynamicRenderingTilePropertiesQCOM(json);
            return;
    

        case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
            handle_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(json);
            return;
    

        case (VKCREATEOPTICALFLOWSESSIONNV):
            handle_vkCreateOpticalFlowSessionNV(json);
            return;
    

        case (VKDESTROYOPTICALFLOWSESSIONNV):
            handle_vkDestroyOpticalFlowSessionNV(json);
            return;
    

        case (VKBINDOPTICALFLOWSESSIONIMAGENV):
            handle_vkBindOpticalFlowSessionImageNV(json);
            return;
    

        case (VKCMDOPTICALFLOWEXECUTENV):
            handle_vkCmdOpticalFlowExecuteNV(json);
            return;
    

        case (VKGETDEVICEFAULTINFOEXT):
            handle_vkGetDeviceFaultInfoEXT(json);
            return;
    

        case (VKCMDSETDEPTHBIAS2EXT):
            handle_vkCmdSetDepthBias2EXT(json);
            return;
    

        case (VKRELEASESWAPCHAINIMAGESEXT):
            handle_vkReleaseSwapchainImagesEXT(json);
            return;
    

        case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
            handle_vkGetDeviceImageSubresourceLayoutKHR(json);
            return;
    

        case (VKMAPMEMORY2KHR):
            handle_vkMapMemory2KHR(json);
            return;
    

        case (VKUNMAPMEMORY2KHR):
            handle_vkUnmapMemory2KHR(json);
            return;
    

        case (VKCREATESHADERSEXT):
            handle_vkCreateShadersEXT(json);
            return;
    

        case (VKDESTROYSHADEREXT):
            handle_vkDestroyShaderEXT(json);
            return;
    

        case (VKGETSHADERBINARYDATAEXT):
            handle_vkGetShaderBinaryDataEXT(json);
            return;
    

        case (VKCMDBINDSHADERSEXT):
            handle_vkCmdBindShadersEXT(json);
            return;
    

        case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
            handle_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(json);
            return;
    
}}
#else

typedef struct {
VkInstance instance;
VkDevice device;
} parent_handle_struct;

std::map<uintptr_t,parent_handle_struct> handle_to_parent_handle_struct;


extern "C" {

VKAPI_ATTR VkResult VKAPI_CALL vk_icdNegotiateLoaderICDInterfaceVersion (uint32_t* pSupportedVersion){
    *pSupportedVersion=3;
    return VK_SUCCESS;
}

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vk_icdGetInstanceProcAddr(VkInstance instance, const char* pName){
        return vkGetInstanceProcAddr(instance,pName);
    }

__attribute__((visibility ("hidden"))) VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance ){
//Will only be called by the client
debug_printf("Executing vkCreateInstance\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEINSTANCE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_yCteunD=json["pCreateInfo"].get_array();
        for(int pSiEPar=0; pSiEPar < 1; pSiEPar++){
            [&](){
            auto& temp=arr_yCteunD[pSiEPar].emplace_object();
            return serialize_struct(temp, pCreateInfo[pSiEPar]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pInstance==NULL){
                json["pInstance"]=boost::json::array();
            return; }json["pInstance"]=boost::json::array(1);
        auto& arr_GanofFb=json["pInstance"].get_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){serialize_VkInstance(arr_GanofFb[ErvKwSS],pInstance[ErvKwSS]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}


[&](){
            if (json["pInstance"].get_array().size()==0){
                pInstance=NULL;
            return; }
        auto& arr_GanofFb=json["pInstance"].get_array();
        for(int ErvKwSS=0; ErvKwSS < 1; ErvKwSS++){
            [&](){deserialize_VkInstance(arr_GanofFb[ErvKwSS], pInstance[ErvKwSS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_enXIhAI;[&](){
            if (json["result"].is_uint64()){
                temp_enXIhAI=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_enXIhAI=static_cast<int>(json["result"].get_int64());
            }else{
                temp_enXIhAI=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_enXIhAI;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pInstance)]={.instance=(*pInstance),.device=NULL};

debug_printf("Ending vkCreateInstance...\n");
debug_printf("Return value of vkCreateInstance is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyInstance( VkInstance instance, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyInstance\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYINSTANCE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINSTANCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


debug_printf("Ending vkDestroyInstance...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDevices( VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDevices\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEPHYSICALDEVICES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceCount==NULL){
                json["pPhysicalDeviceCount"]=boost::json::array();
            return; }json["pPhysicalDeviceCount"]=boost::json::array(1);
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].get_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){arr_ngpFKeB[TRqNryD]=pPhysicalDeviceCount[TRqNryD];}();
        }
        }();
[&](){
            if (pPhysicalDevices==NULL){
                json["pPhysicalDevices"]=boost::json::array();
            return; }json["pPhysicalDevices"]=boost::json::array(*pPhysicalDeviceCount);
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].get_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){serialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY],pPhysicalDevices[ChMMltY]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceCount"].get_array().size()==0){
                pPhysicalDeviceCount=NULL;
            return; }
        auto& arr_ngpFKeB=json["pPhysicalDeviceCount"].get_array();
        for(int TRqNryD=0; TRqNryD < 1; TRqNryD++){
            [&](){
            if (arr_ngpFKeB[TRqNryD].is_uint64()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_uint64());
            }else if (arr_ngpFKeB[TRqNryD].is_int64()){
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_int64());
            }else{
                pPhysicalDeviceCount[TRqNryD]=static_cast<uint32_t>(arr_ngpFKeB[TRqNryD].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPhysicalDevices"].get_array().size()==0){
                pPhysicalDevices=NULL;
            return; }
        auto& arr_ZSQNUNc=json["pPhysicalDevices"].get_array();
        for(int ChMMltY=0; ChMMltY < *pPhysicalDeviceCount; ChMMltY++){
            [&](){deserialize_VkPhysicalDevice(arr_ZSQNUNc[ChMMltY], pPhysicalDevices[ChMMltY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lSnbIbV;[&](){
            if (json["result"].is_uint64()){
                temp_lSnbIbV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_lSnbIbV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_lSnbIbV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_lSnbIbV;}();}();

                if (pPhysicalDevices!=NULL){
                    for (int i=0; i<*pPhysicalDeviceCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPhysicalDevices[i])]=parent;
                    }
                }
                

debug_printf("Ending vkEnumeratePhysicalDevices...\n");
debug_printf("Return value of vkEnumeratePhysicalDevices is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetDeviceProcAddr( VkDevice device, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceProcAddr\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEPROCADDR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }json["pName"]=boost::json::array(strlen(pName)+1);
        auto& arr_XCtfitt=json["pName"].get_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetDeviceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) PFN_vkVoidFunction vkGetInstanceProcAddr( VkInstance instance, const char* pName ){
//Will only be called by the client
debug_printf("Executing vkGetInstanceProcAddr\n");

    boost::json::object json;
    json["stream_type"]=VKGETINSTANCEPROCADDR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pName==NULL){
                json["pName"]=boost::json::array();
            return; }json["pName"]=boost::json::array(strlen(pName)+1);
        auto& arr_XCtfitt=json["pName"].get_array();
        for(int EZmXTUp=0; EZmXTUp < strlen(pName)+1; EZmXTUp++){
            [&](){arr_XCtfitt[EZmXTUp]=pName[EZmXTUp];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETINSTANCEPROCADDR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();

PFN_vkVoidFunction result;

        if (strcmp(pName,"vk_icdNegotiateLoaderICDInterfaceVersion")==0){
            result=(PFN_vkVoidFunction)vk_icdNegotiateLoaderICDInterfaceVersion;
        }
        #ifdef VK_USE_PLATFORM_XCB_KHR
            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXcbSurfaceKHR;
            }
        #endif
        
        #ifdef VK_USE_PLATFORM_XLIB_KHR
            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                result=(PFN_vkVoidFunction)vkCreateXlibSurfaceKHR;
            }
        #endif
        

            else if (strcmp(pName,"vkCreateInstance")==0){
                debug_printf("Retrieving vkCreateInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyInstance")==0){
                debug_printf("Retrieving vkDestroyInstance...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyInstance : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDevices")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDevices...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDevices : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceProcAddr")==0){
                debug_printf("Retrieving vkGetDeviceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetInstanceProcAddr")==0){
                debug_printf("Retrieving vkGetInstanceProcAddr...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetInstanceProcAddr : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDevice")==0){
                debug_printf("Retrieving vkCreateDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDevice")==0){
                debug_printf("Retrieving vkDestroyDevice...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDevice : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceVersion")==0){
                debug_printf("Retrieving vkEnumerateInstanceVersion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceVersion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateInstanceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateInstanceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateInstanceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceLayerProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceLayerProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceLayerProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumerateDeviceExtensionProperties")==0){
                debug_printf("Retrieving vkEnumerateDeviceExtensionProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumerateDeviceExtensionProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue")==0){
                debug_printf("Retrieving vkGetDeviceQueue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit")==0){
                debug_printf("Retrieving vkQueueSubmit...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueWaitIdle")==0){
                debug_printf("Retrieving vkQueueWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeviceWaitIdle")==0){
                debug_printf("Retrieving vkDeviceWaitIdle...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeviceWaitIdle : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateMemory")==0){
                debug_printf("Retrieving vkAllocateMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeMemory")==0){
                debug_printf("Retrieving vkFreeMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory")==0){
                debug_printf("Retrieving vkMapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory")==0){
                debug_printf("Retrieving vkUnmapMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFlushMappedMemoryRanges")==0){
                debug_printf("Retrieving vkFlushMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFlushMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInvalidateMappedMemoryRanges")==0){
                debug_printf("Retrieving vkInvalidateMappedMemoryRanges...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInvalidateMappedMemoryRanges : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryCommitment")==0){
                debug_printf("Retrieving vkGetDeviceMemoryCommitment...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryCommitment : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory")==0){
                debug_printf("Retrieving vkBindBufferMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory")==0){
                debug_printf("Retrieving vkBindImageMemory...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBindSparse")==0){
                debug_printf("Retrieving vkQueueBindSparse...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBindSparse : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFence")==0){
                debug_printf("Retrieving vkCreateFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFence")==0){
                debug_printf("Retrieving vkDestroyFence...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFence : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetFences")==0){
                debug_printf("Retrieving vkResetFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceStatus")==0){
                debug_printf("Retrieving vkGetFenceStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForFences")==0){
                debug_printf("Retrieving vkWaitForFences...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForFences : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSemaphore")==0){
                debug_printf("Retrieving vkCreateSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySemaphore")==0){
                debug_printf("Retrieving vkDestroySemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateEvent")==0){
                debug_printf("Retrieving vkCreateEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyEvent")==0){
                debug_printf("Retrieving vkDestroyEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetEventStatus")==0){
                debug_printf("Retrieving vkGetEventStatus...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetEventStatus : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetEvent")==0){
                debug_printf("Retrieving vkSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetEvent")==0){
                debug_printf("Retrieving vkResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateQueryPool")==0){
                debug_printf("Retrieving vkCreateQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyQueryPool")==0){
                debug_printf("Retrieving vkDestroyQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueryPoolResults")==0){
                debug_printf("Retrieving vkGetQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetQueryPool")==0){
                debug_printf("Retrieving vkResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBuffer")==0){
                debug_printf("Retrieving vkCreateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBuffer")==0){
                debug_printf("Retrieving vkDestroyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateBufferView")==0){
                debug_printf("Retrieving vkCreateBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyBufferView")==0){
                debug_printf("Retrieving vkDestroyBufferView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyBufferView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImage")==0){
                debug_printf("Retrieving vkCreateImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImage")==0){
                debug_printf("Retrieving vkDestroyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateImageView")==0){
                debug_printf("Retrieving vkCreateImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyImageView")==0){
                debug_printf("Retrieving vkDestroyImageView...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyImageView : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShaderModule")==0){
                debug_printf("Retrieving vkCreateShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderModule")==0){
                debug_printf("Retrieving vkDestroyShaderModule...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderModule : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineCache")==0){
                debug_printf("Retrieving vkCreatePipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineCache")==0){
                debug_printf("Retrieving vkDestroyPipelineCache...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineCache : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineCacheData")==0){
                debug_printf("Retrieving vkGetPipelineCacheData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineCacheData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergePipelineCaches")==0){
                debug_printf("Retrieving vkMergePipelineCaches...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergePipelineCaches : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateGraphicsPipelines")==0){
                debug_printf("Retrieving vkCreateGraphicsPipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateGraphicsPipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateComputePipelines")==0){
                debug_printf("Retrieving vkCreateComputePipelines...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateComputePipelines : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")==0){
                debug_printf("Retrieving vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipeline")==0){
                debug_printf("Retrieving vkDestroyPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePipelineLayout")==0){
                debug_printf("Retrieving vkCreatePipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPipelineLayout")==0){
                debug_printf("Retrieving vkDestroyPipelineLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPipelineLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSampler")==0){
                debug_printf("Retrieving vkCreateSampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySampler")==0){
                debug_printf("Retrieving vkDestroySampler...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySampler : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorSetLayout")==0){
                debug_printf("Retrieving vkCreateDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorSetLayout")==0){
                debug_printf("Retrieving vkDestroyDescriptorSetLayout...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorSetLayout : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorPool")==0){
                debug_printf("Retrieving vkCreateDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorPool")==0){
                debug_printf("Retrieving vkDestroyDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetDescriptorPool")==0){
                debug_printf("Retrieving vkResetDescriptorPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetDescriptorPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateDescriptorSets")==0){
                debug_printf("Retrieving vkAllocateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeDescriptorSets")==0){
                debug_printf("Retrieving vkFreeDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSets")==0){
                debug_printf("Retrieving vkUpdateDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateFramebuffer")==0){
                debug_printf("Retrieving vkCreateFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyFramebuffer")==0){
                debug_printf("Retrieving vkDestroyFramebuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyFramebuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass")==0){
                debug_printf("Retrieving vkCreateRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyRenderPass")==0){
                debug_printf("Retrieving vkDestroyRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderAreaGranularity")==0){
                debug_printf("Retrieving vkGetRenderAreaGranularity...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderAreaGranularity : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRenderingAreaGranularityKHR")==0){
                debug_printf("Retrieving vkGetRenderingAreaGranularityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRenderingAreaGranularityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCommandPool")==0){
                debug_printf("Retrieving vkCreateCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCommandPool")==0){
                debug_printf("Retrieving vkDestroyCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandPool")==0){
                debug_printf("Retrieving vkResetCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAllocateCommandBuffers")==0){
                debug_printf("Retrieving vkAllocateCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAllocateCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkFreeCommandBuffers")==0){
                debug_printf("Retrieving vkFreeCommandBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkFreeCommandBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBeginCommandBuffer")==0){
                debug_printf("Retrieving vkBeginCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBeginCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEndCommandBuffer")==0){
                debug_printf("Retrieving vkEndCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEndCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkResetCommandBuffer")==0){
                debug_printf("Retrieving vkResetCommandBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkResetCommandBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipeline")==0){
                debug_printf("Retrieving vkCmdBindPipeline...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipeline : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAttachmentFeedbackLoopEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAttachmentFeedbackLoopEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewport")==0){
                debug_printf("Retrieving vkCmdSetViewport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissor")==0){
                debug_printf("Retrieving vkCmdSetScissor...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissor : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineWidth")==0){
                debug_printf("Retrieving vkCmdSetLineWidth...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineWidth : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias")==0){
                debug_printf("Retrieving vkCmdSetDepthBias...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetBlendConstants")==0){
                debug_printf("Retrieving vkCmdSetBlendConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetBlendConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBounds")==0){
                debug_printf("Retrieving vkCmdSetDepthBounds...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBounds : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilCompareMask")==0){
                debug_printf("Retrieving vkCmdSetStencilCompareMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilCompareMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilWriteMask")==0){
                debug_printf("Retrieving vkCmdSetStencilWriteMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilWriteMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilReference")==0){
                debug_printf("Retrieving vkCmdSetStencilReference...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilReference : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorSets")==0){
                debug_printf("Retrieving vkCmdBindDescriptorSets...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorSets : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDraw")==0){
                debug_printf("Retrieving vkCmdDraw...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDraw : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexed")==0){
                debug_printf("Retrieving vkCmdDrawIndexed...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexed : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMultiIndexedEXT")==0){
                debug_printf("Retrieving vkCmdDrawMultiIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMultiIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirect")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatch")==0){
                debug_printf("Retrieving vkCmdDispatch...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatch : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchIndirect")==0){
                debug_printf("Retrieving vkCmdDispatchIndirect...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchIndirect : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSubpassShadingHUAWEI")==0){
                debug_printf("Retrieving vkCmdSubpassShadingHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSubpassShadingHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawClusterIndirectHUAWEI")==0){
                debug_printf("Retrieving vkCmdDrawClusterIndirectHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawClusterIndirectHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdatePipelineIndirectBufferNV")==0){
                debug_printf("Retrieving vkCmdUpdatePipelineIndirectBufferNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdatePipelineIndirectBufferNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer")==0){
                debug_printf("Retrieving vkCmdCopyBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage")==0){
                debug_printf("Retrieving vkCmdCopyImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage")==0){
                debug_printf("Retrieving vkCmdBlitImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToImageIndirectNV")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToImageIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToImageIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdUpdateBuffer")==0){
                debug_printf("Retrieving vkCmdUpdateBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdUpdateBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdFillBuffer")==0){
                debug_printf("Retrieving vkCmdFillBuffer...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdFillBuffer : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearColorImage")==0){
                debug_printf("Retrieving vkCmdClearColorImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearColorImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearDepthStencilImage")==0){
                debug_printf("Retrieving vkCmdClearDepthStencilImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearDepthStencilImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdClearAttachments")==0){
                debug_printf("Retrieving vkCmdClearAttachments...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdClearAttachments : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage")==0){
                debug_printf("Retrieving vkCmdResolveImage...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent")==0){
                debug_printf("Retrieving vkCmdSetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent")==0){
                debug_printf("Retrieving vkCmdResetEvent...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents")==0){
                debug_printf("Retrieving vkCmdWaitEvents...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQuery")==0){
                debug_printf("Retrieving vkCmdBeginQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQuery")==0){
                debug_printf("Retrieving vkCmdEndQuery...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQuery : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdBeginConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndConditionalRenderingEXT")==0){
                debug_printf("Retrieving vkCmdEndConditionalRenderingEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndConditionalRenderingEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetQueryPool")==0){
                debug_printf("Retrieving vkCmdResetQueryPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetQueryPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyQueryPoolResults")==0){
                debug_printf("Retrieving vkCmdCopyQueryPoolResults...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyQueryPoolResults : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushConstants")==0){
                debug_printf("Retrieving vkCmdPushConstants...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushConstants : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass")==0){
                debug_printf("Retrieving vkCmdNextSubpass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass")==0){
                debug_printf("Retrieving vkCmdEndRenderPass...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteCommands")==0){
                debug_printf("Retrieving vkCmdExecuteCommands...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteCommands : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlanePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlanePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneSupportedDisplaysKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneSupportedDisplaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneSupportedDisplaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModePropertiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayModePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayModeKHR")==0){
                debug_printf("Retrieving vkCreateDisplayModeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayModeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDisplayPlaneSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateDisplayPlaneSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDisplayPlaneSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSharedSwapchainsKHR")==0){
                debug_printf("Retrieving vkCreateSharedSwapchainsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSharedSwapchainsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySurfaceKHR")==0){
                debug_printf("Retrieving vkDestroySurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormatsKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormatsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSwapchainKHR")==0){
                debug_printf("Retrieving vkCreateSwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySwapchainKHR")==0){
                debug_printf("Retrieving vkDestroySwapchainKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySwapchainKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainImagesKHR")==0){
                debug_printf("Retrieving vkGetSwapchainImagesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainImagesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImageKHR")==0){
                debug_printf("Retrieving vkAcquireNextImageKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImageKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueuePresentKHR")==0){
                debug_printf("Retrieving vkQueuePresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueuePresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXlibSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXlibSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXlibSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXlibPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXlibPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateXcbSurfaceKHR")==0){
                debug_printf("Retrieving vkCreateXcbSurfaceKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateXcbSurfaceKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceXcbPresentationSupportKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceXcbPresentationSupportKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkCreateDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugReportCallbackEXT")==0){
                debug_printf("Retrieving vkDestroyDebugReportCallbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugReportCallbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugReportMessageEXT")==0){
                debug_printf("Retrieving vkDebugReportMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugReportMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectNameEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDebugMarkerSetObjectTagEXT")==0){
                debug_printf("Retrieving vkDebugMarkerSetObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDebugMarkerSetObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerBeginEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerBeginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerBeginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerEndEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerEndEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerEndEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDebugMarkerInsertEXT")==0){
                debug_printf("Retrieving vkCmdDebugMarkerInsertEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDebugMarkerInsertEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalImageFormatPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalImageFormatPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdExecuteGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdExecuteGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdExecuteGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPreprocessGeneratedCommandsNV")==0){
                debug_printf("Retrieving vkCmdPreprocessGeneratedCommandsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPreprocessGeneratedCommandsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindPipelineShaderGroupNV")==0){
                debug_printf("Retrieving vkCmdBindPipelineShaderGroupNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindPipelineShaderGroupNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetGeneratedCommandsMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetGeneratedCommandsMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetGeneratedCommandsMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkCreateIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyIndirectCommandsLayoutNV")==0){
                debug_printf("Retrieving vkDestroyIndirectCommandsLayoutNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyIndirectCommandsLayoutNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFeatures2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFeatures2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFeatures2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMemoryProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMemoryProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMemoryProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSparseImageFormatProperties2")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSparseImageFormatProperties2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTrimCommandPool")==0){
                debug_printf("Retrieving vkTrimCommandPool...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTrimCommandPool : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalBufferProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalBufferProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalBufferProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryFdPropertiesKHR")==0){
                debug_printf("Retrieving vkGetMemoryFdPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryFdPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryRemoteAddressNV")==0){
                debug_printf("Retrieving vkGetMemoryRemoteAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryRemoteAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalSemaphoreProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalSemaphoreProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkGetSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportSemaphoreFdKHR")==0){
                debug_printf("Retrieving vkImportSemaphoreFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportSemaphoreFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceExternalFenceProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceExternalFenceProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceExternalFenceProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFenceFdKHR")==0){
                debug_printf("Retrieving vkGetFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkImportFenceFdKHR")==0){
                debug_printf("Retrieving vkImportFenceFdKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkImportFenceFdKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseDisplayEXT")==0){
                debug_printf("Retrieving vkReleaseDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDisplayPowerControlEXT")==0){
                debug_printf("Retrieving vkDisplayPowerControlEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDisplayPowerControlEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDeviceEventEXT")==0){
                debug_printf("Retrieving vkRegisterDeviceEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDeviceEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkRegisterDisplayEventEXT")==0){
                debug_printf("Retrieving vkRegisterDisplayEventEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkRegisterDisplayEventEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainCounterEXT")==0){
                debug_printf("Retrieving vkGetSwapchainCounterEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainCounterEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2EXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceGroups")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceGroups...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceGroups : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPeerMemoryFeatures")==0){
                debug_printf("Retrieving vkGetDeviceGroupPeerMemoryFeatures...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPeerMemoryFeatures : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindBufferMemory2")==0){
                debug_printf("Retrieving vkBindBufferMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindBufferMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindImageMemory2")==0){
                debug_printf("Retrieving vkBindImageMemory2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindImageMemory2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDeviceMask")==0){
                debug_printf("Retrieving vkCmdSetDeviceMask...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDeviceMask : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupPresentCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupPresentCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupPresentCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceGroupSurfacePresentModesKHR")==0){
                debug_printf("Retrieving vkGetDeviceGroupSurfacePresentModesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceGroupSurfacePresentModesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireNextImage2KHR")==0){
                debug_printf("Retrieving vkAcquireNextImage2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireNextImage2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDispatchBase")==0){
                debug_printf("Retrieving vkCmdDispatchBase...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDispatchBase : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDevicePresentRectanglesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDevicePresentRectanglesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDevicePresentRectanglesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkCreateDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDescriptorUpdateTemplate")==0){
                debug_printf("Retrieving vkDestroyDescriptorUpdateTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDescriptorUpdateTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateDescriptorSetWithTemplate")==0){
                debug_printf("Retrieving vkUpdateDescriptorSetWithTemplate...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateDescriptorSetWithTemplate : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPushDescriptorSetWithTemplateKHR")==0){
                debug_printf("Retrieving vkCmdPushDescriptorSetWithTemplateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPushDescriptorSetWithTemplateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetHdrMetadataEXT")==0){
                debug_printf("Retrieving vkSetHdrMetadataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetHdrMetadataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSwapchainStatusKHR")==0){
                debug_printf("Retrieving vkGetSwapchainStatusKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSwapchainStatusKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRefreshCycleDurationGOOGLE")==0){
                debug_printf("Retrieving vkGetRefreshCycleDurationGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRefreshCycleDurationGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPastPresentationTimingGOOGLE")==0){
                debug_printf("Retrieving vkGetPastPresentationTimingGOOGLE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPastPresentationTimingGOOGLE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDiscardRectangleModeEXT")==0){
                debug_printf("Retrieving vkCmdSetDiscardRectangleModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDiscardRectangleModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceMultisamplePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceMultisamplePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSurfaceFormats2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSurfaceFormats2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceDisplayPlaneProperties2KHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceDisplayPlaneProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayModeProperties2KHR")==0){
                debug_printf("Retrieving vkGetDisplayModeProperties2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayModeProperties2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDisplayPlaneCapabilities2KHR")==0){
                debug_printf("Retrieving vkGetDisplayPlaneCapabilities2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDisplayPlaneCapabilities2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetBufferMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSparseMemoryRequirements2")==0){
                debug_printf("Retrieving vkGetImageSparseMemoryRequirements2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSparseMemoryRequirements2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceBufferMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceBufferMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceBufferMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSparseMemoryRequirements")==0){
                debug_printf("Retrieving vkGetDeviceImageSparseMemoryRequirements...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSparseMemoryRequirements : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateSamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkCreateSamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateSamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroySamplerYcbcrConversion")==0){
                debug_printf("Retrieving vkDestroySamplerYcbcrConversion...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroySamplerYcbcrConversion : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceQueue2")==0){
                debug_printf("Retrieving vkGetDeviceQueue2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceQueue2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateValidationCacheEXT")==0){
                debug_printf("Retrieving vkCreateValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyValidationCacheEXT")==0){
                debug_printf("Retrieving vkDestroyValidationCacheEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyValidationCacheEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetValidationCacheDataEXT")==0){
                debug_printf("Retrieving vkGetValidationCacheDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetValidationCacheDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMergeValidationCachesEXT")==0){
                debug_printf("Retrieving vkMergeValidationCachesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMergeValidationCachesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSupport")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSupport...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSupport : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderInfoAMD")==0){
                debug_printf("Retrieving vkGetShaderInfoAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderInfoAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetLocalDimmingAMD")==0){
                debug_printf("Retrieving vkSetLocalDimmingAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetLocalDimmingAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCalibrateableTimeDomainsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetCalibratedTimestampsEXT")==0){
                debug_printf("Retrieving vkGetCalibratedTimestampsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetCalibratedTimestampsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectNameEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectNameEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectNameEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDebugUtilsObjectTagEXT")==0){
                debug_printf("Retrieving vkSetDebugUtilsObjectTagEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDebugUtilsObjectTagEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkQueueInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdBeginDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdEndDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdInsertDebugUtilsLabelEXT")==0){
                debug_printf("Retrieving vkCmdInsertDebugUtilsLabelEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdInsertDebugUtilsLabelEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkCreateDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDebugUtilsMessengerEXT")==0){
                debug_printf("Retrieving vkDestroyDebugUtilsMessengerEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDebugUtilsMessengerEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSubmitDebugUtilsMessageEXT")==0){
                debug_printf("Retrieving vkSubmitDebugUtilsMessageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSubmitDebugUtilsMessageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMemoryHostPointerPropertiesEXT")==0){
                debug_printf("Retrieving vkGetMemoryHostPointerPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMemoryHostPointerPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarkerAMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarkerAMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarkerAMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRenderPass2")==0){
                debug_printf("Retrieving vkCreateRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRenderPass2")==0){
                debug_printf("Retrieving vkCmdBeginRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdNextSubpass2")==0){
                debug_printf("Retrieving vkCmdNextSubpass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdNextSubpass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRenderPass2")==0){
                debug_printf("Retrieving vkCmdEndRenderPass2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRenderPass2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSemaphoreCounterValue")==0){
                debug_printf("Retrieving vkGetSemaphoreCounterValue...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSemaphoreCounterValue : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitSemaphores")==0){
                debug_printf("Retrieving vkWaitSemaphores...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitSemaphores : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSignalSemaphore")==0){
                debug_printf("Retrieving vkSignalSemaphore...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSignalSemaphore : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndexedIndirectCount")==0){
                debug_printf("Retrieving vkCmdDrawIndexedIndirectCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndexedIndirectCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCheckpointNV")==0){
                debug_printf("Retrieving vkCmdSetCheckpointNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCheckpointNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointDataNV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointDataNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointDataNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindTransformFeedbackBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindTransformFeedbackBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindTransformFeedbackBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdBeginTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndTransformFeedbackEXT")==0){
                debug_printf("Retrieving vkCmdEndTransformFeedbackEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndTransformFeedbackEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdBeginQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndQueryIndexedEXT")==0){
                debug_printf("Retrieving vkCmdEndQueryIndexedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndQueryIndexedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawIndirectByteCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawIndirectByteCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawIndirectByteCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExclusiveScissorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetExclusiveScissorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExclusiveScissorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadingRateImageNV")==0){
                debug_printf("Retrieving vkCmdBindShadingRateImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadingRateImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportShadingRatePaletteNV")==0){
                debug_printf("Retrieving vkCmdSetViewportShadingRatePaletteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportShadingRatePaletteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoarseSampleOrderNV")==0){
                debug_printf("Retrieving vkCmdSetCoarseSampleOrderNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoarseSampleOrderNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDrawMeshTasksIndirectCountEXT")==0){
                debug_printf("Retrieving vkCmdDrawMeshTasksIndirectCountEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDrawMeshTasksIndirectCountEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCompileDeferredNV")==0){
                debug_printf("Retrieving vkCompileDeferredNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCompileDeferredNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindInvocationMaskHUAWEI")==0){
                debug_printf("Retrieving vkCmdBindInvocationMaskHUAWEI...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindInvocationMaskHUAWEI : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkDestroyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindAccelerationStructureMemoryNV")==0){
                debug_printf("Retrieving vkBindAccelerationStructureMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindAccelerationStructureMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCmdCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyAccelerationStructureToMemoryKHR")==0){
                debug_printf("Retrieving vkCopyAccelerationStructureToMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyAccelerationStructureToMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCopyMemoryToAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteAccelerationStructuresPropertiesNV")==0){
                debug_printf("Retrieving vkCmdWriteAccelerationStructuresPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteAccelerationStructuresPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructureNV")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructureNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructureNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteAccelerationStructuresPropertiesKHR")==0){
                debug_printf("Retrieving vkWriteAccelerationStructuresPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteAccelerationStructuresPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysNV")==0){
                debug_printf("Retrieving vkCmdTraceRaysNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")==0){
                debug_printf("Retrieving vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingCaptureReplayShaderGroupHandlesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureHandleNV")==0){
                debug_printf("Retrieving vkGetAccelerationStructureHandleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureHandleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesNV")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateRayTracingPipelinesKHR")==0){
                debug_printf("Retrieving vkCreateRayTracingPipelinesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateRayTracingPipelinesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirectKHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdTraceRaysIndirect2KHR")==0){
                debug_printf("Retrieving vkCmdTraceRaysIndirect2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdTraceRaysIndirect2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceAccelerationStructureCompatibilityKHR")==0){
                debug_printf("Retrieving vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceAccelerationStructureCompatibilityKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetRayTracingShaderGroupStackSizeKHR")==0){
                debug_printf("Retrieving vkGetRayTracingShaderGroupStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetRayTracingShaderGroupStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRayTracingPipelineStackSizeKHR")==0){
                debug_printf("Retrieving vkCmdSetRayTracingPipelineStackSizeKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRayTracingPipelineStackSizeKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewHandleNVX")==0){
                debug_printf("Retrieving vkGetImageViewHandleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewHandleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewAddressNVX")==0){
                debug_printf("Retrieving vkGetImageViewAddressNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewAddressNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")==0){
                debug_printf("Retrieving vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireProfilingLockKHR")==0){
                debug_printf("Retrieving vkAcquireProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseProfilingLockKHR")==0){
                debug_printf("Retrieving vkReleaseProfilingLockKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseProfilingLockKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageDrmFormatModifierPropertiesEXT")==0){
                debug_printf("Retrieving vkGetImageDrmFormatModifierPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageDrmFormatModifierPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferDeviceAddress")==0){
                debug_printf("Retrieving vkGetBufferDeviceAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferDeviceAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateHeadlessSurfaceEXT")==0){
                debug_printf("Retrieving vkCreateHeadlessSurfaceEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateHeadlessSurfaceEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkInitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkInitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkInitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUninitializePerformanceApiINTEL")==0){
                debug_printf("Retrieving vkUninitializePerformanceApiINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUninitializePerformanceApiINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceStreamMarkerINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceStreamMarkerINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceStreamMarkerINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPerformanceOverrideINTEL")==0){
                debug_printf("Retrieving vkCmdSetPerformanceOverrideINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPerformanceOverrideINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquirePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkAcquirePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquirePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleasePerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkReleasePerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleasePerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSetPerformanceConfigurationINTEL")==0){
                debug_printf("Retrieving vkQueueSetPerformanceConfigurationINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSetPerformanceConfigurationINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPerformanceParameterINTEL")==0){
                debug_printf("Retrieving vkGetPerformanceParameterINTEL...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPerformanceParameterINTEL : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMemoryOpaqueCaptureAddress")==0){
                debug_printf("Retrieving vkGetDeviceMemoryOpaqueCaptureAddress...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMemoryOpaqueCaptureAddress : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutablePropertiesKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutablePropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutablePropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableStatisticsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableStatisticsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableStatisticsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineExecutableInternalRepresentationsKHR")==0){
                debug_printf("Retrieving vkGetPipelineExecutableInternalRepresentationsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineExecutableInternalRepresentationsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceToolProperties")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceToolProperties...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceToolProperties : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateAccelerationStructureKHR")==0){
                debug_printf("Retrieving vkCreateAccelerationStructureKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateAccelerationStructureKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildAccelerationStructuresIndirectKHR")==0){
                debug_printf("Retrieving vkCmdBuildAccelerationStructuresIndirectKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildAccelerationStructuresIndirectKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildAccelerationStructuresKHR")==0){
                debug_printf("Retrieving vkBuildAccelerationStructuresKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildAccelerationStructuresKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureDeviceAddressKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureDeviceAddressKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureDeviceAddressKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateDeferredOperationKHR")==0){
                debug_printf("Retrieving vkCreateDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyDeferredOperationKHR")==0){
                debug_printf("Retrieving vkDestroyDeferredOperationKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyDeferredOperationKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationMaxConcurrencyKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationMaxConcurrencyKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationMaxConcurrencyKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeferredOperationResultKHR")==0){
                debug_printf("Retrieving vkGetDeferredOperationResultKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeferredOperationResultKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDeferredOperationJoinKHR")==0){
                debug_printf("Retrieving vkDeferredOperationJoinKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDeferredOperationJoinKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectMemoryRequirementsNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectMemoryRequirementsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectMemoryRequirementsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelineIndirectDeviceAddressNV")==0){
                debug_printf("Retrieving vkGetPipelineIndirectDeviceAddressNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelineIndirectDeviceAddressNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCullMode")==0){
                debug_printf("Retrieving vkCmdSetCullMode...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCullMode : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFrontFace")==0){
                debug_printf("Retrieving vkCmdSetFrontFace...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFrontFace : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveTopology")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveTopology...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveTopology : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWithCount")==0){
                debug_printf("Retrieving vkCmdSetViewportWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetScissorWithCount")==0){
                debug_printf("Retrieving vkCmdSetScissorWithCount...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetScissorWithCount : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindIndexBuffer2KHR")==0){
                debug_printf("Retrieving vkCmdBindIndexBuffer2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindIndexBuffer2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindVertexBuffers2")==0){
                debug_printf("Retrieving vkCmdBindVertexBuffers2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindVertexBuffers2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthWriteEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthWriteEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthWriteEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthCompareOp")==0){
                debug_printf("Retrieving vkCmdSetDepthCompareOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthCompareOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBoundsTestEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBoundsTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBoundsTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilTestEnable")==0){
                debug_printf("Retrieving vkCmdSetStencilTestEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilTestEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetStencilOp")==0){
                debug_printf("Retrieving vkCmdSetStencilOp...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetStencilOp : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPatchControlPointsEXT")==0){
                debug_printf("Retrieving vkCmdSetPatchControlPointsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPatchControlPointsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizerDiscardEnable")==0){
                debug_printf("Retrieving vkCmdSetRasterizerDiscardEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizerDiscardEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBiasEnable")==0){
                debug_printf("Retrieving vkCmdSetDepthBiasEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBiasEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPrimitiveRestartEnable")==0){
                debug_printf("Retrieving vkCmdSetPrimitiveRestartEnable...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPrimitiveRestartEnable : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetTessellationDomainOriginEXT")==0){
                debug_printf("Retrieving vkCmdSetTessellationDomainOriginEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetTessellationDomainOriginEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClampEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClampEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClampEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetPolygonModeEXT")==0){
                debug_printf("Retrieving vkCmdSetPolygonModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetPolygonModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationSamplesEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationSamplesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationSamplesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToCoverageEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToCoverageEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToCoverageEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetAlphaToOneEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetAlphaToOneEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetAlphaToOneEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLogicOpEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLogicOpEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLogicOpEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendEquationEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendEquationEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendEquationEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteMaskEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteMaskEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteMaskEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRasterizationStreamEXT")==0){
                debug_printf("Retrieving vkCmdSetRasterizationStreamEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRasterizationStreamEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetConservativeRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetConservativeRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetConservativeRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetExtraPrimitiveOverestimationSizeEXT")==0){
                debug_printf("Retrieving vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetExtraPrimitiveOverestimationSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetSampleLocationsEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetSampleLocationsEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetSampleLocationsEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorBlendAdvancedEXT")==0){
                debug_printf("Retrieving vkCmdSetColorBlendAdvancedEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorBlendAdvancedEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetProvokingVertexModeEXT")==0){
                debug_printf("Retrieving vkCmdSetProvokingVertexModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetProvokingVertexModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineRasterizationModeEXT")==0){
                debug_printf("Retrieving vkCmdSetLineRasterizationModeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineRasterizationModeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetLineStippleEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetLineStippleEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetLineStippleEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthClipNegativeOneToOneEXT")==0){
                debug_printf("Retrieving vkCmdSetDepthClipNegativeOneToOneEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthClipNegativeOneToOneEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportWScalingEnableNV")==0){
                debug_printf("Retrieving vkCmdSetViewportWScalingEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportWScalingEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetViewportSwizzleNV")==0){
                debug_printf("Retrieving vkCmdSetViewportSwizzleNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetViewportSwizzleNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageToColorLocationNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageToColorLocationNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageToColorLocationNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableEnableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageModulationTableNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageModulationTableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageModulationTableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetShadingRateImageEnableNV")==0){
                debug_printf("Retrieving vkCmdSetShadingRateImageEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetShadingRateImageEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetCoverageReductionModeNV")==0){
                debug_printf("Retrieving vkCmdSetCoverageReductionModeNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetCoverageReductionModeNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetRepresentativeFragmentTestEnableNV")==0){
                debug_printf("Retrieving vkCmdSetRepresentativeFragmentTestEnableNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetRepresentativeFragmentTestEnableNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreatePrivateDataSlot")==0){
                debug_printf("Retrieving vkCreatePrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreatePrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyPrivateDataSlot")==0){
                debug_printf("Retrieving vkDestroyPrivateDataSlot...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyPrivateDataSlot : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetPrivateData")==0){
                debug_printf("Retrieving vkSetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPrivateData")==0){
                debug_printf("Retrieving vkGetPrivateData...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPrivateData : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImage2")==0){
                debug_printf("Retrieving vkCmdCopyImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBlitImage2")==0){
                debug_printf("Retrieving vkCmdBlitImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBlitImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyBufferToImage2")==0){
                debug_printf("Retrieving vkCmdCopyBufferToImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyBufferToImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyImageToBuffer2")==0){
                debug_printf("Retrieving vkCmdCopyImageToBuffer2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyImageToBuffer2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResolveImage2")==0){
                debug_printf("Retrieving vkCmdResolveImage2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResolveImage2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateKHR")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceFragmentShadingRatesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceFragmentShadingRatesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetFragmentShadingRateEnumNV")==0){
                debug_printf("Retrieving vkCmdSetFragmentShadingRateEnumNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetFragmentShadingRateEnumNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureBuildSizesKHR")==0){
                debug_printf("Retrieving vkGetAccelerationStructureBuildSizesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureBuildSizesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetVertexInputEXT")==0){
                debug_printf("Retrieving vkCmdSetVertexInputEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetVertexInputEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetColorWriteEnableEXT")==0){
                debug_printf("Retrieving vkCmdSetColorWriteEnableEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetColorWriteEnableEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetEvent2")==0){
                debug_printf("Retrieving vkCmdSetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdResetEvent2")==0){
                debug_printf("Retrieving vkCmdResetEvent2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdResetEvent2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWaitEvents2")==0){
                debug_printf("Retrieving vkCmdWaitEvents2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWaitEvents2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdPipelineBarrier2")==0){
                debug_printf("Retrieving vkCmdPipelineBarrier2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdPipelineBarrier2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkQueueSubmit2")==0){
                debug_printf("Retrieving vkQueueSubmit2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkQueueSubmit2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteTimestamp2")==0){
                debug_printf("Retrieving vkCmdWriteTimestamp2...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteTimestamp2 : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteBufferMarker2AMD")==0){
                debug_printf("Retrieving vkCmdWriteBufferMarker2AMD...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteBufferMarker2AMD : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetQueueCheckpointData2NV")==0){
                debug_printf("Retrieving vkGetQueueCheckpointData2NV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetQueueCheckpointData2NV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToImageEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyImageToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyImageToImageEXT")==0){
                debug_printf("Retrieving vkCopyImageToImageEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyImageToImageEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkTransitionImageLayoutEXT")==0){
                debug_printf("Retrieving vkTransitionImageLayoutEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkTransitionImageLayoutEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoCapabilitiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoCapabilitiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceVideoFormatPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceVideoFormatPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkCreateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUpdateVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkUpdateVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUpdateVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyVideoSessionParametersKHR")==0){
                debug_printf("Retrieving vkDestroyVideoSessionParametersKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyVideoSessionParametersKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetVideoSessionMemoryRequirementsKHR")==0){
                debug_printf("Retrieving vkGetVideoSessionMemoryRequirementsKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetVideoSessionMemoryRequirementsKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindVideoSessionMemoryKHR")==0){
                debug_printf("Retrieving vkBindVideoSessionMemoryKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindVideoSessionMemoryKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecodeVideoKHR")==0){
                debug_printf("Retrieving vkCmdDecodeVideoKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecodeVideoKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdBeginVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdControlVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdControlVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdControlVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndVideoCodingKHR")==0){
                debug_printf("Retrieving vkCmdEndVideoCodingKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndVideoCodingKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdDecompressMemoryIndirectCountNV")==0){
                debug_printf("Retrieving vkCmdDecompressMemoryIndirectCountNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdDecompressMemoryIndirectCountNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuModuleNVX")==0){
                debug_printf("Retrieving vkCreateCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateCuFunctionNVX")==0){
                debug_printf("Retrieving vkCreateCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuModuleNVX")==0){
                debug_printf("Retrieving vkDestroyCuModuleNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuModuleNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyCuFunctionNVX")==0){
                debug_printf("Retrieving vkDestroyCuFunctionNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyCuFunctionNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCuLaunchKernelNVX")==0){
                debug_printf("Retrieving vkCmdCuLaunchKernelNVX...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCuLaunchKernelNVX : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutSizeEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutSizeEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutSizeEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutBindingOffsetEXT")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutBindingOffsetEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorEXT")==0){
                debug_printf("Retrieving vkGetDescriptorEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBuffersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBuffersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBuffersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDescriptorBufferOffsetsEXT")==0){
                debug_printf("Retrieving vkCmdSetDescriptorBufferOffsetsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDescriptorBufferOffsetsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindDescriptorBufferEmbeddedSamplersEXT")==0){
                debug_printf("Retrieving vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindDescriptorBufferEmbeddedSamplersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetBufferOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetBufferOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageViewOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageViewOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetSamplerOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetSamplerOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")==0){
                debug_printf("Retrieving vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkSetDeviceMemoryPriorityEXT")==0){
                debug_printf("Retrieving vkSetDeviceMemoryPriorityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkSetDeviceMemoryPriorityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkAcquireDrmDisplayEXT")==0){
                debug_printf("Retrieving vkAcquireDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkAcquireDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDrmDisplayEXT")==0){
                debug_printf("Retrieving vkGetDrmDisplayEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDrmDisplayEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWaitForPresentKHR")==0){
                debug_printf("Retrieving vkWaitForPresentKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWaitForPresentKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBeginRendering")==0){
                debug_printf("Retrieving vkCmdBeginRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBeginRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdEndRendering")==0){
                debug_printf("Retrieving vkCmdEndRendering...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdEndRendering : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetLayoutHostMappingInfoVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetLayoutHostMappingInfoVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDescriptorSetHostMappingVALVE")==0){
                debug_printf("Retrieving vkGetDescriptorSetHostMappingVALVE...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDescriptorSetHostMappingVALVE : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateMicromapEXT")==0){
                debug_printf("Retrieving vkCreateMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkCmdBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBuildMicromapsEXT")==0){
                debug_printf("Retrieving vkBuildMicromapsEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBuildMicromapsEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyMicromapEXT")==0){
                debug_printf("Retrieving vkDestroyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCmdCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMicromapToMemoryEXT")==0){
                debug_printf("Retrieving vkCopyMicromapToMemoryEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMicromapToMemoryEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCmdCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCopyMemoryToMicromapEXT")==0){
                debug_printf("Retrieving vkCopyMemoryToMicromapEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCopyMemoryToMicromapEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkCmdWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkWriteMicromapsPropertiesEXT")==0){
                debug_printf("Retrieving vkWriteMicromapsPropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkWriteMicromapsPropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceMicromapCompatibilityEXT")==0){
                debug_printf("Retrieving vkGetDeviceMicromapCompatibilityEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceMicromapCompatibilityEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetMicromapBuildSizesEXT")==0){
                debug_printf("Retrieving vkGetMicromapBuildSizesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetMicromapBuildSizesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderModuleCreateInfoIdentifierEXT")==0){
                debug_printf("Retrieving vkGetShaderModuleCreateInfoIdentifierEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderModuleCreateInfoIdentifierEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetImageSubresourceLayout2KHR")==0){
                debug_printf("Retrieving vkGetImageSubresourceLayout2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetImageSubresourceLayout2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPipelinePropertiesEXT")==0){
                debug_printf("Retrieving vkGetPipelinePropertiesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPipelinePropertiesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetFramebufferTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetFramebufferTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetFramebufferTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDynamicRenderingTilePropertiesQCOM")==0){
                debug_printf("Retrieving vkGetDynamicRenderingTilePropertiesQCOM...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDynamicRenderingTilePropertiesQCOM : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceOpticalFlowImageFormatsNV")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceOpticalFlowImageFormatsNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkCreateOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyOpticalFlowSessionNV")==0){
                debug_printf("Retrieving vkDestroyOpticalFlowSessionNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyOpticalFlowSessionNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkBindOpticalFlowSessionImageNV")==0){
                debug_printf("Retrieving vkBindOpticalFlowSessionImageNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkBindOpticalFlowSessionImageNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdOpticalFlowExecuteNV")==0){
                debug_printf("Retrieving vkCmdOpticalFlowExecuteNV...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdOpticalFlowExecuteNV : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceFaultInfoEXT")==0){
                debug_printf("Retrieving vkGetDeviceFaultInfoEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceFaultInfoEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdSetDepthBias2EXT")==0){
                debug_printf("Retrieving vkCmdSetDepthBias2EXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdSetDepthBias2EXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkReleaseSwapchainImagesEXT")==0){
                debug_printf("Retrieving vkReleaseSwapchainImagesEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkReleaseSwapchainImagesEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetDeviceImageSubresourceLayoutKHR")==0){
                debug_printf("Retrieving vkGetDeviceImageSubresourceLayoutKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetDeviceImageSubresourceLayoutKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkMapMemory2KHR")==0){
                debug_printf("Retrieving vkMapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkMapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkUnmapMemory2KHR")==0){
                debug_printf("Retrieving vkUnmapMemory2KHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkUnmapMemory2KHR : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCreateShadersEXT")==0){
                debug_printf("Retrieving vkCreateShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCreateShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkDestroyShaderEXT")==0){
                debug_printf("Retrieving vkDestroyShaderEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkDestroyShaderEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetShaderBinaryDataEXT")==0){
                debug_printf("Retrieving vkGetShaderBinaryDataEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetShaderBinaryDataEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkCmdBindShadersEXT")==0){
                debug_printf("Retrieving vkCmdBindShadersEXT...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkCmdBindShadersEXT : NULL; //We keep track of dispatch separately
                
            }
            

            else if (strcmp(pName,"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")==0){
                debug_printf("Retrieving vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
                result= (value_to<uintptr_t>(json["result"])!=(uintptr_t)NULL) ? (PFN_vkVoidFunction)vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR : NULL; //We keep track of dispatch separately
                
            }
            

            else {
                debug_printf("Unknown function: %s\n", pName);
                result=NULL;
            }
            
            debug_printf("Address of ProcAddr: %p\n",result);
        

debug_printf("Ending vkGetInstanceProcAddr...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_rSttUuQ=json["pProperties"].get_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].emplace_object();
            return serialize_struct(temp, pProperties[RBAofpr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_rSttUuQ=json["pProperties"].get_array();
        for(int RBAofpr=0; RBAofpr < 1; RBAofpr++){
            [&](){
            auto& temp=arr_rSttUuQ[RBAofpr].get_object();
            deserialize_struct(temp,pProperties[RBAofpr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }json["pQueueFamilyPropertyCount"]=boost::json::array(1);
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }json["pQueueFamilyProperties"]=boost::json::array(*pQueueFamilyPropertyCount);
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].get_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].get_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_uint64());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_int64());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].get_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }
        auto& arr_ixxluvk=json["pQueueFamilyProperties"].get_array();
        for(int WYdxXmB=0; WYdxXmB < *pQueueFamilyPropertyCount; WYdxXmB++){
            [&](){
            auto& temp=arr_ixxluvk[WYdxXmB].get_object();
            deserialize_struct(temp,pQueueFamilyProperties[WYdxXmB]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }json["pMemoryProperties"]=boost::json::array(1);
        auto& arr_cVJWqPt=json["pMemoryProperties"].get_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].emplace_object();
            return serialize_struct(temp, pMemoryProperties[iqfYjRc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].get_array().size()==0){
                pMemoryProperties=NULL;
            return; }
        auto& arr_cVJWqPt=json["pMemoryProperties"].get_array();
        for(int iqfYjRc=0; iqfYjRc < 1; iqfYjRc++){
            [&](){
            auto& temp=arr_cVJWqPt[iqfYjRc].get_object();
            deserialize_struct(temp,pMemoryProperties[iqfYjRc]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEFEATURES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }json["pFeatures"]=boost::json::array(1);
        auto& arr_MNJcbZO=json["pFeatures"].get_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].emplace_object();
            return serialize_struct(temp, pFeatures[IqPoadP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].get_array().size()==0){
                pFeatures=NULL;
            return; }
        auto& arr_MNJcbZO=json["pFeatures"].get_array();
        for(int IqPoadP=0; IqPoadP < 1; IqPoadP++){
            [&](){
            auto& temp=arr_MNJcbZO[IqPoadP].get_object();
            deserialize_struct(temp,pFeatures[IqPoadP]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }json["pFormatProperties"]=boost::json::array(1);
        auto& arr_ktGodop=json["pFormatProperties"].get_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].emplace_object();
            return serialize_struct(temp, pFormatProperties[CLkwuSw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].get_array().size()==0){
                pFormatProperties=NULL;
            return; }
        auto& arr_ktGodop=json["pFormatProperties"].get_array();
        for(int CLkwuSw=0; CLkwuSw < 1; CLkwuSw++){
            [&](){
            auto& temp=arr_ktGodop[CLkwuSw].get_object();
            deserialize_struct(temp,pFormatProperties[CLkwuSw]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(1);
        auto& arr_sBgMBXU=json["pImageFormatProperties"].get_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_sBgMBXU=json["pImageFormatProperties"].get_array();
        for(int hhYjZOs=0; hhYjZOs < 1; hhYjZOs++){
            [&](){
            auto& temp=arr_sBgMBXU[hhYjZOs].get_object();
            deserialize_struct(temp,pImageFormatProperties[hhYjZOs]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_Fblblty;[&](){
            if (json["result"].is_uint64()){
                temp_Fblblty=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_Fblblty=static_cast<int>(json["result"].get_int64());
            }else{
                temp_Fblblty=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_Fblblty;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDevice( VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice ){
//Will only be called by the client
debug_printf("Executing vkCreateDevice\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDEVICE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TuuJAwt=json["pCreateInfo"].get_array();
        for(int Ktbkccz=0; Ktbkccz < 1; Ktbkccz++){
            [&](){
            auto& temp=arr_TuuJAwt[Ktbkccz].emplace_object();
            return serialize_struct(temp, pCreateInfo[Ktbkccz]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDevice==NULL){
                json["pDevice"]=boost::json::array();
            return; }json["pDevice"]=boost::json::array(1);
        auto& arr_WTIobJE=json["pDevice"].get_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){serialize_VkDevice(arr_WTIobJE[okBORdn],pDevice[okBORdn]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();


[&](){
            if (json["pDevice"].get_array().size()==0){
                pDevice=NULL;
            return; }
        auto& arr_WTIobJE=json["pDevice"].get_array();
        for(int okBORdn=0; okBORdn < 1; okBORdn++){
            [&](){deserialize_VkDevice(arr_WTIobJE[okBORdn], pDevice[okBORdn]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_arnVPXd;[&](){
            if (json["result"].is_uint64()){
                temp_arnVPXd=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_arnVPXd=static_cast<int>(json["result"].get_int64());
            }else{
                temp_arnVPXd=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_arnVPXd;}();}();
handle_to_parent_handle_struct[(uintptr_t)(*pDevice)]={.instance=NULL,.device=(*pDevice) };
registerDevice(*pDevice,physicalDevice);

debug_printf("Ending vkCreateDevice...\n");
debug_printf("Return value of vkCreateDevice is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDevice( VkDevice device, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDevice\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDEVICE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEVICE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


debug_printf("Ending vkDestroyDevice...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceVersion( uint32_t* pApiVersion ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceVersion\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEINSTANCEVERSION;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pApiVersion==NULL){
                json["pApiVersion"]=boost::json::array();
            return; }json["pApiVersion"]=boost::json::array(1);
        auto& arr_qBCKjKo=json["pApiVersion"].get_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){arr_qBCKjKo[KJjQFCs]=pApiVersion[KJjQFCs];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){
            if (json["pApiVersion"].get_array().size()==0){
                pApiVersion=NULL;
            return; }
        auto& arr_qBCKjKo=json["pApiVersion"].get_array();
        for(int KJjQFCs=0; KJjQFCs < 1; KJjQFCs++){
            [&](){
            if (arr_qBCKjKo[KJjQFCs].is_uint64()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_uint64());
            }else if (arr_qBCKjKo[KJjQFCs].is_int64()){
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_int64());
            }else{
                pApiVersion[KJjQFCs]=static_cast<uint32_t>(arr_qBCKjKo[KJjQFCs].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YOjYIAv;[&](){
            if (json["result"].is_uint64()){
                temp_YOjYIAv=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_YOjYIAv=static_cast<int>(json["result"].get_int64());
            }else{
                temp_YOjYIAv=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_YOjYIAv;}();}();

debug_printf("Ending vkEnumerateInstanceVersion...\n");
debug_printf("Return value of vkEnumerateInstanceVersion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceLayerProperties( uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceLayerProperties\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEINSTANCELAYERPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    
parent_json["instance"]=(uintptr_t)NULL;
{
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].get_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_npLpYVw;[&](){
            if (json["result"].is_uint64()){
                temp_npLpYVw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_npLpYVw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_npLpYVw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_npLpYVw;}();}();

debug_printf("Ending vkEnumerateInstanceLayerProperties...\n");
debug_printf("Return value of vkEnumerateInstanceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateInstanceExtensionProperties( const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateInstanceExtensionProperties\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEINSTANCEEXTENSIONPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    
parent_json["instance"]=(uintptr_t)NULL;

        if(pProperties==NULL){
            const uint32_t DEFAULT_PROPERTIES_LENGTH=100;
            pProperties=(VkExtensionProperties*)malloc(DEFAULT_PROPERTIES_LENGTH*sizeof(VkExtensionProperties));
            *pPropertyCount=DEFAULT_PROPERTIES_LENGTH;
            
            for (uint32_t i=0; i<*pPropertyCount; i++){
                pProperties[i]=VkExtensionProperties();
            }
        }
        
        uint32_t len_of_properties_array=*pPropertyCount;
        
{
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }json["pLayerName"]=boost::json::array(strlen(pLayerName)+1);
        auto& arr_xWfwWBl=json["pLayerName"].get_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEINSTANCEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}

[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].get_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();

        std::set<std::string> propertiesSet;
        for(uint32_t i=0; i<*pPropertyCount; i++){
            propertiesSet.insert(std::string(pProperties[i].extensionName));
        }
        

            #ifdef VK_USE_PLATFORM_XLIB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XLIB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XLIB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XLIB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            

            #ifdef VK_USE_PLATFORM_XCB_KHR
                if(!propertiesSet.contains(std::string(VK_KHR_XCB_SURFACE_EXTENSION_NAME))){
                    if (*pPropertyCount<len_of_properties_array){
                        auto property=VkExtensionProperties();
                        strcpy(property.extensionName,VK_KHR_XCB_SURFACE_EXTENSION_NAME);
                        property.specVersion=VK_KHR_XCB_SURFACE_SPEC_VERSION;
                        pProperties[*pPropertyCount]=property;
                        *pPropertyCount=*pPropertyCount+1;
                    }
                }
            #endif
            
VkResult result;
[&](){[&](){int temp_niAjHXZ;[&](){
            if (json["result"].is_uint64()){
                temp_niAjHXZ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_niAjHXZ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_niAjHXZ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_niAjHXZ;}();}();

debug_printf("Ending vkEnumerateInstanceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateInstanceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceLayerProperties( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceLayerProperties\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEDEVICELAYERPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].emplace_object();
            return serialize_struct(temp, pProperties[AVcpYdO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICELAYERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_AKGITwD=json["pProperties"].get_array();
        for(int AVcpYdO=0; AVcpYdO < *pPropertyCount; AVcpYdO++){
            [&](){
            auto& temp=arr_AKGITwD[AVcpYdO].get_object();
            deserialize_struct(temp,pProperties[AVcpYdO]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_GURLKJj;[&](){
            if (json["result"].is_uint64()){
                temp_GURLKJj=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_GURLKJj=static_cast<int>(json["result"].get_int64());
            }else{
                temp_GURLKJj=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_GURLKJj;}();}();

debug_printf("Ending vkEnumerateDeviceLayerProperties...\n");
debug_printf("Return value of vkEnumerateDeviceLayerProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumerateDeviceExtensionProperties( VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumerateDeviceExtensionProperties\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEDEVICEEXTENSIONPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pLayerName==NULL){
                json["pLayerName"]=boost::json::array();
            return; }json["pLayerName"]=boost::json::array(strlen(pLayerName)+1);
        auto& arr_xWfwWBl=json["pLayerName"].get_array();
        for(int EYxuOlw=0; EYxuOlw < strlen(pLayerName)+1; EYxuOlw++){
            [&](){arr_xWfwWBl[EYxuOlw]=pLayerName[EYxuOlw];}();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].emplace_object();
            return serialize_struct(temp, pProperties[oiKhvHw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEDEVICEEXTENSIONPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_yJzeHZb=json["pProperties"].get_array();
        for(int oiKhvHw=0; oiKhvHw < *pPropertyCount; oiKhvHw++){
            [&](){
            auto& temp=arr_yJzeHZb[oiKhvHw].get_object();
            deserialize_struct(temp,pProperties[oiKhvHw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_VtyFKEt;[&](){
            if (json["result"].is_uint64()){
                temp_VtyFKEt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VtyFKEt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VtyFKEt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VtyFKEt;}();}();

debug_printf("Ending vkEnumerateDeviceExtensionProperties...\n");
debug_printf("Return value of vkEnumerateDeviceExtensionProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue( VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEQUEUE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){json["queueIndex"]=queueIndex;}();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }json["pQueue"]=boost::json::array(1);
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
[&](){
            if (json["queueIndex"].is_uint64()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_uint64());
            }else if (json["queueIndex"].is_int64()){
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_int64());
            }else{
                queueIndex=static_cast<uint32_t>(json["queueIndex"].get_double());
            }
            }();
[&](){
            if (json["pQueue"].get_array().size()==0){
                pQueue=NULL;
            return; }
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

                if (pQueue!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueue[i])]=parent;
                    }
                }
                

debug_printf("Ending vkGetDeviceQueue...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit( VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit\n");
MemoryMapLock.lock_shared();

    boost::json::object json;
    json["stream_type"]=VKQUEUESUBMIT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }json["pSubmits"]=boost::json::array(submitCount);
        auto& arr_kYcwgKD=json["pSubmits"].get_array();
        for(int FrUhwZA=0; FrUhwZA < submitCount; FrUhwZA++){
            [&](){
            auto& temp=arr_kYcwgKD[FrUhwZA].emplace_object();
            return serialize_struct(temp, pSubmits[FrUhwZA]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}
SyncAll();


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["submitCount"].is_uint64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_uint64());
            }else if (json["submitCount"].is_int64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_int64());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].get_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_xDkRYSw;[&](){
            if (json["result"].is_uint64()){
                temp_xDkRYSw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_xDkRYSw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_xDkRYSw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_xDkRYSw;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkQueueSubmit...\n");
debug_printf("Return value of vkQueueSubmit is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueWaitIdle( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueWaitIdle\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEWAITIDLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
VkResult result;
[&](){[&](){int temp_tolQiBl;[&](){
            if (json["result"].is_uint64()){
                temp_tolQiBl=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_tolQiBl=static_cast<int>(json["result"].get_int64());
            }else{
                temp_tolQiBl=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_tolQiBl;}();}();

debug_printf("Ending vkQueueWaitIdle...\n");
debug_printf("Return value of vkQueueWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeviceWaitIdle( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkDeviceWaitIdle\n");

    boost::json::object json;
    json["stream_type"]=VKDEVICEWAITIDLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEVICEWAITIDLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
VkResult result;
[&](){[&](){int temp_acLKDuP;[&](){
            if (json["result"].is_uint64()){
                temp_acLKDuP=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_acLKDuP=static_cast<int>(json["result"].get_int64());
            }else{
                temp_acLKDuP=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_acLKDuP;}();}();

waitForCounterIdle(device);
debug_printf("Ending vkDeviceWaitIdle...\n");
debug_printf("Return value of vkDeviceWaitIdle is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateMemory( VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory ){
//Will only be called by the client
debug_printf("Executing vkAllocateMemory\n");

    boost::json::object json;
    json["stream_type"]=VKALLOCATEMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_NGCHnPz=json["pAllocateInfo"].get_array();
        for(int MAXIAGO=0; MAXIAGO < 1; MAXIAGO++){
            [&](){
            auto& temp=arr_NGCHnPz[MAXIAGO].emplace_object();
            return serialize_struct(temp, pAllocateInfo[MAXIAGO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMemory==NULL){
                json["pMemory"]=boost::json::array();
            return; }json["pMemory"]=boost::json::array(1);
        auto& arr_JqUSUSb=json["pMemory"].get_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){serialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV],pMemory[iFmVAsV]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMemory"].get_array().size()==0){
                pMemory=NULL;
            return; }
        auto& arr_JqUSUSb=json["pMemory"].get_array();
        for(int iFmVAsV=0; iFmVAsV < 1; iFmVAsV++){
            [&](){deserialize_VkDeviceMemory(arr_JqUSUSb[iFmVAsV], pMemory[iFmVAsV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_PToClmy;[&](){
            if (json["result"].is_uint64()){
                temp_PToClmy=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_PToClmy=static_cast<int>(json["result"].get_int64());
            }else{
                temp_PToClmy=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_PToClmy;}();}();
registerDeviceMemory(*pMemory, pAllocateInfo->allocationSize);

debug_printf("Ending vkAllocateMemory...\n");
debug_printf("Return value of vkAllocateMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeMemory( VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkFreeMemory\n");

    boost::json::object json;
    json["stream_type"]=VKFREEMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}
vkUnmapMemory(device,memory);


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();


debug_printf("Ending vkFreeMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory( VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory\n");
MemoryMapLock.lock();

    boost::json::object json;
    json["stream_type"]=VKMAPMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        

        if (size==VK_WHOLE_SIZE){
            size=devicememory_to_size[(uintptr_t)memory]-offset;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_syvZTtN=json["ppData"].get_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (ppData[weOJAdg]==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[weOJAdg]))==NULL){
                arr_syvZTtN[weOJAdg]=boost::json::array();
            return; }arr_syvZTtN[weOJAdg]=boost::json::array(size);
        auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].get_array();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[weOJAdg]))[jYdchEs];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_UEEqVUK;[&](){
            if (json["flags"].is_uint64()){
                temp_UEEqVUK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_UEEqVUK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_UEEqVUK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkMemoryMapFlags)temp_UEEqVUK;}();}();
[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_syvZTtN=json["ppData"].get_array();
        for(int weOJAdg=0; weOJAdg < 1; weOJAdg++){
            [&](){
            if (arr_syvZTtN[weOJAdg].get_array().size()==0){
                ppData[weOJAdg]=NULL;
            return; }char* temp_syvZTtN;[&](){
            if (arr_syvZTtN[weOJAdg].get_array().size()==0){
                temp_syvZTtN=NULL;
            return; }temp_syvZTtN=(char*)malloc(size*sizeof(char));
        auto& arr_vLfeDBZ=arr_syvZTtN[weOJAdg].get_array();
        for(int jYdchEs=0; jYdchEs < size; jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_syvZTtN[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[weOJAdg]=temp_syvZTtN;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_wvjjzvw;[&](){
            if (json["result"].is_uint64()){
                temp_wvjjzvw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_wvjjzvw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_wvjjzvw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_wvjjzvw;}();}();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, memory,size,*ppData,value_to<uintptr_t>(json["mem"]));
        
        #ifndef CLIENT
            json["mem"]=value_to<uintptr_t>(json["mem"]);
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory...\n");
debug_printf("Return value of vkMapMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUnmapMemory( VkDevice device, VkDeviceMemory memory ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory\n");
MemoryMapLock.lock();

    boost::json::object json;
    json["stream_type"]=VKUNMAPMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
}
deregisterDeviceMemoryMap(memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkFlushMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkFlushMappedMemoryRanges\n");

    boost::json::object json;
    json["stream_type"]=VKFLUSHMAPPEDMEMORYRANGES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }json["pMemoryRanges"]=boost::json::array(memoryRangeCount);
        auto& arr_sKDZFVw=json["pMemoryRanges"].get_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFLUSHMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["memoryRangeCount"].is_uint64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_uint64());
            }else if (json["memoryRangeCount"].is_int64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_int64());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_trVQekJ;[&](){
            if (json["result"].is_uint64()){
                temp_trVQekJ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_trVQekJ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_trVQekJ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_trVQekJ;}();}();

debug_printf("Ending vkFlushMappedMemoryRanges...\n");
debug_printf("Return value of vkFlushMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInvalidateMappedMemoryRanges( VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges ){
//Will only be called by the client
debug_printf("Executing vkInvalidateMappedMemoryRanges\n");

    boost::json::object json;
    json["stream_type"]=VKINVALIDATEMAPPEDMEMORYRANGES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["memoryRangeCount"]=memoryRangeCount;}();
[&](){
            if (pMemoryRanges==NULL){
                json["pMemoryRanges"]=boost::json::array();
            return; }json["pMemoryRanges"]=boost::json::array(memoryRangeCount);
        auto& arr_sKDZFVw=json["pMemoryRanges"].get_array();
        for(int GdhGpVL=0; GdhGpVL < memoryRangeCount; GdhGpVL++){
            [&](){
            auto& temp=arr_sKDZFVw[GdhGpVL].emplace_object();
            return serialize_struct(temp, pMemoryRanges[GdhGpVL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINVALIDATEMAPPEDMEMORYRANGES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["memoryRangeCount"].is_uint64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_uint64());
            }else if (json["memoryRangeCount"].is_int64()){
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_int64());
            }else{
                memoryRangeCount=static_cast<uint32_t>(json["memoryRangeCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_jVSAMPV;[&](){
            if (json["result"].is_uint64()){
                temp_jVSAMPV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_jVSAMPV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_jVSAMPV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_jVSAMPV;}();}();

debug_printf("Ending vkInvalidateMappedMemoryRanges...\n");
debug_printf("Return value of vkInvalidateMappedMemoryRanges is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMemoryCommitment( VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryCommitment\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEMEMORYCOMMITMENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){
            if (pCommittedMemoryInBytes==NULL){
                json["pCommittedMemoryInBytes"]=boost::json::array();
            return; }json["pCommittedMemoryInBytes"]=boost::json::array(1);
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].get_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){[&](){arr_BkHcKeY[iEYXrVv]=pCommittedMemoryInBytes[iEYXrVv];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYCOMMITMENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){
            if (json["pCommittedMemoryInBytes"].get_array().size()==0){
                pCommittedMemoryInBytes=NULL;
            return; }
        auto& arr_BkHcKeY=json["pCommittedMemoryInBytes"].get_array();
        for(int iEYXrVv=0; iEYXrVv < 1; iEYXrVv++){
            [&](){uint64_t temp_BkHcKeY;[&](){
            if (arr_BkHcKeY[iEYXrVv].is_uint64()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_uint64());
            }else if (arr_BkHcKeY[iEYXrVv].is_int64()){
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_int64());
            }else{
                temp_BkHcKeY=static_cast<uint64_t>(arr_BkHcKeY[iEYXrVv].get_double());
            }
            }();pCommittedMemoryInBytes[iEYXrVv]=(VkDeviceSize)temp_BkHcKeY;}();
        }
        }();

debug_printf("Ending vkGetDeviceMemoryCommitment...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements( VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETBUFFERMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].get_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory( VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory\n");

    boost::json::object json;
    json["stream_type"]=VKBINDBUFFERMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_uint64());
            }else if (json["memoryOffset"].is_int64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_int64());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_vWIXPNS;[&](){
            if (json["result"].is_uint64()){
                temp_vWIXPNS=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vWIXPNS=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vWIXPNS=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vWIXPNS;}();}();

debug_printf("Ending vkBindBufferMemory...\n");
debug_printf("Return value of vkBindBufferMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements( VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[VeirrNu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_qQjUyYD=json["pMemoryRequirements"].get_array();
        for(int VeirrNu=0; VeirrNu < 1; VeirrNu++){
            [&](){
            auto& temp=arr_qQjUyYD[VeirrNu].get_object();
            deserialize_struct(temp,pMemoryRequirements[VeirrNu]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory( VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory\n");

    boost::json::object json;
    json["stream_type"]=VKBINDIMAGEMEMORY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){[&](){json["memoryOffset"]=memoryOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){uint64_t temp_yVqWYJm;[&](){
            if (json["memoryOffset"].is_uint64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_uint64());
            }else if (json["memoryOffset"].is_int64()){
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_int64());
            }else{
                temp_yVqWYJm=static_cast<uint64_t>(json["memoryOffset"].get_double());
            }
            }();memoryOffset=(VkDeviceSize)temp_yVqWYJm;}();
VkResult result;
[&](){[&](){int temp_DPbOQkR;[&](){
            if (json["result"].is_uint64()){
                temp_DPbOQkR=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_DPbOQkR=static_cast<int>(json["result"].get_int64());
            }else{
                temp_DPbOQkR=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_DPbOQkR;}();}();

debug_printf("Ending vkBindImageMemory...\n");
debug_printf("Return value of vkBindImageMemory is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements( VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].get_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_gCgbiZM=json["pSparseMemoryRequirements"].get_array();
        for(int HKRWUBR=0; HKRWUBR < *pSparseMemoryRequirementCount; HKRWUBR++){
            [&](){
            auto& temp=arr_gCgbiZM[HKRWUBR].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[HKRWUBR]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_jINYdYP=json["pProperties"].get_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].emplace_object();
            return serialize_struct(temp, pProperties[BOLcXca]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_jINYdYP=json["pProperties"].get_array();
        for(int BOLcXca=0; BOLcXca < *pPropertyCount; BOLcXca++){
            [&](){
            auto& temp=arr_jINYdYP[BOLcXca].get_object();
            deserialize_struct(temp,pProperties[BOLcXca]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkQueueBindSparse( VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueBindSparse\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEBINDSPARSE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfo==NULL){
                json["pBindInfo"]=boost::json::array();
            return; }json["pBindInfo"]=boost::json::array(bindInfoCount);
        auto& arr_eUGJCxJ=json["pBindInfo"].get_array();
        for(int ujBkVap=0; ujBkVap < bindInfoCount; ujBkVap++){
            [&](){
            auto& temp=arr_eUGJCxJ[ujBkVap].emplace_object();
            return serialize_struct(temp, pBindInfo[ujBkVap]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBINDSPARSE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_PpQvdMQ;[&](){
            if (json["result"].is_uint64()){
                temp_PpQvdMQ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_PpQvdMQ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_PpQvdMQ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_PpQvdMQ;}();}();

debug_printf("Ending vkQueueBindSparse...\n");
debug_printf("Return value of vkQueueBindSparse is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFence( VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkCreateFence\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEFENCE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_qbBwXza=json["pCreateInfo"].get_array();
        for(int kPSKeJY=0; kPSKeJY < 1; kPSKeJY++){
            [&](){
            auto& temp=arr_qbBwXza[kPSKeJY].emplace_object();
            return serialize_struct(temp, pCreateInfo[kPSKeJY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GExdWhT;[&](){
            if (json["result"].is_uint64()){
                temp_GExdWhT=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_GExdWhT=static_cast<int>(json["result"].get_int64());
            }else{
                temp_GExdWhT=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_GExdWhT;}();}();

                if (pFence!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFence[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFence...\n");
debug_printf("Return value of vkCreateFence is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFence( VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFence\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYFENCE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();


debug_printf("Ending vkDestroyFence...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences ){
//Will only be called by the client
debug_printf("Executing vkResetFences\n");

    boost::json::object json;
    json["stream_type"]=VKRESETFENCES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }json["pFences"]=boost::json::array(fenceCount);
        auto& arr_UUllwqV=json["pFences"].get_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["fenceCount"].is_uint64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_uint64());
            }else if (json["fenceCount"].is_int64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_int64());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_vPmZsFt;[&](){
            if (json["result"].is_uint64()){
                temp_vPmZsFt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vPmZsFt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vPmZsFt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vPmZsFt;}();}();

debug_printf("Ending vkResetFences...\n");
debug_printf("Return value of vkResetFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceStatus( VkDevice device, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkGetFenceStatus\n");

    boost::json::object json;
    json["stream_type"]=VKGETFENCESTATUS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCESTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_kFznveb;[&](){
            if (json["result"].is_uint64()){
                temp_kFznveb=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_kFznveb=static_cast<int>(json["result"].get_int64());
            }else{
                temp_kFznveb=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_kFznveb;}();}();

debug_printf("Ending vkGetFenceStatus...\n");
debug_printf("Return value of vkGetFenceStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForFences( VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForFences\n");
MemoryMapLock.lock_shared();

    boost::json::object json;
    json["stream_type"]=VKWAITFORFENCES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["fenceCount"]=fenceCount;}();
[&](){
            if (pFences==NULL){
                json["pFences"]=boost::json::array();
            return; }json["pFences"]=boost::json::array(fenceCount);
        auto& arr_UUllwqV=json["pFences"].get_array();
        for(int dVDBacx=0; dVDBacx < fenceCount; dVDBacx++){
            [&](){serialize_VkFence(arr_UUllwqV[dVDBacx],pFences[dVDBacx]);}();
        }
        }();
[&](){[&](){json["waitAll"]=waitAll;}();}();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORFENCES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["fenceCount"].is_uint64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_uint64());
            }else if (json["fenceCount"].is_int64()){
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_int64());
            }else{
                fenceCount=static_cast<uint32_t>(json["fenceCount"].get_double());
            }
            }();

[&](){uint32_t temp_pqKsrTL;[&](){
            if (json["waitAll"].is_uint64()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_uint64());
            }else if (json["waitAll"].is_int64()){
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_int64());
            }else{
                temp_pqKsrTL=static_cast<uint32_t>(json["waitAll"].get_double());
            }
            }();waitAll=(VkBool32)temp_pqKsrTL;}();
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_iXmjtzl;[&](){
            if (json["result"].is_uint64()){
                temp_iXmjtzl=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_iXmjtzl=static_cast<int>(json["result"].get_int64());
            }else{
                temp_iXmjtzl=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_iXmjtzl;}();}();

MemoryMapLock.unlock_shared();
debug_printf("Ending vkWaitForFences...\n");
debug_printf("Return value of vkWaitForFences is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSemaphore( VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore ){
//Will only be called by the client
debug_printf("Executing vkCreateSemaphore\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESEMAPHORE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_hQVwpIP=json["pCreateInfo"].get_array();
        for(int TzTYDbe=0; TzTYDbe < 1; TzTYDbe++){
            [&](){
            auto& temp=arr_hQVwpIP[TzTYDbe].emplace_object();
            return serialize_struct(temp, pCreateInfo[TzTYDbe]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSemaphore==NULL){
                json["pSemaphore"]=boost::json::array();
            return; }json["pSemaphore"]=boost::json::array(1);
        auto& arr_rvNHvxY=json["pSemaphore"].get_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){serialize_VkSemaphore(arr_rvNHvxY[lrrAvof],pSemaphore[lrrAvof]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSemaphore"].get_array().size()==0){
                pSemaphore=NULL;
            return; }
        auto& arr_rvNHvxY=json["pSemaphore"].get_array();
        for(int lrrAvof=0; lrrAvof < 1; lrrAvof++){
            [&](){deserialize_VkSemaphore(arr_rvNHvxY[lrrAvof], pSemaphore[lrrAvof]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_oYhdFMQ;[&](){
            if (json["result"].is_uint64()){
                temp_oYhdFMQ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_oYhdFMQ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_oYhdFMQ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_oYhdFMQ;}();}();

                if (pSemaphore!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSemaphore[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSemaphore...\n");
debug_printf("Return value of vkCreateSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySemaphore( VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySemaphore\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSEMAPHORE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();


debug_printf("Ending vkDestroySemaphore...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateEvent( VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent ){
//Will only be called by the client
debug_printf("Executing vkCreateEvent\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_wqWioqo=json["pCreateInfo"].get_array();
        for(int ThfQKZW=0; ThfQKZW < 1; ThfQKZW++){
            [&](){
            auto& temp=arr_wqWioqo[ThfQKZW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ThfQKZW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pEvent==NULL){
                json["pEvent"]=boost::json::array();
            return; }json["pEvent"]=boost::json::array(1);
        auto& arr_edObbrc=json["pEvent"].get_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){serialize_VkEvent(arr_edObbrc[vdhtBcH],pEvent[vdhtBcH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pEvent"].get_array().size()==0){
                pEvent=NULL;
            return; }
        auto& arr_edObbrc=json["pEvent"].get_array();
        for(int vdhtBcH=0; vdhtBcH < 1; vdhtBcH++){
            [&](){deserialize_VkEvent(arr_edObbrc[vdhtBcH], pEvent[vdhtBcH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RhjukGg;[&](){
            if (json["result"].is_uint64()){
                temp_RhjukGg=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_RhjukGg=static_cast<int>(json["result"].get_int64());
            }else{
                temp_RhjukGg=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_RhjukGg;}();}();

                if (pEvent!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pEvent[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateEvent...\n");
debug_printf("Return value of vkCreateEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyEvent( VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyEvent\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkDestroyEvent...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetEventStatus( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkGetEventStatus\n");

    boost::json::object json;
    json["stream_type"]=VKGETEVENTSTATUS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETEVENTSTATUS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_LjAnXKd;[&](){
            if (json["result"].is_uint64()){
                temp_LjAnXKd=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LjAnXKd=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LjAnXKd=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LjAnXKd;}();}();

debug_printf("Ending vkGetEventStatus...\n");
debug_printf("Return value of vkGetEventStatus is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkSetEvent\n");

    boost::json::object json;
    json["stream_type"]=VKSETEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_LpIefps;[&](){
            if (json["result"].is_uint64()){
                temp_LpIefps=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LpIefps=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LpIefps=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LpIefps;}();}();

debug_printf("Ending vkSetEvent...\n");
debug_printf("Return value of vkSetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetEvent( VkDevice device, VkEvent event ){
//Will only be called by the client
debug_printf("Executing vkResetEvent\n");

    boost::json::object json;
    json["stream_type"]=VKRESETEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkEvent(json["event"],event);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkEvent(json["event"], event);}();
VkResult result;
[&](){[&](){int temp_IJKFvzI;[&](){
            if (json["result"].is_uint64()){
                temp_IJKFvzI=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_IJKFvzI=static_cast<int>(json["result"].get_int64());
            }else{
                temp_IJKFvzI=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_IJKFvzI;}();}();

debug_printf("Ending vkResetEvent...\n");
debug_printf("Return value of vkResetEvent is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateQueryPool( VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool ){
//Will only be called by the client
debug_printf("Executing vkCreateQueryPool\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEQUERYPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_AOuTZQo=json["pCreateInfo"].get_array();
        for(int SvYxRUl=0; SvYxRUl < 1; SvYxRUl++){
            [&](){
            auto& temp=arr_AOuTZQo[SvYxRUl].emplace_object();
            return serialize_struct(temp, pCreateInfo[SvYxRUl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pQueryPool==NULL){
                json["pQueryPool"]=boost::json::array();
            return; }json["pQueryPool"]=boost::json::array(1);
        auto& arr_uEjfPmz=json["pQueryPool"].get_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){serialize_VkQueryPool(arr_uEjfPmz[HoCFbNC],pQueryPool[HoCFbNC]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pQueryPool"].get_array().size()==0){
                pQueryPool=NULL;
            return; }
        auto& arr_uEjfPmz=json["pQueryPool"].get_array();
        for(int HoCFbNC=0; HoCFbNC < 1; HoCFbNC++){
            [&](){deserialize_VkQueryPool(arr_uEjfPmz[HoCFbNC], pQueryPool[HoCFbNC]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_YCeirvy;[&](){
            if (json["result"].is_uint64()){
                temp_YCeirvy=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_YCeirvy=static_cast<int>(json["result"].get_int64());
            }else{
                temp_YCeirvy=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_YCeirvy;}();}();

                if (pQueryPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pQueryPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateQueryPool...\n");
debug_printf("Return value of vkCreateQueryPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyQueryPool( VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyQueryPool\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYQUERYPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();


debug_printf("Ending vkDestroyQueryPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetQueryPoolResults( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkGetQueryPoolResults\n");

    boost::json::object json;
    json["stream_type"]=VKGETQUERYPOOLRESULTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_int64());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();
VkResult result;
[&](){[&](){int temp_uWvdBKW;[&](){
            if (json["result"].is_uint64()){
                temp_uWvdBKW=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_uWvdBKW=static_cast<int>(json["result"].get_int64());
            }else{
                temp_uWvdBKW=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_uWvdBKW;}();}();

debug_printf("Ending vkGetQueryPoolResults...\n");
debug_printf("Return value of vkGetQueryPoolResults is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkResetQueryPool( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkResetQueryPool\n");

    boost::json::object json;
    json["stream_type"]=VKRESETQUERYPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();

debug_printf("Ending vkResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkResetQueryPoolEXT( VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
return vkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBuffer( VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_YapwvbL=json["pCreateInfo"].get_array();
        for(int XkzMxbI=0; XkzMxbI < 1; XkzMxbI++){
            [&](){
            auto& temp=arr_YapwvbL[XkzMxbI].emplace_object();
            return serialize_struct(temp, pCreateInfo[XkzMxbI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pBuffer==NULL){
                json["pBuffer"]=boost::json::array();
            return; }json["pBuffer"]=boost::json::array(1);
        auto& arr_cIWQmjJ=json["pBuffer"].get_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){serialize_VkBuffer(arr_cIWQmjJ[XGujqfM],pBuffer[XGujqfM]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pBuffer"].get_array().size()==0){
                pBuffer=NULL;
            return; }
        auto& arr_cIWQmjJ=json["pBuffer"].get_array();
        for(int XGujqfM=0; XGujqfM < 1; XGujqfM++){
            [&](){deserialize_VkBuffer(arr_cIWQmjJ[XGujqfM], pBuffer[XGujqfM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OnfWbtl;[&](){
            if (json["result"].is_uint64()){
                temp_OnfWbtl=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_OnfWbtl=static_cast<int>(json["result"].get_int64());
            }else{
                temp_OnfWbtl=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_OnfWbtl;}();}();

                if (pBuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pBuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBuffer...\n");
debug_printf("Return value of vkCreateBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBuffer( VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();


debug_printf("Ending vkDestroyBuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateBufferView( VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateBufferView\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEBUFFERVIEW;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_SvrkcZl=json["pCreateInfo"].get_array();
        for(int cSdiRJj=0; cSdiRJj < 1; cSdiRJj++){
            [&](){
            auto& temp=arr_SvrkcZl[cSdiRJj].emplace_object();
            return serialize_struct(temp, pCreateInfo[cSdiRJj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }json["pView"]=boost::json::array(1);
        auto& arr_FoBLnTF=json["pView"].get_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){serialize_VkBufferView(arr_FoBLnTF[jjvyrOh],pView[jjvyrOh]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].get_array().size()==0){
                pView=NULL;
            return; }
        auto& arr_FoBLnTF=json["pView"].get_array();
        for(int jjvyrOh=0; jjvyrOh < 1; jjvyrOh++){
            [&](){deserialize_VkBufferView(arr_FoBLnTF[jjvyrOh], pView[jjvyrOh]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_wpZAeSe;[&](){
            if (json["result"].is_uint64()){
                temp_wpZAeSe=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_wpZAeSe=static_cast<int>(json["result"].get_int64());
            }else{
                temp_wpZAeSe=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_wpZAeSe;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateBufferView...\n");
debug_printf("Return value of vkCreateBufferView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyBufferView( VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyBufferView\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYBUFFERVIEW;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkBufferView(json["bufferView"],bufferView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYBUFFERVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkBufferView(json["bufferView"], bufferView);}();


debug_printf("Ending vkDestroyBufferView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImage( VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage ){
//Will only be called by the client
debug_printf("Executing vkCreateImage\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TpPCnAy=json["pCreateInfo"].get_array();
        for(int pRwmwcF=0; pRwmwcF < 1; pRwmwcF++){
            [&](){
            auto& temp=arr_TpPCnAy[pRwmwcF].emplace_object();
            return serialize_struct(temp, pCreateInfo[pRwmwcF]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pImage==NULL){
                json["pImage"]=boost::json::array();
            return; }json["pImage"]=boost::json::array(1);
        auto& arr_YGmHGGw=json["pImage"].get_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){serialize_VkImage(arr_YGmHGGw[Lmwohhp],pImage[Lmwohhp]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pImage"].get_array().size()==0){
                pImage=NULL;
            return; }
        auto& arr_YGmHGGw=json["pImage"].get_array();
        for(int Lmwohhp=0; Lmwohhp < 1; Lmwohhp++){
            [&](){deserialize_VkImage(arr_YGmHGGw[Lmwohhp], pImage[Lmwohhp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZORigsY;[&](){
            if (json["result"].is_uint64()){
                temp_ZORigsY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZORigsY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZORigsY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZORigsY;}();}();

                if (pImage!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pImage[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImage...\n");
debug_printf("Return value of vkCreateImage is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImage( VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImage\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();


debug_printf("Ending vkDestroyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout( VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGESUBRESOURCELAYOUT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }json["pSubresource"]=boost::json::array(1);
        auto& arr_bNRLlpX=json["pSubresource"].get_array();
        for(int trrMzRH=0; trrMzRH < 1; trrMzRH++){
            [&](){
            auto& temp=arr_bNRLlpX[trrMzRH].emplace_object();
            return serialize_struct(temp, pSubresource[trrMzRH]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JAFsVvP=json["pLayout"].get_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].emplace_object();
            return serialize_struct(temp, pLayout[jGHmbXh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JAFsVvP=json["pLayout"].get_array();
        for(int jGHmbXh=0; jGHmbXh < 1; jGHmbXh++){
            [&](){
            auto& temp=arr_JAFsVvP[jGHmbXh].get_object();
            deserialize_struct(temp,pLayout[jGHmbXh]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateImageView( VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView ){
//Will only be called by the client
debug_printf("Executing vkCreateImageView\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEIMAGEVIEW;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_TYfFrkP=json["pCreateInfo"].get_array();
        for(int HNOogbj=0; HNOogbj < 1; HNOogbj++){
            [&](){
            auto& temp=arr_TYfFrkP[HNOogbj].emplace_object();
            return serialize_struct(temp, pCreateInfo[HNOogbj]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pView==NULL){
                json["pView"]=boost::json::array();
            return; }json["pView"]=boost::json::array(1);
        auto& arr_GCwrdnq=json["pView"].get_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){serialize_VkImageView(arr_GCwrdnq[frngisT],pView[frngisT]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pView"].get_array().size()==0){
                pView=NULL;
            return; }
        auto& arr_GCwrdnq=json["pView"].get_array();
        for(int frngisT=0; frngisT < 1; frngisT++){
            [&](){deserialize_VkImageView(arr_GCwrdnq[frngisT], pView[frngisT]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZQdRwrg;[&](){
            if (json["result"].is_uint64()){
                temp_ZQdRwrg=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZQdRwrg=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZQdRwrg=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZQdRwrg;}();}();

                if (pView!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pView[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateImageView...\n");
debug_printf("Return value of vkCreateImageView is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyImageView( VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyImageView\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYIMAGEVIEW;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYIMAGEVIEW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();


debug_printf("Ending vkDestroyImageView...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShaderModule( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule ){
//Will only be called by the client
debug_printf("Executing vkCreateShaderModule\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESHADERMODULE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iSZUILM=json["pCreateInfo"].get_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaderModule==NULL){
                json["pShaderModule"]=boost::json::array();
            return; }json["pShaderModule"]=boost::json::array(1);
        auto& arr_FaKUyxw=json["pShaderModule"].get_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){serialize_VkShaderModule(arr_FaKUyxw[EDcqjpD],pShaderModule[EDcqjpD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pShaderModule"].get_array().size()==0){
                pShaderModule=NULL;
            return; }
        auto& arr_FaKUyxw=json["pShaderModule"].get_array();
        for(int EDcqjpD=0; EDcqjpD < 1; EDcqjpD++){
            [&](){deserialize_VkShaderModule(arr_FaKUyxw[EDcqjpD], pShaderModule[EDcqjpD]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_iuLPIVs;[&](){
            if (json["result"].is_uint64()){
                temp_iuLPIVs=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_iuLPIVs=static_cast<int>(json["result"].get_int64());
            }else{
                temp_iuLPIVs=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_iuLPIVs;}();}();

                if (pShaderModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaderModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShaderModule...\n");
debug_printf("Return value of vkCreateShaderModule is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderModule( VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderModule\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSHADERMODULE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADERMODULE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();


debug_printf("Ending vkDestroyShaderModule...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineCache( VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineCache\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEPIPELINECACHE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_wTXOYfz=json["pCreateInfo"].get_array();
        for(int iWdFkeP=0; iWdFkeP < 1; iWdFkeP++){
            [&](){
            auto& temp=arr_wTXOYfz[iWdFkeP].emplace_object();
            return serialize_struct(temp, pCreateInfo[iWdFkeP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineCache==NULL){
                json["pPipelineCache"]=boost::json::array();
            return; }json["pPipelineCache"]=boost::json::array(1);
        auto& arr_mogHiwV=json["pPipelineCache"].get_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){serialize_VkPipelineCache(arr_mogHiwV[ndOADAA],pPipelineCache[ndOADAA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineCache"].get_array().size()==0){
                pPipelineCache=NULL;
            return; }
        auto& arr_mogHiwV=json["pPipelineCache"].get_array();
        for(int ndOADAA=0; ndOADAA < 1; ndOADAA++){
            [&](){deserialize_VkPipelineCache(arr_mogHiwV[ndOADAA], pPipelineCache[ndOADAA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yYSuCeV;[&](){
            if (json["result"].is_uint64()){
                temp_yYSuCeV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yYSuCeV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yYSuCeV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yYSuCeV;}();}();

                if (pPipelineCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineCache...\n");
debug_printf("Return value of vkCreatePipelineCache is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineCache( VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineCache\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYPIPELINECACHE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINECACHE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();


debug_printf("Ending vkDestroyPipelineCache...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineCacheData( VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineCacheData\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINECACHEDATA;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINECACHEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_jTTriaB;[&](){
            if (json["result"].is_uint64()){
                temp_jTTriaB=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_jTTriaB=static_cast<int>(json["result"].get_int64());
            }else{
                temp_jTTriaB=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_jTTriaB;}();}();

debug_printf("Ending vkGetPipelineCacheData...\n");
debug_printf("Return value of vkGetPipelineCacheData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergePipelineCaches( VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergePipelineCaches\n");

    boost::json::object json;
    json["stream_type"]=VKMERGEPIPELINECACHES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }json["pSrcCaches"]=boost::json::array(srcCacheCount);
        auto& arr_DmqfOOL=json["pSrcCaches"].get_array();
        for(int MmYiSON=0; MmYiSON < srcCacheCount; MmYiSON++){
            [&](){serialize_VkPipelineCache(arr_DmqfOOL[MmYiSON],pSrcCaches[MmYiSON]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEPIPELINECACHES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["dstCache"], dstCache);}();
[&](){
            if (json["srcCacheCount"].is_uint64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_uint64());
            }else if (json["srcCacheCount"].is_int64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_int64());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_VCXflIX;[&](){
            if (json["result"].is_uint64()){
                temp_VCXflIX=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VCXflIX=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VCXflIX=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VCXflIX;}();}();

debug_printf("Ending vkMergePipelineCaches...\n");
debug_printf("Return value of vkMergePipelineCaches is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateGraphicsPipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateGraphicsPipelines\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEGRAPHICSPIPELINES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_juQDvLY=json["pCreateInfos"].get_array();
        for(int wqGiARr=0; wqGiARr < createInfoCount; wqGiARr++){
            [&](){
            auto& temp=arr_juQDvLY[wqGiARr].emplace_object();
            return serialize_struct(temp, pCreateInfos[wqGiARr]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEGRAPHICSPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();


[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_fwluuIW;[&](){
            if (json["result"].is_uint64()){
                temp_fwluuIW=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_fwluuIW=static_cast<int>(json["result"].get_int64());
            }else{
                temp_fwluuIW=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_fwluuIW;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateGraphicsPipelines...\n");
debug_printf("Return value of vkCreateGraphicsPipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateComputePipelines( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateComputePipelines\n");

    boost::json::object json;
    json["stream_type"]=VKCREATECOMPUTEPIPELINES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_eqiaDas=json["pCreateInfos"].get_array();
        for(int NsFJrJk=0; NsFJrJk < createInfoCount; NsFJrJk++){
            [&](){
            auto& temp=arr_eqiaDas[NsFJrJk].emplace_object();
            return serialize_struct(temp, pCreateInfos[NsFJrJk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMPUTEPIPELINES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();


[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_XaCpxZE;[&](){
            if (json["result"].is_uint64()){
                temp_XaCpxZE=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_XaCpxZE=static_cast<int>(json["result"].get_int64());
            }else{
                temp_XaCpxZE=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_XaCpxZE;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateComputePipelines...\n");
debug_printf("Return value of vkCreateComputePipelines is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI( VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderpass"],renderpass);}();
[&](){
            if (pMaxWorkgroupSize==NULL){
                json["pMaxWorkgroupSize"]=boost::json::array();
            return; }json["pMaxWorkgroupSize"]=boost::json::array(1);
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].get_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].emplace_object();
            return serialize_struct(temp, pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderpass"], renderpass);}();
[&](){
            if (json["pMaxWorkgroupSize"].get_array().size()==0){
                pMaxWorkgroupSize=NULL;
            return; }
        auto& arr_QJRQgTX=json["pMaxWorkgroupSize"].get_array();
        for(int WdbibPk=0; WdbibPk < 1; WdbibPk++){
            [&](){
            auto& temp=arr_QJRQgTX[WdbibPk].get_object();
            deserialize_struct(temp,pMaxWorkgroupSize[WdbibPk]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bKsxLVR;[&](){
            if (json["result"].is_uint64()){
                temp_bKsxLVR=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_bKsxLVR=static_cast<int>(json["result"].get_int64());
            }else{
                temp_bKsxLVR=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_bKsxLVR;}();}();

debug_printf("Ending vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI...\n");
debug_printf("Return value of vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipeline( VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipeline\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYPIPELINE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();


debug_printf("Ending vkDestroyPipeline...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePipelineLayout( VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout ){
//Will only be called by the client
debug_printf("Executing vkCreatePipelineLayout\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEPIPELINELAYOUT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iyZpkhm=json["pCreateInfo"].get_array();
        for(int AdWYCmn=0; AdWYCmn < 1; AdWYCmn++){
            [&](){
            auto& temp=arr_iyZpkhm[AdWYCmn].emplace_object();
            return serialize_struct(temp, pCreateInfo[AdWYCmn]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelineLayout==NULL){
                json["pPipelineLayout"]=boost::json::array();
            return; }json["pPipelineLayout"]=boost::json::array(1);
        auto& arr_NheDZho=json["pPipelineLayout"].get_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){serialize_VkPipelineLayout(arr_NheDZho[QNJuRwu],pPipelineLayout[QNJuRwu]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPipelineLayout"].get_array().size()==0){
                pPipelineLayout=NULL;
            return; }
        auto& arr_NheDZho=json["pPipelineLayout"].get_array();
        for(int QNJuRwu=0; QNJuRwu < 1; QNJuRwu++){
            [&](){deserialize_VkPipelineLayout(arr_NheDZho[QNJuRwu], pPipelineLayout[QNJuRwu]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_JaTGUJz;[&](){
            if (json["result"].is_uint64()){
                temp_JaTGUJz=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_JaTGUJz=static_cast<int>(json["result"].get_int64());
            }else{
                temp_JaTGUJz=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_JaTGUJz;}();}();

                if (pPipelineLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelineLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePipelineLayout...\n");
debug_printf("Return value of vkCreatePipelineLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyPipelineLayout( VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPipelineLayout\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYPIPELINELAYOUT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineLayout(json["pipelineLayout"],pipelineLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPIPELINELAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineLayout(json["pipelineLayout"], pipelineLayout);}();


debug_printf("Ending vkDestroyPipelineLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSampler( VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler ){
//Will only be called by the client
debug_printf("Executing vkCreateSampler\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESAMPLER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_xWlqrLm=json["pCreateInfo"].get_array();
        for(int yMsdBPh=0; yMsdBPh < 1; yMsdBPh++){
            [&](){
            auto& temp=arr_xWlqrLm[yMsdBPh].emplace_object();
            return serialize_struct(temp, pCreateInfo[yMsdBPh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSampler==NULL){
                json["pSampler"]=boost::json::array();
            return; }json["pSampler"]=boost::json::array(1);
        auto& arr_nEROYrx=json["pSampler"].get_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){serialize_VkSampler(arr_nEROYrx[iCIaKrl],pSampler[iCIaKrl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSampler"].get_array().size()==0){
                pSampler=NULL;
            return; }
        auto& arr_nEROYrx=json["pSampler"].get_array();
        for(int iCIaKrl=0; iCIaKrl < 1; iCIaKrl++){
            [&](){deserialize_VkSampler(arr_nEROYrx[iCIaKrl], pSampler[iCIaKrl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yPETNHz;[&](){
            if (json["result"].is_uint64()){
                temp_yPETNHz=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yPETNHz=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yPETNHz=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yPETNHz;}();}();

                if (pSampler!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSampler[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSampler...\n");
debug_printf("Return value of vkCreateSampler is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySampler( VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySampler\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSAMPLER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSampler(json["sampler"],sampler);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSampler(json["sampler"], sampler);}();


debug_printf("Ending vkDestroySampler...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorSetLayout( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorSetLayout\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDESCRIPTORSETLAYOUT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dFRsqIW=json["pCreateInfo"].get_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSetLayout==NULL){
                json["pSetLayout"]=boost::json::array();
            return; }json["pSetLayout"]=boost::json::array(1);
        auto& arr_iCAhOCt=json["pSetLayout"].get_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){serialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl],pSetLayout[RWEcihl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSetLayout"].get_array().size()==0){
                pSetLayout=NULL;
            return; }
        auto& arr_iCAhOCt=json["pSetLayout"].get_array();
        for(int RWEcihl=0; RWEcihl < 1; RWEcihl++){
            [&](){deserialize_VkDescriptorSetLayout(arr_iCAhOCt[RWEcihl], pSetLayout[RWEcihl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_QKciijQ;[&](){
            if (json["result"].is_uint64()){
                temp_QKciijQ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_QKciijQ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_QKciijQ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_QKciijQ;}();}();

                if (pSetLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSetLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorSetLayout...\n");
debug_printf("Return value of vkCreateDescriptorSetLayout is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorSetLayout( VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorSetLayout\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDESCRIPTORSETLAYOUT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["descriptorSetLayout"],descriptorSetLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORSETLAYOUT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["descriptorSetLayout"], descriptorSetLayout);}();


debug_printf("Ending vkDestroyDescriptorSetLayout...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorPool( VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorPool\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDESCRIPTORPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_fChMCRL=json["pCreateInfo"].get_array();
        for(int XgrRVVh=0; XgrRVVh < 1; XgrRVVh++){
            [&](){
            auto& temp=arr_fChMCRL[XgrRVVh].emplace_object();
            return serialize_struct(temp, pCreateInfo[XgrRVVh]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorPool==NULL){
                json["pDescriptorPool"]=boost::json::array();
            return; }json["pDescriptorPool"]=boost::json::array(1);
        auto& arr_zvYCksx=json["pDescriptorPool"].get_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){serialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo],pDescriptorPool[UuMLZWo]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorPool"].get_array().size()==0){
                pDescriptorPool=NULL;
            return; }
        auto& arr_zvYCksx=json["pDescriptorPool"].get_array();
        for(int UuMLZWo=0; UuMLZWo < 1; UuMLZWo++){
            [&](){deserialize_VkDescriptorPool(arr_zvYCksx[UuMLZWo], pDescriptorPool[UuMLZWo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_POXquiI;[&](){
            if (json["result"].is_uint64()){
                temp_POXquiI=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_POXquiI=static_cast<int>(json["result"].get_int64());
            }else{
                temp_POXquiI=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_POXquiI;}();}();

                if (pDescriptorPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorPool...\n");
debug_printf("Return value of vkCreateDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorPool\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDESCRIPTORPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();


debug_printf("Ending vkDestroyDescriptorPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetDescriptorPool( VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetDescriptorPool\n");

    boost::json::object json;
    json["stream_type"]=VKRESETDESCRIPTORPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETDESCRIPTORPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){[&](){int temp_zAsidUJ;[&](){
            if (json["flags"].is_uint64()){
                temp_zAsidUJ=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_zAsidUJ=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_zAsidUJ=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkDescriptorPoolResetFlags)temp_zAsidUJ;}();}();
VkResult result;
[&](){[&](){int temp_IyIFPmQ;[&](){
            if (json["result"].is_uint64()){
                temp_IyIFPmQ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_IyIFPmQ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_IyIFPmQ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_IyIFPmQ;}();}();

debug_printf("Ending vkResetDescriptorPool...\n");
debug_printf("Return value of vkResetDescriptorPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateDescriptorSets( VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkAllocateDescriptorSets\n");

    boost::json::object json;
    json["stream_type"]=VKALLOCATEDESCRIPTORSETS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_yVqYJHW=json["pAllocateInfo"].get_array();
        for(int jTINpTr=0; jTINpTr < 1; jTINpTr++){
            [&](){
            auto& temp=arr_yVqYJHW[jTINpTr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[jTINpTr]);
            }();
        }
        }();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(pAllocateInfo->descriptorSetCount);
        auto& arr_hwQSDBT=json["pDescriptorSets"].get_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){serialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY],pDescriptorSets[spXEqJY]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDescriptorSets"].get_array().size()==0){
                pDescriptorSets=NULL;
            return; }
        auto& arr_hwQSDBT=json["pDescriptorSets"].get_array();
        for(int spXEqJY=0; spXEqJY < pAllocateInfo->descriptorSetCount; spXEqJY++){
            [&](){deserialize_VkDescriptorSet(arr_hwQSDBT[spXEqJY], pDescriptorSets[spXEqJY]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LQaOJmJ;[&](){
            if (json["result"].is_uint64()){
                temp_LQaOJmJ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LQaOJmJ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LQaOJmJ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LQaOJmJ;}();}();

                if (pDescriptorSets!=NULL){
                    for (int i=0; i<pAllocateInfo->descriptorSetCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorSets[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateDescriptorSets...\n");
debug_printf("Return value of vkAllocateDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkFreeDescriptorSets( VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets ){
//Will only be called by the client
debug_printf("Executing vkFreeDescriptorSets\n");

    boost::json::object json;
    json["stream_type"]=VKFREEDESCRIPTORSETS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorPool(json["descriptorPool"],descriptorPool);}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(descriptorSetCount);
        auto& arr_JZNsxgK=json["pDescriptorSets"].get_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorPool(json["descriptorPool"], descriptorPool);}();
[&](){
            if (json["descriptorSetCount"].is_uint64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_uint64());
            }else if (json["descriptorSetCount"].is_int64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_int64());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_YypqqnY;[&](){
            if (json["result"].is_uint64()){
                temp_YypqqnY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_YypqqnY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_YypqqnY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_YypqqnY;}();}();

debug_printf("Ending vkFreeDescriptorSets...\n");
debug_printf("Return value of vkFreeDescriptorSets is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSets( VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSets\n");

    boost::json::object json;
    json["stream_type"]=VKUPDATEDESCRIPTORSETS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }json["pDescriptorWrites"]=boost::json::array(descriptorWriteCount);
        auto& arr_AuOrFWk=json["pDescriptorWrites"].get_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
[&](){json["descriptorCopyCount"]=descriptorCopyCount;}();
[&](){
            if (pDescriptorCopies==NULL){
                json["pDescriptorCopies"]=boost::json::array();
            return; }json["pDescriptorCopies"]=boost::json::array(descriptorCopyCount);
        auto& arr_WWZDhqd=json["pDescriptorCopies"].get_array();
        for(int ryeXdkw=0; ryeXdkw < descriptorCopyCount; ryeXdkw++){
            [&](){
            auto& temp=arr_WWZDhqd[ryeXdkw].emplace_object();
            return serialize_struct(temp, pDescriptorCopies[ryeXdkw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["descriptorWriteCount"].is_uint64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_uint64());
            }else if (json["descriptorWriteCount"].is_int64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_int64());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_double());
            }
            }();

[&](){
            if (json["descriptorCopyCount"].is_uint64()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_uint64());
            }else if (json["descriptorCopyCount"].is_int64()){
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_int64());
            }else{
                descriptorCopyCount=static_cast<uint32_t>(json["descriptorCopyCount"].get_double());
            }
            }();


debug_printf("Ending vkUpdateDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateFramebuffer( VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer ){
//Will only be called by the client
debug_printf("Executing vkCreateFramebuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEFRAMEBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_LBIrWmz=json["pCreateInfo"].get_array();
        for(int jMLqpUb=0; jMLqpUb < 1; jMLqpUb++){
            [&](){
            auto& temp=arr_LBIrWmz[jMLqpUb].emplace_object();
            return serialize_struct(temp, pCreateInfo[jMLqpUb]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFramebuffer==NULL){
                json["pFramebuffer"]=boost::json::array();
            return; }json["pFramebuffer"]=boost::json::array(1);
        auto& arr_xECXRAK=json["pFramebuffer"].get_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){serialize_VkFramebuffer(arr_xECXRAK[zDUSKRl],pFramebuffer[zDUSKRl]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFramebuffer"].get_array().size()==0){
                pFramebuffer=NULL;
            return; }
        auto& arr_xECXRAK=json["pFramebuffer"].get_array();
        for(int zDUSKRl=0; zDUSKRl < 1; zDUSKRl++){
            [&](){deserialize_VkFramebuffer(arr_xECXRAK[zDUSKRl], pFramebuffer[zDUSKRl]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_AOWGmZj;[&](){
            if (json["result"].is_uint64()){
                temp_AOWGmZj=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_AOWGmZj=static_cast<int>(json["result"].get_int64());
            }else{
                temp_AOWGmZj=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_AOWGmZj;}();}();

                if (pFramebuffer!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFramebuffer[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateFramebuffer...\n");
debug_printf("Return value of vkCreateFramebuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyFramebuffer( VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyFramebuffer\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYFRAMEBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYFRAMEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();


debug_printf("Ending vkDestroyFramebuffer...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass( VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass\n");

    boost::json::object json;
    json["stream_type"]=VKCREATERENDERPASS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_upxhtZe=json["pCreateInfo"].get_array();
        for(int oHJSJzU=0; oHJSJzU < 1; oHJSJzU++){
            [&](){
            auto& temp=arr_upxhtZe[oHJSJzU].emplace_object();
            return serialize_struct(temp, pCreateInfo[oHJSJzU]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }json["pRenderPass"]=boost::json::array(1);
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].get_array().size()==0){
                pRenderPass=NULL;
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OCmIgFP;[&](){
            if (json["result"].is_uint64()){
                temp_OCmIgFP=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_OCmIgFP=static_cast<int>(json["result"].get_int64());
            }else{
                temp_OCmIgFP=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_OCmIgFP;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass...\n");
debug_printf("Return value of vkCreateRenderPass is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyRenderPass( VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyRenderPass\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYRENDERPASS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();


debug_printf("Ending vkDestroyRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderAreaGranularity( VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderAreaGranularity\n");

    boost::json::object json;
    json["stream_type"]=VKGETRENDERAREAGRANULARITY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkRenderPass(json["renderPass"],renderPass);}();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }json["pGranularity"]=boost::json::array(1);
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERAREAGRANULARITY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkRenderPass(json["renderPass"], renderPass);}();
[&](){
            if (json["pGranularity"].get_array().size()==0){
                pGranularity=NULL;
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].get_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderAreaGranularity...\n");
}
__attribute__((visibility ("hidden"))) void vkGetRenderingAreaGranularityKHR( VkDevice device, const VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity ){
//Will only be called by the client
debug_printf("Executing vkGetRenderingAreaGranularityKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETRENDERINGAREAGRANULARITYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingAreaInfo==NULL){
                json["pRenderingAreaInfo"]=boost::json::array();
            return; }json["pRenderingAreaInfo"]=boost::json::array(1);
        auto& arr_QFvDqfG=json["pRenderingAreaInfo"].get_array();
        for(int WRYBJDa=0; WRYBJDa < 1; WRYBJDa++){
            [&](){
            auto& temp=arr_QFvDqfG[WRYBJDa].emplace_object();
            return serialize_struct(temp, pRenderingAreaInfo[WRYBJDa]);
            }();
        }
        }();
[&](){
            if (pGranularity==NULL){
                json["pGranularity"]=boost::json::array();
            return; }json["pGranularity"]=boost::json::array(1);
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].emplace_object();
            return serialize_struct(temp, pGranularity[tgiNLQL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRENDERINGAREAGRANULARITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pGranularity"].get_array().size()==0){
                pGranularity=NULL;
            return; }
        auto& arr_VvmWHYL=json["pGranularity"].get_array();
        for(int tgiNLQL=0; tgiNLQL < 1; tgiNLQL++){
            [&](){
            auto& temp=arr_VvmWHYL[tgiNLQL].get_object();
            deserialize_struct(temp,pGranularity[tgiNLQL]);
            }();
        }
        }();

debug_printf("Ending vkGetRenderingAreaGranularityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCommandPool( VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool ){
//Will only be called by the client
debug_printf("Executing vkCreateCommandPool\n");

    boost::json::object json;
    json["stream_type"]=VKCREATECOMMANDPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_ISnaSOj=json["pCreateInfo"].get_array();
        for(int ubLLexW=0; ubLLexW < 1; ubLLexW++){
            [&](){
            auto& temp=arr_ISnaSOj[ubLLexW].emplace_object();
            return serialize_struct(temp, pCreateInfo[ubLLexW]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCommandPool==NULL){
                json["pCommandPool"]=boost::json::array();
            return; }json["pCommandPool"]=boost::json::array(1);
        auto& arr_ohCGecZ=json["pCommandPool"].get_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){serialize_VkCommandPool(arr_ohCGecZ[oHETrgL],pCommandPool[oHETrgL]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pCommandPool"].get_array().size()==0){
                pCommandPool=NULL;
            return; }
        auto& arr_ohCGecZ=json["pCommandPool"].get_array();
        for(int oHETrgL=0; oHETrgL < 1; oHETrgL++){
            [&](){deserialize_VkCommandPool(arr_ohCGecZ[oHETrgL], pCommandPool[oHETrgL]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_TwnbacJ;[&](){
            if (json["result"].is_uint64()){
                temp_TwnbacJ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TwnbacJ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_TwnbacJ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_TwnbacJ;}();}();

                if (pCommandPool!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandPool[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCommandPool...\n");
debug_printf("Return value of vkCreateCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCommandPool( VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCommandPool\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYCOMMANDPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();


debug_printf("Ending vkDestroyCommandPool...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandPool\n");

    boost::json::object json;
    json["stream_type"]=VKRESETCOMMANDPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_ZfbLqrp;[&](){
            if (json["flags"].is_uint64()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_ZfbLqrp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandPoolResetFlags)temp_ZfbLqrp;}();}();
VkResult result;
[&](){[&](){int temp_ysibPDT;[&](){
            if (json["result"].is_uint64()){
                temp_ysibPDT=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ysibPDT=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ysibPDT=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ysibPDT;}();}();

debug_printf("Ending vkResetCommandPool...\n");
debug_printf("Return value of vkResetCommandPool is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAllocateCommandBuffers( VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkAllocateCommandBuffers\n");

    boost::json::object json;
    json["stream_type"]=VKALLOCATECOMMANDBUFFERS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocateInfo==NULL){
                json["pAllocateInfo"]=boost::json::array();
            return; }json["pAllocateInfo"]=boost::json::array(1);
        auto& arr_ZURucFE=json["pAllocateInfo"].get_array();
        for(int VMrKYrr=0; VMrKYrr < 1; VMrKYrr++){
            [&](){
            auto& temp=arr_ZURucFE[VMrKYrr].emplace_object();
            return serialize_struct(temp, pAllocateInfo[VMrKYrr]);
            }();
        }
        }();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(pAllocateInfo->commandBufferCount);
        auto& arr_WZYlBGU=json["pCommandBuffers"].get_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){serialize_VkCommandBuffer(arr_WZYlBGU[RztseIK],pCommandBuffers[RztseIK]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKALLOCATECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCommandBuffers"].get_array().size()==0){
                pCommandBuffers=NULL;
            return; }
        auto& arr_WZYlBGU=json["pCommandBuffers"].get_array();
        for(int RztseIK=0; RztseIK < pAllocateInfo->commandBufferCount; RztseIK++){
            [&](){deserialize_VkCommandBuffer(arr_WZYlBGU[RztseIK], pCommandBuffers[RztseIK]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KJhrnJP;[&](){
            if (json["result"].is_uint64()){
                temp_KJhrnJP=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_KJhrnJP=static_cast<int>(json["result"].get_int64());
            }else{
                temp_KJhrnJP=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_KJhrnJP;}();}();

                if (pCommandBuffers!=NULL){
                    for (int i=0; i<pAllocateInfo->commandBufferCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCommandBuffers[i])]=parent;
                    }
                }
                

debug_printf("Ending vkAllocateCommandBuffers...\n");
debug_printf("Return value of vkAllocateCommandBuffers is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkFreeCommandBuffers( VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkFreeCommandBuffers\n");

    boost::json::object json;
    json["stream_type"]=VKFREECOMMANDBUFFERS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(commandBufferCount);
        auto& arr_PdRlpEO=json["pCommandBuffers"].get_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKFREECOMMANDBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){
            if (json["commandBufferCount"].is_uint64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_uint64());
            }else if (json["commandBufferCount"].is_int64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_int64());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_double());
            }
            }();


debug_printf("Ending vkFreeCommandBuffers...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBeginCommandBuffer( VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkBeginCommandBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKBEGINCOMMANDBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }json["pBeginInfo"]=boost::json::array(1);
        auto& arr_cULABHU=json["pBeginInfo"].get_array();
        for(int MlslWJM=0; MlslWJM < 1; MlslWJM++){
            [&](){
            auto& temp=arr_cULABHU[MlslWJM].emplace_object();
            return serialize_struct(temp, pBeginInfo[MlslWJM]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBEGINCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_mMeFygb;[&](){
            if (json["result"].is_uint64()){
                temp_mMeFygb=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_mMeFygb=static_cast<int>(json["result"].get_int64());
            }else{
                temp_mMeFygb=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_mMeFygb;}();}();

debug_printf("Ending vkBeginCommandBuffer...\n");
debug_printf("Return value of vkBeginCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEndCommandBuffer( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkEndCommandBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKENDCOMMANDBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENDCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
VkResult result;
[&](){[&](){int temp_BVLpkXY;[&](){
            if (json["result"].is_uint64()){
                temp_BVLpkXY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_BVLpkXY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_BVLpkXY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_BVLpkXY;}();}();

debug_printf("Ending vkEndCommandBuffer...\n");
debug_printf("Return value of vkEndCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkResetCommandBuffer( VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags ){
//Will only be called by the client
debug_printf("Executing vkResetCommandBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKRESETCOMMANDBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRESETCOMMANDBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lxCkbVG;[&](){
            if (json["flags"].is_uint64()){
                temp_lxCkbVG=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_lxCkbVG=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_lxCkbVG=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandBufferResetFlags)temp_lxCkbVG;}();}();
VkResult result;
[&](){[&](){int temp_RMtPwdq;[&](){
            if (json["result"].is_uint64()){
                temp_RMtPwdq=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_RMtPwdq=static_cast<int>(json["result"].get_int64());
            }else{
                temp_RMtPwdq=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_RMtPwdq;}();}();

debug_printf("Ending vkResetCommandBuffer...\n");
debug_printf("Return value of vkResetCommandBuffer is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipeline( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipeline\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDPIPELINE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdBindPipeline...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAttachmentFeedbackLoopEnableEXT( VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAttachmentFeedbackLoopEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["aspectMask"]=aspectMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETATTACHMENTFEEDBACKLOOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_LWxAVsj;[&](){
            if (json["aspectMask"].is_uint64()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_uint64());
            }else if (json["aspectMask"].is_int64()){
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_int64());
            }else{
                temp_LWxAVsj=static_cast<int>(json["aspectMask"].get_double());
            }
            }();aspectMask=(VkImageAspectFlags)temp_LWxAVsj;}();}();

debug_printf("Ending vkCmdSetAttachmentFeedbackLoopEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewport( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewport\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }json["pViewports"]=boost::json::array(viewportCount);
        auto& arr_SyYryUE=json["pViewports"].get_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetViewport...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissor( VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissor\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSCISSOR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstScissor"]=firstScissor;}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }json["pScissors"]=boost::json::array(scissorCount);
        auto& arr_RpUaBcS=json["pScissors"].get_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSOR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstScissor"].is_uint64()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_uint64());
            }else if (json["firstScissor"].is_int64()){
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_int64());
            }else{
                firstScissor=static_cast<uint32_t>(json["firstScissor"].get_double());
            }
            }();
[&](){
            if (json["scissorCount"].is_uint64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_uint64());
            }else if (json["scissorCount"].is_int64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_int64());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetScissor...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineWidth( VkCommandBuffer commandBuffer, float lineWidth ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineWidth\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLINEWIDTH;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineWidth"]=lineWidth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINEWIDTH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["lineWidth"].is_uint64()){
                lineWidth=static_cast<float>(json["lineWidth"].get_uint64());
            }else if (json["lineWidth"].is_int64()){
                lineWidth=static_cast<float>(json["lineWidth"].get_int64());
            }else{
                lineWidth=static_cast<float>(json["lineWidth"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetLineWidth...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias( VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHBIAS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["depthBiasConstantFactor"]=depthBiasConstantFactor;}();
[&](){json["depthBiasClamp"]=depthBiasClamp;}();
[&](){json["depthBiasSlopeFactor"]=depthBiasSlopeFactor;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["depthBiasConstantFactor"].is_uint64()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_uint64());
            }else if (json["depthBiasConstantFactor"].is_int64()){
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_int64());
            }else{
                depthBiasConstantFactor=static_cast<float>(json["depthBiasConstantFactor"].get_double());
            }
            }();
[&](){
            if (json["depthBiasClamp"].is_uint64()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_uint64());
            }else if (json["depthBiasClamp"].is_int64()){
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_int64());
            }else{
                depthBiasClamp=static_cast<float>(json["depthBiasClamp"].get_double());
            }
            }();
[&](){
            if (json["depthBiasSlopeFactor"].is_uint64()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_uint64());
            }else if (json["depthBiasSlopeFactor"].is_int64()){
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_int64());
            }else{
                depthBiasSlopeFactor=static_cast<float>(json["depthBiasSlopeFactor"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetDepthBias...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetBlendConstants( VkCommandBuffer commandBuffer, const float blendConstants[4] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetBlendConstants\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETBLENDCONSTANTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["blendConstants"]=boost::json::array(4);
        auto& arr_HTjCZtj=json["blendConstants"].get_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            [&](){arr_HTjCZtj[lLRJClr]=blendConstants[lLRJClr];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETBLENDCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
        auto& arr_HTjCZtj=json["blendConstants"].get_array();
        for(int lLRJClr=0; lLRJClr < 4; lLRJClr++){
            
        }
        }();

debug_printf("Ending vkCmdSetBlendConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBounds( VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBounds\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHBOUNDS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["minDepthBounds"]=minDepthBounds;}();
[&](){json["maxDepthBounds"]=maxDepthBounds;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["minDepthBounds"].is_uint64()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_uint64());
            }else if (json["minDepthBounds"].is_int64()){
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_int64());
            }else{
                minDepthBounds=static_cast<float>(json["minDepthBounds"].get_double());
            }
            }();
[&](){
            if (json["maxDepthBounds"].is_uint64()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_uint64());
            }else if (json["maxDepthBounds"].is_int64()){
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_int64());
            }else{
                maxDepthBounds=static_cast<float>(json["maxDepthBounds"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetDepthBounds...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilCompareMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilCompareMask\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSTENCILCOMPAREMASK;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["compareMask"]=compareMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILCOMPAREMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["compareMask"].is_uint64()){
                compareMask=static_cast<uint32_t>(json["compareMask"].get_uint64());
            }else if (json["compareMask"].is_int64()){
                compareMask=static_cast<uint32_t>(json["compareMask"].get_int64());
            }else{
                compareMask=static_cast<uint32_t>(json["compareMask"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilCompareMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilWriteMask( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilWriteMask\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSTENCILWRITEMASK;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["writeMask"]=writeMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILWRITEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["writeMask"].is_uint64()){
                writeMask=static_cast<uint32_t>(json["writeMask"].get_uint64());
            }else if (json["writeMask"].is_int64()){
                writeMask=static_cast<uint32_t>(json["writeMask"].get_int64());
            }else{
                writeMask=static_cast<uint32_t>(json["writeMask"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilWriteMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilReference( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilReference\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSTENCILREFERENCE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){json["reference"]=reference;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILREFERENCE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){
            if (json["reference"].is_uint64()){
                reference=static_cast<uint32_t>(json["reference"].get_uint64());
            }else if (json["reference"].is_int64()){
                reference=static_cast<uint32_t>(json["reference"].get_int64());
            }else{
                reference=static_cast<uint32_t>(json["reference"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetStencilReference...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorSets( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorSets\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDDESCRIPTORSETS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["descriptorSetCount"]=descriptorSetCount;}();
[&](){
            if (pDescriptorSets==NULL){
                json["pDescriptorSets"]=boost::json::array();
            return; }json["pDescriptorSets"]=boost::json::array(descriptorSetCount);
        auto& arr_JZNsxgK=json["pDescriptorSets"].get_array();
        for(int RJUNTKq=0; RJUNTKq < descriptorSetCount; RJUNTKq++){
            [&](){serialize_VkDescriptorSet(arr_JZNsxgK[RJUNTKq],pDescriptorSets[RJUNTKq]);}();
        }
        }();
[&](){json["dynamicOffsetCount"]=dynamicOffsetCount;}();
[&](){
            if (pDynamicOffsets==NULL){
                json["pDynamicOffsets"]=boost::json::array();
            return; }json["pDynamicOffsets"]=boost::json::array(dynamicOffsetCount);
        auto& arr_Zetuxcc=json["pDynamicOffsets"].get_array();
        for(int nxuqgVF=0; nxuqgVF < dynamicOffsetCount; nxuqgVF++){
            [&](){arr_Zetuxcc[nxuqgVF]=pDynamicOffsets[nxuqgVF];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORSETS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["firstSet"].is_uint64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_uint64());
            }else if (json["firstSet"].is_int64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_int64());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].get_double());
            }
            }();
[&](){
            if (json["descriptorSetCount"].is_uint64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_uint64());
            }else if (json["descriptorSetCount"].is_int64()){
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_int64());
            }else{
                descriptorSetCount=static_cast<uint32_t>(json["descriptorSetCount"].get_double());
            }
            }();

[&](){
            if (json["dynamicOffsetCount"].is_uint64()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_uint64());
            }else if (json["dynamicOffsetCount"].is_int64()){
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_int64());
            }else{
                dynamicOffsetCount=static_cast<uint32_t>(json["dynamicOffsetCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdBindDescriptorSets...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDINDEXBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_uint64());
            }else if (json["indexType"].is_int64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_int64());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDVERTEXBUFFERS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdBindVertexBuffers...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDraw\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAW;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexCount"]=vertexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstVertex"]=firstVertex;}();
[&](){json["firstInstance"]=firstInstance;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAW):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["vertexCount"].is_uint64()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_uint64());
            }else if (json["vertexCount"].is_int64()){
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_int64());
            }else{
                vertexCount=static_cast<uint32_t>(json["vertexCount"].get_double());
            }
            }();
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
[&](){
            if (json["firstVertex"].is_uint64()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_uint64());
            }else if (json["firstVertex"].is_int64()){
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_int64());
            }else{
                firstVertex=static_cast<uint32_t>(json["firstVertex"].get_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();

debug_printf("Ending vkCmdDraw...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexed\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDEXED;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["indexCount"]=indexCount;}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstIndex"]=firstIndex;}();
[&](){json["vertexOffset"]=vertexOffset;}();
[&](){json["firstInstance"]=firstInstance;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXED):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["indexCount"].is_uint64()){
                indexCount=static_cast<uint32_t>(json["indexCount"].get_uint64());
            }else if (json["indexCount"].is_int64()){
                indexCount=static_cast<uint32_t>(json["indexCount"].get_int64());
            }else{
                indexCount=static_cast<uint32_t>(json["indexCount"].get_double());
            }
            }();
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
[&](){
            if (json["firstIndex"].is_uint64()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_uint64());
            }else if (json["firstIndex"].is_int64()){
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_int64());
            }else{
                firstIndex=static_cast<uint32_t>(json["firstIndex"].get_double());
            }
            }();
[&](){
            if (json["vertexOffset"].is_uint64()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_uint64());
            }else if (json["vertexOffset"].is_int64()){
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_int64());
            }else{
                vertexOffset=static_cast<int32_t>(json["vertexOffset"].get_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexed...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMULTIEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pVertexInfo==NULL){
                json["pVertexInfo"]=boost::json::array();
            return; }json["pVertexInfo"]=boost::json::array(drawCount);
        auto& arr_NmVssTF=json["pVertexInfo"].get_array();
        for(int xJCsgzh=0; xJCsgzh < drawCount; xJCsgzh++){
            [&](){
            auto& temp=arr_NmVssTF[xJCsgzh].emplace_object();
            return serialize_struct(temp, pVertexInfo[xJCsgzh]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();

[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMultiEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMultiIndexedEXT( VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMultiIndexedEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMULTIINDEXEDEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["drawCount"]=drawCount;}();
[&](){
            if (pIndexInfo==NULL){
                json["pIndexInfo"]=boost::json::array();
            return; }json["pIndexInfo"]=boost::json::array(drawCount);
        auto& arr_OvAOCiL=json["pIndexInfo"].get_array();
        for(int FmfkOAV=0; FmfkOAV < drawCount; FmfkOAV++){
            [&](){
            auto& temp=arr_OvAOCiL[FmfkOAV].emplace_object();
            return serialize_struct(temp, pIndexInfo[FmfkOAV]);
            }();
        }
        }();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){json["stride"]=stride;}();
[&](){
            if (pVertexOffset==NULL){
                json["pVertexOffset"]=boost::json::array();
            return; }json["pVertexOffset"]=boost::json::array(1);
        auto& arr_PavgIEG=json["pVertexOffset"].get_array();
        for(int PNvrUEs=0; PNvrUEs < 1; PNvrUEs++){
            [&](){arr_PavgIEG[PNvrUEs]=pVertexOffset[PNvrUEs];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMULTIINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();

[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();


debug_printf("Ending vkCmdDrawMultiIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirect\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDIRECT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirect\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDEXEDINDIRECT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexedIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatch( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatch\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDISPATCH;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCH):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

debug_printf("Ending vkCmdDispatch...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchIndirect\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDISPATCHINDIRECT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHINDIRECT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDispatchIndirect...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSubpassShadingHUAWEI( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdSubpassShadingHUAWEI\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSUBPASSSHADINGHUAWEI;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSUBPASSSHADINGHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdSubpassShadingHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterHUAWEI( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterHUAWEI\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWCLUSTERHUAWEI;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawClusterHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawClusterIndirectHUAWEI( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawClusterIndirectHUAWEI\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWCLUSTERINDIRECTHUAWEI;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWCLUSTERINDIRECTHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();

debug_printf("Ending vkCmdDrawClusterIndirectHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdatePipelineIndirectBufferNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdatePipelineIndirectBufferNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDUPDATEPIPELINEINDIRECTBUFFERNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEPIPELINEINDIRECTBUFFERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();

debug_printf("Ending vkCmdUpdatePipelineIndirectBufferNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_McSYWcQ=json["pRegions"].get_array();
        for(int IaMuFrO=0; IaMuFrO < regionCount; IaMuFrO++){
            [&](){
            auto& temp=arr_McSYWcQ[IaMuFrO].emplace_object();
            return serialize_struct(temp, pRegions[IaMuFrO]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdCopyBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_HMPixWj=json["pRegions"].get_array();
        for(int TvxHvSV=0; TvxHvSV < regionCount; TvxHvSV++){
            [&](){
            auto& temp=arr_HMPixWj[TvxHvSV].emplace_object();
            return serialize_struct(temp, pRegions[TvxHvSV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdCopyImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBLITIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_dQsoHhP=json["pRegions"].get_array();
        for(int YEXYPDJ=0; YEXYPDJ < regionCount; YEXYPDJ++){
            [&](){
            auto& temp=arr_dQsoHhP[YEXYPDJ].emplace_object();
            return serialize_struct(temp, pRegions[YEXYPDJ]);
            }();
        }
        }();
[&](){[&](){[&](){json["filter"]=filter;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();

[&](){[&](){int temp_DaCTyEq;[&](){
            if (json["filter"].is_uint64()){
                temp_DaCTyEq=static_cast<int>(json["filter"].get_uint64());
            }else if (json["filter"].is_int64()){
                temp_DaCTyEq=static_cast<int>(json["filter"].get_int64());
            }else{
                temp_DaCTyEq=static_cast<int>(json["filter"].get_double());
            }
            }();filter=(VkFilter)temp_DaCTyEq;}();}();

debug_printf("Ending vkCmdBlitImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYBUFFERTOIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["srcBuffer"],srcBuffer);}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_igZnVsu=json["pRegions"].get_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["srcBuffer"], srcBuffer);}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdCopyBufferToImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYIMAGETOBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_igZnVsu=json["pRegions"].get_array();
        for(int yuuZKOo=0; yuuZKOo < regionCount; yuuZKOo++){
            [&](){
            auto& temp=arr_igZnVsu[yuuZKOo].emplace_object();
            return serialize_struct(temp, pRegions[yuuZKOo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdCopyImageToBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryIndirectNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMEMORYINDIRECTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_uint64());
            }else if (json["copyBufferAddress"].is_int64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_int64());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){
            if (json["copyCount"].is_uint64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_uint64());
            }else if (json["copyCount"].is_int64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_int64());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdCopyMemoryIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToImageIndirectNV( VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToImageIndirectNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMEMORYTOIMAGEINDIRECTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["copyBufferAddress"]=copyBufferAddress;}();}();
[&](){json["copyCount"]=copyCount;}();
[&](){json["stride"]=stride;}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){
            if (pImageSubresources==NULL){
                json["pImageSubresources"]=boost::json::array();
            return; }json["pImageSubresources"]=boost::json::array(copyCount);
        auto& arr_hVMAkcO=json["pImageSubresources"].get_array();
        for(int OfGHasS=0; OfGHasS < copyCount; OfGHasS++){
            [&](){
            auto& temp=arr_hVMAkcO[OfGHasS].emplace_object();
            return serialize_struct(temp, pImageSubresources[OfGHasS]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOIMAGEINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_qveUnrh;[&](){
            if (json["copyBufferAddress"].is_uint64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_uint64());
            }else if (json["copyBufferAddress"].is_int64()){
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_int64());
            }else{
                temp_qveUnrh=static_cast<uint64_t>(json["copyBufferAddress"].get_double());
            }
            }();copyBufferAddress=(VkDeviceAddress)temp_qveUnrh;}();
[&](){
            if (json["copyCount"].is_uint64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_uint64());
            }else if (json["copyCount"].is_int64()){
                copyCount=static_cast<uint32_t>(json["copyCount"].get_int64());
            }else{
                copyCount=static_cast<uint32_t>(json["copyCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();


debug_printf("Ending vkCmdCopyMemoryToImageIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdUpdateBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdUpdateBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCMDUPDATEBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["dataSize"]=dataSize;}();}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < dataSize; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDUPDATEBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_SwYyzuh;[&](){
            if (json["dataSize"].is_uint64()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_int64());
            }else{
                temp_SwYyzuh=static_cast<uint64_t>(json["dataSize"].get_double());
            }
            }();dataSize=(VkDeviceSize)temp_SwYyzuh;}();


debug_printf("Ending vkCmdUpdateBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdFillBuffer( VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data ){
//Will only be called by the client
debug_printf("Executing vkCmdFillBuffer\n");

    boost::json::object json;
    json["stream_type"]=VKCMDFILLBUFFER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){json["data"]=data;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDFILLBUFFER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){
            if (json["data"].is_uint64()){
                data=static_cast<uint32_t>(json["data"].get_uint64());
            }else if (json["data"].is_int64()){
                data=static_cast<uint32_t>(json["data"].get_int64());
            }else{
                data=static_cast<uint32_t>(json["data"].get_double());
            }
            }();

debug_printf("Ending vkCmdFillBuffer...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearColorImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearColorImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCLEARCOLORIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pColor==NULL){
                json["pColor"]=boost::json::array();
            return; }json["pColor"]=boost::json::array(1);
        auto& arr_SGRyjqE=json["pColor"].get_array();
        for(int ldPlUDi=0; ldPlUDi < 1; ldPlUDi++){
            [&](){
            auto& temp=arr_SGRyjqE[ldPlUDi].emplace_object();
            return serialize_struct(temp, pColor[ldPlUDi]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }json["pRanges"]=boost::json::array(rangeCount);
        auto& arr_BisbUqU=json["pRanges"].get_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARCOLORIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){
            if (json["rangeCount"].is_uint64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_uint64());
            }else if (json["rangeCount"].is_int64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_int64());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdClearColorImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearDepthStencilImage( VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges ){
//Will only be called by the client
debug_printf("Executing vkCmdClearDepthStencilImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCLEARDEPTHSTENCILIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
[&](){
            if (pDepthStencil==NULL){
                json["pDepthStencil"]=boost::json::array();
            return; }json["pDepthStencil"]=boost::json::array(1);
        auto& arr_gYzlVps=json["pDepthStencil"].get_array();
        for(int jJUemfv=0; jJUemfv < 1; jJUemfv++){
            [&](){
            auto& temp=arr_gYzlVps[jJUemfv].emplace_object();
            return serialize_struct(temp, pDepthStencil[jJUemfv]);
            }();
        }
        }();
[&](){json["rangeCount"]=rangeCount;}();
[&](){
            if (pRanges==NULL){
                json["pRanges"]=boost::json::array();
            return; }json["pRanges"]=boost::json::array(rangeCount);
        auto& arr_BisbUqU=json["pRanges"].get_array();
        for(int IZgopUD=0; IZgopUD < rangeCount; IZgopUD++){
            [&](){
            auto& temp=arr_BisbUqU[IZgopUD].emplace_object();
            return serialize_struct(temp, pRanges[IZgopUD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARDEPTHSTENCILIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

[&](){
            if (json["rangeCount"].is_uint64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_uint64());
            }else if (json["rangeCount"].is_int64()){
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_int64());
            }else{
                rangeCount=static_cast<uint32_t>(json["rangeCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdClearDepthStencilImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdClearAttachments( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects ){
//Will only be called by the client
debug_printf("Executing vkCmdClearAttachments\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCLEARATTACHMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pAttachments==NULL){
                json["pAttachments"]=boost::json::array();
            return; }json["pAttachments"]=boost::json::array(attachmentCount);
        auto& arr_fOlilkR=json["pAttachments"].get_array();
        for(int BsFiayf=0; BsFiayf < attachmentCount; BsFiayf++){
            [&](){
            auto& temp=arr_fOlilkR[BsFiayf].emplace_object();
            return serialize_struct(temp, pAttachments[BsFiayf]);
            }();
        }
        }();
[&](){json["rectCount"]=rectCount;}();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }json["pRects"]=boost::json::array(rectCount);
        auto& arr_cgJwUFb=json["pRects"].get_array();
        for(int HncrKEH=0; HncrKEH < rectCount; HncrKEH++){
            [&](){
            auto& temp=arr_cgJwUFb[HncrKEH].emplace_object();
            return serialize_struct(temp, pRects[HncrKEH]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCLEARATTACHMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();

[&](){
            if (json["rectCount"].is_uint64()){
                rectCount=static_cast<uint32_t>(json["rectCount"].get_uint64());
            }else if (json["rectCount"].is_int64()){
                rectCount=static_cast<uint32_t>(json["rectCount"].get_int64());
            }else{
                rectCount=static_cast<uint32_t>(json["rectCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdClearAttachments...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage( VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage\n");

    boost::json::object json;
    json["stream_type"]=VKCMDRESOLVEIMAGE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImage(json["srcImage"],srcImage);}();
[&](){[&](){[&](){json["srcImageLayout"]=srcImageLayout;}();}();}();
[&](){serialize_VkImage(json["dstImage"],dstImage);}();
[&](){[&](){[&](){json["dstImageLayout"]=dstImageLayout;}();}();}();
[&](){json["regionCount"]=regionCount;}();
[&](){
            if (pRegions==NULL){
                json["pRegions"]=boost::json::array();
            return; }json["pRegions"]=boost::json::array(regionCount);
        auto& arr_OGNZeww=json["pRegions"].get_array();
        for(int UbqELUx=0; UbqELUx < regionCount; UbqELUx++){
            [&](){
            auto& temp=arr_OGNZeww[UbqELUx].emplace_object();
            return serialize_struct(temp, pRegions[UbqELUx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImage(json["srcImage"], srcImage);}();
[&](){[&](){int temp_zMKCozb;[&](){
            if (json["srcImageLayout"].is_uint64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_uint64());
            }else if (json["srcImageLayout"].is_int64()){
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_int64());
            }else{
                temp_zMKCozb=static_cast<int>(json["srcImageLayout"].get_double());
            }
            }();srcImageLayout=(VkImageLayout)temp_zMKCozb;}();}();
[&](){deserialize_VkImage(json["dstImage"], dstImage);}();
[&](){[&](){int temp_jOGlaAP;[&](){
            if (json["dstImageLayout"].is_uint64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_uint64());
            }else if (json["dstImageLayout"].is_int64()){
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_int64());
            }else{
                temp_jOGlaAP=static_cast<int>(json["dstImageLayout"].get_double());
            }
            }();dstImageLayout=(VkImageLayout)temp_jOGlaAP;}();}();
[&](){
            if (json["regionCount"].is_uint64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_uint64());
            }else if (json["regionCount"].is_int64()){
                regionCount=static_cast<uint32_t>(json["regionCount"].get_int64());
            }else{
                regionCount=static_cast<uint32_t>(json["regionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdResolveImage...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdSetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent\n");

    boost::json::object json;
    json["stream_type"]=VKCMDRESETEVENT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_aUxfTbC;[&](){
            if (json["stageMask"].is_uint64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_aUxfTbC=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags)temp_aUxfTbC;}();}();

debug_printf("Ending vkCmdResetEvent...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWAITEVENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }json["pEvents"]=boost::json::array(eventCount);
        auto& arr_tUuyOPJ=json["pEvents"].get_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }json["pMemoryBarriers"]=boost::json::array(memoryBarrierCount);
        auto& arr_fXDYoDs=json["pMemoryBarriers"].get_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }json["pBufferMemoryBarriers"]=boost::json::array(bufferMemoryBarrierCount);
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].get_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }json["pImageMemoryBarriers"]=boost::json::array(imageMemoryBarrierCount);
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].get_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["eventCount"].is_uint64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_uint64());
            }else if (json["eventCount"].is_int64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_int64());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].get_double());
            }
            }();

[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_uint64());
            }else if (json["srcStageMask"].is_int64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_int64());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_uint64());
            }else if (json["dstStageMask"].is_int64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_int64());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){
            if (json["memoryBarrierCount"].is_uint64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_uint64());
            }else if (json["memoryBarrierCount"].is_int64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_int64());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_double());
            }
            }();

[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_uint64());
            }else if (json["bufferMemoryBarrierCount"].is_int64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_int64());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_double());
            }
            }();

[&](){
            if (json["imageMemoryBarrierCount"].is_uint64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_uint64());
            }else if (json["imageMemoryBarrierCount"].is_int64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_int64());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdWaitEvents...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier( VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPIPELINEBARRIER;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["srcStageMask"]=srcStageMask;}();}();}();
[&](){[&](){[&](){json["dstStageMask"]=dstStageMask;}();}();}();
[&](){[&](){[&](){json["dependencyFlags"]=dependencyFlags;}();}();}();
[&](){json["memoryBarrierCount"]=memoryBarrierCount;}();
[&](){
            if (pMemoryBarriers==NULL){
                json["pMemoryBarriers"]=boost::json::array();
            return; }json["pMemoryBarriers"]=boost::json::array(memoryBarrierCount);
        auto& arr_fXDYoDs=json["pMemoryBarriers"].get_array();
        for(int JhnlCAW=0; JhnlCAW < memoryBarrierCount; JhnlCAW++){
            [&](){
            auto& temp=arr_fXDYoDs[JhnlCAW].emplace_object();
            return serialize_struct(temp, pMemoryBarriers[JhnlCAW]);
            }();
        }
        }();
[&](){json["bufferMemoryBarrierCount"]=bufferMemoryBarrierCount;}();
[&](){
            if (pBufferMemoryBarriers==NULL){
                json["pBufferMemoryBarriers"]=boost::json::array();
            return; }json["pBufferMemoryBarriers"]=boost::json::array(bufferMemoryBarrierCount);
        auto& arr_FmJTDmX=json["pBufferMemoryBarriers"].get_array();
        for(int aFMQios=0; aFMQios < bufferMemoryBarrierCount; aFMQios++){
            [&](){
            auto& temp=arr_FmJTDmX[aFMQios].emplace_object();
            return serialize_struct(temp, pBufferMemoryBarriers[aFMQios]);
            }();
        }
        }();
[&](){json["imageMemoryBarrierCount"]=imageMemoryBarrierCount;}();
[&](){
            if (pImageMemoryBarriers==NULL){
                json["pImageMemoryBarriers"]=boost::json::array();
            return; }json["pImageMemoryBarriers"]=boost::json::array(imageMemoryBarrierCount);
        auto& arr_nkkvvYR=json["pImageMemoryBarriers"].get_array();
        for(int trWYSmx=0; trWYSmx < imageMemoryBarrierCount; trWYSmx++){
            [&](){
            auto& temp=arr_nkkvvYR[trWYSmx].emplace_object();
            return serialize_struct(temp, pImageMemoryBarriers[trWYSmx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_puDZLNO;[&](){
            if (json["srcStageMask"].is_uint64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_uint64());
            }else if (json["srcStageMask"].is_int64()){
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_int64());
            }else{
                temp_puDZLNO=static_cast<int>(json["srcStageMask"].get_double());
            }
            }();srcStageMask=(VkPipelineStageFlags)temp_puDZLNO;}();}();
[&](){[&](){int temp_OgAwXVW;[&](){
            if (json["dstStageMask"].is_uint64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_uint64());
            }else if (json["dstStageMask"].is_int64()){
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_int64());
            }else{
                temp_OgAwXVW=static_cast<int>(json["dstStageMask"].get_double());
            }
            }();dstStageMask=(VkPipelineStageFlags)temp_OgAwXVW;}();}();
[&](){[&](){int temp_MJCELwI;[&](){
            if (json["dependencyFlags"].is_uint64()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_uint64());
            }else if (json["dependencyFlags"].is_int64()){
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_int64());
            }else{
                temp_MJCELwI=static_cast<int>(json["dependencyFlags"].get_double());
            }
            }();dependencyFlags=(VkDependencyFlags)temp_MJCELwI;}();}();
[&](){
            if (json["memoryBarrierCount"].is_uint64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_uint64());
            }else if (json["memoryBarrierCount"].is_int64()){
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_int64());
            }else{
                memoryBarrierCount=static_cast<uint32_t>(json["memoryBarrierCount"].get_double());
            }
            }();

[&](){
            if (json["bufferMemoryBarrierCount"].is_uint64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_uint64());
            }else if (json["bufferMemoryBarrierCount"].is_int64()){
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_int64());
            }else{
                bufferMemoryBarrierCount=static_cast<uint32_t>(json["bufferMemoryBarrierCount"].get_double());
            }
            }();

[&](){
            if (json["imageMemoryBarrierCount"].is_uint64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_uint64());
            }else if (json["imageMemoryBarrierCount"].is_int64()){
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_int64());
            }else{
                imageMemoryBarrierCount=static_cast<uint32_t>(json["imageMemoryBarrierCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdPipelineBarrier...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQuery\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINQUERY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();

debug_printf("Ending vkCmdBeginQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQuery( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQuery\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDQUERY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

debug_printf("Ending vkCmdEndQuery...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginConditionalRenderingEXT( VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginConditionalRenderingEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINCONDITIONALRENDERINGEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pConditionalRenderingBegin==NULL){
                json["pConditionalRenderingBegin"]=boost::json::array();
            return; }json["pConditionalRenderingBegin"]=boost::json::array(1);
        auto& arr_guEoeuh=json["pConditionalRenderingBegin"].get_array();
        for(int KETgcvj=0; KETgcvj < 1; KETgcvj++){
            [&](){
            auto& temp=arr_guEoeuh[KETgcvj].emplace_object();
            return serialize_struct(temp, pConditionalRenderingBegin[KETgcvj]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndConditionalRenderingEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndConditionalRenderingEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDCONDITIONALRENDERINGEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDCONDITIONALRENDERINGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndConditionalRenderingEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetQueryPool( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount ){
//Will only be called by the client
debug_printf("Executing vkCmdResetQueryPool\n");

    boost::json::object json;
    json["stream_type"]=VKCMDRESETQUERYPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETQUERYPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();

debug_printf("Ending vkCmdResetQueryPool...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITETIMESTAMP;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_uint64());
            }else if (json["pipelineStage"].is_int64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_int64());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteTimestamp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyQueryPoolResults( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyQueryPoolResults\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYQUERYPOOLRESULTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
[&](){json["queryCount"]=queryCount;}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){[&](){json["stride"]=stride;}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYQUERYPOOLRESULTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();
[&](){
            if (json["queryCount"].is_uint64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_uint64());
            }else if (json["queryCount"].is_int64()){
                queryCount=static_cast<uint32_t>(json["queryCount"].get_int64());
            }else{
                queryCount=static_cast<uint32_t>(json["queryCount"].get_double());
            }
            }();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){uint64_t temp_fLSTSIg;[&](){
            if (json["stride"].is_uint64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_int64());
            }else{
                temp_fLSTSIg=static_cast<uint64_t>(json["stride"].get_double());
            }
            }();stride=(VkDeviceSize)temp_fLSTSIg;}();
[&](){[&](){int temp_jzLjdpj;[&](){
            if (json["flags"].is_uint64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_jzLjdpj=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_jzLjdpj=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryResultFlags)temp_jzLjdpj;}();}();

debug_printf("Ending vkCmdCopyQueryPoolResults...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPushConstants( VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues ){
//Will only be called by the client
debug_printf("Executing vkCmdPushConstants\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPUSHCONSTANTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){[&](){[&](){json["stageFlags"]=stageFlags;}();}();}();
[&](){json["offset"]=offset;}();
[&](){json["size"]=size;}();
[&](){
            if (pValues==NULL){
                json["pValues"]=boost::json::array();
            return; }[&](){
            if (((char*)(pValues))==NULL){
                json["pValues"]=boost::json::array();
            return; }json["pValues"]=boost::json::array(size);
        auto& arr_xbuPmvw=json["pValues"].get_array();
        for(int vSvAlWQ=0; vSvAlWQ < size; vSvAlWQ++){
            [&](){arr_xbuPmvw[vSvAlWQ]=((char*)(pValues))[vSvAlWQ];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHCONSTANTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){[&](){int temp_oWGKgUV;[&](){
            if (json["stageFlags"].is_uint64()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_uint64());
            }else if (json["stageFlags"].is_int64()){
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_int64());
            }else{
                temp_oWGKgUV=static_cast<int>(json["stageFlags"].get_double());
            }
            }();stageFlags=(VkShaderStageFlags)temp_oWGKgUV;}();}();
[&](){
            if (json["offset"].is_uint64()){
                offset=static_cast<uint32_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                offset=static_cast<uint32_t>(json["offset"].get_int64());
            }else{
                offset=static_cast<uint32_t>(json["offset"].get_double());
            }
            }();
[&](){
            if (json["size"].is_uint64()){
                size=static_cast<uint32_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                size=static_cast<uint32_t>(json["size"].get_int64());
            }else{
                size=static_cast<uint32_t>(json["size"].get_double());
            }
            }();


debug_printf("Ending vkCmdPushConstants...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINRENDERPASS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }json["pRenderPassBegin"]=boost::json::array(1);
        auto& arr_XtnTubd=json["pRenderPassBegin"].get_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_uint64());
            }else if (json["contents"].is_int64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_int64());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].get_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdBeginRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass( VkCommandBuffer commandBuffer, VkSubpassContents contents ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass\n");

    boost::json::object json;
    json["stream_type"]=VKCMDNEXTSUBPASS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["contents"]=contents;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_pXPXcBB;[&](){
            if (json["contents"].is_uint64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_uint64());
            }else if (json["contents"].is_int64()){
                temp_pXPXcBB=static_cast<int>(json["contents"].get_int64());
            }else{
                temp_pXPXcBB=static_cast<int>(json["contents"].get_double());
            }
            }();contents=(VkSubpassContents)temp_pXPXcBB;}();}();

debug_printf("Ending vkCmdNextSubpass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDRENDERPASS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRenderPass...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteCommands( VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteCommands\n");

    boost::json::object json;
    json["stream_type"]=VKCMDEXECUTECOMMANDS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["commandBufferCount"]=commandBufferCount;}();
[&](){
            if (pCommandBuffers==NULL){
                json["pCommandBuffers"]=boost::json::array();
            return; }json["pCommandBuffers"]=boost::json::array(commandBufferCount);
        auto& arr_PdRlpEO=json["pCommandBuffers"].get_array();
        for(int YDaxlFD=0; YDaxlFD < commandBufferCount; YDaxlFD++){
            [&](){serialize_VkCommandBuffer(arr_PdRlpEO[YDaxlFD],pCommandBuffers[YDaxlFD]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTECOMMANDS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["commandBufferCount"].is_uint64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_uint64());
            }else if (json["commandBufferCount"].is_int64()){
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_int64());
            }else{
                commandBufferCount=static_cast<uint32_t>(json["commandBufferCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdExecuteCommands...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_jKVTjSh=json["pProperties"].get_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].emplace_object();
            return serialize_struct(temp, pProperties[ULwTWiE]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_jKVTjSh=json["pProperties"].get_array();
        for(int ULwTWiE=0; ULwTWiE < *pPropertyCount; ULwTWiE++){
            [&](){
            auto& temp=arr_jKVTjSh[ULwTWiE].get_object();
            deserialize_struct(temp,pProperties[ULwTWiE]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wMWMDOL;[&](){
            if (json["result"].is_uint64()){
                temp_wMWMDOL=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_wMWMDOL=static_cast<int>(json["result"].get_int64());
            }else{
                temp_wMWMDOL=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_wMWMDOL;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlanePropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_TBQSgXa=json["pProperties"].get_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].emplace_object();
            return serialize_struct(temp, pProperties[yGKhOKS]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_TBQSgXa=json["pProperties"].get_array();
        for(int yGKhOKS=0; yGKhOKS < *pPropertyCount; yGKhOKS++){
            [&](){
            auto& temp=arr_TBQSgXa[yGKhOKS].get_object();
            deserialize_struct(temp,pProperties[yGKhOKS]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ltzLwWn;[&](){
            if (json["result"].is_uint64()){
                temp_ltzLwWn=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ltzLwWn=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ltzLwWn=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ltzLwWn;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlanePropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlanePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneSupportedDisplaysKHR( VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneSupportedDisplaysKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pDisplayCount==NULL){
                json["pDisplayCount"]=boost::json::array();
            return; }json["pDisplayCount"]=boost::json::array(1);
        auto& arr_HfQXIoE=json["pDisplayCount"].get_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){arr_HfQXIoE[tJtenSc]=pDisplayCount[tJtenSc];}();
        }
        }();
[&](){
            if (pDisplays==NULL){
                json["pDisplays"]=boost::json::array();
            return; }json["pDisplays"]=boost::json::array(*pDisplayCount);
        auto& arr_zfKAWAH=json["pDisplays"].get_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){serialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV],pDisplays[OSaHdZV]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANESUPPORTEDDISPLAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["planeIndex"].is_uint64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_uint64());
            }else if (json["planeIndex"].is_int64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_int64());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_double());
            }
            }();
[&](){
            if (json["pDisplayCount"].get_array().size()==0){
                pDisplayCount=NULL;
            return; }
        auto& arr_HfQXIoE=json["pDisplayCount"].get_array();
        for(int tJtenSc=0; tJtenSc < 1; tJtenSc++){
            [&](){
            if (arr_HfQXIoE[tJtenSc].is_uint64()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_uint64());
            }else if (arr_HfQXIoE[tJtenSc].is_int64()){
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_int64());
            }else{
                pDisplayCount[tJtenSc]=static_cast<uint32_t>(arr_HfQXIoE[tJtenSc].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pDisplays"].get_array().size()==0){
                pDisplays=NULL;
            return; }
        auto& arr_zfKAWAH=json["pDisplays"].get_array();
        for(int OSaHdZV=0; OSaHdZV < *pDisplayCount; OSaHdZV++){
            [&](){deserialize_VkDisplayKHR(arr_zfKAWAH[OSaHdZV], pDisplays[OSaHdZV]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_OikTSIm;[&](){
            if (json["result"].is_uint64()){
                temp_OikTSIm=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_OikTSIm=static_cast<int>(json["result"].get_int64());
            }else{
                temp_OikTSIm=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_OikTSIm;}();}();

debug_printf("Ending vkGetDisplayPlaneSupportedDisplaysKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneSupportedDisplaysKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModePropertiesKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModePropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDISPLAYMODEPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_kllbUBl=json["pProperties"].get_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].emplace_object();
            return serialize_struct(temp, pProperties[MCBnXbq]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_kllbUBl=json["pProperties"].get_array();
        for(int MCBnXbq=0; MCBnXbq < *pPropertyCount; MCBnXbq++){
            [&](){
            auto& temp=arr_kllbUBl[MCBnXbq].get_object();
            deserialize_struct(temp,pProperties[MCBnXbq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_LoZRfEp;[&](){
            if (json["result"].is_uint64()){
                temp_LoZRfEp=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LoZRfEp=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LoZRfEp=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LoZRfEp;}();}();

debug_printf("Ending vkGetDisplayModePropertiesKHR...\n");
debug_printf("Return value of vkGetDisplayModePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayModeKHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayModeKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDISPLAYMODEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_mQflhNS=json["pCreateInfo"].get_array();
        for(int UOiSdEd=0; UOiSdEd < 1; UOiSdEd++){
            [&](){
            auto& temp=arr_mQflhNS[UOiSdEd].emplace_object();
            return serialize_struct(temp, pCreateInfo[UOiSdEd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMode==NULL){
                json["pMode"]=boost::json::array();
            return; }json["pMode"]=boost::json::array(1);
        auto& arr_CHqKWyT=json["pMode"].get_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){serialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo],pMode[PRMVnqo]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYMODEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pMode"].get_array().size()==0){
                pMode=NULL;
            return; }
        auto& arr_CHqKWyT=json["pMode"].get_array();
        for(int PRMVnqo=0; PRMVnqo < 1; PRMVnqo++){
            [&](){deserialize_VkDisplayModeKHR(arr_CHqKWyT[PRMVnqo], pMode[PRMVnqo]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_kniGOao;[&](){
            if (json["result"].is_uint64()){
                temp_kniGOao=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_kniGOao=static_cast<int>(json["result"].get_int64());
            }else{
                temp_kniGOao=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_kniGOao;}();}();

                if (pMode!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMode[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayModeKHR...\n");
debug_printf("Return value of vkCreateDisplayModeKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilitiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDISPLAYPLANECAPABILITIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayModeKHR(json["mode"],mode);}();
[&](){json["planeIndex"]=planeIndex;}();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_HrzVMCr=json["pCapabilities"].get_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].emplace_object();
            return serialize_struct(temp, pCapabilities[aOxwnlc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayModeKHR(json["mode"], mode);}();
[&](){
            if (json["planeIndex"].is_uint64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_uint64());
            }else if (json["planeIndex"].is_int64()){
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_int64());
            }else{
                planeIndex=static_cast<uint32_t>(json["planeIndex"].get_double());
            }
            }();
[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_HrzVMCr=json["pCapabilities"].get_array();
        for(int aOxwnlc=0; aOxwnlc < 1; aOxwnlc++){
            [&](){
            auto& temp=arr_HrzVMCr[aOxwnlc].get_object();
            deserialize_struct(temp,pCapabilities[aOxwnlc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_zLZXATV;[&](){
            if (json["result"].is_uint64()){
                temp_zLZXATV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_zLZXATV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_zLZXATV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_zLZXATV;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDisplayPlaneSurfaceKHR( VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateDisplayPlaneSurfaceKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDISPLAYPLANESURFACEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_pnrRUFC=json["pCreateInfo"].get_array();
        for(int KAVLDOd=0; KAVLDOd < 1; KAVLDOd++){
            [&](){
            auto& temp=arr_pnrRUFC[KAVLDOd].emplace_object();
            return serialize_struct(temp, pCreateInfo[KAVLDOd]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDISPLAYPLANESURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_saNZXhN;[&](){
            if (json["result"].is_uint64()){
                temp_saNZXhN=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_saNZXhN=static_cast<int>(json["result"].get_int64());
            }else{
                temp_saNZXhN=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_saNZXhN;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDisplayPlaneSurfaceKHR...\n");
debug_printf("Return value of vkCreateDisplayPlaneSurfaceKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSharedSwapchainsKHR( VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains ){
//Will only be called by the client
debug_printf("Executing vkCreateSharedSwapchainsKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESHAREDSWAPCHAINSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(swapchainCount);
        auto& arr_GXhEUBn=json["pCreateInfos"].get_array();
        for(int KSXdUUO=0; KSXdUUO < swapchainCount; KSXdUUO++){
            [&](){
            auto& temp=arr_GXhEUBn[KSXdUUO].emplace_object();
            return serialize_struct(temp, pCreateInfos[KSXdUUO]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }json["pSwapchains"]=boost::json::array(swapchainCount);
        auto& arr_UlEaWkU=json["pSwapchains"].get_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){serialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd],pSwapchains[SREXLhd]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHAREDSWAPCHAINSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["swapchainCount"].is_uint64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_uint64());
            }else if (json["swapchainCount"].is_int64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_int64());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_double());
            }
            }();


[&](){
            if (json["pSwapchains"].get_array().size()==0){
                pSwapchains=NULL;
            return; }
        auto& arr_UlEaWkU=json["pSwapchains"].get_array();
        for(int SREXLhd=0; SREXLhd < swapchainCount; SREXLhd++){
            [&](){deserialize_VkSwapchainKHR(arr_UlEaWkU[SREXLhd], pSwapchains[SREXLhd]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_MTbyvky;[&](){
            if (json["result"].is_uint64()){
                temp_MTbyvky=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_MTbyvky=static_cast<int>(json["result"].get_int64());
            }else{
                temp_MTbyvky=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_MTbyvky;}();}();

                if (pSwapchains!=NULL){
                    for (int i=0; i<swapchainCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchains[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSharedSwapchainsKHR...\n");
debug_printf("Return value of vkCreateSharedSwapchainsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySurfaceKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSURFACEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSURFACEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();


debug_printf("Ending vkDestroySurfaceKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceSupportKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACESUPPORTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSupported==NULL){
                json["pSupported"]=boost::json::array();
            return; }json["pSupported"]=boost::json::array(1);
        auto& arr_SEnYPHg=json["pSupported"].get_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){[&](){arr_SEnYPHg[rAhuVoM]=pSupported[rAhuVoM];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACESUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSupported"].get_array().size()==0){
                pSupported=NULL;
            return; }
        auto& arr_SEnYPHg=json["pSupported"].get_array();
        for(int rAhuVoM=0; rAhuVoM < 1; rAhuVoM++){
            [&](){uint32_t temp_SEnYPHg;[&](){
            if (arr_SEnYPHg[rAhuVoM].is_uint64()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_uint64());
            }else if (arr_SEnYPHg[rAhuVoM].is_int64()){
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_int64());
            }else{
                temp_SEnYPHg=static_cast<uint32_t>(arr_SEnYPHg[rAhuVoM].get_double());
            }
            }();pSupported[rAhuVoM]=(VkBool32)temp_SEnYPHg;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LotRUeU;[&](){
            if (json["result"].is_uint64()){
                temp_LotRUeU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LotRUeU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LotRUeU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LotRUeU;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceSupportKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceSupportKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilitiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].get_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_mjTYhnS=json["pSurfaceCapabilities"].get_array();
        for(int MvYVwuP=0; MvYVwuP < 1; MvYVwuP++){
            [&](){
            auto& temp=arr_mjTYhnS[MvYVwuP].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[MvYVwuP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ItXtZre;[&](){
            if (json["result"].is_uint64()){
                temp_ItXtZre=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ItXtZre=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ItXtZre=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ItXtZre;}();}();
pSurfaceCapabilities->currentExtent=VkExtent2D{0xFFFFFFFF,0xFFFFFFFF};

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormatsKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormatsKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACEFORMATSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }json["pSurfaceFormatCount"]=boost::json::array(1);
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }json["pSurfaceFormats"]=boost::json::array(*pSurfaceFormatCount);
        auto& arr_FttXsVA=json["pSurfaceFormats"].get_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[sioXabq]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceFormatCount"].get_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_uint64());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_int64());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].get_array().size()==0){
                pSurfaceFormats=NULL;
            return; }
        auto& arr_FttXsVA=json["pSurfaceFormats"].get_array();
        for(int sioXabq=0; sioXabq < *pSurfaceFormatCount; sioXabq++){
            [&](){
            auto& temp=arr_FttXsVA[sioXabq].get_object();
            deserialize_struct(temp,pSurfaceFormats[sioXabq]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_uuOhwVg;[&](){
            if (json["result"].is_uint64()){
                temp_uuOhwVg=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_uuOhwVg=static_cast<int>(json["result"].get_int64());
            }else{
                temp_uuOhwVg=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_uuOhwVg;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormatsKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormatsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfacePresentModesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfacePresentModesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pPresentModeCount==NULL){
                json["pPresentModeCount"]=boost::json::array();
            return; }json["pPresentModeCount"]=boost::json::array(1);
        auto& arr_jrQQyxv=json["pPresentModeCount"].get_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){arr_jrQQyxv[yThsxfd]=pPresentModeCount[yThsxfd];}();
        }
        }();
[&](){
            if (pPresentModes==NULL){
                json["pPresentModes"]=boost::json::array();
            return; }json["pPresentModes"]=boost::json::array(*pPresentModeCount);
        auto& arr_hrNyEFX=json["pPresentModes"].get_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){[&](){arr_hrNyEFX[ULOmMaK]=pPresentModes[ULOmMaK];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pPresentModeCount"].get_array().size()==0){
                pPresentModeCount=NULL;
            return; }
        auto& arr_jrQQyxv=json["pPresentModeCount"].get_array();
        for(int yThsxfd=0; yThsxfd < 1; yThsxfd++){
            [&](){
            if (arr_jrQQyxv[yThsxfd].is_uint64()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_uint64());
            }else if (arr_jrQQyxv[yThsxfd].is_int64()){
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_int64());
            }else{
                pPresentModeCount[yThsxfd]=static_cast<uint32_t>(arr_jrQQyxv[yThsxfd].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPresentModes"].get_array().size()==0){
                pPresentModes=NULL;
            return; }
        auto& arr_hrNyEFX=json["pPresentModes"].get_array();
        for(int ULOmMaK=0; ULOmMaK < *pPresentModeCount; ULOmMaK++){
            [&](){[&](){int temp_ZltIdVU;[&](){
            if (arr_hrNyEFX[ULOmMaK].is_uint64()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_uint64());
            }else if (arr_hrNyEFX[ULOmMaK].is_int64()){
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_int64());
            }else{
                temp_ZltIdVU=static_cast<int>(arr_hrNyEFX[ULOmMaK].get_double());
            }
            }();pPresentModes[ULOmMaK]=(VkPresentModeKHR)temp_ZltIdVU;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vbOoAvY;[&](){
            if (json["result"].is_uint64()){
                temp_vbOoAvY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vbOoAvY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vbOoAvY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vbOoAvY;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSwapchainKHR( VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain ){
//Will only be called by the client
debug_printf("Executing vkCreateSwapchainKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESWAPCHAINKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{

        VkSwapchainCreateInfoKHR temp_info=*pCreateInfo;
        
        temp_info.imageUsage|=VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        
        pCreateInfo=&temp_info;
        
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_egkAfIq=json["pCreateInfo"].get_array();
        for(int RzLCOHt=0; RzLCOHt < 1; RzLCOHt++){
            [&](){
            auto& temp=arr_egkAfIq[RzLCOHt].emplace_object();
            return serialize_struct(temp, pCreateInfo[RzLCOHt]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSwapchain==NULL){
                json["pSwapchain"]=boost::json::array();
            return; }json["pSwapchain"]=boost::json::array(1);
        auto& arr_vaTnpgr=json["pSwapchain"].get_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){serialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc],pSwapchain[KnKufZc]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSwapchain"].get_array().size()==0){
                pSwapchain=NULL;
            return; }
        auto& arr_vaTnpgr=json["pSwapchain"].get_array();
        for(int KnKufZc=0; KnKufZc < 1; KnKufZc++){
            [&](){deserialize_VkSwapchainKHR(arr_vaTnpgr[KnKufZc], pSwapchain[KnKufZc]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_zHrmoVe;[&](){
            if (json["result"].is_uint64()){
                temp_zHrmoVe=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_zHrmoVe=static_cast<int>(json["result"].get_int64());
            }else{
                temp_zHrmoVe=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_zHrmoVe;}();}();

                if (pSwapchain!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSwapchain[i])]=parent;
                    }
                }
                
registerSwapchain(*pSwapchain,device, pCreateInfo);

debug_printf("Ending vkCreateSwapchainKHR...\n");
debug_printf("Return value of vkCreateSwapchainKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroySwapchainKHR( VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySwapchainKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSWAPCHAINKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSWAPCHAINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();


debug_printf("Ending vkDestroySwapchainKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainImagesKHR( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainImagesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETSWAPCHAINIMAGESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pSwapchainImageCount==NULL){
                json["pSwapchainImageCount"]=boost::json::array();
            return; }json["pSwapchainImageCount"]=boost::json::array(1);
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].get_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){arr_fUdbkNA[YVmxCel]=pSwapchainImageCount[YVmxCel];}();
        }
        }();
[&](){
            if (pSwapchainImages==NULL){
                json["pSwapchainImages"]=boost::json::array();
            return; }json["pSwapchainImages"]=boost::json::array(*pSwapchainImageCount);
        auto& arr_KNYDiQo=json["pSwapchainImages"].get_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){serialize_VkImage(arr_KNYDiQo[ICMlCyp],pSwapchainImages[ICMlCyp]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINIMAGESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pSwapchainImageCount"].get_array().size()==0){
                pSwapchainImageCount=NULL;
            return; }
        auto& arr_fUdbkNA=json["pSwapchainImageCount"].get_array();
        for(int YVmxCel=0; YVmxCel < 1; YVmxCel++){
            [&](){
            if (arr_fUdbkNA[YVmxCel].is_uint64()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_uint64());
            }else if (arr_fUdbkNA[YVmxCel].is_int64()){
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_int64());
            }else{
                pSwapchainImageCount[YVmxCel]=static_cast<uint32_t>(arr_fUdbkNA[YVmxCel].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSwapchainImages"].get_array().size()==0){
                pSwapchainImages=NULL;
            return; }
        auto& arr_KNYDiQo=json["pSwapchainImages"].get_array();
        for(int ICMlCyp=0; ICMlCyp < *pSwapchainImageCount; ICMlCyp++){
            [&](){deserialize_VkImage(arr_KNYDiQo[ICMlCyp], pSwapchainImages[ICMlCyp]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_RTeqDCy;[&](){
            if (json["result"].is_uint64()){
                temp_RTeqDCy=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_RTeqDCy=static_cast<int>(json["result"].get_int64());
            }else{
                temp_RTeqDCy=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_RTeqDCy;}();}();

debug_printf("Ending vkGetSwapchainImagesKHR...\n");
debug_printf("Return value of vkGetSwapchainImagesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImageKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImageKHR\n");

    boost::json::object json;
    json["stream_type"]=VKACQUIRENEXTIMAGEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["timeout"]=timeout;}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){serialize_VkFence(json["fence"],fence);}();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }json["pImageIndex"]=boost::json::array(1);
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){deserialize_VkFence(json["fence"], fence);}();
[&](){
            if (json["pImageIndex"].get_array().size()==0){
                pImageIndex=NULL;
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_uint64());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_int64());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wzTITSb;[&](){
            if (json["result"].is_uint64()){
                temp_wzTITSb=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_wzTITSb=static_cast<int>(json["result"].get_int64());
            }else{
                temp_wzTITSb=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_wzTITSb;}();}();

debug_printf("Ending vkAcquireNextImageKHR...\n");
debug_printf("Return value of vkAcquireNextImageKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR* pPresentInfo ){
//Will only be called by the client
debug_printf("Executing vkQueuePresentKHR\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEPRESENTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{

        auto new_info=(VkPresentInfoKHR*)copyVkStruct(pPresentInfo);
        
        auto parent_struct=(StreamStructure*)new_info;
        void* curr_struct=copyVkStruct(parent_struct->pNext);
        VkSwapchainPresentFenceInfoEXT* swapchain_fence_info=NULL;
        
        while(curr_struct!=NULL){
            parent_struct->pNext=curr_struct;
            if (((StreamStructure*)curr_struct)->sType==VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT){
                swapchain_fence_info=(VkSwapchainPresentFenceInfoEXT*)curr_struct;
            }
            parent_struct=(StreamStructure*)curr_struct;
            curr_struct=copyVkStruct(parent_struct->pNext);
        }
            
         if (swapchain_fence_info==NULL){
            swapchain_fence_info=new VkSwapchainPresentFenceInfoEXT;
            swapchain_fence_info->sType=VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT;
            swapchain_fence_info->pNext=NULL;
            swapchain_fence_info->swapchainCount=0;
            swapchain_fence_info->pFences=NULL;
            parent_struct->pNext=swapchain_fence_info;
         }
         
         auto old_count=swapchain_fence_info->swapchainCount;
         auto fences_list=(VkFence*)memdup(swapchain_fence_info->pFences,old_count*sizeof(VkFence));
         
         swapchain_fence_info->swapchainCount=new_info->swapchainCount;
         auto new_count=swapchain_fence_info->swapchainCount;
         fences_list=(VkFence*)realloc(fences_list,new_count*sizeof(VkFence));
         swapchain_fence_info->pFences=fences_list;
         
         auto fence_create_info=VkFenceCreateInfo{
         .sType=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
         .pNext=NULL,
         .flags=0
         };
         
         for (int i=0; i< new_count; i++){
            if ((i>= old_count) || (fences_list[i]==VK_NULL_HANDLE)){
                vkCreateFence(swapchain_to_device[(uintptr_t)(new_info->pSwapchains[i])],&fence_create_info, NULL, &(fences_list[i]));
            }
         }
         
         VkPresentInfoKHR* pPresentInfo=new_info;
         
          std::thread display_thread(QueueDisplay, fences_list, (VkSwapchainKHR*)memdup(pPresentInfo->pSwapchains, new_count*sizeof(VkSwapchainKHR)), (uint32_t*)memdup(pPresentInfo->pImageIndices, new_count*sizeof(uint32_t)), new_count);
          display_thread.detach();
        
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pPresentInfo==NULL){
                json["pPresentInfo"]=boost::json::array();
            return; }json["pPresentInfo"]=boost::json::array(1);
        auto& arr_EyhZHrS=json["pPresentInfo"].get_array();
        for(int EKHdNlu=0; EKHdNlu < 1; EKHdNlu++){
            [&](){
            auto& temp=arr_EyhZHrS[EKHdNlu].emplace_object();
            return serialize_struct(temp, pPresentInfo[EKHdNlu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();

VkResult result;
[&](){[&](){int temp_csTKlYw;[&](){
            if (json["result"].is_uint64()){
                temp_csTKlYw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_csTKlYw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_csTKlYw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_csTKlYw;}();}();

debug_printf("Ending vkQueuePresentKHR...\n");
debug_printf("Return value of vkQueuePresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXlibSurfaceKHR( VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXlibSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xlib);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXlibPresentationSupportKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (dpy==NULL){
                json["dpy"]=boost::json::array();
            return; }json["dpy"]=(uintptr_t)dpy;}();
[&](){json["visualID"]=(uintptr_t)visualID;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
[&](){
            if (json["dpy"].get_array().size()==0){
                dpy=NULL;
            return; }dpy=(Display* )(value_to<uintptr_t>(json["dpy"]));}();
[&](){visualID=(VisualID )(value_to<uintptr_t>(json["visualID"]));}();
VkBool32 result;
[&](){uint32_t temp_hXhCCrN;[&](){
            if (json["result"].is_uint64()){
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].get_int64());
            }else{
                temp_hXhCCrN=static_cast<uint32_t>(json["result"].get_double());
            }
            }();result=(VkBool32)temp_hXhCCrN;}();

debug_printf("Ending vkGetPhysicalDeviceXlibPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateXcbSurfaceKHR( VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateXcbSurfaceKHR\n");

        auto create_info=VkHeadlessSurfaceCreateInfoEXT{.sType=VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, .pNext=NULL, .flags=0};
        auto result=vkCreateHeadlessSurfaceEXT(instance,&create_info,pAllocator,pSurface);
        if (result!=VK_SUCCESS){
            return result;
        }
        

        registerSurface(*pSurface,pCreateInfo,Xcb);
        
        return result;
        }
        
__attribute__((visibility ("hidden"))) VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceXcbPresentationSupportKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (connection==NULL){
                json["connection"]=boost::json::array();
            return; }json["connection"]=(uintptr_t)connection;}();
[&](){json["visual_id"]=(uintptr_t)visual_id;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
[&](){
            if (json["connection"].get_array().size()==0){
                connection=NULL;
            return; }connection=(xcb_connection_t* )(value_to<uintptr_t>(json["connection"]));}();
[&](){visual_id=(xcb_visualid_t )(value_to<uintptr_t>(json["visual_id"]));}();
VkBool32 result;
[&](){uint32_t temp_TsntsfC;[&](){
            if (json["result"].is_uint64()){
                temp_TsntsfC=static_cast<uint32_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TsntsfC=static_cast<uint32_t>(json["result"].get_int64());
            }else{
                temp_TsntsfC=static_cast<uint32_t>(json["result"].get_double());
            }
            }();result=(VkBool32)temp_TsntsfC;}();

debug_printf("Ending vkGetPhysicalDeviceXcbPresentationSupportKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugReportCallbackEXT( VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugReportCallbackEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDEBUGREPORTCALLBACKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_YvgjHhM=json["pCreateInfo"].get_array();
        for(int BsRBklZ=0; BsRBklZ < 1; BsRBklZ++){
            [&](){
            auto& temp=arr_YvgjHhM[BsRBklZ].emplace_object();
            return serialize_struct(temp, pCreateInfo[BsRBklZ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pCallback==NULL){
                json["pCallback"]=boost::json::array();
            return; }json["pCallback"]=boost::json::array(1);
        auto& arr_qwLilWz=json["pCallback"].get_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){serialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy],pCallback[GoaYtYy]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pCallback"].get_array().size()==0){
                pCallback=NULL;
            return; }
        auto& arr_qwLilWz=json["pCallback"].get_array();
        for(int GoaYtYy=0; GoaYtYy < 1; GoaYtYy++){
            [&](){deserialize_VkDebugReportCallbackEXT(arr_qwLilWz[GoaYtYy], pCallback[GoaYtYy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_KbUnynS;[&](){
            if (json["result"].is_uint64()){
                temp_KbUnynS=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_KbUnynS=static_cast<int>(json["result"].get_int64());
            }else{
                temp_KbUnynS=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_KbUnynS;}();}();

                if (pCallback!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pCallback[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugReportCallbackEXT...\n");
debug_printf("Return value of vkCreateDebugReportCallbackEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugReportCallbackEXT( VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugReportCallbackEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDEBUGREPORTCALLBACKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugReportCallbackEXT(json["callback"],callback);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGREPORTCALLBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugReportCallbackEXT(json["callback"], callback);}();


debug_printf("Ending vkDestroyDebugReportCallbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkDebugReportMessageEXT( VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage ){
//Will only be called by the client
debug_printf("Executing vkDebugReportMessageEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDEBUGREPORTMESSAGEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["object"]=object;}();
[&](){json["location"]=location;}();
[&](){json["messageCode"]=messageCode;}();
[&](){
            if (pLayerPrefix==NULL){
                json["pLayerPrefix"]=boost::json::array();
            return; }json["pLayerPrefix"]=boost::json::array(strlen(pLayerPrefix)+1);
        auto& arr_SZVAgkt=json["pLayerPrefix"].get_array();
        for(int ESuRCqF=0; ESuRCqF < strlen(pLayerPrefix)+1; ESuRCqF++){
            [&](){arr_SZVAgkt[ESuRCqF]=pLayerPrefix[ESuRCqF];}();
        }
        }();
[&](){
            if (pMessage==NULL){
                json["pMessage"]=boost::json::array();
            return; }json["pMessage"]=boost::json::array(strlen(pMessage)+1);
        auto& arr_rGBBIki=json["pMessage"].get_array();
        for(int ZYKcZZQ=0; ZYKcZZQ < strlen(pMessage)+1; ZYKcZZQ++){
            [&](){arr_rGBBIki[ZYKcZZQ]=pMessage[ZYKcZZQ];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGREPORTMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_tiROuYA;[&](){
            if (json["flags"].is_uint64()){
                temp_tiROuYA=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_tiROuYA=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_tiROuYA=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkDebugReportFlagsEXT)temp_tiROuYA;}();}();
[&](){[&](){int temp_rGtGMFh;[&](){
            if (json["objectType"].is_uint64()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_rGtGMFh=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkDebugReportObjectTypeEXT)temp_rGtGMFh;}();}();
[&](){
            if (json["object"].is_uint64()){
                object=static_cast<uint64_t>(json["object"].get_uint64());
            }else if (json["object"].is_int64()){
                object=static_cast<uint64_t>(json["object"].get_int64());
            }else{
                object=static_cast<uint64_t>(json["object"].get_double());
            }
            }();
[&](){
            if (json["location"].is_uint64()){
                location=static_cast<size_t>(json["location"].get_uint64());
            }else if (json["location"].is_int64()){
                location=static_cast<size_t>(json["location"].get_int64());
            }else{
                location=static_cast<size_t>(json["location"].get_double());
            }
            }();
[&](){
            if (json["messageCode"].is_uint64()){
                messageCode=static_cast<int32_t>(json["messageCode"].get_uint64());
            }else if (json["messageCode"].is_int64()){
                messageCode=static_cast<int32_t>(json["messageCode"].get_int64());
            }else{
                messageCode=static_cast<int32_t>(json["messageCode"].get_double());
            }
            }();



debug_printf("Ending vkDebugReportMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectNameEXT( VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectNameEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDEBUGMARKERSETOBJECTNAMEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }json["pNameInfo"]=boost::json::array(1);
        auto& arr_WQmILKl=json["pNameInfo"].get_array();
        for(int VlhHang=0; VlhHang < 1; VlhHang++){
            [&](){
            auto& temp=arr_WQmILKl[VlhHang].emplace_object();
            return serialize_struct(temp, pNameInfo[VlhHang]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_VfBgOIt;[&](){
            if (json["result"].is_uint64()){
                temp_VfBgOIt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VfBgOIt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VfBgOIt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VfBgOIt;}();}();

debug_printf("Ending vkDebugMarkerSetObjectNameEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDebugMarkerSetObjectTagEXT( VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkDebugMarkerSetObjectTagEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDEBUGMARKERSETOBJECTTAGEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }json["pTagInfo"]=boost::json::array(1);
        auto& arr_uESKIxS=json["pTagInfo"].get_array();
        for(int fibGciH=0; fibGciH < 1; fibGciH++){
            [&](){
            auto& temp=arr_uESKIxS[fibGciH].emplace_object();
            return serialize_struct(temp, pTagInfo[fibGciH]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEBUGMARKERSETOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ZCuJyoB;[&](){
            if (json["result"].is_uint64()){
                temp_ZCuJyoB=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZCuJyoB=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZCuJyoB=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZCuJyoB;}();}();

debug_printf("Ending vkDebugMarkerSetObjectTagEXT...\n");
debug_printf("Return value of vkDebugMarkerSetObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerBeginEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerBeginEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDEBUGMARKERBEGINEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_sUKpmoY=json["pMarkerInfo"].get_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERBEGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerBeginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerEndEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerEndEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDEBUGMARKERENDEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERENDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdDebugMarkerEndEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDebugMarkerInsertEXT( VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDebugMarkerInsertEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDEBUGMARKERINSERTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_sUKpmoY=json["pMarkerInfo"].get_array();
        for(int MSMqdqs=0; MSMqdqs < 1; MSMqdqs++){
            [&](){
            auto& temp=arr_sUKpmoY[MSMqdqs].emplace_object();
            return serialize_struct(temp, pMarkerInfo[MSMqdqs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDEBUGMARKERINSERTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDebugMarkerInsertEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV( VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalImageFormatPropertiesNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){[&](){[&](){json["type"]=type;}();}();}();
[&](){[&](){[&](){json["tiling"]=tiling;}();}();}();
[&](){[&](){[&](){json["usage"]=usage;}();}();}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){[&](){[&](){json["externalHandleType"]=externalHandleType;}();}();}();
[&](){
            if (pExternalImageFormatProperties==NULL){
                json["pExternalImageFormatProperties"]=boost::json::array();
            return; }json["pExternalImageFormatProperties"]=boost::json::array(1);
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].get_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].emplace_object();
            return serialize_struct(temp, pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){[&](){int temp_bMZuPlo;[&](){
            if (json["type"].is_uint64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_uint64());
            }else if (json["type"].is_int64()){
                temp_bMZuPlo=static_cast<int>(json["type"].get_int64());
            }else{
                temp_bMZuPlo=static_cast<int>(json["type"].get_double());
            }
            }();type=(VkImageType)temp_bMZuPlo;}();}();
[&](){[&](){int temp_PtqdPDE;[&](){
            if (json["tiling"].is_uint64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_uint64());
            }else if (json["tiling"].is_int64()){
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_int64());
            }else{
                temp_PtqdPDE=static_cast<int>(json["tiling"].get_double());
            }
            }();tiling=(VkImageTiling)temp_PtqdPDE;}();}();
[&](){[&](){int temp_sXuQFYv;[&](){
            if (json["usage"].is_uint64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_uint64());
            }else if (json["usage"].is_int64()){
                temp_sXuQFYv=static_cast<int>(json["usage"].get_int64());
            }else{
                temp_sXuQFYv=static_cast<int>(json["usage"].get_double());
            }
            }();usage=(VkImageUsageFlags)temp_sXuQFYv;}();}();
[&](){[&](){int temp_LpOHWxp;[&](){
            if (json["flags"].is_uint64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_LpOHWxp=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_LpOHWxp=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkImageCreateFlags)temp_LpOHWxp;}();}();
[&](){[&](){int temp_DSfbDyM;[&](){
            if (json["externalHandleType"].is_uint64()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_uint64());
            }else if (json["externalHandleType"].is_int64()){
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_int64());
            }else{
                temp_DSfbDyM=static_cast<int>(json["externalHandleType"].get_double());
            }
            }();externalHandleType=(VkExternalMemoryHandleTypeFlagsNV)temp_DSfbDyM;}();}();
[&](){
            if (json["pExternalImageFormatProperties"].get_array().size()==0){
                pExternalImageFormatProperties=NULL;
            return; }
        auto& arr_gXHGwln=json["pExternalImageFormatProperties"].get_array();
        for(int CfNLqMF=0; CfNLqMF < 1; CfNLqMF++){
            [&](){
            auto& temp=arr_gXHGwln[CfNLqMF].get_object();
            deserialize_struct(temp,pExternalImageFormatProperties[CfNLqMF]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_vEkPnlL;[&](){
            if (json["result"].is_uint64()){
                temp_vEkPnlL=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vEkPnlL=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vEkPnlL=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vEkPnlL;}();}();

debug_printf("Ending vkGetPhysicalDeviceExternalImageFormatPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceExternalImageFormatPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdExecuteGeneratedCommandsNV( VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdExecuteGeneratedCommandsNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDEXECUTEGENERATEDCOMMANDSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["isPreprocessed"]=isPreprocessed;}();}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }json["pGeneratedCommandsInfo"]=boost::json::array(1);
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].get_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDEXECUTEGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_tPMaOPc;[&](){
            if (json["isPreprocessed"].is_uint64()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_uint64());
            }else if (json["isPreprocessed"].is_int64()){
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_int64());
            }else{
                temp_tPMaOPc=static_cast<uint32_t>(json["isPreprocessed"].get_double());
            }
            }();isPreprocessed=(VkBool32)temp_tPMaOPc;}();


debug_printf("Ending vkCmdExecuteGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPreprocessGeneratedCommandsNV( VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPreprocessGeneratedCommandsNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPREPROCESSGENERATEDCOMMANDSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pGeneratedCommandsInfo==NULL){
                json["pGeneratedCommandsInfo"]=boost::json::array();
            return; }json["pGeneratedCommandsInfo"]=boost::json::array(1);
        auto& arr_mvZtJqS=json["pGeneratedCommandsInfo"].get_array();
        for(int breVZQP=0; breVZQP < 1; breVZQP++){
            [&](){
            auto& temp=arr_mvZtJqS[breVZQP].emplace_object();
            return serialize_struct(temp, pGeneratedCommandsInfo[breVZQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPREPROCESSGENERATEDCOMMANDSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPreprocessGeneratedCommandsNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindPipelineShaderGroupNV( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex ){
//Will only be called by the client
debug_printf("Executing vkCmdBindPipelineShaderGroupNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDPIPELINESHADERGROUPNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["groupIndex"]=groupIndex;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDPIPELINESHADERGROUPNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["groupIndex"].is_uint64()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_uint64());
            }else if (json["groupIndex"].is_int64()){
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_int64());
            }else{
                groupIndex=static_cast<uint32_t>(json["groupIndex"].get_double());
            }
            }();

debug_printf("Ending vkCmdBindPipelineShaderGroupNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetGeneratedCommandsMemoryRequirementsNV( VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetGeneratedCommandsMemoryRequirementsNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_bVjZkmU=json["pInfo"].get_array();
        for(int suoLDtj=0; suoLDtj < 1; suoLDtj++){
            [&](){
            auto& temp=arr_bVjZkmU[suoLDtj].emplace_object();
            return serialize_struct(temp, pInfo[suoLDtj]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetGeneratedCommandsMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateIndirectCommandsLayoutNV( VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout ){
//Will only be called by the client
debug_printf("Executing vkCreateIndirectCommandsLayoutNV\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEINDIRECTCOMMANDSLAYOUTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_EQPGiEt=json["pCreateInfo"].get_array();
        for(int TPVCKbG=0; TPVCKbG < 1; TPVCKbG++){
            [&](){
            auto& temp=arr_EQPGiEt[TPVCKbG].emplace_object();
            return serialize_struct(temp, pCreateInfo[TPVCKbG]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pIndirectCommandsLayout==NULL){
                json["pIndirectCommandsLayout"]=boost::json::array();
            return; }json["pIndirectCommandsLayout"]=boost::json::array(1);
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].get_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){serialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy],pIndirectCommandsLayout[becsFhy]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pIndirectCommandsLayout"].get_array().size()==0){
                pIndirectCommandsLayout=NULL;
            return; }
        auto& arr_lGdEoyU=json["pIndirectCommandsLayout"].get_array();
        for(int becsFhy=0; becsFhy < 1; becsFhy++){
            [&](){deserialize_VkIndirectCommandsLayoutNV(arr_lGdEoyU[becsFhy], pIndirectCommandsLayout[becsFhy]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pvQcinN;[&](){
            if (json["result"].is_uint64()){
                temp_pvQcinN=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_pvQcinN=static_cast<int>(json["result"].get_int64());
            }else{
                temp_pvQcinN=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_pvQcinN;}();}();

                if (pIndirectCommandsLayout!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pIndirectCommandsLayout[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateIndirectCommandsLayoutNV...\n");
debug_printf("Return value of vkCreateIndirectCommandsLayoutNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyIndirectCommandsLayoutNV( VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyIndirectCommandsLayoutNV\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYINDIRECTCOMMANDSLAYOUTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"],indirectCommandsLayout);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYINDIRECTCOMMANDSLAYOUTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkIndirectCommandsLayoutNV(json["indirectCommandsLayout"], indirectCommandsLayout);}();


debug_printf("Ending vkDestroyIndirectCommandsLayoutNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFeatures2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEFEATURES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFeatures==NULL){
                json["pFeatures"]=boost::json::array();
            return; }json["pFeatures"]=boost::json::array(1);
        auto& arr_QUwriqy=json["pFeatures"].get_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].emplace_object();
            return serialize_struct(temp, pFeatures[AlewVZE]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFEATURES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFeatures"].get_array().size()==0){
                pFeatures=NULL;
            return; }
        auto& arr_QUwriqy=json["pFeatures"].get_array();
        for(int AlewVZE=0; AlewVZE < 1; AlewVZE++){
            [&](){
            auto& temp=arr_QUwriqy[AlewVZE].get_object();
            deserialize_struct(temp,pFeatures[AlewVZE]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFeatures2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFeatures2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures ){
return vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_oZVBLox=json["pProperties"].get_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].emplace_object();
            return serialize_struct(temp, pProperties[pxUpVYV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oZVBLox=json["pProperties"].get_array();
        for(int pxUpVYV=0; pxUpVYV < 1; pxUpVYV++){
            [&](){
            auto& temp=arr_oZVBLox[pxUpVYV].get_object();
            deserialize_struct(temp,pProperties[pxUpVYV]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties ){
return vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFormatProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEFORMATPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["format"]=format;}();}();}();
[&](){
            if (pFormatProperties==NULL){
                json["pFormatProperties"]=boost::json::array();
            return; }json["pFormatProperties"]=boost::json::array(1);
        auto& arr_RNYTnLU=json["pFormatProperties"].get_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].emplace_object();
            return serialize_struct(temp, pFormatProperties[VZFdkqX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_MKJOJVI;[&](){
            if (json["format"].is_uint64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_uint64());
            }else if (json["format"].is_int64()){
                temp_MKJOJVI=static_cast<int>(json["format"].get_int64());
            }else{
                temp_MKJOJVI=static_cast<int>(json["format"].get_double());
            }
            }();format=(VkFormat)temp_MKJOJVI;}();}();
[&](){
            if (json["pFormatProperties"].get_array().size()==0){
                pFormatProperties=NULL;
            return; }
        auto& arr_RNYTnLU=json["pFormatProperties"].get_array();
        for(int VZFdkqX=0; VZFdkqX < 1; VZFdkqX++){
            [&](){
            auto& temp=arr_RNYTnLU[VZFdkqX].get_object();
            deserialize_struct(temp,pFormatProperties[VZFdkqX]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceFormatProperties2KHR( VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties ){
return vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceImageFormatProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pImageFormatInfo==NULL){
                json["pImageFormatInfo"]=boost::json::array();
            return; }json["pImageFormatInfo"]=boost::json::array(1);
        auto& arr_MpVGyYe=json["pImageFormatInfo"].get_array();
        for(int YAeYFEt=0; YAeYFEt < 1; YAeYFEt++){
            [&](){
            auto& temp=arr_MpVGyYe[YAeYFEt].emplace_object();
            return serialize_struct(temp, pImageFormatInfo[YAeYFEt]);
            }();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(1);
        auto& arr_wmAZzRc=json["pImageFormatProperties"].get_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_wmAZzRc=json["pImageFormatProperties"].get_array();
        for(int NQfBHSv=0; NQfBHSv < 1; NQfBHSv++){
            [&](){
            auto& temp=arr_wmAZzRc[NQfBHSv].get_object();
            deserialize_struct(temp,pImageFormatProperties[NQfBHSv]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_TYPijbq;[&](){
            if (json["result"].is_uint64()){
                temp_TYPijbq=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TYPijbq=static_cast<int>(json["result"].get_int64());
            }else{
                temp_TYPijbq=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_TYPijbq;}();}();

debug_printf("Ending vkGetPhysicalDeviceImageFormatProperties2...\n");
debug_printf("Return value of vkGetPhysicalDeviceImageFormatProperties2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties ){
return vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pQueueFamilyPropertyCount==NULL){
                json["pQueueFamilyPropertyCount"]=boost::json::array();
            return; }json["pQueueFamilyPropertyCount"]=boost::json::array(1);
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){arr_tzRlmPf[cPKCUxv]=pQueueFamilyPropertyCount[cPKCUxv];}();
        }
        }();
[&](){
            if (pQueueFamilyProperties==NULL){
                json["pQueueFamilyProperties"]=boost::json::array();
            return; }json["pQueueFamilyProperties"]=boost::json::array(*pQueueFamilyPropertyCount);
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].get_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].emplace_object();
            return serialize_struct(temp, pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pQueueFamilyPropertyCount"].get_array().size()==0){
                pQueueFamilyPropertyCount=NULL;
            return; }
        auto& arr_tzRlmPf=json["pQueueFamilyPropertyCount"].get_array();
        for(int cPKCUxv=0; cPKCUxv < 1; cPKCUxv++){
            [&](){
            if (arr_tzRlmPf[cPKCUxv].is_uint64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_uint64());
            }else if (arr_tzRlmPf[cPKCUxv].is_int64()){
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_int64());
            }else{
                pQueueFamilyPropertyCount[cPKCUxv]=static_cast<uint32_t>(arr_tzRlmPf[cPKCUxv].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pQueueFamilyProperties"].get_array().size()==0){
                pQueueFamilyProperties=NULL;
            return; }
        auto& arr_NqmNsHw=json["pQueueFamilyProperties"].get_array();
        for(int UxEWlik=0; UxEWlik < *pQueueFamilyPropertyCount; UxEWlik++){
            [&](){
            auto& temp=arr_NqmNsHw[UxEWlik].get_object();
            deserialize_struct(temp,pQueueFamilyProperties[UxEWlik]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties ){
return vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMemoryProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEMEMORYPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pMemoryProperties==NULL){
                json["pMemoryProperties"]=boost::json::array();
            return; }json["pMemoryProperties"]=boost::json::array(1);
        auto& arr_nJXNYGt=json["pMemoryProperties"].get_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].emplace_object();
            return serialize_struct(temp, pMemoryProperties[tFDFCkf]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMEMORYPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pMemoryProperties"].get_array().size()==0){
                pMemoryProperties=NULL;
            return; }
        auto& arr_nJXNYGt=json["pMemoryProperties"].get_array();
        for(int tFDFCkf=0; tFDFCkf < 1; tFDFCkf++){
            [&](){
            auto& temp=arr_nJXNYGt[tFDFCkf].get_object();
            deserialize_struct(temp,pMemoryProperties[tFDFCkf]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMemoryProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMemoryProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties ){
return vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSparseImageFormatProperties2\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFormatInfo==NULL){
                json["pFormatInfo"]=boost::json::array();
            return; }json["pFormatInfo"]=boost::json::array(1);
        auto& arr_nZOUWlt=json["pFormatInfo"].get_array();
        for(int cvknnOe=0; cvknnOe < 1; cvknnOe++){
            [&](){
            auto& temp=arr_nZOUWlt[cvknnOe].emplace_object();
            return serialize_struct(temp, pFormatInfo[cvknnOe]);
            }();
        }
        }();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_YaLkATe=json["pProperties"].get_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].emplace_object();
            return serialize_struct(temp, pProperties[lIrIGCv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_YaLkATe=json["pProperties"].get_array();
        for(int lIrIGCv=0; lIrIGCv < *pPropertyCount; lIrIGCv++){
            [&](){
            auto& temp=arr_YaLkATe[lIrIGCv].get_object();
            deserialize_struct(temp,pProperties[lIrIGCv]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceSparseImageFormatProperties2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceSparseImageFormatProperties2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties ){
return vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetKHR( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPUSHDESCRIPTORSETKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){json["descriptorWriteCount"]=descriptorWriteCount;}();
[&](){
            if (pDescriptorWrites==NULL){
                json["pDescriptorWrites"]=boost::json::array();
            return; }json["pDescriptorWrites"]=boost::json::array(descriptorWriteCount);
        auto& arr_AuOrFWk=json["pDescriptorWrites"].get_array();
        for(int qJACxKx=0; qJACxKx < descriptorWriteCount; qJACxKx++){
            [&](){
            auto& temp=arr_AuOrFWk[qJACxKx].emplace_object();
            return serialize_struct(temp, pDescriptorWrites[qJACxKx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();
[&](){
            if (json["descriptorWriteCount"].is_uint64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_uint64());
            }else if (json["descriptorWriteCount"].is_int64()){
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_int64());
            }else{
                descriptorWriteCount=static_cast<uint32_t>(json["descriptorWriteCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdPushDescriptorSetKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPool( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
//Will only be called by the client
debug_printf("Executing vkTrimCommandPool\n");

    boost::json::object json;
    json["stream_type"]=VKTRIMCOMMANDPOOL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCommandPool(json["commandPool"],commandPool);}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRIMCOMMANDPOOL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCommandPool(json["commandPool"], commandPool);}();
[&](){[&](){int temp_FGvozFl;[&](){
            if (json["flags"].is_uint64()){
                temp_FGvozFl=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_FGvozFl=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_FGvozFl=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkCommandPoolTrimFlags)temp_FGvozFl;}();}();

debug_printf("Ending vkTrimCommandPool...\n");
}
__attribute__((visibility ("hidden"))) void vkTrimCommandPoolKHR( VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags ){
return vkTrimCommandPool(device, commandPool, flags);
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalBufferProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalBufferInfo==NULL){
                json["pExternalBufferInfo"]=boost::json::array();
            return; }json["pExternalBufferInfo"]=boost::json::array(1);
        auto& arr_VbIxQJg=json["pExternalBufferInfo"].get_array();
        for(int XeSwNaV=0; XeSwNaV < 1; XeSwNaV++){
            [&](){
            auto& temp=arr_VbIxQJg[XeSwNaV].emplace_object();
            return serialize_struct(temp, pExternalBufferInfo[XeSwNaV]);
            }();
        }
        }();
[&](){
            if (pExternalBufferProperties==NULL){
                json["pExternalBufferProperties"]=boost::json::array();
            return; }json["pExternalBufferProperties"]=boost::json::array(1);
        auto& arr_oXzExYk=json["pExternalBufferProperties"].get_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].emplace_object();
            return serialize_struct(temp, pExternalBufferProperties[ufvutei]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalBufferProperties"].get_array().size()==0){
                pExternalBufferProperties=NULL;
            return; }
        auto& arr_oXzExYk=json["pExternalBufferProperties"].get_array();
        for(int ufvutei=0; ufvutei < 1; ufvutei++){
            [&](){
            auto& temp=arr_oXzExYk[ufvutei].get_object();
            deserialize_struct(temp,pExternalBufferProperties[ufvutei]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalBufferProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalBufferPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties ){
return vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdKHR( VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETMEMORYFDKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_imCbcqk=json["pGetFdInfo"].get_array();
        for(int oZoTEJx=0; oZoTEJx < 1; oZoTEJx++){
            [&](){
            auto& temp=arr_imCbcqk[oZoTEJx].emplace_object();
            return serialize_struct(temp, pGetFdInfo[oZoTEJx]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_koObBcU;[&](){
            if (json["result"].is_uint64()){
                temp_koObBcU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_koObBcU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_koObBcU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_koObBcU;}();}();

debug_printf("Ending vkGetMemoryFdKHR...\n");
debug_printf("Return value of vkGetMemoryFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryFdPropertiesKHR( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryFdPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETMEMORYFDPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){json["fd"]=fd;}();
[&](){
            if (pMemoryFdProperties==NULL){
                json["pMemoryFdProperties"]=boost::json::array();
            return; }json["pMemoryFdProperties"]=boost::json::array(1);
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].get_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].emplace_object();
            return serialize_struct(temp, pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYFDPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_uint64());
            }else if (json["handleType"].is_int64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_int64());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();
[&](){
            if (json["fd"].is_uint64()){
                fd=static_cast<int>(json["fd"].get_uint64());
            }else if (json["fd"].is_int64()){
                fd=static_cast<int>(json["fd"].get_int64());
            }else{
                fd=static_cast<int>(json["fd"].get_double());
            }
            }();
[&](){
            if (json["pMemoryFdProperties"].get_array().size()==0){
                pMemoryFdProperties=NULL;
            return; }
        auto& arr_tzzZhYk=json["pMemoryFdProperties"].get_array();
        for(int UpKTZRJ=0; UpKTZRJ < 1; UpKTZRJ++){
            [&](){
            auto& temp=arr_tzzZhYk[UpKTZRJ].get_object();
            deserialize_struct(temp,pMemoryFdProperties[UpKTZRJ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HRcPPmY;[&](){
            if (json["result"].is_uint64()){
                temp_HRcPPmY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HRcPPmY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HRcPPmY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HRcPPmY;}();}();

debug_printf("Ending vkGetMemoryFdPropertiesKHR...\n");
debug_printf("Return value of vkGetMemoryFdPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryRemoteAddressNV( VkDevice device, const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryRemoteAddressNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETMEMORYREMOTEADDRESSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryGetRemoteAddressInfo==NULL){
                json["pMemoryGetRemoteAddressInfo"]=boost::json::array();
            return; }json["pMemoryGetRemoteAddressInfo"]=boost::json::array(1);
        auto& arr_JYmQngD=json["pMemoryGetRemoteAddressInfo"].get_array();
        for(int tlzypUU=0; tlzypUU < 1; tlzypUU++){
            [&](){
            auto& temp=arr_JYmQngD[tlzypUU].emplace_object();
            return serialize_struct(temp, pMemoryGetRemoteAddressInfo[tlzypUU]);
            }();
        }
        }();
[&](){
            if (pAddress==NULL){
                json["pAddress"]=boost::json::array();
            return; }json["pAddress"]=boost::json::array(1);
        auto& arr_LTIxmQF=json["pAddress"].get_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){[&](){
            if (pAddress[LIvckbR]==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }[&](){
            if (((char*)(pAddress[LIvckbR]))==NULL){
                arr_LTIxmQF[LIvckbR]=boost::json::array();
            return; }arr_LTIxmQF[LIvckbR]=boost::json::array(strlen(((char*)(pAddress[LIvckbR])))+1);
        auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].get_array();
        for(int lBwzqzO=0; lBwzqzO < strlen(((char*)(pAddress[LIvckbR])))+1; lBwzqzO++){
            [&](){arr_FUzakvN[lBwzqzO]=((char*)(pAddress[LIvckbR]))[lBwzqzO];}();
        }
        }();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYREMOTEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pAddress"].get_array().size()==0){
                pAddress=NULL;
            return; }
        auto& arr_LTIxmQF=json["pAddress"].get_array();
        for(int LIvckbR=0; LIvckbR < 1; LIvckbR++){
            [&](){void* temp_LTIxmQF;[&](){
            if (arr_LTIxmQF[LIvckbR].get_array().size()==0){
                temp_LTIxmQF=NULL;
            return; }char* temp_KKuuYCW;[&](){
            if (arr_LTIxmQF[LIvckbR].get_array().size()==0){
                temp_KKuuYCW=NULL;
            return; }temp_KKuuYCW=(char*)malloc(arr_LTIxmQF[LIvckbR].get_array().size()*sizeof(char));
        auto& arr_FUzakvN=arr_LTIxmQF[LIvckbR].get_array();
        for(int lBwzqzO=0; lBwzqzO < arr_LTIxmQF[LIvckbR].get_array().size(); lBwzqzO++){
            [&](){
            if (arr_FUzakvN[lBwzqzO].is_uint64()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_uint64());
            }else if (arr_FUzakvN[lBwzqzO].is_int64()){
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_int64());
            }else{
                temp_KKuuYCW[lBwzqzO]=static_cast<char>(arr_FUzakvN[lBwzqzO].get_double());
            }
            }();
        }
        }();temp_LTIxmQF=temp_KKuuYCW;}();pAddress[LIvckbR]=(VkRemoteAddressNV)temp_LTIxmQF;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GmMstTE;[&](){
            if (json["result"].is_uint64()){
                temp_GmMstTE=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_GmMstTE=static_cast<int>(json["result"].get_int64());
            }else{
                temp_GmMstTE=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_GmMstTE;}();}();

debug_printf("Ending vkGetMemoryRemoteAddressNV...\n");
debug_printf("Return value of vkGetMemoryRemoteAddressNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalSemaphoreProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalSemaphoreInfo==NULL){
                json["pExternalSemaphoreInfo"]=boost::json::array();
            return; }json["pExternalSemaphoreInfo"]=boost::json::array(1);
        auto& arr_qgIgkyH=json["pExternalSemaphoreInfo"].get_array();
        for(int VMbMUUS=0; VMbMUUS < 1; VMbMUUS++){
            [&](){
            auto& temp=arr_qgIgkyH[VMbMUUS].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreInfo[VMbMUUS]);
            }();
        }
        }();
[&](){
            if (pExternalSemaphoreProperties==NULL){
                json["pExternalSemaphoreProperties"]=boost::json::array();
            return; }json["pExternalSemaphoreProperties"]=boost::json::array(1);
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].get_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].emplace_object();
            return serialize_struct(temp, pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalSemaphoreProperties"].get_array().size()==0){
                pExternalSemaphoreProperties=NULL;
            return; }
        auto& arr_yLCjbDt=json["pExternalSemaphoreProperties"].get_array();
        for(int rKjPzGR=0; rKjPzGR < 1; rKjPzGR++){
            [&](){
            auto& temp=arr_yLCjbDt[rKjPzGR].get_object();
            deserialize_struct(temp,pExternalSemaphoreProperties[rKjPzGR]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalSemaphoreProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties ){
return vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreFdKHR( VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreFdKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETSEMAPHOREFDKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_fyTHWII=json["pGetFdInfo"].get_array();
        for(int dBynwwO=0; dBynwwO < 1; dBynwwO++){
            [&](){
            auto& temp=arr_fyTHWII[dBynwwO].emplace_object();
            return serialize_struct(temp, pGetFdInfo[dBynwwO]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_VbFkwnE;[&](){
            if (json["result"].is_uint64()){
                temp_VbFkwnE=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VbFkwnE=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VbFkwnE=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VbFkwnE;}();}();

debug_printf("Ending vkGetSemaphoreFdKHR...\n");
debug_printf("Return value of vkGetSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportSemaphoreFdKHR( VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportSemaphoreFdKHR\n");

    boost::json::object json;
    json["stream_type"]=VKIMPORTSEMAPHOREFDKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportSemaphoreFdInfo==NULL){
                json["pImportSemaphoreFdInfo"]=boost::json::array();
            return; }json["pImportSemaphoreFdInfo"]=boost::json::array(1);
        auto& arr_vWNEWeX=json["pImportSemaphoreFdInfo"].get_array();
        for(int kfpLCyT=0; kfpLCyT < 1; kfpLCyT++){
            [&](){
            auto& temp=arr_vWNEWeX[kfpLCyT].emplace_object();
            return serialize_struct(temp, pImportSemaphoreFdInfo[kfpLCyT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTSEMAPHOREFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_cakEtRs;[&](){
            if (json["result"].is_uint64()){
                temp_cakEtRs=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_cakEtRs=static_cast<int>(json["result"].get_int64());
            }else{
                temp_cakEtRs=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_cakEtRs;}();}();

debug_printf("Ending vkImportSemaphoreFdKHR...\n");
debug_printf("Return value of vkImportSemaphoreFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceExternalFenceProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pExternalFenceInfo==NULL){
                json["pExternalFenceInfo"]=boost::json::array();
            return; }json["pExternalFenceInfo"]=boost::json::array(1);
        auto& arr_DSVeGvM=json["pExternalFenceInfo"].get_array();
        for(int ApMvCYQ=0; ApMvCYQ < 1; ApMvCYQ++){
            [&](){
            auto& temp=arr_DSVeGvM[ApMvCYQ].emplace_object();
            return serialize_struct(temp, pExternalFenceInfo[ApMvCYQ]);
            }();
        }
        }();
[&](){
            if (pExternalFenceProperties==NULL){
                json["pExternalFenceProperties"]=boost::json::array();
            return; }json["pExternalFenceProperties"]=boost::json::array(1);
        auto& arr_nPbItsj=json["pExternalFenceProperties"].get_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].emplace_object();
            return serialize_struct(temp, pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEEXTERNALFENCEPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pExternalFenceProperties"].get_array().size()==0){
                pExternalFenceProperties=NULL;
            return; }
        auto& arr_nPbItsj=json["pExternalFenceProperties"].get_array();
        for(int VoSEUdo=0; VoSEUdo < 1; VoSEUdo++){
            [&](){
            auto& temp=arr_nPbItsj[VoSEUdo].get_object();
            deserialize_struct(temp,pExternalFenceProperties[VoSEUdo]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceExternalFenceProperties...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceExternalFencePropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties ){
return vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkGetFenceFdKHR( VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd ){
//Will only be called by the client
debug_printf("Executing vkGetFenceFdKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETFENCEFDKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pGetFdInfo==NULL){
                json["pGetFdInfo"]=boost::json::array();
            return; }json["pGetFdInfo"]=boost::json::array(1);
        auto& arr_mgmOmEV=json["pGetFdInfo"].get_array();
        for(int DYSusBe=0; DYSusBe < 1; DYSusBe++){
            [&](){
            auto& temp=arr_mgmOmEV[DYSusBe].emplace_object();
            return serialize_struct(temp, pGetFdInfo[DYSusBe]);
            }();
        }
        }();
[&](){
            if (pFd==NULL){
                json["pFd"]=boost::json::array();
            return; }json["pFd"]=boost::json::array(1);
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){arr_iYlwGBh[ENGggcC]=pFd[ENGggcC];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pFd"].get_array().size()==0){
                pFd=NULL;
            return; }
        auto& arr_iYlwGBh=json["pFd"].get_array();
        for(int ENGggcC=0; ENGggcC < 1; ENGggcC++){
            [&](){
            if (arr_iYlwGBh[ENGggcC].is_uint64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_uint64());
            }else if (arr_iYlwGBh[ENGggcC].is_int64()){
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_int64());
            }else{
                pFd[ENGggcC]=static_cast<int>(arr_iYlwGBh[ENGggcC].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_LMnCBOV;[&](){
            if (json["result"].is_uint64()){
                temp_LMnCBOV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LMnCBOV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LMnCBOV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LMnCBOV;}();}();

debug_printf("Ending vkGetFenceFdKHR...\n");
debug_printf("Return value of vkGetFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkImportFenceFdKHR( VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo ){
//Will only be called by the client
debug_printf("Executing vkImportFenceFdKHR\n");

    boost::json::object json;
    json["stream_type"]=VKIMPORTFENCEFDKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pImportFenceFdInfo==NULL){
                json["pImportFenceFdInfo"]=boost::json::array();
            return; }json["pImportFenceFdInfo"]=boost::json::array(1);
        auto& arr_PmxwQMO=json["pImportFenceFdInfo"].get_array();
        for(int QSUnAUF=0; QSUnAUF < 1; QSUnAUF++){
            [&](){
            auto& temp=arr_PmxwQMO[QSUnAUF].emplace_object();
            return serialize_struct(temp, pImportFenceFdInfo[QSUnAUF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKIMPORTFENCEFDKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_qKtqMsG;[&](){
            if (json["result"].is_uint64()){
                temp_qKtqMsG=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_qKtqMsG=static_cast<int>(json["result"].get_int64());
            }else{
                temp_qKtqMsG=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_qKtqMsG;}();}();

debug_printf("Ending vkImportFenceFdKHR...\n");
debug_printf("Return value of vkImportFenceFdKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseDisplayEXT( VkPhysicalDevice physicalDevice, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkReleaseDisplayEXT\n");

    boost::json::object json;
    json["stream_type"]=VKRELEASEDISPLAYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_ZiaeAKR;[&](){
            if (json["result"].is_uint64()){
                temp_ZiaeAKR=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZiaeAKR=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZiaeAKR=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZiaeAKR;}();}();

debug_printf("Ending vkReleaseDisplayEXT...\n");
debug_printf("Return value of vkReleaseDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDisplayPowerControlEXT( VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo ){
//Will only be called by the client
debug_printf("Executing vkDisplayPowerControlEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDISPLAYPOWERCONTROLEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayPowerInfo==NULL){
                json["pDisplayPowerInfo"]=boost::json::array();
            return; }json["pDisplayPowerInfo"]=boost::json::array(1);
        auto& arr_MrfcjyV=json["pDisplayPowerInfo"].get_array();
        for(int xtIgTXd=0; xtIgTXd < 1; xtIgTXd++){
            [&](){
            auto& temp=arr_MrfcjyV[xtIgTXd].emplace_object();
            return serialize_struct(temp, pDisplayPowerInfo[xtIgTXd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDISPLAYPOWERCONTROLEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();

VkResult result;
[&](){[&](){int temp_XyteYho;[&](){
            if (json["result"].is_uint64()){
                temp_XyteYho=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_XyteYho=static_cast<int>(json["result"].get_int64());
            }else{
                temp_XyteYho=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_XyteYho;}();}();

debug_printf("Ending vkDisplayPowerControlEXT...\n");
debug_printf("Return value of vkDisplayPowerControlEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDeviceEventEXT( VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDeviceEventEXT\n");

    boost::json::object json;
    json["stream_type"]=VKREGISTERDEVICEEVENTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceEventInfo==NULL){
                json["pDeviceEventInfo"]=boost::json::array();
            return; }json["pDeviceEventInfo"]=boost::json::array(1);
        auto& arr_PBonFka=json["pDeviceEventInfo"].get_array();
        for(int JNqwWzK=0; JNqwWzK < 1; JNqwWzK++){
            [&](){
            auto& temp=arr_PBonFka[JNqwWzK].emplace_object();
            return serialize_struct(temp, pDeviceEventInfo[JNqwWzK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDEVICEEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZZbHdPH;[&](){
            if (json["result"].is_uint64()){
                temp_ZZbHdPH=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZZbHdPH=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZZbHdPH=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZZbHdPH;}();}();

debug_printf("Ending vkRegisterDeviceEventEXT...\n");
debug_printf("Return value of vkRegisterDeviceEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkRegisterDisplayEventEXT( VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence ){
//Will only be called by the client
debug_printf("Executing vkRegisterDisplayEventEXT\n");

    boost::json::object json;
    json["stream_type"]=VKREGISTERDISPLAYEVENTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pDisplayEventInfo==NULL){
                json["pDisplayEventInfo"]=boost::json::array();
            return; }json["pDisplayEventInfo"]=boost::json::array(1);
        auto& arr_EEWRWgk=json["pDisplayEventInfo"].get_array();
        for(int ZywgBIl=0; ZywgBIl < 1; ZywgBIl++){
            [&](){
            auto& temp=arr_EEWRWgk[ZywgBIl].emplace_object();
            return serialize_struct(temp, pDisplayEventInfo[ZywgBIl]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFence==NULL){
                json["pFence"]=boost::json::array();
            return; }json["pFence"]=boost::json::array(1);
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){serialize_VkFence(arr_SJohVKr[FNNPPoF],pFence[FNNPPoF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKREGISTERDISPLAYEVENTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();


[&](){
            if (json["pFence"].get_array().size()==0){
                pFence=NULL;
            return; }
        auto& arr_SJohVKr=json["pFence"].get_array();
        for(int FNNPPoF=0; FNNPPoF < 1; FNNPPoF++){
            [&](){deserialize_VkFence(arr_SJohVKr[FNNPPoF], pFence[FNNPPoF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_taUgaUB;[&](){
            if (json["result"].is_uint64()){
                temp_taUgaUB=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_taUgaUB=static_cast<int>(json["result"].get_int64());
            }else{
                temp_taUgaUB=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_taUgaUB;}();}();

debug_printf("Ending vkRegisterDisplayEventEXT...\n");
debug_printf("Return value of vkRegisterDisplayEventEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainCounterEXT( VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainCounterEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETSWAPCHAINCOUNTEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){[&](){[&](){json["counter"]=counter;}();}();}();
[&](){
            if (pCounterValue==NULL){
                json["pCounterValue"]=boost::json::array();
            return; }json["pCounterValue"]=boost::json::array(1);
        auto& arr_VmPfCNz=json["pCounterValue"].get_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){arr_VmPfCNz[BVcpEyO]=pCounterValue[BVcpEyO];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINCOUNTEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){[&](){int temp_RusGBTK;[&](){
            if (json["counter"].is_uint64()){
                temp_RusGBTK=static_cast<int>(json["counter"].get_uint64());
            }else if (json["counter"].is_int64()){
                temp_RusGBTK=static_cast<int>(json["counter"].get_int64());
            }else{
                temp_RusGBTK=static_cast<int>(json["counter"].get_double());
            }
            }();counter=(VkSurfaceCounterFlagBitsEXT)temp_RusGBTK;}();}();
[&](){
            if (json["pCounterValue"].get_array().size()==0){
                pCounterValue=NULL;
            return; }
        auto& arr_VmPfCNz=json["pCounterValue"].get_array();
        for(int BVcpEyO=0; BVcpEyO < 1; BVcpEyO++){
            [&](){
            if (arr_VmPfCNz[BVcpEyO].is_uint64()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_uint64());
            }else if (arr_VmPfCNz[BVcpEyO].is_int64()){
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_int64());
            }else{
                pCounterValue[BVcpEyO]=static_cast<uint64_t>(arr_VmPfCNz[BVcpEyO].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ABsCcZw;[&](){
            if (json["result"].is_uint64()){
                temp_ABsCcZw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ABsCcZw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ABsCcZw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ABsCcZw;}();}();

debug_printf("Ending vkGetSwapchainCounterEXT...\n");
debug_printf("Return value of vkGetSwapchainCounterEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2EXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].get_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_KYzynfJ=json["pSurfaceCapabilities"].get_array();
        for(int QJCcfVY=0; QJCcfVY < 1; QJCcfVY++){
            [&](){
            auto& temp=arr_KYzynfJ[QJCcfVY].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[QJCcfVY]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XSKmzOC;[&](){
            if (json["result"].is_uint64()){
                temp_XSKmzOC=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_XSKmzOC=static_cast<int>(json["result"].get_int64());
            }else{
                temp_XSKmzOC=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_XSKmzOC;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2EXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2EXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroups( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceGroups\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEPHYSICALDEVICEGROUPS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pPhysicalDeviceGroupCount==NULL){
                json["pPhysicalDeviceGroupCount"]=boost::json::array();
            return; }json["pPhysicalDeviceGroupCount"]=boost::json::array(1);
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].get_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){arr_Cmahtvc[SYfwvYv]=pPhysicalDeviceGroupCount[SYfwvYv];}();
        }
        }();
[&](){
            if (pPhysicalDeviceGroupProperties==NULL){
                json["pPhysicalDeviceGroupProperties"]=boost::json::array();
            return; }json["pPhysicalDeviceGroupProperties"]=boost::json::array(*pPhysicalDeviceGroupCount);
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].get_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].emplace_object();
            return serialize_struct(temp, pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEGROUPS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){
            if (json["pPhysicalDeviceGroupCount"].get_array().size()==0){
                pPhysicalDeviceGroupCount=NULL;
            return; }
        auto& arr_Cmahtvc=json["pPhysicalDeviceGroupCount"].get_array();
        for(int SYfwvYv=0; SYfwvYv < 1; SYfwvYv++){
            [&](){
            if (arr_Cmahtvc[SYfwvYv].is_uint64()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_uint64());
            }else if (arr_Cmahtvc[SYfwvYv].is_int64()){
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_int64());
            }else{
                pPhysicalDeviceGroupCount[SYfwvYv]=static_cast<uint32_t>(arr_Cmahtvc[SYfwvYv].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPhysicalDeviceGroupProperties"].get_array().size()==0){
                pPhysicalDeviceGroupProperties=NULL;
            return; }
        auto& arr_kSmADNy=json["pPhysicalDeviceGroupProperties"].get_array();
        for(int LorZWUi=0; LorZWUi < *pPhysicalDeviceGroupCount; LorZWUi++){
            [&](){
            auto& temp=arr_kSmADNy[LorZWUi].get_object();
            deserialize_struct(temp,pPhysicalDeviceGroupProperties[LorZWUi]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_PisRKZs;[&](){
            if (json["result"].is_uint64()){
                temp_PisRKZs=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_PisRKZs=static_cast<int>(json["result"].get_int64());
            }else{
                temp_PisRKZs=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_PisRKZs;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceGroups...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceGroups is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceGroupsKHR( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties ){
return vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeatures( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPeerMemoryFeatures\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEGROUPPEERMEMORYFEATURES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["heapIndex"]=heapIndex;}();
[&](){json["localDeviceIndex"]=localDeviceIndex;}();
[&](){json["remoteDeviceIndex"]=remoteDeviceIndex;}();
[&](){
            if (pPeerMemoryFeatures==NULL){
                json["pPeerMemoryFeatures"]=boost::json::array();
            return; }json["pPeerMemoryFeatures"]=boost::json::array(1);
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].get_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){[&](){arr_IMNDPVx[dvtpqQO]=pPeerMemoryFeatures[dvtpqQO];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPEERMEMORYFEATURES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["heapIndex"].is_uint64()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_uint64());
            }else if (json["heapIndex"].is_int64()){
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_int64());
            }else{
                heapIndex=static_cast<uint32_t>(json["heapIndex"].get_double());
            }
            }();
[&](){
            if (json["localDeviceIndex"].is_uint64()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_uint64());
            }else if (json["localDeviceIndex"].is_int64()){
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_int64());
            }else{
                localDeviceIndex=static_cast<uint32_t>(json["localDeviceIndex"].get_double());
            }
            }();
[&](){
            if (json["remoteDeviceIndex"].is_uint64()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_uint64());
            }else if (json["remoteDeviceIndex"].is_int64()){
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_int64());
            }else{
                remoteDeviceIndex=static_cast<uint32_t>(json["remoteDeviceIndex"].get_double());
            }
            }();
[&](){
            if (json["pPeerMemoryFeatures"].get_array().size()==0){
                pPeerMemoryFeatures=NULL;
            return; }
        auto& arr_IMNDPVx=json["pPeerMemoryFeatures"].get_array();
        for(int dvtpqQO=0; dvtpqQO < 1; dvtpqQO++){
            [&](){[&](){int temp_ohtAtfL;[&](){
            if (arr_IMNDPVx[dvtpqQO].is_uint64()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_uint64());
            }else if (arr_IMNDPVx[dvtpqQO].is_int64()){
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_int64());
            }else{
                temp_ohtAtfL=static_cast<int>(arr_IMNDPVx[dvtpqQO].get_double());
            }
            }();pPeerMemoryFeatures[dvtpqQO]=(VkPeerMemoryFeatureFlags)temp_ohtAtfL;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceGroupPeerMemoryFeatures...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceGroupPeerMemoryFeaturesKHR( VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures ){
return vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindBufferMemory2\n");

    boost::json::object json;
    json["stream_type"]=VKBINDBUFFERMEMORY2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_NWunNSr=json["pBindInfos"].get_array();
        for(int DbCSPHR=0; DbCSPHR < bindInfoCount; DbCSPHR++){
            [&](){
            auto& temp=arr_NWunNSr[DbCSPHR].emplace_object();
            return serialize_struct(temp, pBindInfos[DbCSPHR]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDBUFFERMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_vNOwvGi;[&](){
            if (json["result"].is_uint64()){
                temp_vNOwvGi=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vNOwvGi=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vNOwvGi=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vNOwvGi;}();}();

debug_printf("Ending vkBindBufferMemory2...\n");
debug_printf("Return value of vkBindBufferMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindBufferMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos ){
return vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindImageMemory2\n");

    boost::json::object json;
    json["stream_type"]=VKBINDIMAGEMEMORY2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_FifZmRy=json["pBindInfos"].get_array();
        for(int TInZfLo=0; TInZfLo < bindInfoCount; TInZfLo++){
            [&](){
            auto& temp=arr_FifZmRy[TInZfLo].emplace_object();
            return serialize_struct(temp, pBindInfos[TInZfLo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDIMAGEMEMORY2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_rQeTCPF;[&](){
            if (json["result"].is_uint64()){
                temp_rQeTCPF=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_rQeTCPF=static_cast<int>(json["result"].get_int64());
            }else{
                temp_rQeTCPF=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_rQeTCPF;}();}();

debug_printf("Ending vkBindImageMemory2...\n");
debug_printf("Return value of vkBindImageMemory2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindImageMemory2KHR( VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos ){
return vkBindImageMemory2(device, bindInfoCount, pBindInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMask( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDeviceMask\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEVICEMASK;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["deviceMask"]=deviceMask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEVICEMASK):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["deviceMask"].is_uint64()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_uint64());
            }else if (json["deviceMask"].is_int64()){
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_int64());
            }else{
                deviceMask=static_cast<uint32_t>(json["deviceMask"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetDeviceMask...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDeviceMaskKHR( VkCommandBuffer commandBuffer, uint32_t deviceMask ){
return vkCmdSetDeviceMask(commandBuffer, deviceMask);
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupPresentCapabilitiesKHR( VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupPresentCapabilitiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEGROUPPRESENTCAPABILITIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDeviceGroupPresentCapabilities==NULL){
                json["pDeviceGroupPresentCapabilities"]=boost::json::array();
            return; }json["pDeviceGroupPresentCapabilities"]=boost::json::array(1);
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].get_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].emplace_object();
            return serialize_struct(temp, pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPPRESENTCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pDeviceGroupPresentCapabilities"].get_array().size()==0){
                pDeviceGroupPresentCapabilities=NULL;
            return; }
        auto& arr_gEodIfI=json["pDeviceGroupPresentCapabilities"].get_array();
        for(int HHoUQIw=0; HHoUQIw < 1; HHoUQIw++){
            [&](){
            auto& temp=arr_gEodIfI[HHoUQIw].get_object();
            deserialize_struct(temp,pDeviceGroupPresentCapabilities[HHoUQIw]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_sVUfVso;[&](){
            if (json["result"].is_uint64()){
                temp_sVUfVso=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_sVUfVso=static_cast<int>(json["result"].get_int64());
            }else{
                temp_sVUfVso=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_sVUfVso;}();}();

debug_printf("Ending vkGetDeviceGroupPresentCapabilitiesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupPresentCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceGroupSurfacePresentModesKHR( VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceGroupSurfacePresentModesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEGROUPSURFACEPRESENTMODESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pModes==NULL){
                json["pModes"]=boost::json::array();
            return; }json["pModes"]=boost::json::array(1);
        auto& arr_RUtBuZy=json["pModes"].get_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){[&](){arr_RUtBuZy[OxSHrMn]=pModes[OxSHrMn];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEGROUPSURFACEPRESENTMODESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pModes"].get_array().size()==0){
                pModes=NULL;
            return; }
        auto& arr_RUtBuZy=json["pModes"].get_array();
        for(int OxSHrMn=0; OxSHrMn < 1; OxSHrMn++){
            [&](){[&](){int temp_TkvTwGZ;[&](){
            if (arr_RUtBuZy[OxSHrMn].is_uint64()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_uint64());
            }else if (arr_RUtBuZy[OxSHrMn].is_int64()){
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_int64());
            }else{
                temp_TkvTwGZ=static_cast<int>(arr_RUtBuZy[OxSHrMn].get_double());
            }
            }();pModes[OxSHrMn]=(VkDeviceGroupPresentModeFlagsKHR)temp_TkvTwGZ;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_lHEVacH;[&](){
            if (json["result"].is_uint64()){
                temp_lHEVacH=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_lHEVacH=static_cast<int>(json["result"].get_int64());
            }else{
                temp_lHEVacH=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_lHEVacH;}();}();

debug_printf("Ending vkGetDeviceGroupSurfacePresentModesKHR...\n");
debug_printf("Return value of vkGetDeviceGroupSurfacePresentModesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireNextImage2KHR( VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex ){
//Will only be called by the client
debug_printf("Executing vkAcquireNextImage2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKACQUIRENEXTIMAGE2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }json["pAcquireInfo"]=boost::json::array(1);
        auto& arr_plPbild=json["pAcquireInfo"].get_array();
        for(int QzLRJum=0; QzLRJum < 1; QzLRJum++){
            [&](){
            auto& temp=arr_plPbild[QzLRJum].emplace_object();
            return serialize_struct(temp, pAcquireInfo[QzLRJum]);
            }();
        }
        }();
[&](){
            if (pImageIndex==NULL){
                json["pImageIndex"]=boost::json::array();
            return; }json["pImageIndex"]=boost::json::array(1);
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){arr_oSqpNfH[BEjuBtR]=pImageIndex[BEjuBtR];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIRENEXTIMAGE2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pImageIndex"].get_array().size()==0){
                pImageIndex=NULL;
            return; }
        auto& arr_oSqpNfH=json["pImageIndex"].get_array();
        for(int BEjuBtR=0; BEjuBtR < 1; BEjuBtR++){
            [&](){
            if (arr_oSqpNfH[BEjuBtR].is_uint64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_uint64());
            }else if (arr_oSqpNfH[BEjuBtR].is_int64()){
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_int64());
            }else{
                pImageIndex[BEjuBtR]=static_cast<uint32_t>(arr_oSqpNfH[BEjuBtR].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_NeZlQTZ;[&](){
            if (json["result"].is_uint64()){
                temp_NeZlQTZ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_NeZlQTZ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_NeZlQTZ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_NeZlQTZ;}();}();

debug_printf("Ending vkAcquireNextImage2KHR...\n");
debug_printf("Return value of vkAcquireNextImage2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBase( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDispatchBase\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDISPATCHBASE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["baseGroupX"]=baseGroupX;}();
[&](){json["baseGroupY"]=baseGroupY;}();
[&](){json["baseGroupZ"]=baseGroupZ;}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDISPATCHBASE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["baseGroupX"].is_uint64()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_uint64());
            }else if (json["baseGroupX"].is_int64()){
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_int64());
            }else{
                baseGroupX=static_cast<uint32_t>(json["baseGroupX"].get_double());
            }
            }();
[&](){
            if (json["baseGroupY"].is_uint64()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_uint64());
            }else if (json["baseGroupY"].is_int64()){
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_int64());
            }else{
                baseGroupY=static_cast<uint32_t>(json["baseGroupY"].get_double());
            }
            }();
[&](){
            if (json["baseGroupZ"].is_uint64()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_uint64());
            }else if (json["baseGroupZ"].is_int64()){
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_int64());
            }else{
                baseGroupZ=static_cast<uint32_t>(json["baseGroupZ"].get_double());
            }
            }();
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

debug_printf("Ending vkCmdDispatchBase...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDispatchBaseKHR( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
return vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDevicePresentRectanglesKHR( VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDevicePresentRectanglesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkSurfaceKHR(json["surface"],surface);}();
[&](){
            if (pRectCount==NULL){
                json["pRectCount"]=boost::json::array();
            return; }json["pRectCount"]=boost::json::array(1);
        auto& arr_vsEoMvr=json["pRectCount"].get_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){arr_vsEoMvr[TgFYlRi]=pRectCount[TgFYlRi];}();
        }
        }();
[&](){
            if (pRects==NULL){
                json["pRects"]=boost::json::array();
            return; }json["pRects"]=boost::json::array(*pRectCount);
        auto& arr_BxIGDMm=json["pRects"].get_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].emplace_object();
            return serialize_struct(temp, pRects[LNnHsjT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEPRESENTRECTANGLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkSurfaceKHR(json["surface"], surface);}();
[&](){
            if (json["pRectCount"].get_array().size()==0){
                pRectCount=NULL;
            return; }
        auto& arr_vsEoMvr=json["pRectCount"].get_array();
        for(int TgFYlRi=0; TgFYlRi < 1; TgFYlRi++){
            [&](){
            if (arr_vsEoMvr[TgFYlRi].is_uint64()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_uint64());
            }else if (arr_vsEoMvr[TgFYlRi].is_int64()){
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_int64());
            }else{
                pRectCount[TgFYlRi]=static_cast<uint32_t>(arr_vsEoMvr[TgFYlRi].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pRects"].get_array().size()==0){
                pRects=NULL;
            return; }
        auto& arr_BxIGDMm=json["pRects"].get_array();
        for(int LNnHsjT=0; LNnHsjT < *pRectCount; LNnHsjT++){
            [&](){
            auto& temp=arr_BxIGDMm[LNnHsjT].get_object();
            deserialize_struct(temp,pRects[LNnHsjT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_RnpDULR;[&](){
            if (json["result"].is_uint64()){
                temp_RnpDULR=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_RnpDULR=static_cast<int>(json["result"].get_int64());
            }else{
                temp_RnpDULR=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_RnpDULR;}();}();

debug_printf("Ending vkGetPhysicalDevicePresentRectanglesKHR...\n");
debug_printf("Return value of vkGetPhysicalDevicePresentRectanglesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplate( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
//Will only be called by the client
debug_printf("Executing vkCreateDescriptorUpdateTemplate\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDESCRIPTORUPDATETEMPLATE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_GOaQfzV=json["pCreateInfo"].get_array();
        for(int bDXkRSI=0; bDXkRSI < 1; bDXkRSI++){
            [&](){
            auto& temp=arr_GOaQfzV[bDXkRSI].emplace_object();
            return serialize_struct(temp, pCreateInfo[bDXkRSI]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDescriptorUpdateTemplate==NULL){
                json["pDescriptorUpdateTemplate"]=boost::json::array();
            return; }json["pDescriptorUpdateTemplate"]=boost::json::array(1);
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].get_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){serialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS],pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pDescriptorUpdateTemplate"].get_array().size()==0){
                pDescriptorUpdateTemplate=NULL;
            return; }
        auto& arr_wchWplA=json["pDescriptorUpdateTemplate"].get_array();
        for(int zVHgATS=0; zVHgATS < 1; zVHgATS++){
            [&](){deserialize_VkDescriptorUpdateTemplate(arr_wchWplA[zVHgATS], pDescriptorUpdateTemplate[zVHgATS]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_EHbIYub;[&](){
            if (json["result"].is_uint64()){
                temp_EHbIYub=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_EHbIYub=static_cast<int>(json["result"].get_int64());
            }else{
                temp_EHbIYub=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_EHbIYub;}();}();

                if (pDescriptorUpdateTemplate!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDescriptorUpdateTemplate[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDescriptorUpdateTemplate...\n");
debug_printf("Return value of vkCreateDescriptorUpdateTemplate is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDescriptorUpdateTemplateKHR( VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate ){
return vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplate( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDescriptorUpdateTemplate\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDESCRIPTORUPDATETEMPLATE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDESCRIPTORUPDATETEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkDestroyDescriptorUpdateTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyDescriptorUpdateTemplateKHR( VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator ){
return vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplate( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkUpdateDescriptorSetWithTemplate\n");

    boost::json::object json;
    json["stream_type"]=VKUPDATEDESCRIPTORSETWITHTEMPLATE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEDESCRIPTORSETWITHTEMPLATE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();


debug_printf("Ending vkUpdateDescriptorSetWithTemplate...\n");
}
__attribute__((visibility ("hidden"))) void vkUpdateDescriptorSetWithTemplateKHR( VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData ){
return vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdPushDescriptorSetWithTemplateKHR( VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData ){
//Will only be called by the client
debug_printf("Executing vkCmdPushDescriptorSetWithTemplateKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"],descriptorUpdateTemplate);}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_ZUZjIQc=json["pData"].get_array();
        for(int wgKJNeB=0; wgKJNeB < strlen(((char*)(pData)))+1; wgKJNeB++){
            [&](){arr_ZUZjIQc[wgKJNeB]=((char*)(pData))[wgKJNeB];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPUSHDESCRIPTORSETWITHTEMPLATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkDescriptorUpdateTemplate(json["descriptorUpdateTemplate"], descriptorUpdateTemplate);}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();


debug_printf("Ending vkCmdPushDescriptorSetWithTemplateKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkSetHdrMetadataEXT( VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata ){
//Will only be called by the client
debug_printf("Executing vkSetHdrMetadataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKSETHDRMETADATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["swapchainCount"]=swapchainCount;}();
[&](){
            if (pSwapchains==NULL){
                json["pSwapchains"]=boost::json::array();
            return; }json["pSwapchains"]=boost::json::array(swapchainCount);
        auto& arr_ItrwriJ=json["pSwapchains"].get_array();
        for(int ButVMnQ=0; ButVMnQ < swapchainCount; ButVMnQ++){
            [&](){serialize_VkSwapchainKHR(arr_ItrwriJ[ButVMnQ],pSwapchains[ButVMnQ]);}();
        }
        }();
[&](){
            if (pMetadata==NULL){
                json["pMetadata"]=boost::json::array();
            return; }json["pMetadata"]=boost::json::array(swapchainCount);
        auto& arr_gUCeGgy=json["pMetadata"].get_array();
        for(int qGnEfca=0; qGnEfca < swapchainCount; qGnEfca++){
            [&](){
            auto& temp=arr_gUCeGgy[qGnEfca].emplace_object();
            return serialize_struct(temp, pMetadata[qGnEfca]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETHDRMETADATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["swapchainCount"].is_uint64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_uint64());
            }else if (json["swapchainCount"].is_int64()){
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_int64());
            }else{
                swapchainCount=static_cast<uint32_t>(json["swapchainCount"].get_double());
            }
            }();



debug_printf("Ending vkSetHdrMetadataEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetSwapchainStatusKHR( VkDevice device, VkSwapchainKHR swapchain ){
//Will only be called by the client
debug_printf("Executing vkGetSwapchainStatusKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETSWAPCHAINSTATUSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSWAPCHAINSTATUSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
VkResult result;
[&](){[&](){int temp_AdtrAXT;[&](){
            if (json["result"].is_uint64()){
                temp_AdtrAXT=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_AdtrAXT=static_cast<int>(json["result"].get_int64());
            }else{
                temp_AdtrAXT=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_AdtrAXT;}();}();

debug_printf("Ending vkGetSwapchainStatusKHR...\n");
debug_printf("Return value of vkGetSwapchainStatusKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRefreshCycleDurationGOOGLE( VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties ){
//Will only be called by the client
debug_printf("Executing vkGetRefreshCycleDurationGOOGLE\n");

    boost::json::object json;
    json["stream_type"]=VKGETREFRESHCYCLEDURATIONGOOGLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pDisplayTimingProperties==NULL){
                json["pDisplayTimingProperties"]=boost::json::array();
            return; }json["pDisplayTimingProperties"]=boost::json::array(1);
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].get_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].emplace_object();
            return serialize_struct(temp, pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETREFRESHCYCLEDURATIONGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pDisplayTimingProperties"].get_array().size()==0){
                pDisplayTimingProperties=NULL;
            return; }
        auto& arr_nDUaeZL=json["pDisplayTimingProperties"].get_array();
        for(int NSFWKiB=0; NSFWKiB < 1; NSFWKiB++){
            [&](){
            auto& temp=arr_nDUaeZL[NSFWKiB].get_object();
            deserialize_struct(temp,pDisplayTimingProperties[NSFWKiB]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YFfCUgf;[&](){
            if (json["result"].is_uint64()){
                temp_YFfCUgf=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_YFfCUgf=static_cast<int>(json["result"].get_int64());
            }else{
                temp_YFfCUgf=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_YFfCUgf;}();}();

debug_printf("Ending vkGetRefreshCycleDurationGOOGLE...\n");
debug_printf("Return value of vkGetRefreshCycleDurationGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPastPresentationTimingGOOGLE( VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings ){
//Will only be called by the client
debug_printf("Executing vkGetPastPresentationTimingGOOGLE\n");

    boost::json::object json;
    json["stream_type"]=VKGETPASTPRESENTATIONTIMINGGOOGLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){
            if (pPresentationTimingCount==NULL){
                json["pPresentationTimingCount"]=boost::json::array();
            return; }json["pPresentationTimingCount"]=boost::json::array(1);
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].get_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){arr_LiCpViZ[ihpxywU]=pPresentationTimingCount[ihpxywU];}();
        }
        }();
[&](){
            if (pPresentationTimings==NULL){
                json["pPresentationTimings"]=boost::json::array();
            return; }json["pPresentationTimings"]=boost::json::array(*pPresentationTimingCount);
        auto& arr_CGvQjMK=json["pPresentationTimings"].get_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].emplace_object();
            return serialize_struct(temp, pPresentationTimings[CzbyDFb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPASTPRESENTATIONTIMINGGOOGLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["pPresentationTimingCount"].get_array().size()==0){
                pPresentationTimingCount=NULL;
            return; }
        auto& arr_LiCpViZ=json["pPresentationTimingCount"].get_array();
        for(int ihpxywU=0; ihpxywU < 1; ihpxywU++){
            [&](){
            if (arr_LiCpViZ[ihpxywU].is_uint64()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_uint64());
            }else if (arr_LiCpViZ[ihpxywU].is_int64()){
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_int64());
            }else{
                pPresentationTimingCount[ihpxywU]=static_cast<uint32_t>(arr_LiCpViZ[ihpxywU].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pPresentationTimings"].get_array().size()==0){
                pPresentationTimings=NULL;
            return; }
        auto& arr_CGvQjMK=json["pPresentationTimings"].get_array();
        for(int CzbyDFb=0; CzbyDFb < *pPresentationTimingCount; CzbyDFb++){
            [&](){
            auto& temp=arr_CGvQjMK[CzbyDFb].get_object();
            deserialize_struct(temp,pPresentationTimings[CzbyDFb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_SaSGjng;[&](){
            if (json["result"].is_uint64()){
                temp_SaSGjng=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_SaSGjng=static_cast<int>(json["result"].get_int64());
            }else{
                temp_SaSGjng=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_SaSGjng;}();}();

debug_printf("Ending vkGetPastPresentationTimingGOOGLE...\n");
debug_printf("Return value of vkGetPastPresentationTimingGOOGLE is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORTWSCALINGNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportWScalings==NULL){
                json["pViewportWScalings"]=boost::json::array();
            return; }json["pViewportWScalings"]=boost::json::array(viewportCount);
        auto& arr_gZVGKnq=json["pViewportWScalings"].get_array();
        for(int GRZXlou=0; GRZXlou < viewportCount; GRZXlou++){
            [&](){
            auto& temp=arr_gZVGKnq[GRZXlou].emplace_object();
            return serialize_struct(temp, pViewportWScalings[GRZXlou]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportWScalingNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEXT( VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDISCARDRECTANGLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstDiscardRectangle"]=firstDiscardRectangle;}();
[&](){json["discardRectangleCount"]=discardRectangleCount;}();
[&](){
            if (pDiscardRectangles==NULL){
                json["pDiscardRectangles"]=boost::json::array();
            return; }json["pDiscardRectangles"]=boost::json::array(discardRectangleCount);
        auto& arr_uUeweOj=json["pDiscardRectangles"].get_array();
        for(int WtUHHLW=0; WtUHHLW < discardRectangleCount; WtUHHLW++){
            [&](){
            auto& temp=arr_uUeweOj[WtUHHLW].emplace_object();
            return serialize_struct(temp, pDiscardRectangles[WtUHHLW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstDiscardRectangle"].is_uint64()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_uint64());
            }else if (json["firstDiscardRectangle"].is_int64()){
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_int64());
            }else{
                firstDiscardRectangle=static_cast<uint32_t>(json["firstDiscardRectangle"].get_double());
            }
            }();
[&](){
            if (json["discardRectangleCount"].is_uint64()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_uint64());
            }else if (json["discardRectangleCount"].is_int64()){
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_int64());
            }else{
                discardRectangleCount=static_cast<uint32_t>(json["discardRectangleCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetDiscardRectangleEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDISCARDRECTANGLEENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["discardRectangleEnable"]=discardRectangleEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GnHxsqE;[&](){
            if (json["discardRectangleEnable"].is_uint64()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_uint64());
            }else if (json["discardRectangleEnable"].is_int64()){
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_int64());
            }else{
                temp_GnHxsqE=static_cast<uint32_t>(json["discardRectangleEnable"].get_double());
            }
            }();discardRectangleEnable=(VkBool32)temp_GnHxsqE;}();

debug_printf("Ending vkCmdSetDiscardRectangleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDiscardRectangleModeEXT( VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDiscardRectangleModeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDISCARDRECTANGLEMODEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["discardRectangleMode"]=discardRectangleMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDISCARDRECTANGLEMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iBxDvRc;[&](){
            if (json["discardRectangleMode"].is_uint64()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_uint64());
            }else if (json["discardRectangleMode"].is_int64()){
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_int64());
            }else{
                temp_iBxDvRc=static_cast<int>(json["discardRectangleMode"].get_double());
            }
            }();discardRectangleMode=(VkDiscardRectangleModeEXT)temp_iBxDvRc;}();}();

debug_printf("Ending vkCmdSetDiscardRectangleModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEXT( VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSAMPLELOCATIONSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSampleLocationsInfo==NULL){
                json["pSampleLocationsInfo"]=boost::json::array();
            return; }json["pSampleLocationsInfo"]=boost::json::array(1);
        auto& arr_KfRxBlJ=json["pSampleLocationsInfo"].get_array();
        for(int XjGOezZ=0; XjGOezZ < 1; XjGOezZ++){
            [&](){
            auto& temp=arr_KfRxBlJ[XjGOezZ].emplace_object();
            return serialize_struct(temp, pSampleLocationsInfo[XjGOezZ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetSampleLocationsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceMultisamplePropertiesEXT( VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceMultisamplePropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pMultisampleProperties==NULL){
                json["pMultisampleProperties"]=boost::json::array();
            return; }json["pMultisampleProperties"]=boost::json::array(1);
        auto& arr_IduiRHb=json["pMultisampleProperties"].get_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].emplace_object();
            return serialize_struct(temp, pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();
[&](){
            if (json["pMultisampleProperties"].get_array().size()==0){
                pMultisampleProperties=NULL;
            return; }
        auto& arr_IduiRHb=json["pMultisampleProperties"].get_array();
        for(int xJhEIjr=0; xJhEIjr < 1; xJhEIjr++){
            [&](){
            auto& temp=arr_IduiRHb[xJhEIjr].get_object();
            deserialize_struct(temp,pMultisampleProperties[xJhEIjr]);
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceMultisamplePropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceCapabilities2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }json["pSurfaceInfo"]=boost::json::array(1);
        auto& arr_kqlTDpj=json["pSurfaceInfo"].get_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceCapabilities==NULL){
                json["pSurfaceCapabilities"]=boost::json::array();
            return; }json["pSurfaceCapabilities"]=boost::json::array(1);
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].get_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].emplace_object();
            return serialize_struct(temp, pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceCapabilities"].get_array().size()==0){
                pSurfaceCapabilities=NULL;
            return; }
        auto& arr_JfroxEi=json["pSurfaceCapabilities"].get_array();
        for(int Baebpht=0; Baebpht < 1; Baebpht++){
            [&](){
            auto& temp=arr_JfroxEi[Baebpht].get_object();
            deserialize_struct(temp,pSurfaceCapabilities[Baebpht]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_vrcoNXr;[&](){
            if (json["result"].is_uint64()){
                temp_vrcoNXr=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vrcoNXr=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vrcoNXr=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vrcoNXr;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceCapabilities2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSurfaceFormats2KHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSurfaceFormats2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESURFACEFORMATS2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pSurfaceInfo==NULL){
                json["pSurfaceInfo"]=boost::json::array();
            return; }json["pSurfaceInfo"]=boost::json::array(1);
        auto& arr_kqlTDpj=json["pSurfaceInfo"].get_array();
        for(int yiVsRWe=0; yiVsRWe < 1; yiVsRWe++){
            [&](){
            auto& temp=arr_kqlTDpj[yiVsRWe].emplace_object();
            return serialize_struct(temp, pSurfaceInfo[yiVsRWe]);
            }();
        }
        }();
[&](){
            if (pSurfaceFormatCount==NULL){
                json["pSurfaceFormatCount"]=boost::json::array();
            return; }json["pSurfaceFormatCount"]=boost::json::array(1);
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){arr_mbQwRYl[bFtFQKD]=pSurfaceFormatCount[bFtFQKD];}();
        }
        }();
[&](){
            if (pSurfaceFormats==NULL){
                json["pSurfaceFormats"]=boost::json::array();
            return; }json["pSurfaceFormats"]=boost::json::array(*pSurfaceFormatCount);
        auto& arr_AuCicsY=json["pSurfaceFormats"].get_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].emplace_object();
            return serialize_struct(temp, pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESURFACEFORMATS2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pSurfaceFormatCount"].get_array().size()==0){
                pSurfaceFormatCount=NULL;
            return; }
        auto& arr_mbQwRYl=json["pSurfaceFormatCount"].get_array();
        for(int bFtFQKD=0; bFtFQKD < 1; bFtFQKD++){
            [&](){
            if (arr_mbQwRYl[bFtFQKD].is_uint64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_uint64());
            }else if (arr_mbQwRYl[bFtFQKD].is_int64()){
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_int64());
            }else{
                pSurfaceFormatCount[bFtFQKD]=static_cast<uint32_t>(arr_mbQwRYl[bFtFQKD].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSurfaceFormats"].get_array().size()==0){
                pSurfaceFormats=NULL;
            return; }
        auto& arr_AuCicsY=json["pSurfaceFormats"].get_array();
        for(int lVrVWxA=0; lVrVWxA < *pSurfaceFormatCount; lVrVWxA++){
            [&](){
            auto& temp=arr_AuCicsY[lVrVWxA].get_object();
            deserialize_struct(temp,pSurfaceFormats[lVrVWxA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_IOZGDeU;[&](){
            if (json["result"].is_uint64()){
                temp_IOZGDeU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_IOZGDeU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_IOZGDeU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_IOZGDeU;}();}();

debug_printf("Ending vkGetPhysicalDeviceSurfaceFormats2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceSurfaceFormats2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayProperties2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_WgClQQW=json["pProperties"].get_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].emplace_object();
            return serialize_struct(temp, pProperties[IPCMyur]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_WgClQQW=json["pProperties"].get_array();
        for(int IPCMyur=0; IPCMyur < *pPropertyCount; IPCMyur++){
            [&](){
            auto& temp=arr_WgClQQW[IPCMyur].get_object();
            deserialize_struct(temp,pProperties[IPCMyur]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_hJvdKix;[&](){
            if (json["result"].is_uint64()){
                temp_hJvdKix=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_hJvdKix=static_cast<int>(json["result"].get_int64());
            }else{
                temp_hJvdKix=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_hJvdKix;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceDisplayPlaneProperties2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_oqLTQEe=json["pProperties"].get_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].emplace_object();
            return serialize_struct(temp, pProperties[KJvijjP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oqLTQEe=json["pProperties"].get_array();
        for(int KJvijjP=0; KJvijjP < *pPropertyCount; KJvijjP++){
            [&](){
            auto& temp=arr_oqLTQEe[KJvijjP].get_object();
            deserialize_struct(temp,pProperties[KJvijjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HhYxptS;[&](){
            if (json["result"].is_uint64()){
                temp_HhYxptS=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HhYxptS=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HhYxptS=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HhYxptS;}();}();

debug_printf("Ending vkGetPhysicalDeviceDisplayPlaneProperties2KHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceDisplayPlaneProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayModeProperties2KHR( VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayModeProperties2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDISPLAYMODEPROPERTIES2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_LvUqkhm=json["pProperties"].get_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].emplace_object();
            return serialize_struct(temp, pProperties[gThvzcU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYMODEPROPERTIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_LvUqkhm=json["pProperties"].get_array();
        for(int gThvzcU=0; gThvzcU < *pPropertyCount; gThvzcU++){
            [&](){
            auto& temp=arr_LvUqkhm[gThvzcU].get_object();
            deserialize_struct(temp,pProperties[gThvzcU]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_xnvCFuo;[&](){
            if (json["result"].is_uint64()){
                temp_xnvCFuo=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_xnvCFuo=static_cast<int>(json["result"].get_int64());
            }else{
                temp_xnvCFuo=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_xnvCFuo;}();}();

debug_printf("Ending vkGetDisplayModeProperties2KHR...\n");
debug_printf("Return value of vkGetDisplayModeProperties2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDisplayPlaneCapabilities2KHR( VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetDisplayPlaneCapabilities2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDISPLAYPLANECAPABILITIES2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pDisplayPlaneInfo==NULL){
                json["pDisplayPlaneInfo"]=boost::json::array();
            return; }json["pDisplayPlaneInfo"]=boost::json::array(1);
        auto& arr_rwBYAlG=json["pDisplayPlaneInfo"].get_array();
        for(int iEdZMtQ=0; iEdZMtQ < 1; iEdZMtQ++){
            [&](){
            auto& temp=arr_rwBYAlG[iEdZMtQ].emplace_object();
            return serialize_struct(temp, pDisplayPlaneInfo[iEdZMtQ]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_perBkIp=json["pCapabilities"].get_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].emplace_object();
            return serialize_struct(temp, pCapabilities[wDZGRHI]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDISPLAYPLANECAPABILITIES2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_perBkIp=json["pCapabilities"].get_array();
        for(int wDZGRHI=0; wDZGRHI < 1; wDZGRHI++){
            [&](){
            auto& temp=arr_perBkIp[wDZGRHI].get_object();
            deserialize_struct(temp,pCapabilities[wDZGRHI]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_SuQXlIN;[&](){
            if (json["result"].is_uint64()){
                temp_SuQXlIN=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_SuQXlIN=static_cast<int>(json["result"].get_int64());
            }else{
                temp_SuQXlIN=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_SuQXlIN;}();}();

debug_printf("Ending vkGetDisplayPlaneCapabilities2KHR...\n");
debug_printf("Return value of vkGetDisplayPlaneCapabilities2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetBufferMemoryRequirements2\n");

    boost::json::object json;
    json["stream_type"]=VKGETBUFFERMEMORYREQUIREMENTS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_xrBSgMU=json["pInfo"].get_array();
        for(int XaVdoIX=0; XaVdoIX < 1; XaVdoIX++){
            [&](){
            auto& temp=arr_xrBSgMU[XaVdoIX].emplace_object();
            return serialize_struct(temp, pInfo[XaVdoIX]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetBufferMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetBufferMemoryRequirements2KHR( VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageMemoryRequirements2\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEMEMORYREQUIREMENTS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_OVesMNt=json["pInfo"].get_array();
        for(int xSwhhlO=0; xSwhhlO < 1; xSwhhlO++){
            [&](){
            auto& temp=arr_OVesMNt[xSwhhlO].emplace_object();
            return serialize_struct(temp, pInfo[xSwhhlO]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetImageMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageMemoryRequirements2KHR( VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetImageSparseMemoryRequirements2\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGESPARSEMEMORYREQUIREMENTS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_frlqZZl=json["pInfo"].get_array();
        for(int DnuwqwS=0; DnuwqwS < 1; DnuwqwS++){
            [&](){
            auto& temp=arr_frlqZZl[DnuwqwS].emplace_object();
            return serialize_struct(temp, pInfo[DnuwqwS]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESPARSEMEMORYREQUIREMENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSparseMemoryRequirements2...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSparseMemoryRequirements2KHR( VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirements( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceBufferMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEBUFFERMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LbYKRdp=json["pInfo"].get_array();
        for(int sabbuKR=0; sabbuKR < 1; sabbuKR++){
            [&](){
            auto& temp=arr_LbYKRdp[sabbuKR].emplace_object();
            return serialize_struct(temp, pInfo[sabbuKR]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEBUFFERMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceBufferMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceBufferMemoryRequirementsKHR( VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEIMAGEMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_dGiJKQX=json["pInfo"].get_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements ){
return vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirements( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSparseMemoryRequirements\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_dGiJKQX=json["pInfo"].get_array();
        for(int Hfcgcwr=0; Hfcgcwr < 1; Hfcgcwr++){
            [&](){
            auto& temp=arr_dGiJKQX[Hfcgcwr].emplace_object();
            return serialize_struct(temp, pInfo[Hfcgcwr]);
            }();
        }
        }();
[&](){
            if (pSparseMemoryRequirementCount==NULL){
                json["pSparseMemoryRequirementCount"]=boost::json::array();
            return; }json["pSparseMemoryRequirementCount"]=boost::json::array(1);
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){arr_QpqRnvg[pFgmjla]=pSparseMemoryRequirementCount[pFgmjla];}();
        }
        }();
[&](){
            if (pSparseMemoryRequirements==NULL){
                json["pSparseMemoryRequirements"]=boost::json::array();
            return; }json["pSparseMemoryRequirements"]=boost::json::array(*pSparseMemoryRequirementCount);
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].emplace_object();
            return serialize_struct(temp, pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESPARSEMEMORYREQUIREMENTS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSparseMemoryRequirementCount"].get_array().size()==0){
                pSparseMemoryRequirementCount=NULL;
            return; }
        auto& arr_QpqRnvg=json["pSparseMemoryRequirementCount"].get_array();
        for(int pFgmjla=0; pFgmjla < 1; pFgmjla++){
            [&](){
            if (arr_QpqRnvg[pFgmjla].is_uint64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_uint64());
            }else if (arr_QpqRnvg[pFgmjla].is_int64()){
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_int64());
            }else{
                pSparseMemoryRequirementCount[pFgmjla]=static_cast<uint32_t>(arr_QpqRnvg[pFgmjla].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pSparseMemoryRequirements"].get_array().size()==0){
                pSparseMemoryRequirements=NULL;
            return; }
        auto& arr_vCRbLVA=json["pSparseMemoryRequirements"].get_array();
        for(int QTojQNx=0; QTojQNx < *pSparseMemoryRequirementCount; QTojQNx++){
            [&](){
            auto& temp=arr_vCRbLVA[QTojQNx].get_object();
            deserialize_struct(temp,pSparseMemoryRequirements[QTojQNx]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSparseMemoryRequirements...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSparseMemoryRequirementsKHR( VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements ){
return vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversion( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
//Will only be called by the client
debug_printf("Executing vkCreateSamplerYcbcrConversion\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESAMPLERYCBCRCONVERSION;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_kLHhxUL=json["pCreateInfo"].get_array();
        for(int zgqBgkX=0; zgqBgkX < 1; zgqBgkX++){
            [&](){
            auto& temp=arr_kLHhxUL[zgqBgkX].emplace_object();
            return serialize_struct(temp, pCreateInfo[zgqBgkX]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pYcbcrConversion==NULL){
                json["pYcbcrConversion"]=boost::json::array();
            return; }json["pYcbcrConversion"]=boost::json::array(1);
        auto& arr_joRRIst=json["pYcbcrConversion"].get_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){serialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr],pYcbcrConversion[VRaBMYr]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pYcbcrConversion"].get_array().size()==0){
                pYcbcrConversion=NULL;
            return; }
        auto& arr_joRRIst=json["pYcbcrConversion"].get_array();
        for(int VRaBMYr=0; VRaBMYr < 1; VRaBMYr++){
            [&](){deserialize_VkSamplerYcbcrConversion(arr_joRRIst[VRaBMYr], pYcbcrConversion[VRaBMYr]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_isarYKk;[&](){
            if (json["result"].is_uint64()){
                temp_isarYKk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_isarYKk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_isarYKk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_isarYKk;}();}();

                if (pYcbcrConversion!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pYcbcrConversion[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateSamplerYcbcrConversion...\n");
debug_printf("Return value of vkCreateSamplerYcbcrConversion is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateSamplerYcbcrConversionKHR( VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion ){
return vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversion( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroySamplerYcbcrConversion\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSAMPLERYCBCRCONVERSION;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSamplerYcbcrConversion(json["ycbcrConversion"],ycbcrConversion);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSAMPLERYCBCRCONVERSION):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSamplerYcbcrConversion(json["ycbcrConversion"], ycbcrConversion);}();


debug_printf("Ending vkDestroySamplerYcbcrConversion...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroySamplerYcbcrConversionKHR( VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator ){
return vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
__attribute__((visibility ("hidden"))) void vkGetDeviceQueue2( VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceQueue2\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEQUEUE2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pQueueInfo==NULL){
                json["pQueueInfo"]=boost::json::array();
            return; }json["pQueueInfo"]=boost::json::array(1);
        auto& arr_bNCRimR=json["pQueueInfo"].get_array();
        for(int ubuvbaB=0; ubuvbaB < 1; ubuvbaB++){
            [&](){
            auto& temp=arr_bNCRimR[ubuvbaB].emplace_object();
            return serialize_struct(temp, pQueueInfo[ubuvbaB]);
            }();
        }
        }();
[&](){
            if (pQueue==NULL){
                json["pQueue"]=boost::json::array();
            return; }json["pQueue"]=boost::json::array(1);
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){serialize_VkQueue(arr_rYZbcEA[jOgbunb],pQueue[jOgbunb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEQUEUE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pQueue"].get_array().size()==0){
                pQueue=NULL;
            return; }
        auto& arr_rYZbcEA=json["pQueue"].get_array();
        for(int jOgbunb=0; jOgbunb < 1; jOgbunb++){
            [&](){deserialize_VkQueue(arr_rYZbcEA[jOgbunb], pQueue[jOgbunb]);}();
        }
        }();

debug_printf("Ending vkGetDeviceQueue2...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateValidationCacheEXT( VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache ){
//Will only be called by the client
debug_printf("Executing vkCreateValidationCacheEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEVALIDATIONCACHEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_ZCXiwLp=json["pCreateInfo"].get_array();
        for(int XeWuaSR=0; XeWuaSR < 1; XeWuaSR++){
            [&](){
            auto& temp=arr_ZCXiwLp[XeWuaSR].emplace_object();
            return serialize_struct(temp, pCreateInfo[XeWuaSR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pValidationCache==NULL){
                json["pValidationCache"]=boost::json::array();
            return; }json["pValidationCache"]=boost::json::array(1);
        auto& arr_oYoDWhC=json["pValidationCache"].get_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){serialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs],pValidationCache[ejlwFKs]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pValidationCache"].get_array().size()==0){
                pValidationCache=NULL;
            return; }
        auto& arr_oYoDWhC=json["pValidationCache"].get_array();
        for(int ejlwFKs=0; ejlwFKs < 1; ejlwFKs++){
            [&](){deserialize_VkValidationCacheEXT(arr_oYoDWhC[ejlwFKs], pValidationCache[ejlwFKs]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_NGqSAPw;[&](){
            if (json["result"].is_uint64()){
                temp_NGqSAPw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_NGqSAPw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_NGqSAPw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_NGqSAPw;}();}();

                if (pValidationCache!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pValidationCache[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateValidationCacheEXT...\n");
debug_printf("Return value of vkCreateValidationCacheEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyValidationCacheEXT( VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyValidationCacheEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYVALIDATIONCACHEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVALIDATIONCACHEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();


debug_printf("Ending vkDestroyValidationCacheEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetValidationCacheDataEXT( VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetValidationCacheDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETVALIDATIONCACHEDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["validationCache"],validationCache);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVALIDATIONCACHEDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["validationCache"], validationCache);}();
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_qUleAuZ;[&](){
            if (json["result"].is_uint64()){
                temp_qUleAuZ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_qUleAuZ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_qUleAuZ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_qUleAuZ;}();}();

debug_printf("Ending vkGetValidationCacheDataEXT...\n");
debug_printf("Return value of vkGetValidationCacheDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkMergeValidationCachesEXT( VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches ){
//Will only be called by the client
debug_printf("Executing vkMergeValidationCachesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKMERGEVALIDATIONCACHESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkValidationCacheEXT(json["dstCache"],dstCache);}();
[&](){json["srcCacheCount"]=srcCacheCount;}();
[&](){
            if (pSrcCaches==NULL){
                json["pSrcCaches"]=boost::json::array();
            return; }json["pSrcCaches"]=boost::json::array(srcCacheCount);
        auto& arr_xXUlTaQ=json["pSrcCaches"].get_array();
        for(int AJDSLsE=0; AJDSLsE < srcCacheCount; AJDSLsE++){
            [&](){serialize_VkValidationCacheEXT(arr_xXUlTaQ[AJDSLsE],pSrcCaches[AJDSLsE]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMERGEVALIDATIONCACHESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkValidationCacheEXT(json["dstCache"], dstCache);}();
[&](){
            if (json["srcCacheCount"].is_uint64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_uint64());
            }else if (json["srcCacheCount"].is_int64()){
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_int64());
            }else{
                srcCacheCount=static_cast<uint32_t>(json["srcCacheCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_fgUntwV;[&](){
            if (json["result"].is_uint64()){
                temp_fgUntwV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_fgUntwV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_fgUntwV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_fgUntwV;}();}();

debug_printf("Ending vkMergeValidationCachesEXT...\n");
debug_printf("Return value of vkMergeValidationCachesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupport( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSupport\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTORSETLAYOUTSUPPORT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dFRsqIW=json["pCreateInfo"].get_array();
        for(int tUGauKK=0; tUGauKK < 1; tUGauKK++){
            [&](){
            auto& temp=arr_dFRsqIW[tUGauKK].emplace_object();
            return serialize_struct(temp, pCreateInfo[tUGauKK]);
            }();
        }
        }();
[&](){
            if (pSupport==NULL){
                json["pSupport"]=boost::json::array();
            return; }json["pSupport"]=boost::json::array(1);
        auto& arr_xgzGluH=json["pSupport"].get_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].emplace_object();
            return serialize_struct(temp, pSupport[UvZyHDI]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSUPPORT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pSupport"].get_array().size()==0){
                pSupport=NULL;
            return; }
        auto& arr_xgzGluH=json["pSupport"].get_array();
        for(int UvZyHDI=0; UvZyHDI < 1; UvZyHDI++){
            [&](){
            auto& temp=arr_xgzGluH[UvZyHDI].get_object();
            deserialize_struct(temp,pSupport[UvZyHDI]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSupport...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSupportKHR( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport ){
return vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderInfoAMD( VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetShaderInfoAMD\n");

    boost::json::object json;
    json["stream_type"]=VKGETSHADERINFOAMD;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){[&](){[&](){json["shaderStage"]=shaderStage;}();}();}();
[&](){[&](){[&](){json["infoType"]=infoType;}();}();}();
[&](){
            if (pInfoSize==NULL){
                json["pInfoSize"]=boost::json::array();
            return; }json["pInfoSize"]=boost::json::array(1);
        auto& arr_ouDPuUh=json["pInfoSize"].get_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){arr_ouDPuUh[wpUCmEy]=pInfoSize[wpUCmEy];}();
        }
        }();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }[&](){
            if (((char*)(pInfo))==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(*pInfoSize);
        auto& arr_UHSCjHI=json["pInfo"].get_array();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){arr_UHSCjHI[rexTFCi]=((char*)(pInfo))[rexTFCi];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERINFOAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){[&](){int temp_nGZQHxq;[&](){
            if (json["shaderStage"].is_uint64()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_uint64());
            }else if (json["shaderStage"].is_int64()){
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_int64());
            }else{
                temp_nGZQHxq=static_cast<int>(json["shaderStage"].get_double());
            }
            }();shaderStage=(VkShaderStageFlagBits)temp_nGZQHxq;}();}();
[&](){[&](){int temp_nNfHNkf;[&](){
            if (json["infoType"].is_uint64()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_uint64());
            }else if (json["infoType"].is_int64()){
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_int64());
            }else{
                temp_nNfHNkf=static_cast<int>(json["infoType"].get_double());
            }
            }();infoType=(VkShaderInfoTypeAMD)temp_nNfHNkf;}();}();
[&](){
            if (json["pInfoSize"].get_array().size()==0){
                pInfoSize=NULL;
            return; }
        auto& arr_ouDPuUh=json["pInfoSize"].get_array();
        for(int wpUCmEy=0; wpUCmEy < 1; wpUCmEy++){
            [&](){
            if (arr_ouDPuUh[wpUCmEy].is_uint64()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_uint64());
            }else if (arr_ouDPuUh[wpUCmEy].is_int64()){
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_int64());
            }else{
                pInfoSize[wpUCmEy]=static_cast<size_t>(arr_ouDPuUh[wpUCmEy].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pInfo"].get_array().size()==0){
                pInfo=NULL;
            return; }char* temp_ziBtDwK;[&](){
            if (json["pInfo"].get_array().size()==0){
                temp_ziBtDwK=NULL;
            return; }temp_ziBtDwK=(char*)malloc(*pInfoSize*sizeof(char));
        auto& arr_UHSCjHI=json["pInfo"].get_array();
        for(int rexTFCi=0; rexTFCi < *pInfoSize; rexTFCi++){
            [&](){
            if (arr_UHSCjHI[rexTFCi].is_uint64()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_uint64());
            }else if (arr_UHSCjHI[rexTFCi].is_int64()){
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_int64());
            }else{
                temp_ziBtDwK[rexTFCi]=static_cast<char>(arr_UHSCjHI[rexTFCi].get_double());
            }
            }();
        }
        }();pInfo=temp_ziBtDwK;}();
VkResult result;
[&](){[&](){int temp_SeHBHly;[&](){
            if (json["result"].is_uint64()){
                temp_SeHBHly=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_SeHBHly=static_cast<int>(json["result"].get_int64());
            }else{
                temp_SeHBHly=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_SeHBHly;}();}();

debug_printf("Ending vkGetShaderInfoAMD...\n");
debug_printf("Return value of vkGetShaderInfoAMD is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetLocalDimmingAMD( VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable ){
//Will only be called by the client
debug_printf("Executing vkSetLocalDimmingAMD\n");

    boost::json::object json;
    json["stream_type"]=VKSETLOCALDIMMINGAMD;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapChain"],swapChain);}();
[&](){[&](){json["localDimmingEnable"]=localDimmingEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETLOCALDIMMINGAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapChain"], swapChain);}();
[&](){uint32_t temp_jfGMipq;[&](){
            if (json["localDimmingEnable"].is_uint64()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_uint64());
            }else if (json["localDimmingEnable"].is_int64()){
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_int64());
            }else{
                temp_jfGMipq=static_cast<uint32_t>(json["localDimmingEnable"].get_double());
            }
            }();localDimmingEnable=(VkBool32)temp_jfGMipq;}();

debug_printf("Ending vkSetLocalDimmingAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT( VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainEXT* pTimeDomains ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCalibrateableTimeDomainsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pTimeDomainCount==NULL){
                json["pTimeDomainCount"]=boost::json::array();
            return; }json["pTimeDomainCount"]=boost::json::array(1);
        auto& arr_siSbERs=json["pTimeDomainCount"].get_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){arr_siSbERs[xFQhUzA]=pTimeDomainCount[xFQhUzA];}();
        }
        }();
[&](){
            if (pTimeDomains==NULL){
                json["pTimeDomains"]=boost::json::array();
            return; }json["pTimeDomains"]=boost::json::array(*pTimeDomainCount);
        auto& arr_fMkUaJq=json["pTimeDomains"].get_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){[&](){arr_fMkUaJq[ZiXuFCL]=pTimeDomains[ZiXuFCL];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pTimeDomainCount"].get_array().size()==0){
                pTimeDomainCount=NULL;
            return; }
        auto& arr_siSbERs=json["pTimeDomainCount"].get_array();
        for(int xFQhUzA=0; xFQhUzA < 1; xFQhUzA++){
            [&](){
            if (arr_siSbERs[xFQhUzA].is_uint64()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_uint64());
            }else if (arr_siSbERs[xFQhUzA].is_int64()){
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_int64());
            }else{
                pTimeDomainCount[xFQhUzA]=static_cast<uint32_t>(arr_siSbERs[xFQhUzA].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pTimeDomains"].get_array().size()==0){
                pTimeDomains=NULL;
            return; }
        auto& arr_fMkUaJq=json["pTimeDomains"].get_array();
        for(int ZiXuFCL=0; ZiXuFCL < *pTimeDomainCount; ZiXuFCL++){
            [&](){[&](){int temp_EryZVUE;[&](){
            if (arr_fMkUaJq[ZiXuFCL].is_uint64()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_uint64());
            }else if (arr_fMkUaJq[ZiXuFCL].is_int64()){
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_int64());
            }else{
                temp_EryZVUE=static_cast<int>(arr_fMkUaJq[ZiXuFCL].get_double());
            }
            }();pTimeDomains[ZiXuFCL]=(VkTimeDomainEXT)temp_EryZVUE;}();}();
        }
        }();
VkResult result;
[&](){[&](){int temp_mVFqWLu;[&](){
            if (json["result"].is_uint64()){
                temp_mVFqWLu=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_mVFqWLu=static_cast<int>(json["result"].get_int64());
            }else{
                temp_mVFqWLu=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_mVFqWLu;}();}();

debug_printf("Ending vkGetPhysicalDeviceCalibrateableTimeDomainsEXT...\n");
debug_printf("Return value of vkGetPhysicalDeviceCalibrateableTimeDomainsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetCalibratedTimestampsEXT( VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation ){
//Will only be called by the client
debug_printf("Executing vkGetCalibratedTimestampsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETCALIBRATEDTIMESTAMPSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["timestampCount"]=timestampCount;}();
[&](){
            if (pTimestampInfos==NULL){
                json["pTimestampInfos"]=boost::json::array();
            return; }json["pTimestampInfos"]=boost::json::array(timestampCount);
        auto& arr_XQeyMsT=json["pTimestampInfos"].get_array();
        for(int aXwwgcz=0; aXwwgcz < timestampCount; aXwwgcz++){
            [&](){
            auto& temp=arr_XQeyMsT[aXwwgcz].emplace_object();
            return serialize_struct(temp, pTimestampInfos[aXwwgcz]);
            }();
        }
        }();
[&](){
            if (pTimestamps==NULL){
                json["pTimestamps"]=boost::json::array();
            return; }json["pTimestamps"]=boost::json::array(timestampCount);
        auto& arr_CHzcvgg=json["pTimestamps"].get_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){arr_CHzcvgg[ptqlrVt]=pTimestamps[ptqlrVt];}();
        }
        }();
[&](){
            if (pMaxDeviation==NULL){
                json["pMaxDeviation"]=boost::json::array();
            return; }json["pMaxDeviation"]=boost::json::array(1);
        auto& arr_zQmthvJ=json["pMaxDeviation"].get_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){arr_zQmthvJ[FUkBved]=pMaxDeviation[FUkBved];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETCALIBRATEDTIMESTAMPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["timestampCount"].is_uint64()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_uint64());
            }else if (json["timestampCount"].is_int64()){
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_int64());
            }else{
                timestampCount=static_cast<uint32_t>(json["timestampCount"].get_double());
            }
            }();

[&](){
            if (json["pTimestamps"].get_array().size()==0){
                pTimestamps=NULL;
            return; }
        auto& arr_CHzcvgg=json["pTimestamps"].get_array();
        for(int ptqlrVt=0; ptqlrVt < timestampCount; ptqlrVt++){
            [&](){
            if (arr_CHzcvgg[ptqlrVt].is_uint64()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_uint64());
            }else if (arr_CHzcvgg[ptqlrVt].is_int64()){
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_int64());
            }else{
                pTimestamps[ptqlrVt]=static_cast<uint64_t>(arr_CHzcvgg[ptqlrVt].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pMaxDeviation"].get_array().size()==0){
                pMaxDeviation=NULL;
            return; }
        auto& arr_zQmthvJ=json["pMaxDeviation"].get_array();
        for(int FUkBved=0; FUkBved < 1; FUkBved++){
            [&](){
            if (arr_zQmthvJ[FUkBved].is_uint64()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_uint64());
            }else if (arr_zQmthvJ[FUkBved].is_int64()){
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_int64());
            }else{
                pMaxDeviation[FUkBved]=static_cast<uint64_t>(arr_zQmthvJ[FUkBved].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_AqSIVIC;[&](){
            if (json["result"].is_uint64()){
                temp_AqSIVIC=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_AqSIVIC=static_cast<int>(json["result"].get_int64());
            }else{
                temp_AqSIVIC=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_AqSIVIC;}();}();

debug_printf("Ending vkGetCalibratedTimestampsEXT...\n");
debug_printf("Return value of vkGetCalibratedTimestampsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectNameEXT( VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectNameEXT\n");

    boost::json::object json;
    json["stream_type"]=VKSETDEBUGUTILSOBJECTNAMEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pNameInfo==NULL){
                json["pNameInfo"]=boost::json::array();
            return; }json["pNameInfo"]=boost::json::array(1);
        auto& arr_gpHzyjV=json["pNameInfo"].get_array();
        for(int sXDrIfX=0; sXDrIfX < 1; sXDrIfX++){
            [&](){
            auto& temp=arr_gpHzyjV[sXDrIfX].emplace_object();
            return serialize_struct(temp, pNameInfo[sXDrIfX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTNAMEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ZbhglLt;[&](){
            if (json["result"].is_uint64()){
                temp_ZbhglLt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZbhglLt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZbhglLt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZbhglLt;}();}();

debug_printf("Ending vkSetDebugUtilsObjectNameEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectNameEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetDebugUtilsObjectTagEXT( VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo ){
//Will only be called by the client
debug_printf("Executing vkSetDebugUtilsObjectTagEXT\n");

    boost::json::object json;
    json["stream_type"]=VKSETDEBUGUTILSOBJECTTAGEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pTagInfo==NULL){
                json["pTagInfo"]=boost::json::array();
            return; }json["pTagInfo"]=boost::json::array(1);
        auto& arr_jMraQzd=json["pTagInfo"].get_array();
        for(int lQZzjnQ=0; lQZzjnQ < 1; lQZzjnQ++){
            [&](){
            auto& temp=arr_jMraQzd[lQZzjnQ].emplace_object();
            return serialize_struct(temp, pTagInfo[lQZzjnQ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEBUGUTILSOBJECTTAGEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_CgpaGeC;[&](){
            if (json["result"].is_uint64()){
                temp_CgpaGeC=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_CgpaGeC=static_cast<int>(json["result"].get_int64());
            }else{
                temp_CgpaGeC=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_CgpaGeC;}();}();

debug_printf("Ending vkSetDebugUtilsObjectTagEXT...\n");
debug_printf("Return value of vkSetDebugUtilsObjectTagEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkQueueBeginDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueBeginDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEBEGINDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueEndDebugUtilsLabelEXT( VkQueue queue ){
//Will only be called by the client
debug_printf("Executing vkQueueEndDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEENDDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();

debug_printf("Ending vkQueueEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkQueueInsertDebugUtilsLabelEXT( VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkQueueInsertDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUEINSERTDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUEINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();


debug_printf("Ending vkQueueInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndDebugUtilsLabelEXT( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdInsertDebugUtilsLabelEXT( VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdInsertDebugUtilsLabelEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDINSERTDEBUGUTILSLABELEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLabelInfo==NULL){
                json["pLabelInfo"]=boost::json::array();
            return; }json["pLabelInfo"]=boost::json::array(1);
        auto& arr_GvONoAl=json["pLabelInfo"].get_array();
        for(int XxFTlct=0; XxFTlct < 1; XxFTlct++){
            [&](){
            auto& temp=arr_GvONoAl[XxFTlct].emplace_object();
            return serialize_struct(temp, pLabelInfo[XxFTlct]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDINSERTDEBUGUTILSLABELEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdInsertDebugUtilsLabelEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDebugUtilsMessengerEXT( VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger ){
//Will only be called by the client
debug_printf("Executing vkCreateDebugUtilsMessengerEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDEBUGUTILSMESSENGEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_alrnjyY=json["pCreateInfo"].get_array();
        for(int uDOYkhP=0; uDOYkhP < 1; uDOYkhP++){
            [&](){
            auto& temp=arr_alrnjyY[uDOYkhP].emplace_object();
            return serialize_struct(temp, pCreateInfo[uDOYkhP]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMessenger==NULL){
                json["pMessenger"]=boost::json::array();
            return; }json["pMessenger"]=boost::json::array(1);
        auto& arr_INDwqtI=json["pMessenger"].get_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){serialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe],pMessenger[XlveIOe]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pMessenger"].get_array().size()==0){
                pMessenger=NULL;
            return; }
        auto& arr_INDwqtI=json["pMessenger"].get_array();
        for(int XlveIOe=0; XlveIOe < 1; XlveIOe++){
            [&](){deserialize_VkDebugUtilsMessengerEXT(arr_INDwqtI[XlveIOe], pMessenger[XlveIOe]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_GvoCfSy;[&](){
            if (json["result"].is_uint64()){
                temp_GvoCfSy=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_GvoCfSy=static_cast<int>(json["result"].get_int64());
            }else{
                temp_GvoCfSy=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_GvoCfSy;}();}();

                if (pMessenger!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMessenger[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDebugUtilsMessengerEXT...\n");
debug_printf("Return value of vkCreateDebugUtilsMessengerEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDebugUtilsMessengerEXT( VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDebugUtilsMessengerEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDEBUGUTILSMESSENGEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){serialize_VkDebugUtilsMessengerEXT(json["messenger"],messenger);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEBUGUTILSMESSENGEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){deserialize_VkDebugUtilsMessengerEXT(json["messenger"], messenger);}();


debug_printf("Ending vkDestroyDebugUtilsMessengerEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkSubmitDebugUtilsMessageEXT( VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData ){
//Will only be called by the client
debug_printf("Executing vkSubmitDebugUtilsMessageEXT\n");

    boost::json::object json;
    json["stream_type"]=VKSUBMITDEBUGUTILSMESSAGEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){[&](){[&](){json["messageSeverity"]=messageSeverity;}();}();}();
[&](){[&](){[&](){json["messageTypes"]=messageTypes;}();}();}();
[&](){
            if (pCallbackData==NULL){
                json["pCallbackData"]=boost::json::array();
            return; }json["pCallbackData"]=boost::json::array(1);
        auto& arr_kahfHKb=json["pCallbackData"].get_array();
        for(int YuXULtv=0; YuXULtv < 1; YuXULtv++){
            [&](){
            auto& temp=arr_kahfHKb[YuXULtv].emplace_object();
            return serialize_struct(temp, pCallbackData[YuXULtv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSUBMITDEBUGUTILSMESSAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();
[&](){[&](){int temp_UpocUQR;[&](){
            if (json["messageSeverity"].is_uint64()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_uint64());
            }else if (json["messageSeverity"].is_int64()){
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_int64());
            }else{
                temp_UpocUQR=static_cast<int>(json["messageSeverity"].get_double());
            }
            }();messageSeverity=(VkDebugUtilsMessageSeverityFlagBitsEXT)temp_UpocUQR;}();}();
[&](){[&](){int temp_vbjSEUE;[&](){
            if (json["messageTypes"].is_uint64()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_uint64());
            }else if (json["messageTypes"].is_int64()){
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_int64());
            }else{
                temp_vbjSEUE=static_cast<int>(json["messageTypes"].get_double());
            }
            }();messageTypes=(VkDebugUtilsMessageTypeFlagsEXT)temp_vbjSEUE;}();}();


debug_printf("Ending vkSubmitDebugUtilsMessageEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetMemoryHostPointerPropertiesEXT( VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties ){
//Will only be called by the client
debug_printf("Executing vkGetMemoryHostPointerPropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETMEMORYHOSTPOINTERPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["handleType"]=handleType;}();}();}();
[&](){
            if (pHostPointer==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }[&](){
            if (((char*)(pHostPointer))==NULL){
                json["pHostPointer"]=boost::json::array();
            return; }json["pHostPointer"]=boost::json::array(strlen(((char*)(pHostPointer)))+1);
        auto& arr_iKHPNio=json["pHostPointer"].get_array();
        for(int UFxRrhm=0; UFxRrhm < strlen(((char*)(pHostPointer)))+1; UFxRrhm++){
            [&](){arr_iKHPNio[UFxRrhm]=((char*)(pHostPointer))[UFxRrhm];}();
        }
        }();}();
[&](){
            if (pMemoryHostPointerProperties==NULL){
                json["pMemoryHostPointerProperties"]=boost::json::array();
            return; }json["pMemoryHostPointerProperties"]=boost::json::array(1);
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].get_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].emplace_object();
            return serialize_struct(temp, pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMEMORYHOSTPOINTERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_vuWMBJk;[&](){
            if (json["handleType"].is_uint64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_uint64());
            }else if (json["handleType"].is_int64()){
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_int64());
            }else{
                temp_vuWMBJk=static_cast<int>(json["handleType"].get_double());
            }
            }();handleType=(VkExternalMemoryHandleTypeFlagBits)temp_vuWMBJk;}();}();

[&](){
            if (json["pMemoryHostPointerProperties"].get_array().size()==0){
                pMemoryHostPointerProperties=NULL;
            return; }
        auto& arr_CBNxdHG=json["pMemoryHostPointerProperties"].get_array();
        for(int hqDeAHT=0; hqDeAHT < 1; hqDeAHT++){
            [&](){
            auto& temp=arr_CBNxdHG[hqDeAHT].get_object();
            deserialize_struct(temp,pMemoryHostPointerProperties[hqDeAHT]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_Iwamftl;[&](){
            if (json["result"].is_uint64()){
                temp_Iwamftl=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_Iwamftl=static_cast<int>(json["result"].get_int64());
            }else{
                temp_Iwamftl=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_Iwamftl;}();}();

debug_printf("Ending vkGetMemoryHostPointerPropertiesEXT...\n");
debug_printf("Return value of vkGetMemoryHostPointerPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarkerAMD( VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarkerAMD\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITEBUFFERMARKERAMD;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineStage"]=pipelineStage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKERAMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_WILNXWI;[&](){
            if (json["pipelineStage"].is_uint64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_uint64());
            }else if (json["pipelineStage"].is_int64()){
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_int64());
            }else{
                temp_WILNXWI=static_cast<int>(json["pipelineStage"].get_double());
            }
            }();pipelineStage=(VkPipelineStageFlagBits)temp_WILNXWI;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){
            if (json["marker"].is_uint64()){
                marker=static_cast<uint32_t>(json["marker"].get_uint64());
            }else if (json["marker"].is_int64()){
                marker=static_cast<uint32_t>(json["marker"].get_int64());
            }else{
                marker=static_cast<uint32_t>(json["marker"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteBufferMarkerAMD...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
//Will only be called by the client
debug_printf("Executing vkCreateRenderPass2\n");

    boost::json::object json;
    json["stream_type"]=VKCREATERENDERPASS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_cDssBor=json["pCreateInfo"].get_array();
        for(int SgbVidQ=0; SgbVidQ < 1; SgbVidQ++){
            [&](){
            auto& temp=arr_cDssBor[SgbVidQ].emplace_object();
            return serialize_struct(temp, pCreateInfo[SgbVidQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pRenderPass==NULL){
                json["pRenderPass"]=boost::json::array();
            return; }json["pRenderPass"]=boost::json::array(1);
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){serialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP],pRenderPass[BAjGGPP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pRenderPass"].get_array().size()==0){
                pRenderPass=NULL;
            return; }
        auto& arr_ZwdXTfx=json["pRenderPass"].get_array();
        for(int BAjGGPP=0; BAjGGPP < 1; BAjGGPP++){
            [&](){deserialize_VkRenderPass(arr_ZwdXTfx[BAjGGPP], pRenderPass[BAjGGPP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_DrIhxoS;[&](){
            if (json["result"].is_uint64()){
                temp_DrIhxoS=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_DrIhxoS=static_cast<int>(json["result"].get_int64());
            }else{
                temp_DrIhxoS=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_DrIhxoS;}();}();

                if (pRenderPass!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pRenderPass[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRenderPass2...\n");
debug_printf("Return value of vkCreateRenderPass2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRenderPass2KHR( VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass ){
return vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRenderPass2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINRENDERPASS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderPassBegin==NULL){
                json["pRenderPassBegin"]=boost::json::array();
            return; }json["pRenderPassBegin"]=boost::json::array(1);
        auto& arr_XtnTubd=json["pRenderPassBegin"].get_array();
        for(int lCAvoJt=0; lCAvoJt < 1; lCAvoJt++){
            [&](){
            auto& temp=arr_XtnTubd[lCAvoJt].emplace_object();
            return serialize_struct(temp, pRenderPassBegin[lCAvoJt]);
            }();
        }
        }();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }json["pSubpassBeginInfo"]=boost::json::array(1);
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].get_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdBeginRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderPass2KHR( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo ){
return vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdNextSubpass2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDNEXTSUBPASS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassBeginInfo==NULL){
                json["pSubpassBeginInfo"]=boost::json::array();
            return; }json["pSubpassBeginInfo"]=boost::json::array(1);
        auto& arr_yxkVVDb=json["pSubpassBeginInfo"].get_array();
        for(int nzkBQUL=0; nzkBQUL < 1; nzkBQUL++){
            [&](){
            auto& temp=arr_yxkVVDb[nzkBQUL].emplace_object();
            return serialize_struct(temp, pSubpassBeginInfo[nzkBQUL]);
            }();
        }
        }();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }json["pSubpassEndInfo"]=boost::json::array(1);
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].get_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDNEXTSUBPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();



debug_printf("Ending vkCmdNextSubpass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdNextSubpass2KHR( VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRenderPass2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDRENDERPASS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pSubpassEndInfo==NULL){
                json["pSubpassEndInfo"]=boost::json::array();
            return; }json["pSubpassEndInfo"]=boost::json::array(1);
        auto& arr_mmmwoMH=json["pSubpassEndInfo"].get_array();
        for(int oMdHEHu=0; oMdHEHu < 1; oMdHEHu++){
            [&](){
            auto& temp=arr_mmmwoMH[oMdHEHu].emplace_object();
            return serialize_struct(temp, pSubpassEndInfo[oMdHEHu]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERPASS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndRenderPass2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderPass2KHR( VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo ){
return vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValue( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetSemaphoreCounterValue\n");

    boost::json::object json;
    json["stream_type"]=VKGETSEMAPHORECOUNTERVALUE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSemaphore(json["semaphore"],semaphore);}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }json["pValue"]=boost::json::array(1);
        auto& arr_xnMrErb=json["pValue"].get_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){arr_xnMrErb[fdUIVMD]=pValue[fdUIVMD];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSEMAPHORECOUNTERVALUE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSemaphore(json["semaphore"], semaphore);}();
[&](){
            if (json["pValue"].get_array().size()==0){
                pValue=NULL;
            return; }
        auto& arr_xnMrErb=json["pValue"].get_array();
        for(int fdUIVMD=0; fdUIVMD < 1; fdUIVMD++){
            [&](){
            if (arr_xnMrErb[fdUIVMD].is_uint64()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_uint64());
            }else if (arr_xnMrErb[fdUIVMD].is_int64()){
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_int64());
            }else{
                pValue[fdUIVMD]=static_cast<uint64_t>(arr_xnMrErb[fdUIVMD].get_double());
            }
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HswTyiI;[&](){
            if (json["result"].is_uint64()){
                temp_HswTyiI=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HswTyiI=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HswTyiI=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HswTyiI;}();}();

debug_printf("Ending vkGetSemaphoreCounterValue...\n");
debug_printf("Return value of vkGetSemaphoreCounterValue is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSemaphoreCounterValueKHR( VkDevice device, VkSemaphore semaphore, uint64_t* pValue ){
return vkGetSemaphoreCounterValue(device, semaphore, pValue);
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphores( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitSemaphores\n");

    boost::json::object json;
    json["stream_type"]=VKWAITSEMAPHORES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pWaitInfo==NULL){
                json["pWaitInfo"]=boost::json::array();
            return; }json["pWaitInfo"]=boost::json::array(1);
        auto& arr_xzakrWz=json["pWaitInfo"].get_array();
        for(int hsOLCWG=0; hsOLCWG < 1; hsOLCWG++){
            [&](){
            auto& temp=arr_xzakrWz[hsOLCWG].emplace_object();
            return serialize_struct(temp, pWaitInfo[hsOLCWG]);
            }();
        }
        }();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITSEMAPHORES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_zsBKwrb;[&](){
            if (json["result"].is_uint64()){
                temp_zsBKwrb=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_zsBKwrb=static_cast<int>(json["result"].get_int64());
            }else{
                temp_zsBKwrb=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_zsBKwrb;}();}();

debug_printf("Ending vkWaitSemaphores...\n");
debug_printf("Return value of vkWaitSemaphores is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitSemaphoresKHR( VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout ){
return vkWaitSemaphores(device, pWaitInfo, timeout);
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphore( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
//Will only be called by the client
debug_printf("Executing vkSignalSemaphore\n");

    boost::json::object json;
    json["stream_type"]=VKSIGNALSEMAPHORE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pSignalInfo==NULL){
                json["pSignalInfo"]=boost::json::array();
            return; }json["pSignalInfo"]=boost::json::array(1);
        auto& arr_WdRQTJS=json["pSignalInfo"].get_array();
        for(int MYLvJyX=0; MYLvJyX < 1; MYLvJyX++){
            [&](){
            auto& temp=arr_WdRQTJS[MYLvJyX].emplace_object();
            return serialize_struct(temp, pSignalInfo[MYLvJyX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSIGNALSEMAPHORE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_ebLddpw;[&](){
            if (json["result"].is_uint64()){
                temp_ebLddpw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ebLddpw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ebLddpw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ebLddpw;}();}();

debug_printf("Ending vkSignalSemaphore...\n");
debug_printf("Return value of vkSignalSemaphore is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSignalSemaphoreKHR( VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo ){
return vkSignalSemaphore(device, pSignalInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectCount\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDIRECTCOUNT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndexedIndirectCount\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDEXEDINDIRECTCOUNT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDEXEDINDIRECTCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndexedIndirectCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndexedIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
return vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
__attribute__((visibility ("hidden"))) void vkCmdSetCheckpointNV( VkCommandBuffer commandBuffer, const void* pCheckpointMarker ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCheckpointNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCHECKPOINTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCheckpointMarker==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }[&](){
            if (((char*)(pCheckpointMarker))==NULL){
                json["pCheckpointMarker"]=boost::json::array();
            return; }json["pCheckpointMarker"]=boost::json::array(strlen(((char*)(pCheckpointMarker)))+1);
        auto& arr_eBRjtYz=json["pCheckpointMarker"].get_array();
        for(int VYoknaS=0; VYoknaS < strlen(((char*)(pCheckpointMarker)))+1; VYoknaS++){
            [&](){arr_eBRjtYz[VYoknaS]=((char*)(pCheckpointMarker))[VYoknaS];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCHECKPOINTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetCheckpointNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointDataNV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointDataNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETQUEUECHECKPOINTDATANV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }json["pCheckpointDataCount"]=boost::json::array(1);
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }json["pCheckpointData"]=boost::json::array(*pCheckpointDataCount);
        auto& arr_gxwhODc=json["pCheckpointData"].get_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].emplace_object();
            return serialize_struct(temp, pCheckpointData[TfFHlNo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATANV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].get_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_uint64());
            }else if (arr_LsYqVIK[lgasnOP].is_int64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_int64());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCheckpointData"].get_array().size()==0){
                pCheckpointData=NULL;
            return; }
        auto& arr_gxwhODc=json["pCheckpointData"].get_array();
        for(int TfFHlNo=0; TfFHlNo < *pCheckpointDataCount; TfFHlNo++){
            [&](){
            auto& temp=arr_gxwhODc[TfFHlNo].get_object();
            deserialize_struct(temp,pCheckpointData[TfFHlNo]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointDataNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindTransformFeedbackBuffersEXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes ){
//Will only be called by the client
debug_printf("Executing vkCmdBindTransformFeedbackBuffersEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }json["pSizes"]=boost::json::array(bindingCount);
        auto& arr_OwyEmcF=json["pSizes"].get_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDTRANSFORMFEEDBACKBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();




debug_printf("Ending vkCmdBindTransformFeedbackBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginTransformFeedbackEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINTRANSFORMFEEDBACKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }json["pCounterBuffers"]=boost::json::array(counterBufferCount);
        auto& arr_eyGyJgR=json["pCounterBuffers"].get_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }json["pCounterBufferOffsets"]=boost::json::array(counterBufferCount);
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].get_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstCounterBuffer"].is_uint64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_uint64());
            }else if (json["firstCounterBuffer"].is_int64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_int64());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_double());
            }
            }();
[&](){
            if (json["counterBufferCount"].is_uint64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_uint64());
            }else if (json["counterBufferCount"].is_int64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_int64());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdBeginTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndTransformFeedbackEXT( VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdEndTransformFeedbackEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDTRANSFORMFEEDBACKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstCounterBuffer"]=firstCounterBuffer;}();
[&](){json["counterBufferCount"]=counterBufferCount;}();
[&](){
            if (pCounterBuffers==NULL){
                json["pCounterBuffers"]=boost::json::array();
            return; }json["pCounterBuffers"]=boost::json::array(counterBufferCount);
        auto& arr_eyGyJgR=json["pCounterBuffers"].get_array();
        for(int dBINaJF=0; dBINaJF < counterBufferCount; dBINaJF++){
            [&](){serialize_VkBuffer(arr_eyGyJgR[dBINaJF],pCounterBuffers[dBINaJF]);}();
        }
        }();
[&](){
            if (pCounterBufferOffsets==NULL){
                json["pCounterBufferOffsets"]=boost::json::array();
            return; }json["pCounterBufferOffsets"]=boost::json::array(counterBufferCount);
        auto& arr_AiSbQbQ=json["pCounterBufferOffsets"].get_array();
        for(int ThYypfr=0; ThYypfr < counterBufferCount; ThYypfr++){
            [&](){[&](){arr_AiSbQbQ[ThYypfr]=pCounterBufferOffsets[ThYypfr];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDTRANSFORMFEEDBACKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstCounterBuffer"].is_uint64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_uint64());
            }else if (json["firstCounterBuffer"].is_int64()){
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_int64());
            }else{
                firstCounterBuffer=static_cast<uint32_t>(json["firstCounterBuffer"].get_double());
            }
            }();
[&](){
            if (json["counterBufferCount"].is_uint64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_uint64());
            }else if (json["counterBufferCount"].is_int64()){
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_int64());
            }else{
                counterBufferCount=static_cast<uint32_t>(json["counterBufferCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdEndTransformFeedbackEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginQueryIndexedEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINQUERYINDEXEDEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){[&](){[&](){json["flags"]=flags;}();}();}();
[&](){json["index"]=index;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
[&](){[&](){int temp_iyzDJOK;[&](){
            if (json["flags"].is_uint64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_uint64());
            }else if (json["flags"].is_int64()){
                temp_iyzDJOK=static_cast<int>(json["flags"].get_int64());
            }else{
                temp_iyzDJOK=static_cast<int>(json["flags"].get_double());
            }
            }();flags=(VkQueryControlFlags)temp_iyzDJOK;}();}();
[&](){
            if (json["index"].is_uint64()){
                index=static_cast<uint32_t>(json["index"].get_uint64());
            }else if (json["index"].is_int64()){
                index=static_cast<uint32_t>(json["index"].get_int64());
            }else{
                index=static_cast<uint32_t>(json["index"].get_double());
            }
            }();

debug_printf("Ending vkCmdBeginQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndQueryIndexedEXT( VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index ){
//Will only be called by the client
debug_printf("Executing vkCmdEndQueryIndexedEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDQUERYINDEXEDEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
[&](){json["index"]=index;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDQUERYINDEXEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();
[&](){
            if (json["index"].is_uint64()){
                index=static_cast<uint32_t>(json["index"].get_uint64());
            }else if (json["index"].is_int64()){
                index=static_cast<uint32_t>(json["index"].get_int64());
            }else{
                index=static_cast<uint32_t>(json["index"].get_double());
            }
            }();

debug_printf("Ending vkCmdEndQueryIndexedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawIndirectByteCountEXT( VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawIndirectByteCountEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWINDIRECTBYTECOUNTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["instanceCount"]=instanceCount;}();
[&](){json["firstInstance"]=firstInstance;}();
[&](){serialize_VkBuffer(json["counterBuffer"],counterBuffer);}();
[&](){[&](){json["counterBufferOffset"]=counterBufferOffset;}();}();
[&](){json["counterOffset"]=counterOffset;}();
[&](){json["vertexStride"]=vertexStride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWINDIRECTBYTECOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["instanceCount"].is_uint64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_uint64());
            }else if (json["instanceCount"].is_int64()){
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_int64());
            }else{
                instanceCount=static_cast<uint32_t>(json["instanceCount"].get_double());
            }
            }();
[&](){
            if (json["firstInstance"].is_uint64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_uint64());
            }else if (json["firstInstance"].is_int64()){
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_int64());
            }else{
                firstInstance=static_cast<uint32_t>(json["firstInstance"].get_double());
            }
            }();
[&](){deserialize_VkBuffer(json["counterBuffer"], counterBuffer);}();
[&](){uint64_t temp_AQwWAlK;[&](){
            if (json["counterBufferOffset"].is_uint64()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_uint64());
            }else if (json["counterBufferOffset"].is_int64()){
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_int64());
            }else{
                temp_AQwWAlK=static_cast<uint64_t>(json["counterBufferOffset"].get_double());
            }
            }();counterBufferOffset=(VkDeviceSize)temp_AQwWAlK;}();
[&](){
            if (json["counterOffset"].is_uint64()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_uint64());
            }else if (json["counterOffset"].is_int64()){
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_int64());
            }else{
                counterOffset=static_cast<uint32_t>(json["counterOffset"].get_double());
            }
            }();
[&](){
            if (json["vertexStride"].is_uint64()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_uint64());
            }else if (json["vertexStride"].is_int64()){
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_int64());
            }else{
                vertexStride=static_cast<uint32_t>(json["vertexStride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawIndirectByteCountEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETEXCLUSIVESCISSORNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissors==NULL){
                json["pExclusiveScissors"]=boost::json::array();
            return; }json["pExclusiveScissors"]=boost::json::array(exclusiveScissorCount);
        auto& arr_aPFLQnr=json["pExclusiveScissors"].get_array();
        for(int uoWCiOs=0; uoWCiOs < exclusiveScissorCount; uoWCiOs++){
            [&](){
            auto& temp=arr_aPFLQnr[uoWCiOs].emplace_object();
            return serialize_struct(temp, pExclusiveScissors[uoWCiOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstExclusiveScissor"].is_uint64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_uint64());
            }else if (json["firstExclusiveScissor"].is_int64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_int64());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_double());
            }
            }();
[&](){
            if (json["exclusiveScissorCount"].is_uint64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_uint64());
            }else if (json["exclusiveScissorCount"].is_int64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_int64());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetExclusiveScissorNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExclusiveScissorEnableNV( VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExclusiveScissorEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETEXCLUSIVESCISSORENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstExclusiveScissor"]=firstExclusiveScissor;}();
[&](){json["exclusiveScissorCount"]=exclusiveScissorCount;}();
[&](){
            if (pExclusiveScissorEnables==NULL){
                json["pExclusiveScissorEnables"]=boost::json::array();
            return; }json["pExclusiveScissorEnables"]=boost::json::array(exclusiveScissorCount);
        auto& arr_xqHCjsr=json["pExclusiveScissorEnables"].get_array();
        for(int ZwZaOgk=0; ZwZaOgk < exclusiveScissorCount; ZwZaOgk++){
            [&](){[&](){arr_xqHCjsr[ZwZaOgk]=pExclusiveScissorEnables[ZwZaOgk];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXCLUSIVESCISSORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstExclusiveScissor"].is_uint64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_uint64());
            }else if (json["firstExclusiveScissor"].is_int64()){
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_int64());
            }else{
                firstExclusiveScissor=static_cast<uint32_t>(json["firstExclusiveScissor"].get_double());
            }
            }();
[&](){
            if (json["exclusiveScissorCount"].is_uint64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_uint64());
            }else if (json["exclusiveScissorCount"].is_int64()){
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_int64());
            }else{
                exclusiveScissorCount=static_cast<uint32_t>(json["exclusiveScissorCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetExclusiveScissorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadingRateImageNV( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadingRateImageNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDSHADINGRATEIMAGENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADINGRATEIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindShadingRateImageNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportShadingRatePaletteNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportShadingRatePaletteNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORTSHADINGRATEPALETTENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pShadingRatePalettes==NULL){
                json["pShadingRatePalettes"]=boost::json::array();
            return; }json["pShadingRatePalettes"]=boost::json::array(viewportCount);
        auto& arr_QGCIyPL=json["pShadingRatePalettes"].get_array();
        for(int iwmSeHU=0; iwmSeHU < viewportCount; iwmSeHU++){
            [&](){
            auto& temp=arr_QGCIyPL[iwmSeHU].emplace_object();
            return serialize_struct(temp, pShadingRatePalettes[iwmSeHU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSHADINGRATEPALETTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportShadingRatePaletteNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoarseSampleOrderNV( VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoarseSampleOrderNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOARSESAMPLEORDERNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["sampleOrderType"]=sampleOrderType;}();}();}();
[&](){json["customSampleOrderCount"]=customSampleOrderCount;}();
[&](){
            if (pCustomSampleOrders==NULL){
                json["pCustomSampleOrders"]=boost::json::array();
            return; }json["pCustomSampleOrders"]=boost::json::array(customSampleOrderCount);
        auto& arr_UoJKhih=json["pCustomSampleOrders"].get_array();
        for(int nBPVlSV=0; nBPVlSV < customSampleOrderCount; nBPVlSV++){
            [&](){
            auto& temp=arr_UoJKhih[nBPVlSV].emplace_object();
            return serialize_struct(temp, pCustomSampleOrders[nBPVlSV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOARSESAMPLEORDERNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_iGYbmmy;[&](){
            if (json["sampleOrderType"].is_uint64()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_uint64());
            }else if (json["sampleOrderType"].is_int64()){
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_int64());
            }else{
                temp_iGYbmmy=static_cast<int>(json["sampleOrderType"].get_double());
            }
            }();sampleOrderType=(VkCoarseSampleOrderTypeNV)temp_iGYbmmy;}();}();
[&](){
            if (json["customSampleOrderCount"].is_uint64()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_uint64());
            }else if (json["customSampleOrderCount"].is_int64()){
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_int64());
            }else{
                customSampleOrderCount=static_cast<uint32_t>(json["customSampleOrderCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetCoarseSampleOrderNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksNV( VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["taskCount"]=taskCount;}();
[&](){json["firstTask"]=firstTask;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["taskCount"].is_uint64()){
                taskCount=static_cast<uint32_t>(json["taskCount"].get_uint64());
            }else if (json["taskCount"].is_int64()){
                taskCount=static_cast<uint32_t>(json["taskCount"].get_int64());
            }else{
                taskCount=static_cast<uint32_t>(json["taskCount"].get_double());
            }
            }();
[&](){
            if (json["firstTask"].is_uint64()){
                firstTask=static_cast<uint32_t>(json["firstTask"].get_uint64());
            }else if (json["firstTask"].is_int64()){
                firstTask=static_cast<uint32_t>(json["firstTask"].get_int64());
            }else{
                firstTask=static_cast<uint32_t>(json["firstTask"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountNV( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksEXT( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["groupCountX"]=groupCountX;}();
[&](){json["groupCountY"]=groupCountY;}();
[&](){json["groupCountZ"]=groupCountZ;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["groupCountX"].is_uint64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_uint64());
            }else if (json["groupCountX"].is_int64()){
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_int64());
            }else{
                groupCountX=static_cast<uint32_t>(json["groupCountX"].get_double());
            }
            }();
[&](){
            if (json["groupCountY"].is_uint64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_uint64());
            }else if (json["groupCountY"].is_int64()){
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_int64());
            }else{
                groupCountY=static_cast<uint32_t>(json["groupCountY"].get_double());
            }
            }();
[&](){
            if (json["groupCountZ"].is_uint64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_uint64());
            }else if (json["groupCountZ"].is_int64()){
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_int64());
            }else{
                groupCountZ=static_cast<uint32_t>(json["groupCountZ"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){json["drawCount"]=drawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){
            if (json["drawCount"].is_uint64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_uint64());
            }else if (json["drawCount"].is_int64()){
                drawCount=static_cast<uint32_t>(json["drawCount"].get_int64());
            }else{
                drawCount=static_cast<uint32_t>(json["drawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDrawMeshTasksIndirectCountEXT( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDrawMeshTasksIndirectCountEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){serialize_VkBuffer(json["countBuffer"],countBuffer);}();
[&](){[&](){json["countBufferOffset"]=countBufferOffset;}();}();
[&](){json["maxDrawCount"]=maxDrawCount;}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDRAWMESHTASKSINDIRECTCOUNTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){deserialize_VkBuffer(json["countBuffer"], countBuffer);}();
[&](){uint64_t temp_JpaFKmS;[&](){
            if (json["countBufferOffset"].is_uint64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_uint64());
            }else if (json["countBufferOffset"].is_int64()){
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_int64());
            }else{
                temp_JpaFKmS=static_cast<uint64_t>(json["countBufferOffset"].get_double());
            }
            }();countBufferOffset=(VkDeviceSize)temp_JpaFKmS;}();
[&](){
            if (json["maxDrawCount"].is_uint64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_uint64());
            }else if (json["maxDrawCount"].is_int64()){
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_int64());
            }else{
                maxDrawCount=static_cast<uint32_t>(json["maxDrawCount"].get_double());
            }
            }();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDrawMeshTasksIndirectCountEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCompileDeferredNV( VkDevice device, VkPipeline pipeline, uint32_t shader ){
//Will only be called by the client
debug_printf("Executing vkCompileDeferredNV\n");

    boost::json::object json;
    json["stream_type"]=VKCOMPILEDEFERREDNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["shader"]=shader;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOMPILEDEFERREDNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["shader"].is_uint64()){
                shader=static_cast<uint32_t>(json["shader"].get_uint64());
            }else if (json["shader"].is_int64()){
                shader=static_cast<uint32_t>(json["shader"].get_int64());
            }else{
                shader=static_cast<uint32_t>(json["shader"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_lkDOwDU;[&](){
            if (json["result"].is_uint64()){
                temp_lkDOwDU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_lkDOwDU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_lkDOwDU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_lkDOwDU;}();}();

debug_printf("Ending vkCompileDeferredNV...\n");
debug_printf("Return value of vkCompileDeferredNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureNV( VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureNV\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEACCELERATIONSTRUCTURENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_cRwwWhs=json["pCreateInfo"].get_array();
        for(int oEOLGTm=0; oEOLGTm < 1; oEOLGTm++){
            [&](){
            auto& temp=arr_cRwwWhs[oEOLGTm].emplace_object();
            return serialize_struct(temp, pCreateInfo[oEOLGTm]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }json["pAccelerationStructure"]=boost::json::array(1);
        auto& arr_FUsucto=json["pAccelerationStructure"].get_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){serialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM],pAccelerationStructure[tRSoAUM]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].get_array().size()==0){
                pAccelerationStructure=NULL;
            return; }
        auto& arr_FUsucto=json["pAccelerationStructure"].get_array();
        for(int tRSoAUM=0; tRSoAUM < 1; tRSoAUM++){
            [&](){deserialize_VkAccelerationStructureNV(arr_FUsucto[tRSoAUM], pAccelerationStructure[tRSoAUM]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_IuEtyfT;[&](){
            if (json["result"].is_uint64()){
                temp_IuEtyfT=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_IuEtyfT=static_cast<int>(json["result"].get_int64());
            }else{
                temp_IuEtyfT=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_IuEtyfT;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureNV...\n");
debug_printf("Return value of vkCreateAccelerationStructureNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindInvocationMaskHUAWEI( VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout ){
//Will only be called by the client
debug_printf("Executing vkCmdBindInvocationMaskHUAWEI\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDINVOCATIONMASKHUAWEI;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){[&](){[&](){json["imageLayout"]=imageLayout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINVOCATIONMASKHUAWEI):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){[&](){int temp_VgsvIeW;[&](){
            if (json["imageLayout"].is_uint64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_uint64());
            }else if (json["imageLayout"].is_int64()){
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_int64());
            }else{
                temp_VgsvIeW=static_cast<int>(json["imageLayout"].get_double());
            }
            }();imageLayout=(VkImageLayout)temp_VgsvIeW;}();}();

debug_printf("Ending vkCmdBindInvocationMaskHUAWEI...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureKHR( VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureKHR(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureKHR(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyAccelerationStructureNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyAccelerationStructureNV\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYACCELERATIONSTRUCTURENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();


debug_printf("Ending vkDestroyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureMemoryRequirementsNV( VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureMemoryRequirementsNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QKzjkmC=json["pInfo"].get_array();
        for(int eEDmZTf=0; eEDmZTf < 1; eEDmZTf++){
            [&](){
            auto& temp=arr_QKzjkmC[eEDmZTf].emplace_object();
            return serialize_struct(temp, pInfo[eEDmZTf]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_lzklPBG=json["pMemoryRequirements"].get_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_lzklPBG=json["pMemoryRequirements"].get_array();
        for(int HmtSVPA=0; HmtSVPA < 1; HmtSVPA++){
            [&](){
            auto& temp=arr_lzklPBG[HmtSVPA].get_object();
            deserialize_struct(temp,pMemoryRequirements[HmtSVPA]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindAccelerationStructureMemoryNV( VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos ){
//Will only be called by the client
debug_printf("Executing vkBindAccelerationStructureMemoryNV\n");

    boost::json::object json;
    json["stream_type"]=VKBINDACCELERATIONSTRUCTUREMEMORYNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["bindInfoCount"]=bindInfoCount;}();
[&](){
            if (pBindInfos==NULL){
                json["pBindInfos"]=boost::json::array();
            return; }json["pBindInfos"]=boost::json::array(bindInfoCount);
        auto& arr_rhzkvXd=json["pBindInfos"].get_array();
        for(int tRvmYFr=0; tRvmYFr < bindInfoCount; tRvmYFr++){
            [&](){
            auto& temp=arr_rhzkvXd[tRvmYFr].emplace_object();
            return serialize_struct(temp, pBindInfos[tRvmYFr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDACCELERATIONSTRUCTUREMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["bindInfoCount"].is_uint64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_uint64());
            }else if (json["bindInfoCount"].is_int64()){
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_int64());
            }else{
                bindInfoCount=static_cast<uint32_t>(json["bindInfoCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_tcqhJAr;[&](){
            if (json["result"].is_uint64()){
                temp_tcqhJAr=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_tcqhJAr=static_cast<int>(json["result"].get_int64());
            }else{
                temp_tcqhJAr=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_tcqhJAr;}();}();

debug_printf("Ending vkBindAccelerationStructureMemoryNV...\n");
debug_printf("Return value of vkBindAccelerationStructureMemoryNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureNV( VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTURENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){[&](){[&](){json["mode"]=mode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){[&](){int temp_KfOqWqs;[&](){
            if (json["mode"].is_uint64()){
                temp_KfOqWqs=static_cast<int>(json["mode"].get_uint64());
            }else if (json["mode"].is_int64()){
                temp_KfOqWqs=static_cast<int>(json["mode"].get_int64());
            }else{
                temp_KfOqWqs=static_cast<int>(json["mode"].get_double());
            }
            }();mode=(VkCopyAccelerationStructureModeKHR)temp_KfOqWqs;}();}();

debug_printf("Ending vkCmdCopyAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mSSajtp=json["pInfo"].get_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mSSajtp=json["pInfo"].get_array();
        for(int ghvrBgW=0; ghvrBgW < 1; ghvrBgW++){
            [&](){
            auto& temp=arr_mSSajtp[ghvrBgW].emplace_object();
            return serialize_struct(temp, pInfo[ghvrBgW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_oTeNRkE;[&](){
            if (json["result"].is_uint64()){
                temp_oTeNRkE=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_oTeNRkE=static_cast<int>(json["result"].get_int64());
            }else{
                temp_oTeNRkE=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_oTeNRkE;}();}();

debug_printf("Ending vkCopyAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyAccelerationStructureToMemoryKHR( VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyAccelerationStructureToMemoryKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_MpzusRq=json["pInfo"].get_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyAccelerationStructureToMemoryKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyAccelerationStructureToMemoryKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyAccelerationStructureToMemoryKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_MpzusRq=json["pInfo"].get_array();
        for(int hToWSKz=0; hToWSKz < 1; hToWSKz++){
            [&](){
            auto& temp=arr_MpzusRq[hToWSKz].emplace_object();
            return serialize_struct(temp, pInfo[hToWSKz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYACCELERATIONSTRUCTURETOMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_yBdwNKk;[&](){
            if (json["result"].is_uint64()){
                temp_yBdwNKk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yBdwNKk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yBdwNKk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yBdwNKk;}();}();

debug_printf("Ending vkCopyAccelerationStructureToMemoryKHR...\n");
debug_printf("Return value of vkCopyAccelerationStructureToMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToAccelerationStructureKHR( VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_yRNSaUF=json["pInfo"].get_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToAccelerationStructureKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToAccelerationStructureKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_yRNSaUF=json["pInfo"].get_array();
        for(int ulOBYSb=0; ulOBYSb < 1; ulOBYSb++){
            [&](){
            auto& temp=arr_yRNSaUF[ulOBYSb].emplace_object();
            return serialize_struct(temp, pInfo[ulOBYSb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_sCYLTOz;[&](){
            if (json["result"].is_uint64()){
                temp_sCYLTOz=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_sCYLTOz=static_cast<int>(json["result"].get_int64());
            }else{
                temp_sCYLTOz=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_sCYLTOz;}();}();

debug_printf("Ending vkCopyMemoryToAccelerationStructureKHR...\n");
debug_printf("Return value of vkCopyMemoryToAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesKHR( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_oCGlcEh=json["pAccelerationStructures"].get_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteAccelerationStructuresPropertiesNV( VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteAccelerationStructuresPropertiesNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_NSQEnJt=json["pAccelerationStructures"].get_array();
        for(int zIyqkBG=0; zIyqkBG < accelerationStructureCount; zIyqkBG++){
            [&](){serialize_VkAccelerationStructureNV(arr_NSQEnJt[zIyqkBG],pAccelerationStructures[zIyqkBG]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteAccelerationStructuresPropertiesNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructureNV( VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructureNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_GYyRhgo=json["pInfo"].get_array();
        for(int jJuvWAP=0; jJuvWAP < 1; jJuvWAP++){
            [&](){
            auto& temp=arr_GYyRhgo[jJuvWAP].emplace_object();
            return serialize_struct(temp, pInfo[jJuvWAP]);
            }();
        }
        }();
[&](){serialize_VkBuffer(json["instanceData"],instanceData);}();
[&](){[&](){json["instanceOffset"]=instanceOffset;}();}();
[&](){[&](){json["update"]=update;}();}();
[&](){serialize_VkAccelerationStructureNV(json["dst"],dst);}();
[&](){serialize_VkAccelerationStructureNV(json["src"],src);}();
[&](){serialize_VkBuffer(json["scratch"],scratch);}();
[&](){[&](){json["scratchOffset"]=scratchOffset;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){deserialize_VkBuffer(json["instanceData"], instanceData);}();
[&](){uint64_t temp_sEYJico;[&](){
            if (json["instanceOffset"].is_uint64()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_uint64());
            }else if (json["instanceOffset"].is_int64()){
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_int64());
            }else{
                temp_sEYJico=static_cast<uint64_t>(json["instanceOffset"].get_double());
            }
            }();instanceOffset=(VkDeviceSize)temp_sEYJico;}();
[&](){uint32_t temp_LpVZhJf;[&](){
            if (json["update"].is_uint64()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_uint64());
            }else if (json["update"].is_int64()){
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_int64());
            }else{
                temp_LpVZhJf=static_cast<uint32_t>(json["update"].get_double());
            }
            }();update=(VkBool32)temp_LpVZhJf;}();
[&](){deserialize_VkAccelerationStructureNV(json["dst"], dst);}();
[&](){deserialize_VkAccelerationStructureNV(json["src"], src);}();
[&](){deserialize_VkBuffer(json["scratch"], scratch);}();
[&](){uint64_t temp_rbfZpmL;[&](){
            if (json["scratchOffset"].is_uint64()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_uint64());
            }else if (json["scratchOffset"].is_int64()){
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_int64());
            }else{
                temp_rbfZpmL=static_cast<uint64_t>(json["scratchOffset"].get_double());
            }
            }();scratchOffset=(VkDeviceSize)temp_rbfZpmL;}();

debug_printf("Ending vkCmdBuildAccelerationStructureNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteAccelerationStructuresPropertiesKHR( VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteAccelerationStructuresPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["accelerationStructureCount"]=accelerationStructureCount;}();
[&](){
            if (pAccelerationStructures==NULL){
                json["pAccelerationStructures"]=boost::json::array();
            return; }json["pAccelerationStructures"]=boost::json::array(accelerationStructureCount);
        auto& arr_oCGlcEh=json["pAccelerationStructures"].get_array();
        for(int tzoupLn=0; tzoupLn < accelerationStructureCount; tzoupLn++){
            [&](){serialize_VkAccelerationStructureKHR(arr_oCGlcEh[tzoupLn],pAccelerationStructures[tzoupLn]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEACCELERATIONSTRUCTURESPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["accelerationStructureCount"].is_uint64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_uint64());
            }else if (json["accelerationStructureCount"].is_int64()){
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_int64());
            }else{
                accelerationStructureCount=static_cast<uint32_t>(json["accelerationStructureCount"].get_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<size_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<size_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<size_t>(json["stride"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_NtoSKQr;[&](){
            if (json["result"].is_uint64()){
                temp_NtoSKQr=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_NtoSKQr=static_cast<int>(json["result"].get_int64());
            }else{
                temp_NtoSKQr=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_NtoSKQr;}();}();

debug_printf("Ending vkWriteAccelerationStructuresPropertiesKHR...\n");
debug_printf("Return value of vkWriteAccelerationStructuresPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDTRACERAYSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }json["pRaygenShaderBindingTable"]=boost::json::array(1);
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].get_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }json["pMissShaderBindingTable"]=boost::json::array(1);
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].get_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }json["pHitShaderBindingTable"]=boost::json::array(1);
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].get_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }json["pCallableShaderBindingTable"]=boost::json::array(1);
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].get_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){
            if (json["width"].is_uint64()){
                width=static_cast<uint32_t>(json["width"].get_uint64());
            }else if (json["width"].is_int64()){
                width=static_cast<uint32_t>(json["width"].get_int64());
            }else{
                width=static_cast<uint32_t>(json["width"].get_double());
            }
            }();
[&](){
            if (json["height"].is_uint64()){
                height=static_cast<uint32_t>(json["height"].get_uint64());
            }else if (json["height"].is_int64()){
                height=static_cast<uint32_t>(json["height"].get_int64());
            }else{
                height=static_cast<uint32_t>(json["height"].get_double());
            }
            }();
[&](){
            if (json["depth"].is_uint64()){
                depth=static_cast<uint32_t>(json["depth"].get_uint64());
            }else if (json["depth"].is_int64()){
                depth=static_cast<uint32_t>(json["depth"].get_int64());
            }else{
                depth=static_cast<uint32_t>(json["depth"].get_double());
            }
            }();

debug_printf("Ending vkCmdTraceRaysKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysNV( VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDTRACERAYSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["raygenShaderBindingTableBuffer"],raygenShaderBindingTableBuffer);}();
[&](){[&](){json["raygenShaderBindingOffset"]=raygenShaderBindingOffset;}();}();
[&](){serialize_VkBuffer(json["missShaderBindingTableBuffer"],missShaderBindingTableBuffer);}();
[&](){[&](){json["missShaderBindingOffset"]=missShaderBindingOffset;}();}();
[&](){[&](){json["missShaderBindingStride"]=missShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["hitShaderBindingTableBuffer"],hitShaderBindingTableBuffer);}();
[&](){[&](){json["hitShaderBindingOffset"]=hitShaderBindingOffset;}();}();
[&](){[&](){json["hitShaderBindingStride"]=hitShaderBindingStride;}();}();
[&](){serialize_VkBuffer(json["callableShaderBindingTableBuffer"],callableShaderBindingTableBuffer);}();
[&](){[&](){json["callableShaderBindingOffset"]=callableShaderBindingOffset;}();}();
[&](){[&](){json["callableShaderBindingStride"]=callableShaderBindingStride;}();}();
[&](){json["width"]=width;}();
[&](){json["height"]=height;}();
[&](){json["depth"]=depth;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["raygenShaderBindingTableBuffer"], raygenShaderBindingTableBuffer);}();
[&](){uint64_t temp_nbAYEyt;[&](){
            if (json["raygenShaderBindingOffset"].is_uint64()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_uint64());
            }else if (json["raygenShaderBindingOffset"].is_int64()){
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_int64());
            }else{
                temp_nbAYEyt=static_cast<uint64_t>(json["raygenShaderBindingOffset"].get_double());
            }
            }();raygenShaderBindingOffset=(VkDeviceSize)temp_nbAYEyt;}();
[&](){deserialize_VkBuffer(json["missShaderBindingTableBuffer"], missShaderBindingTableBuffer);}();
[&](){uint64_t temp_ORIaXGF;[&](){
            if (json["missShaderBindingOffset"].is_uint64()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_uint64());
            }else if (json["missShaderBindingOffset"].is_int64()){
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_int64());
            }else{
                temp_ORIaXGF=static_cast<uint64_t>(json["missShaderBindingOffset"].get_double());
            }
            }();missShaderBindingOffset=(VkDeviceSize)temp_ORIaXGF;}();
[&](){uint64_t temp_BOvfilr;[&](){
            if (json["missShaderBindingStride"].is_uint64()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_uint64());
            }else if (json["missShaderBindingStride"].is_int64()){
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_int64());
            }else{
                temp_BOvfilr=static_cast<uint64_t>(json["missShaderBindingStride"].get_double());
            }
            }();missShaderBindingStride=(VkDeviceSize)temp_BOvfilr;}();
[&](){deserialize_VkBuffer(json["hitShaderBindingTableBuffer"], hitShaderBindingTableBuffer);}();
[&](){uint64_t temp_oKlCsJj;[&](){
            if (json["hitShaderBindingOffset"].is_uint64()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_uint64());
            }else if (json["hitShaderBindingOffset"].is_int64()){
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_int64());
            }else{
                temp_oKlCsJj=static_cast<uint64_t>(json["hitShaderBindingOffset"].get_double());
            }
            }();hitShaderBindingOffset=(VkDeviceSize)temp_oKlCsJj;}();
[&](){uint64_t temp_qhwyGdu;[&](){
            if (json["hitShaderBindingStride"].is_uint64()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_uint64());
            }else if (json["hitShaderBindingStride"].is_int64()){
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_int64());
            }else{
                temp_qhwyGdu=static_cast<uint64_t>(json["hitShaderBindingStride"].get_double());
            }
            }();hitShaderBindingStride=(VkDeviceSize)temp_qhwyGdu;}();
[&](){deserialize_VkBuffer(json["callableShaderBindingTableBuffer"], callableShaderBindingTableBuffer);}();
[&](){uint64_t temp_WmjXZmz;[&](){
            if (json["callableShaderBindingOffset"].is_uint64()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_uint64());
            }else if (json["callableShaderBindingOffset"].is_int64()){
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_int64());
            }else{
                temp_WmjXZmz=static_cast<uint64_t>(json["callableShaderBindingOffset"].get_double());
            }
            }();callableShaderBindingOffset=(VkDeviceSize)temp_WmjXZmz;}();
[&](){uint64_t temp_giLAAVF;[&](){
            if (json["callableShaderBindingStride"].is_uint64()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_uint64());
            }else if (json["callableShaderBindingStride"].is_int64()){
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_int64());
            }else{
                temp_giLAAVF=static_cast<uint64_t>(json["callableShaderBindingStride"].get_double());
            }
            }();callableShaderBindingStride=(VkDeviceSize)temp_giLAAVF;}();
[&](){
            if (json["width"].is_uint64()){
                width=static_cast<uint32_t>(json["width"].get_uint64());
            }else if (json["width"].is_int64()){
                width=static_cast<uint32_t>(json["width"].get_int64());
            }else{
                width=static_cast<uint32_t>(json["width"].get_double());
            }
            }();
[&](){
            if (json["height"].is_uint64()){
                height=static_cast<uint32_t>(json["height"].get_uint64());
            }else if (json["height"].is_int64()){
                height=static_cast<uint32_t>(json["height"].get_int64());
            }else{
                height=static_cast<uint32_t>(json["height"].get_double());
            }
            }();
[&](){
            if (json["depth"].is_uint64()){
                depth=static_cast<uint32_t>(json["depth"].get_uint64());
            }else if (json["depth"].is_int64()){
                depth=static_cast<uint32_t>(json["depth"].get_int64());
            }else{
                depth=static_cast<uint32_t>(json["depth"].get_double());
            }
            }();

debug_printf("Ending vkCmdTraceRaysNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupHandlesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETRAYTRACINGSHADERGROUPHANDLESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["firstGroup"].is_uint64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_uint64());
            }else if (json["firstGroup"].is_int64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_int64());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_double());
            }
            }();
[&](){
            if (json["groupCount"].is_uint64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_uint64());
            }else if (json["groupCount"].is_int64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_int64());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].get_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_KLLRitp;[&](){
            if (json["result"].is_uint64()){
                temp_KLLRitp=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_KLLRitp=static_cast<int>(json["result"].get_int64());
            }else{
                temp_KLLRitp=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_KLLRitp;}();}();

debug_printf("Ending vkGetRayTracingShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingShaderGroupHandlesNV( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
return vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
__attribute__((visibility ("hidden"))) VkResult vkGetRayTracingCaptureReplayShaderGroupHandlesKHR( VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingCaptureReplayShaderGroupHandlesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["firstGroup"]=firstGroup;}();
[&](){json["groupCount"]=groupCount;}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["firstGroup"].is_uint64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_uint64());
            }else if (json["firstGroup"].is_int64()){
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_int64());
            }else{
                firstGroup=static_cast<uint32_t>(json["firstGroup"].get_double());
            }
            }();
[&](){
            if (json["groupCount"].is_uint64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_uint64());
            }else if (json["groupCount"].is_int64()){
                groupCount=static_cast<uint32_t>(json["groupCount"].get_int64());
            }else{
                groupCount=static_cast<uint32_t>(json["groupCount"].get_double());
            }
            }();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_eyQTZEO;[&](){
            if (json["result"].is_uint64()){
                temp_eyQTZEO=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_eyQTZEO=static_cast<int>(json["result"].get_int64());
            }else{
                temp_eyQTZEO=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_eyQTZEO;}();}();

debug_printf("Ending vkGetRayTracingCaptureReplayShaderGroupHandlesKHR...\n");
debug_printf("Return value of vkGetRayTracingCaptureReplayShaderGroupHandlesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureHandleNV( VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureHandleNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETACCELERATIONSTRUCTUREHANDLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkAccelerationStructureNV(json["accelerationStructure"],accelerationStructure);}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREHANDLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkAccelerationStructureNV(json["accelerationStructure"], accelerationStructure);}();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
VkResult result;
[&](){[&](){int temp_BimoMvo;[&](){
            if (json["result"].is_uint64()){
                temp_BimoMvo=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_BimoMvo=static_cast<int>(json["result"].get_int64());
            }else{
                temp_BimoMvo=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_BimoMvo;}();}();

debug_printf("Ending vkGetAccelerationStructureHandleNV...\n");
debug_printf("Return value of vkGetAccelerationStructureHandleNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesNV( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesNV\n");

    boost::json::object json;
    json["stream_type"]=VKCREATERAYTRACINGPIPELINESNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_bzMTsat=json["pCreateInfos"].get_array();
        for(int oRbABSQ=0; oRbABSQ < createInfoCount; oRbABSQ++){
            [&](){
            auto& temp=arr_bzMTsat[oRbABSQ].emplace_object();
            return serialize_struct(temp, pCreateInfos[oRbABSQ]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();


[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_vIEvAGL;[&](){
            if (json["result"].is_uint64()){
                temp_vIEvAGL=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_vIEvAGL=static_cast<int>(json["result"].get_int64());
            }else{
                temp_vIEvAGL=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_vIEvAGL;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesNV...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateRayTracingPipelinesKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines ){
//Will only be called by the client
debug_printf("Executing vkCreateRayTracingPipelinesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATERAYTRACINGPIPELINESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){serialize_VkPipelineCache(json["pipelineCache"],pipelineCache);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_zltFjJj=json["pCreateInfos"].get_array();
        for(int Szqaxlk=0; Szqaxlk < createInfoCount; Szqaxlk++){
            [&](){
            auto& temp=arr_zltFjJj[Szqaxlk].emplace_object();
            return serialize_struct(temp, pCreateInfos[Szqaxlk]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPipelines==NULL){
                json["pPipelines"]=boost::json::array();
            return; }json["pPipelines"]=boost::json::array(createInfoCount);
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){serialize_VkPipeline(arr_wuOYMDC[NOgwgOJ],pPipelines[NOgwgOJ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATERAYTRACINGPIPELINESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){deserialize_VkPipelineCache(json["pipelineCache"], pipelineCache);}();
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();


[&](){
            if (json["pPipelines"].get_array().size()==0){
                pPipelines=NULL;
            return; }
        auto& arr_wuOYMDC=json["pPipelines"].get_array();
        for(int NOgwgOJ=0; NOgwgOJ < createInfoCount; NOgwgOJ++){
            [&](){deserialize_VkPipeline(arr_wuOYMDC[NOgwgOJ], pPipelines[NOgwgOJ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_HNasHBP;[&](){
            if (json["result"].is_uint64()){
                temp_HNasHBP=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HNasHBP=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HNasHBP=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HNasHBP;}();}();

                if (pPipelines!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPipelines[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateRayTracingPipelinesKHR...\n");
debug_printf("Return value of vkCreateRayTracingPipelinesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_kVfVVDF=json["pProperties"].get_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].emplace_object();
            return serialize_struct(temp, pProperties[WfgOgPA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_kVfVVDF=json["pProperties"].get_array();
        for(int WfgOgPA=0; WfgOgPA < *pPropertyCount; WfgOgPA++){
            [&](){
            auto& temp=arr_kVfVVDF[WfgOgPA].get_object();
            deserialize_struct(temp,pProperties[WfgOgPA]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_wCoTUxK;[&](){
            if (json["result"].is_uint64()){
                temp_wCoTUxK=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_wCoTUxK=static_cast<int>(json["result"].get_int64());
            }else{
                temp_wCoTUxK=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_wCoTUxK;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirectKHR( VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirectKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDTRACERAYSINDIRECTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRaygenShaderBindingTable==NULL){
                json["pRaygenShaderBindingTable"]=boost::json::array();
            return; }json["pRaygenShaderBindingTable"]=boost::json::array(1);
        auto& arr_SlnAEUX=json["pRaygenShaderBindingTable"].get_array();
        for(int VKRuDIv=0; VKRuDIv < 1; VKRuDIv++){
            [&](){
            auto& temp=arr_SlnAEUX[VKRuDIv].emplace_object();
            return serialize_struct(temp, pRaygenShaderBindingTable[VKRuDIv]);
            }();
        }
        }();
[&](){
            if (pMissShaderBindingTable==NULL){
                json["pMissShaderBindingTable"]=boost::json::array();
            return; }json["pMissShaderBindingTable"]=boost::json::array(1);
        auto& arr_vBQknzc=json["pMissShaderBindingTable"].get_array();
        for(int ZhvHpIX=0; ZhvHpIX < 1; ZhvHpIX++){
            [&](){
            auto& temp=arr_vBQknzc[ZhvHpIX].emplace_object();
            return serialize_struct(temp, pMissShaderBindingTable[ZhvHpIX]);
            }();
        }
        }();
[&](){
            if (pHitShaderBindingTable==NULL){
                json["pHitShaderBindingTable"]=boost::json::array();
            return; }json["pHitShaderBindingTable"]=boost::json::array(1);
        auto& arr_IhHhjXk=json["pHitShaderBindingTable"].get_array();
        for(int yriMdrU=0; yriMdrU < 1; yriMdrU++){
            [&](){
            auto& temp=arr_IhHhjXk[yriMdrU].emplace_object();
            return serialize_struct(temp, pHitShaderBindingTable[yriMdrU]);
            }();
        }
        }();
[&](){
            if (pCallableShaderBindingTable==NULL){
                json["pCallableShaderBindingTable"]=boost::json::array();
            return; }json["pCallableShaderBindingTable"]=boost::json::array(1);
        auto& arr_EmEYSBY=json["pCallableShaderBindingTable"].get_array();
        for(int TiOHiqW=0; TiOHiqW < 1; TiOHiqW++){
            [&](){
            auto& temp=arr_EmEYSBY[TiOHiqW].emplace_object();
            return serialize_struct(temp, pCallableShaderBindingTable[TiOHiqW]);
            }();
        }
        }();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();




[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_uint64());
            }else if (json["indirectDeviceAddress"].is_int64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_int64());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdTraceRaysIndirect2KHR( VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress ){
//Will only be called by the client
debug_printf("Executing vkCmdTraceRaysIndirect2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDTRACERAYSINDIRECT2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectDeviceAddress"]=indirectDeviceAddress;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDTRACERAYSINDIRECT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_QXnaHDk;[&](){
            if (json["indirectDeviceAddress"].is_uint64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_uint64());
            }else if (json["indirectDeviceAddress"].is_int64()){
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_int64());
            }else{
                temp_QXnaHDk=static_cast<uint64_t>(json["indirectDeviceAddress"].get_double());
            }
            }();indirectDeviceAddress=(VkDeviceAddress)temp_QXnaHDk;}();

debug_printf("Ending vkCmdTraceRaysIndirect2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDeviceAccelerationStructureCompatibilityKHR( VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceAccelerationStructureCompatibilityKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }json["pVersionInfo"]=boost::json::array(1);
        auto& arr_wbhdpeb=json["pVersionInfo"].get_array();
        for(int vhWWlwM=0; vhWWlwM < 1; vhWWlwM++){
            [&](){
            auto& temp=arr_wbhdpeb[vhWWlwM].emplace_object();
            return serialize_struct(temp, pVersionInfo[vhWWlwM]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }json["pCompatibility"]=boost::json::array(1);
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].get_array().size()==0){
                pCompatibility=NULL;
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_uint64());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_int64());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceAccelerationStructureCompatibilityKHR...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceSize vkGetRayTracingShaderGroupStackSizeKHR( VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader ){
//Will only be called by the client
debug_printf("Executing vkGetRayTracingShaderGroupStackSizeKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPipeline(json["pipeline"],pipeline);}();
[&](){json["group"]=group;}();
[&](){[&](){[&](){json["groupShader"]=groupShader;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETRAYTRACINGSHADERGROUPSTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPipeline(json["pipeline"], pipeline);}();
[&](){
            if (json["group"].is_uint64()){
                group=static_cast<uint32_t>(json["group"].get_uint64());
            }else if (json["group"].is_int64()){
                group=static_cast<uint32_t>(json["group"].get_int64());
            }else{
                group=static_cast<uint32_t>(json["group"].get_double());
            }
            }();
[&](){[&](){int temp_EOWKSMj;[&](){
            if (json["groupShader"].is_uint64()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_uint64());
            }else if (json["groupShader"].is_int64()){
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_int64());
            }else{
                temp_EOWKSMj=static_cast<int>(json["groupShader"].get_double());
            }
            }();groupShader=(VkShaderGroupShaderKHR)temp_EOWKSMj;}();}();
VkDeviceSize result;
[&](){uint64_t temp_ZqPypzB;[&](){
            if (json["result"].is_uint64()){
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                temp_ZqPypzB=static_cast<uint64_t>(json["result"].get_double());
            }
            }();result=(VkDeviceSize)temp_ZqPypzB;}();

debug_printf("Ending vkGetRayTracingShaderGroupStackSizeKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetRayTracingPipelineStackSizeKHR( VkCommandBuffer commandBuffer, uint32_t pipelineStackSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRayTracingPipelineStackSizeKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["pipelineStackSize"]=pipelineStackSize;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRAYTRACINGPIPELINESTACKSIZEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["pipelineStackSize"].is_uint64()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_uint64());
            }else if (json["pipelineStackSize"].is_int64()){
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_int64());
            }else{
                pipelineStackSize=static_cast<uint32_t>(json["pipelineStackSize"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetRayTracingPipelineStackSizeKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetImageViewHandleNVX( VkDevice device, const VkImageViewHandleInfoNVX* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewHandleNVX\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEVIEWHANDLENVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_mfMZJfb=json["pInfo"].get_array();
        for(int dQabsff=0; dQabsff < 1; dQabsff++){
            [&](){
            auto& temp=arr_mfMZJfb[dQabsff].emplace_object();
            return serialize_struct(temp, pInfo[dQabsff]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWHANDLENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint32_t result;
[&](){
            if (json["result"].is_uint64()){
                result=static_cast<uint32_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                result=static_cast<uint32_t>(json["result"].get_int64());
            }else{
                result=static_cast<uint32_t>(json["result"].get_double());
            }
            }();

debug_printf("Ending vkGetImageViewHandleNVX...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewAddressNVX( VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewAddressNVX\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEVIEWADDRESSNVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImageView(json["imageView"],imageView);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_hveoAIn=json["pProperties"].get_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].emplace_object();
            return serialize_struct(temp, pProperties[FiVrJfn]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWADDRESSNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImageView(json["imageView"], imageView);}();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hveoAIn=json["pProperties"].get_array();
        for(int FiVrJfn=0; FiVrJfn < 1; FiVrJfn++){
            [&](){
            auto& temp=arr_hveoAIn[FiVrJfn].get_object();
            deserialize_struct(temp,pProperties[FiVrJfn]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_APQqeGV;[&](){
            if (json["result"].is_uint64()){
                temp_APQqeGV=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_APQqeGV=static_cast<int>(json["result"].get_int64());
            }else{
                temp_APQqeGV=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_APQqeGV;}();}();

debug_printf("Ending vkGetImageViewAddressNVX...\n");
debug_printf("Return value of vkGetImageViewAddressNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions ){
//Will only be called by the client
debug_printf("Executing vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR\n");

    boost::json::object json;
    json["stream_type"]=VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["queueFamilyIndex"]=queueFamilyIndex;}();
[&](){
            if (pCounterCount==NULL){
                json["pCounterCount"]=boost::json::array();
            return; }json["pCounterCount"]=boost::json::array(1);
        auto& arr_QuwxWHd=json["pCounterCount"].get_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){arr_QuwxWHd[HDbVSFc]=pCounterCount[HDbVSFc];}();
        }
        }();
[&](){
            if (pCounters==NULL){
                json["pCounters"]=boost::json::array();
            return; }json["pCounters"]=boost::json::array(*pCounterCount);
        auto& arr_vEVlsJt=json["pCounters"].get_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].emplace_object();
            return serialize_struct(temp, pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (pCounterDescriptions==NULL){
                json["pCounterDescriptions"]=boost::json::array();
            return; }json["pCounterDescriptions"]=boost::json::array(*pCounterCount);
        auto& arr_znRZkzO=json["pCounterDescriptions"].get_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].emplace_object();
            return serialize_struct(temp, pCounterDescriptions[GjxogPx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["queueFamilyIndex"].is_uint64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_uint64());
            }else if (json["queueFamilyIndex"].is_int64()){
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_int64());
            }else{
                queueFamilyIndex=static_cast<uint32_t>(json["queueFamilyIndex"].get_double());
            }
            }();
[&](){
            if (json["pCounterCount"].get_array().size()==0){
                pCounterCount=NULL;
            return; }
        auto& arr_QuwxWHd=json["pCounterCount"].get_array();
        for(int HDbVSFc=0; HDbVSFc < 1; HDbVSFc++){
            [&](){
            if (arr_QuwxWHd[HDbVSFc].is_uint64()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_uint64());
            }else if (arr_QuwxWHd[HDbVSFc].is_int64()){
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_int64());
            }else{
                pCounterCount[HDbVSFc]=static_cast<uint32_t>(arr_QuwxWHd[HDbVSFc].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCounters"].get_array().size()==0){
                pCounters=NULL;
            return; }
        auto& arr_vEVlsJt=json["pCounters"].get_array();
        for(int WmftXku=0; WmftXku < *pCounterCount; WmftXku++){
            [&](){
            auto& temp=arr_vEVlsJt[WmftXku].get_object();
            deserialize_struct(temp,pCounters[WmftXku]);
            }();
        }
        }();
[&](){
            if (json["pCounterDescriptions"].get_array().size()==0){
                pCounterDescriptions=NULL;
            return; }
        auto& arr_znRZkzO=json["pCounterDescriptions"].get_array();
        for(int GjxogPx=0; GjxogPx < *pCounterCount; GjxogPx++){
            [&](){
            auto& temp=arr_znRZkzO[GjxogPx].get_object();
            deserialize_struct(temp,pCounterDescriptions[GjxogPx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_iuXpjxQ;[&](){
            if (json["result"].is_uint64()){
                temp_iuXpjxQ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_iuXpjxQ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_iuXpjxQ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_iuXpjxQ;}();}();

debug_printf("Ending vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR...\n");
debug_printf("Return value of vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR( VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPerformanceQueryCreateInfo==NULL){
                json["pPerformanceQueryCreateInfo"]=boost::json::array();
            return; }json["pPerformanceQueryCreateInfo"]=boost::json::array(1);
        auto& arr_HfbrSJi=json["pPerformanceQueryCreateInfo"].get_array();
        for(int aEYwfht=0; aEYwfht < 1; aEYwfht++){
            [&](){
            auto& temp=arr_HfbrSJi[aEYwfht].emplace_object();
            return serialize_struct(temp, pPerformanceQueryCreateInfo[aEYwfht]);
            }();
        }
        }();
[&](){
            if (pNumPasses==NULL){
                json["pNumPasses"]=boost::json::array();
            return; }json["pNumPasses"]=boost::json::array(1);
        auto& arr_QgclfwI=json["pNumPasses"].get_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){arr_QgclfwI[vyixxEg]=pNumPasses[vyixxEg];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pNumPasses"].get_array().size()==0){
                pNumPasses=NULL;
            return; }
        auto& arr_QgclfwI=json["pNumPasses"].get_array();
        for(int vyixxEg=0; vyixxEg < 1; vyixxEg++){
            [&](){
            if (arr_QgclfwI[vyixxEg].is_uint64()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_uint64());
            }else if (arr_QgclfwI[vyixxEg].is_int64()){
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_int64());
            }else{
                pNumPasses[vyixxEg]=static_cast<uint32_t>(arr_QgclfwI[vyixxEg].get_double());
            }
            }();
        }
        }();

debug_printf("Ending vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireProfilingLockKHR( VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkAcquireProfilingLockKHR\n");

    boost::json::object json;
    json["stream_type"]=VKACQUIREPROFILINGLOCKKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_BslWEPE=json["pInfo"].get_array();
        for(int ZgSmBLm=0; ZgSmBLm < 1; ZgSmBLm++){
            [&](){
            auto& temp=arr_BslWEPE[ZgSmBLm].emplace_object();
            return serialize_struct(temp, pInfo[ZgSmBLm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_Proylyu;[&](){
            if (json["result"].is_uint64()){
                temp_Proylyu=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_Proylyu=static_cast<int>(json["result"].get_int64());
            }else{
                temp_Proylyu=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_Proylyu;}();}();

debug_printf("Ending vkAcquireProfilingLockKHR...\n");
debug_printf("Return value of vkAcquireProfilingLockKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkReleaseProfilingLockKHR( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkReleaseProfilingLockKHR\n");

    boost::json::object json;
    json["stream_type"]=VKRELEASEPROFILINGLOCKKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPROFILINGLOCKKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkReleaseProfilingLockKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageDrmFormatModifierPropertiesEXT( VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetImageDrmFormatModifierPropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_oxSUmzu=json["pProperties"].get_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].emplace_object();
            return serialize_struct(temp, pProperties[JPWNMan]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEDRMFORMATMODIFIERPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_oxSUmzu=json["pProperties"].get_array();
        for(int JPWNMan=0; JPWNMan < 1; JPWNMan++){
            [&](){
            auto& temp=arr_oxSUmzu[JPWNMan].get_object();
            deserialize_struct(temp,pProperties[JPWNMan]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_BityiSk;[&](){
            if (json["result"].is_uint64()){
                temp_BityiSk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_BityiSk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_BityiSk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_BityiSk;}();}();

debug_printf("Ending vkGetImageDrmFormatModifierPropertiesEXT...\n");
debug_printf("Return value of vkGetImageDrmFormatModifierPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureAddress\n");

    boost::json::object json;
    json["stream_type"]=VKGETBUFFEROPAQUECAPTUREADDRESS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LRSftdl=json["pInfo"].get_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){
            if (json["result"].is_uint64()){
                result=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                result=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                result=static_cast<uint64_t>(json["result"].get_double());
            }
            }();

debug_printf("Ending vkGetBufferOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetBufferOpaqueCaptureAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddress( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetBufferDeviceAddress\n");

    boost::json::object json;
    json["stream_type"]=VKGETBUFFERDEVICEADDRESS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_LRSftdl=json["pInfo"].get_array();
        for(int CPHfQOs=0; CPHfQOs < 1; CPHfQOs++){
            [&](){
            auto& temp=arr_LRSftdl[CPHfQOs].emplace_object();
            return serialize_struct(temp, pInfo[CPHfQOs]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFERDEVICEADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_qUAUGbq;[&](){
            if (json["result"].is_uint64()){
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                temp_qUAUGbq=static_cast<uint64_t>(json["result"].get_double());
            }
            }();result=(VkDeviceAddress)temp_qUAUGbq;}();

debug_printf("Ending vkGetBufferDeviceAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressKHR( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetBufferDeviceAddressEXT( VkDevice device, const VkBufferDeviceAddressInfo* pInfo ){
return vkGetBufferDeviceAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateHeadlessSurfaceEXT( VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface ){
//Will only be called by the client
debug_printf("Executing vkCreateHeadlessSurfaceEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEHEADLESSSURFACEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)instance];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkInstance(json["instance"],instance);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_yHbnuDf=json["pCreateInfo"].get_array();
        for(int CyHXDmy=0; CyHXDmy < 1; CyHXDmy++){
            [&](){
            auto& temp=arr_yHbnuDf[CyHXDmy].emplace_object();
            return serialize_struct(temp, pCreateInfo[CyHXDmy]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSurface==NULL){
                json["pSurface"]=boost::json::array();
            return; }json["pSurface"]=boost::json::array(1);
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){serialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH],pSurface[tOvHdjH]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEHEADLESSSURFACEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkInstance(json["instance"], instance);}();


[&](){
            if (json["pSurface"].get_array().size()==0){
                pSurface=NULL;
            return; }
        auto& arr_zGtWguc=json["pSurface"].get_array();
        for(int tOvHdjH=0; tOvHdjH < 1; tOvHdjH++){
            [&](){deserialize_VkSurfaceKHR(arr_zGtWguc[tOvHdjH], pSurface[tOvHdjH]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_TzZyHWk;[&](){
            if (json["result"].is_uint64()){
                temp_TzZyHWk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TzZyHWk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_TzZyHWk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_TzZyHWk;}();}();

                if (pSurface!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSurface[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateHeadlessSurfaceEXT...\n");
debug_printf("Return value of vkCreateHeadlessSurfaceEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV( VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pCombinationCount==NULL){
                json["pCombinationCount"]=boost::json::array();
            return; }json["pCombinationCount"]=boost::json::array(1);
        auto& arr_VrJxAqY=json["pCombinationCount"].get_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){arr_VrJxAqY[jKkiHUO]=pCombinationCount[jKkiHUO];}();
        }
        }();
[&](){
            if (pCombinations==NULL){
                json["pCombinations"]=boost::json::array();
            return; }json["pCombinations"]=boost::json::array(*pCombinationCount);
        auto& arr_aOIaDFM=json["pCombinations"].get_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].emplace_object();
            return serialize_struct(temp, pCombinations[oxJqbjP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pCombinationCount"].get_array().size()==0){
                pCombinationCount=NULL;
            return; }
        auto& arr_VrJxAqY=json["pCombinationCount"].get_array();
        for(int jKkiHUO=0; jKkiHUO < 1; jKkiHUO++){
            [&](){
            if (arr_VrJxAqY[jKkiHUO].is_uint64()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_uint64());
            }else if (arr_VrJxAqY[jKkiHUO].is_int64()){
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_int64());
            }else{
                pCombinationCount[jKkiHUO]=static_cast<uint32_t>(arr_VrJxAqY[jKkiHUO].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCombinations"].get_array().size()==0){
                pCombinations=NULL;
            return; }
        auto& arr_aOIaDFM=json["pCombinations"].get_array();
        for(int oxJqbjP=0; oxJqbjP < *pCombinationCount; oxJqbjP++){
            [&](){
            auto& temp=arr_aOIaDFM[oxJqbjP].get_object();
            deserialize_struct(temp,pCombinations[oxJqbjP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_yOeKofu;[&](){
            if (json["result"].is_uint64()){
                temp_yOeKofu=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yOeKofu=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yOeKofu=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yOeKofu;}();}();

debug_printf("Ending vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkInitializePerformanceApiINTEL( VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo ){
//Will only be called by the client
debug_printf("Executing vkInitializePerformanceApiINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKINITIALIZEPERFORMANCEAPIINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInitializeInfo==NULL){
                json["pInitializeInfo"]=boost::json::array();
            return; }json["pInitializeInfo"]=boost::json::array(1);
        auto& arr_BGIuPda=json["pInitializeInfo"].get_array();
        for(int pMSNyrD=0; pMSNyrD < 1; pMSNyrD++){
            [&](){
            auto& temp=arr_BGIuPda[pMSNyrD].emplace_object();
            return serialize_struct(temp, pInitializeInfo[pMSNyrD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_giEXhKW;[&](){
            if (json["result"].is_uint64()){
                temp_giEXhKW=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_giEXhKW=static_cast<int>(json["result"].get_int64());
            }else{
                temp_giEXhKW=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_giEXhKW;}();}();

debug_printf("Ending vkInitializePerformanceApiINTEL...\n");
debug_printf("Return value of vkInitializePerformanceApiINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkUninitializePerformanceApiINTEL( VkDevice device ){
//Will only be called by the client
debug_printf("Executing vkUninitializePerformanceApiINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKUNINITIALIZEPERFORMANCEAPIINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNINITIALIZEPERFORMANCEAPIINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

debug_printf("Ending vkUninitializePerformanceApiINTEL...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceMarkerINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPERFORMANCEMARKERINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_jnuNlGq=json["pMarkerInfo"].get_array();
        for(int zTzAESc=0; zTzAESc < 1; zTzAESc++){
            [&](){
            auto& temp=arr_jnuNlGq[zTzAESc].emplace_object();
            return serialize_struct(temp, pMarkerInfo[zTzAESc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_xYiZXdw;[&](){
            if (json["result"].is_uint64()){
                temp_xYiZXdw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_xYiZXdw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_xYiZXdw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_xYiZXdw;}();}();

debug_printf("Ending vkCmdSetPerformanceMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceStreamMarkerINTEL( VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceStreamMarkerINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPERFORMANCESTREAMMARKERINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pMarkerInfo==NULL){
                json["pMarkerInfo"]=boost::json::array();
            return; }json["pMarkerInfo"]=boost::json::array(1);
        auto& arr_MVQnSpz=json["pMarkerInfo"].get_array();
        for(int xfSMHfo=0; xfSMHfo < 1; xfSMHfo++){
            [&](){
            auto& temp=arr_MVQnSpz[xfSMHfo].emplace_object();
            return serialize_struct(temp, pMarkerInfo[xfSMHfo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCESTREAMMARKERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_icTHZCa;[&](){
            if (json["result"].is_uint64()){
                temp_icTHZCa=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_icTHZCa=static_cast<int>(json["result"].get_int64());
            }else{
                temp_icTHZCa=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_icTHZCa;}();}();

debug_printf("Ending vkCmdSetPerformanceStreamMarkerINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceStreamMarkerINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCmdSetPerformanceOverrideINTEL( VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPerformanceOverrideINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPERFORMANCEOVERRIDEINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pOverrideInfo==NULL){
                json["pOverrideInfo"]=boost::json::array();
            return; }json["pOverrideInfo"]=boost::json::array(1);
        auto& arr_LHSFuEM=json["pOverrideInfo"].get_array();
        for(int KZSCUHM=0; KZSCUHM < 1; KZSCUHM++){
            [&](){
            auto& temp=arr_LHSFuEM[KZSCUHM].emplace_object();
            return serialize_struct(temp, pOverrideInfo[KZSCUHM]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPERFORMANCEOVERRIDEINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

VkResult result;
[&](){[&](){int temp_kyUAzJJ;[&](){
            if (json["result"].is_uint64()){
                temp_kyUAzJJ=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_kyUAzJJ=static_cast<int>(json["result"].get_int64());
            }else{
                temp_kyUAzJJ=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_kyUAzJJ;}();}();

debug_printf("Ending vkCmdSetPerformanceOverrideINTEL...\n");
debug_printf("Return value of vkCmdSetPerformanceOverrideINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkAcquirePerformanceConfigurationINTEL( VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration ){
//Will only be called by the client
debug_printf("Executing vkAcquirePerformanceConfigurationINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKACQUIREPERFORMANCECONFIGURATIONINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAcquireInfo==NULL){
                json["pAcquireInfo"]=boost::json::array();
            return; }json["pAcquireInfo"]=boost::json::array(1);
        auto& arr_ZyqvvlF=json["pAcquireInfo"].get_array();
        for(int RYEcOAO=0; RYEcOAO < 1; RYEcOAO++){
            [&](){
            auto& temp=arr_ZyqvvlF[RYEcOAO].emplace_object();
            return serialize_struct(temp, pAcquireInfo[RYEcOAO]);
            }();
        }
        }();
[&](){
            if (pConfiguration==NULL){
                json["pConfiguration"]=boost::json::array();
            return; }json["pConfiguration"]=boost::json::array(1);
        auto& arr_zSRZrDS=json["pConfiguration"].get_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){serialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA],pConfiguration[MTgkTDA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pConfiguration"].get_array().size()==0){
                pConfiguration=NULL;
            return; }
        auto& arr_zSRZrDS=json["pConfiguration"].get_array();
        for(int MTgkTDA=0; MTgkTDA < 1; MTgkTDA++){
            [&](){deserialize_VkPerformanceConfigurationINTEL(arr_zSRZrDS[MTgkTDA], pConfiguration[MTgkTDA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_AsKhKBD;[&](){
            if (json["result"].is_uint64()){
                temp_AsKhKBD=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_AsKhKBD=static_cast<int>(json["result"].get_int64());
            }else{
                temp_AsKhKBD=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_AsKhKBD;}();}();

debug_printf("Ending vkAcquirePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkAcquirePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkReleasePerformanceConfigurationINTEL( VkDevice device, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkReleasePerformanceConfigurationINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKRELEASEPERFORMANCECONFIGURATIONINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASEPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_ZlGbunc;[&](){
            if (json["result"].is_uint64()){
                temp_ZlGbunc=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZlGbunc=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZlGbunc=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZlGbunc;}();}();

debug_printf("Ending vkReleasePerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkReleasePerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSetPerformanceConfigurationINTEL( VkQueue queue, VkPerformanceConfigurationINTEL configuration ){
//Will only be called by the client
debug_printf("Executing vkQueueSetPerformanceConfigurationINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUESETPERFORMANCECONFIGURATIONINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){serialize_VkPerformanceConfigurationINTEL(json["configuration"],configuration);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESETPERFORMANCECONFIGURATIONINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){deserialize_VkPerformanceConfigurationINTEL(json["configuration"], configuration);}();
VkResult result;
[&](){[&](){int temp_jsqfGAY;[&](){
            if (json["result"].is_uint64()){
                temp_jsqfGAY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_jsqfGAY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_jsqfGAY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_jsqfGAY;}();}();

debug_printf("Ending vkQueueSetPerformanceConfigurationINTEL...\n");
debug_printf("Return value of vkQueueSetPerformanceConfigurationINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPerformanceParameterINTEL( VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue ){
//Will only be called by the client
debug_printf("Executing vkGetPerformanceParameterINTEL\n");

    boost::json::object json;
    json["stream_type"]=VKGETPERFORMANCEPARAMETERINTEL;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["parameter"]=parameter;}();}();}();
[&](){
            if (pValue==NULL){
                json["pValue"]=boost::json::array();
            return; }json["pValue"]=boost::json::array(1);
        auto& arr_hOmaGpc=json["pValue"].get_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].emplace_object();
            return serialize_struct(temp, pValue[lyxuUNd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPERFORMANCEPARAMETERINTEL):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_TQususa;[&](){
            if (json["parameter"].is_uint64()){
                temp_TQususa=static_cast<int>(json["parameter"].get_uint64());
            }else if (json["parameter"].is_int64()){
                temp_TQususa=static_cast<int>(json["parameter"].get_int64());
            }else{
                temp_TQususa=static_cast<int>(json["parameter"].get_double());
            }
            }();parameter=(VkPerformanceParameterTypeINTEL)temp_TQususa;}();}();
[&](){
            if (json["pValue"].get_array().size()==0){
                pValue=NULL;
            return; }
        auto& arr_hOmaGpc=json["pValue"].get_array();
        for(int lyxuUNd=0; lyxuUNd < 1; lyxuUNd++){
            [&](){
            auto& temp=arr_hOmaGpc[lyxuUNd].get_object();
            deserialize_struct(temp,pValue[lyxuUNd]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_AOHjoLz;[&](){
            if (json["result"].is_uint64()){
                temp_AOHjoLz=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_AOHjoLz=static_cast<int>(json["result"].get_int64());
            }else{
                temp_AOHjoLz=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_AOHjoLz;}();}();

debug_printf("Ending vkGetPerformanceParameterINTEL...\n");
debug_printf("Return value of vkGetPerformanceParameterINTEL is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddress( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMemoryOpaqueCaptureAddress\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_hjweGct=json["pInfo"].get_array();
        for(int vcZpbuB=0; vcZpbuB < 1; vcZpbuB++){
            [&](){
            auto& temp=arr_hjweGct[vcZpbuB].emplace_object();
            return serialize_struct(temp, pInfo[vcZpbuB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMEMORYOPAQUECAPTUREADDRESS):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

uint64_t result;
[&](){
            if (json["result"].is_uint64()){
                result=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                result=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                result=static_cast<uint64_t>(json["result"].get_double());
            }
            }();

debug_printf("Ending vkGetDeviceMemoryOpaqueCaptureAddress...\n");
return result;
}
__attribute__((visibility ("hidden"))) uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR( VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo ){
return vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutablePropertiesKHR( VkDevice device, const VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutablePropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEEXECUTABLEPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }json["pPipelineInfo"]=boost::json::array(1);
        auto& arr_SxuxUqw=json["pPipelineInfo"].get_array();
        for(int mwoMxRp=0; mwoMxRp < 1; mwoMxRp++){
            [&](){
            auto& temp=arr_SxuxUqw[mwoMxRp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[mwoMxRp]);
            }();
        }
        }();
[&](){
            if (pExecutableCount==NULL){
                json["pExecutableCount"]=boost::json::array();
            return; }json["pExecutableCount"]=boost::json::array(1);
        auto& arr_tlXPSPh=json["pExecutableCount"].get_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){arr_tlXPSPh[ZFmbkCm]=pExecutableCount[ZFmbkCm];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pExecutableCount);
        auto& arr_vtfdUfF=json["pProperties"].get_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].emplace_object();
            return serialize_struct(temp, pProperties[uPFqrVz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pExecutableCount"].get_array().size()==0){
                pExecutableCount=NULL;
            return; }
        auto& arr_tlXPSPh=json["pExecutableCount"].get_array();
        for(int ZFmbkCm=0; ZFmbkCm < 1; ZFmbkCm++){
            [&](){
            if (arr_tlXPSPh[ZFmbkCm].is_uint64()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_uint64());
            }else if (arr_tlXPSPh[ZFmbkCm].is_int64()){
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_int64());
            }else{
                pExecutableCount[ZFmbkCm]=static_cast<uint32_t>(arr_tlXPSPh[ZFmbkCm].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_vtfdUfF=json["pProperties"].get_array();
        for(int uPFqrVz=0; uPFqrVz < *pExecutableCount; uPFqrVz++){
            [&](){
            auto& temp=arr_vtfdUfF[uPFqrVz].get_object();
            deserialize_struct(temp,pProperties[uPFqrVz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bmoAfmd;[&](){
            if (json["result"].is_uint64()){
                temp_bmoAfmd=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_bmoAfmd=static_cast<int>(json["result"].get_int64());
            }else{
                temp_bmoAfmd=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_bmoAfmd;}();}();

debug_printf("Ending vkGetPipelineExecutablePropertiesKHR...\n");
debug_printf("Return value of vkGetPipelineExecutablePropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableStatisticsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableStatisticsKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEEXECUTABLESTATISTICSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }json["pExecutableInfo"]=boost::json::array(1);
        auto& arr_xbHlsCc=json["pExecutableInfo"].get_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pStatisticCount==NULL){
                json["pStatisticCount"]=boost::json::array();
            return; }json["pStatisticCount"]=boost::json::array(1);
        auto& arr_BIkbvee=json["pStatisticCount"].get_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){arr_BIkbvee[MiieuSo]=pStatisticCount[MiieuSo];}();
        }
        }();
[&](){
            if (pStatistics==NULL){
                json["pStatistics"]=boost::json::array();
            return; }json["pStatistics"]=boost::json::array(*pStatisticCount);
        auto& arr_cGybyJf=json["pStatistics"].get_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].emplace_object();
            return serialize_struct(temp, pStatistics[ktSOZGx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLESTATISTICSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pStatisticCount"].get_array().size()==0){
                pStatisticCount=NULL;
            return; }
        auto& arr_BIkbvee=json["pStatisticCount"].get_array();
        for(int MiieuSo=0; MiieuSo < 1; MiieuSo++){
            [&](){
            if (arr_BIkbvee[MiieuSo].is_uint64()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_uint64());
            }else if (arr_BIkbvee[MiieuSo].is_int64()){
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_int64());
            }else{
                pStatisticCount[MiieuSo]=static_cast<uint32_t>(arr_BIkbvee[MiieuSo].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pStatistics"].get_array().size()==0){
                pStatistics=NULL;
            return; }
        auto& arr_cGybyJf=json["pStatistics"].get_array();
        for(int ktSOZGx=0; ktSOZGx < *pStatisticCount; ktSOZGx++){
            [&](){
            auto& temp=arr_cGybyJf[ktSOZGx].get_object();
            deserialize_struct(temp,pStatistics[ktSOZGx]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tgNgnbg;[&](){
            if (json["result"].is_uint64()){
                temp_tgNgnbg=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_tgNgnbg=static_cast<int>(json["result"].get_int64());
            }else{
                temp_tgNgnbg=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_tgNgnbg;}();}();

debug_printf("Ending vkGetPipelineExecutableStatisticsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableStatisticsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelineExecutableInternalRepresentationsKHR( VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineExecutableInternalRepresentationsKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pExecutableInfo==NULL){
                json["pExecutableInfo"]=boost::json::array();
            return; }json["pExecutableInfo"]=boost::json::array(1);
        auto& arr_xbHlsCc=json["pExecutableInfo"].get_array();
        for(int JTDfcCv=0; JTDfcCv < 1; JTDfcCv++){
            [&](){
            auto& temp=arr_xbHlsCc[JTDfcCv].emplace_object();
            return serialize_struct(temp, pExecutableInfo[JTDfcCv]);
            }();
        }
        }();
[&](){
            if (pInternalRepresentationCount==NULL){
                json["pInternalRepresentationCount"]=boost::json::array();
            return; }json["pInternalRepresentationCount"]=boost::json::array(1);
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].get_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){arr_bVgggzH[urjNjhc]=pInternalRepresentationCount[urjNjhc];}();
        }
        }();
[&](){
            if (pInternalRepresentations==NULL){
                json["pInternalRepresentations"]=boost::json::array();
            return; }json["pInternalRepresentations"]=boost::json::array(*pInternalRepresentationCount);
        auto& arr_yqajgdo=json["pInternalRepresentations"].get_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].emplace_object();
            return serialize_struct(temp, pInternalRepresentations[OdpgULc]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pInternalRepresentationCount"].get_array().size()==0){
                pInternalRepresentationCount=NULL;
            return; }
        auto& arr_bVgggzH=json["pInternalRepresentationCount"].get_array();
        for(int urjNjhc=0; urjNjhc < 1; urjNjhc++){
            [&](){
            if (arr_bVgggzH[urjNjhc].is_uint64()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_uint64());
            }else if (arr_bVgggzH[urjNjhc].is_int64()){
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_int64());
            }else{
                pInternalRepresentationCount[urjNjhc]=static_cast<uint32_t>(arr_bVgggzH[urjNjhc].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pInternalRepresentations"].get_array().size()==0){
                pInternalRepresentations=NULL;
            return; }
        auto& arr_yqajgdo=json["pInternalRepresentations"].get_array();
        for(int OdpgULc=0; OdpgULc < *pInternalRepresentationCount; OdpgULc++){
            [&](){
            auto& temp=arr_yqajgdo[OdpgULc].get_object();
            deserialize_struct(temp,pInternalRepresentations[OdpgULc]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_ZbFBqRu;[&](){
            if (json["result"].is_uint64()){
                temp_ZbFBqRu=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ZbFBqRu=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ZbFBqRu=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ZbFBqRu;}();}();

debug_printf("Ending vkGetPipelineExecutableInternalRepresentationsKHR...\n");
debug_printf("Return value of vkGetPipelineExecutableInternalRepresentationsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEXT( VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLINESTIPPLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["lineStippleFactor"]=lineStippleFactor;}();
[&](){json["lineStipplePattern"]=lineStipplePattern;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["lineStippleFactor"].is_uint64()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_uint64());
            }else if (json["lineStippleFactor"].is_int64()){
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_int64());
            }else{
                lineStippleFactor=static_cast<uint32_t>(json["lineStippleFactor"].get_double());
            }
            }();
[&](){
            if (json["lineStipplePattern"].is_uint64()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_uint64());
            }else if (json["lineStipplePattern"].is_int64()){
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_int64());
            }else{
                lineStipplePattern=static_cast<uint16_t>(json["lineStipplePattern"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetLineStippleEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolProperties( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceToolProperties\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICETOOLPROPERTIES;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pToolCount==NULL){
                json["pToolCount"]=boost::json::array();
            return; }json["pToolCount"]=boost::json::array(1);
        auto& arr_PNAKwfC=json["pToolCount"].get_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){arr_PNAKwfC[iRGIIgT]=pToolCount[iRGIIgT];}();
        }
        }();
[&](){
            if (pToolProperties==NULL){
                json["pToolProperties"]=boost::json::array();
            return; }json["pToolProperties"]=boost::json::array(*pToolCount);
        auto& arr_OYowiCQ=json["pToolProperties"].get_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].emplace_object();
            return serialize_struct(temp, pToolProperties[dlPXJcQ]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICETOOLPROPERTIES):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pToolCount"].get_array().size()==0){
                pToolCount=NULL;
            return; }
        auto& arr_PNAKwfC=json["pToolCount"].get_array();
        for(int iRGIIgT=0; iRGIIgT < 1; iRGIIgT++){
            [&](){
            if (arr_PNAKwfC[iRGIIgT].is_uint64()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_uint64());
            }else if (arr_PNAKwfC[iRGIIgT].is_int64()){
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_int64());
            }else{
                pToolCount[iRGIIgT]=static_cast<uint32_t>(arr_PNAKwfC[iRGIIgT].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pToolProperties"].get_array().size()==0){
                pToolProperties=NULL;
            return; }
        auto& arr_OYowiCQ=json["pToolProperties"].get_array();
        for(int dlPXJcQ=0; dlPXJcQ < *pToolCount; dlPXJcQ++){
            [&](){
            auto& temp=arr_OYowiCQ[dlPXJcQ].get_object();
            deserialize_struct(temp,pToolProperties[dlPXJcQ]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_quwAQvB;[&](){
            if (json["result"].is_uint64()){
                temp_quwAQvB=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_quwAQvB=static_cast<int>(json["result"].get_int64());
            }else{
                temp_quwAQvB=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_quwAQvB;}();}();

debug_printf("Ending vkGetPhysicalDeviceToolProperties...\n");
debug_printf("Return value of vkGetPhysicalDeviceToolProperties is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceToolPropertiesEXT( VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties ){
return vkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
}
__attribute__((visibility ("hidden"))) VkResult vkCreateAccelerationStructureKHR( VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure ){
//Will only be called by the client
debug_printf("Executing vkCreateAccelerationStructureKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEACCELERATIONSTRUCTUREKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XoURuCS=json["pCreateInfo"].get_array();
        for(int bGUDBRC=0; bGUDBRC < 1; bGUDBRC++){
            [&](){
            auto& temp=arr_XoURuCS[bGUDBRC].emplace_object();
            return serialize_struct(temp, pCreateInfo[bGUDBRC]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pAccelerationStructure==NULL){
                json["pAccelerationStructure"]=boost::json::array();
            return; }json["pAccelerationStructure"]=boost::json::array(1);
        auto& arr_vKbZGTA=json["pAccelerationStructure"].get_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){serialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb],pAccelerationStructure[YRzkUOb]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEACCELERATIONSTRUCTUREKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pAccelerationStructure"].get_array().size()==0){
                pAccelerationStructure=NULL;
            return; }
        auto& arr_vKbZGTA=json["pAccelerationStructure"].get_array();
        for(int YRzkUOb=0; YRzkUOb < 1; YRzkUOb++){
            [&](){deserialize_VkAccelerationStructureKHR(arr_vKbZGTA[YRzkUOb], pAccelerationStructure[YRzkUOb]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_xpTclnw;[&](){
            if (json["result"].is_uint64()){
                temp_xpTclnw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_xpTclnw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_xpTclnw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_xpTclnw;}();}();

                if (pAccelerationStructure!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pAccelerationStructure[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateAccelerationStructureKHR...\n");
debug_printf("Return value of vkCreateAccelerationStructureKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }json["ppBuildRangeInfos"]=boost::json::array(1);
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].get_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }arr_FMxYLmq[CRaOjpb]=boost::json::array(infoCount);
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].get_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdBuildAccelerationStructuresKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBuildAccelerationStructuresIndirectKHR( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildAccelerationStructuresIndirectKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (pIndirectDeviceAddresses==NULL){
                json["pIndirectDeviceAddresses"]=boost::json::array();
            return; }json["pIndirectDeviceAddresses"]=boost::json::array(infoCount);
        auto& arr_YkBEqzj=json["pIndirectDeviceAddresses"].get_array();
        for(int tMAuxlx=0; tMAuxlx < infoCount; tMAuxlx++){
            [&](){[&](){arr_YkBEqzj[tMAuxlx]=pIndirectDeviceAddresses[tMAuxlx];}();}();
        }
        }();
[&](){
            if (pIndirectStrides==NULL){
                json["pIndirectStrides"]=boost::json::array();
            return; }json["pIndirectStrides"]=boost::json::array(infoCount);
        auto& arr_Helprzq=json["pIndirectStrides"].get_array();
        for(int IXUUYlr=0; IXUUYlr < infoCount; IXUUYlr++){
            [&](){arr_Helprzq[IXUUYlr]=pIndirectStrides[IXUUYlr];}();
        }
        }();
[&](){
            if (ppMaxPrimitiveCounts==NULL){
                json["ppMaxPrimitiveCounts"]=boost::json::array();
            return; }json["ppMaxPrimitiveCounts"]=boost::json::array(1);
        auto& arr_DfsqJWs=json["ppMaxPrimitiveCounts"].get_array();
        for(int TyNkaSn=0; TyNkaSn < 1; TyNkaSn++){
            [&](){
            if (ppMaxPrimitiveCounts[TyNkaSn]==NULL){
                arr_DfsqJWs[TyNkaSn]=boost::json::array();
            return; }arr_DfsqJWs[TyNkaSn]=boost::json::array(infoCount);
        auto& arr_kfQrDXL=arr_DfsqJWs[TyNkaSn].get_array();
        for(int SABezVP=0; SABezVP < infoCount; SABezVP++){
            [&](){arr_kfQrDXL[SABezVP]=ppMaxPrimitiveCounts[TyNkaSn][SABezVP];}();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();





debug_printf("Ending vkCmdBuildAccelerationStructuresIndirectKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildAccelerationStructuresKHR( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildAccelerationStructuresKHR\n");

    boost::json::object json;
    json["stream_type"]=VKBUILDACCELERATIONSTRUCTURESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_lswJvjt=json["pInfos"].get_array();
        for(int frdaizU=0; frdaizU < infoCount; frdaizU++){
            [&](){
            auto& temp=arr_lswJvjt[frdaizU].emplace_object();
            return serialize_struct(temp, pInfos[frdaizU]);
            }();
        }
        }();
[&](){
            if (ppBuildRangeInfos==NULL){
                json["ppBuildRangeInfos"]=boost::json::array();
            return; }json["ppBuildRangeInfos"]=boost::json::array(1);
        auto& arr_FMxYLmq=json["ppBuildRangeInfos"].get_array();
        for(int CRaOjpb=0; CRaOjpb < 1; CRaOjpb++){
            [&](){
            if (ppBuildRangeInfos[CRaOjpb]==NULL){
                arr_FMxYLmq[CRaOjpb]=boost::json::array();
            return; }arr_FMxYLmq[CRaOjpb]=boost::json::array(infoCount);
        auto& arr_PKxEvVS=arr_FMxYLmq[CRaOjpb].get_array();
        for(int IUJrDJF=0; IUJrDJF < infoCount; IUJrDJF++){
            [&](){
            auto& temp=arr_PKxEvVS[IUJrDJF].emplace_object();
            return serialize_struct(temp, ppBuildRangeInfos[CRaOjpb][IUJrDJF]);
            }();
        }
        }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDACCELERATIONSTRUCTURESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();


VkResult result;
[&](){[&](){int temp_jDxtCth;[&](){
            if (json["result"].is_uint64()){
                temp_jDxtCth=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_jDxtCth=static_cast<int>(json["result"].get_int64());
            }else{
                temp_jDxtCth=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_jDxtCth;}();}();

debug_printf("Ending vkBuildAccelerationStructuresKHR...\n");
debug_printf("Return value of vkBuildAccelerationStructuresKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetAccelerationStructureDeviceAddressKHR( VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureDeviceAddressKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_CAfLmMn=json["pInfo"].get_array();
        for(int DozYfEa=0; DozYfEa < 1; DozYfEa++){
            [&](){
            auto& temp=arr_CAfLmMn[DozYfEa].emplace_object();
            return serialize_struct(temp, pInfo[DozYfEa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREDEVICEADDRESSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_TsXKzrv;[&](){
            if (json["result"].is_uint64()){
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                temp_TsXKzrv=static_cast<uint64_t>(json["result"].get_double());
            }
            }();result=(VkDeviceAddress)temp_TsXKzrv;}();

debug_printf("Ending vkGetAccelerationStructureDeviceAddressKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateDeferredOperationKHR( VkDevice device, const VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation ){
//Will only be called by the client
debug_printf("Executing vkCreateDeferredOperationKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEDEFERREDOPERATIONKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pDeferredOperation==NULL){
                json["pDeferredOperation"]=boost::json::array();
            return; }json["pDeferredOperation"]=boost::json::array(1);
        auto& arr_fPVilHH=json["pDeferredOperation"].get_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){serialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX],pDeferredOperation[BrrtHdX]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pDeferredOperation"].get_array().size()==0){
                pDeferredOperation=NULL;
            return; }
        auto& arr_fPVilHH=json["pDeferredOperation"].get_array();
        for(int BrrtHdX=0; BrrtHdX < 1; BrrtHdX++){
            [&](){deserialize_VkDeferredOperationKHR(arr_fPVilHH[BrrtHdX], pDeferredOperation[BrrtHdX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_LPzNqZx;[&](){
            if (json["result"].is_uint64()){
                temp_LPzNqZx=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LPzNqZx=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LPzNqZx=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LPzNqZx;}();}();

                if (pDeferredOperation!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pDeferredOperation[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateDeferredOperationKHR...\n");
debug_printf("Return value of vkCreateDeferredOperationKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyDeferredOperationKHR( VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyDeferredOperationKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYDEFERREDOPERATIONKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYDEFERREDOPERATIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();


debug_printf("Ending vkDestroyDeferredOperationKHR...\n");
}
__attribute__((visibility ("hidden"))) uint32_t vkGetDeferredOperationMaxConcurrencyKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationMaxConcurrencyKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONMAXCONCURRENCYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
uint32_t result;
[&](){
            if (json["result"].is_uint64()){
                result=static_cast<uint32_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                result=static_cast<uint32_t>(json["result"].get_int64());
            }else{
                result=static_cast<uint32_t>(json["result"].get_double());
            }
            }();

debug_printf("Ending vkGetDeferredOperationMaxConcurrencyKHR...\n");
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeferredOperationResultKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkGetDeferredOperationResultKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEFERREDOPERATIONRESULTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEFERREDOPERATIONRESULTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_WGAgFkU;[&](){
            if (json["result"].is_uint64()){
                temp_WGAgFkU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_WGAgFkU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_WGAgFkU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_WGAgFkU;}();}();

debug_printf("Ending vkGetDeferredOperationResultKHR...\n");
debug_printf("Return value of vkGetDeferredOperationResultKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkDeferredOperationJoinKHR( VkDevice device, VkDeferredOperationKHR operation ){
//Will only be called by the client
debug_printf("Executing vkDeferredOperationJoinKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDEFERREDOPERATIONJOINKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["operation"],operation);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDEFERREDOPERATIONJOINKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["operation"], operation);}();
VkResult result;
[&](){[&](){int temp_DKlerev;[&](){
            if (json["result"].is_uint64()){
                temp_DKlerev=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_DKlerev=static_cast<int>(json["result"].get_int64());
            }else{
                temp_DKlerev=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_DKlerev;}();}();

debug_printf("Ending vkDeferredOperationJoinKHR...\n");
debug_printf("Return value of vkDeferredOperationJoinKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetPipelineIndirectMemoryRequirementsNV( VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectMemoryRequirementsNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XLStDVY=json["pCreateInfo"].get_array();
        for(int FoBxBjF=0; FoBxBjF < 1; FoBxBjF++){
            [&](){
            auto& temp=arr_XLStDVY[FoBxBjF].emplace_object();
            return serialize_struct(temp, pCreateInfo[FoBxBjF]);
            }();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(1);
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTMEMORYREQUIREMENTSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_ZIfZgsB=json["pMemoryRequirements"].get_array();
        for(int jKzQtoG=0; jKzQtoG < 1; jKzQtoG++){
            [&](){
            auto& temp=arr_ZIfZgsB[jKzQtoG].get_object();
            deserialize_struct(temp,pMemoryRequirements[jKzQtoG]);
            }();
        }
        }();

debug_printf("Ending vkGetPipelineIndirectMemoryRequirementsNV...\n");
}
__attribute__((visibility ("hidden"))) VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV( VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo ){
//Will only be called by the client
debug_printf("Executing vkGetPipelineIndirectDeviceAddressNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEINDIRECTDEVICEADDRESSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_iNXSdlN=json["pInfo"].get_array();
        for(int EeNdDDD=0; EeNdDDD < 1; EeNdDDD++){
            [&](){
            auto& temp=arr_iNXSdlN[EeNdDDD].emplace_object();
            return serialize_struct(temp, pInfo[EeNdDDD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEINDIRECTDEVICEADDRESSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkDeviceAddress result;
[&](){uint64_t temp_FNTHIwh;[&](){
            if (json["result"].is_uint64()){
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].get_int64());
            }else{
                temp_FNTHIwh=static_cast<uint64_t>(json["result"].get_double());
            }
            }();result=(VkDeviceAddress)temp_FNTHIwh;}();

debug_printf("Ending vkGetPipelineIndirectDeviceAddressNV...\n");
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullMode( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCullMode\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCULLMODE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["cullMode"]=cullMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCULLMODE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_JocwJIC;[&](){
            if (json["cullMode"].is_uint64()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_uint64());
            }else if (json["cullMode"].is_int64()){
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_int64());
            }else{
                temp_JocwJIC=static_cast<int>(json["cullMode"].get_double());
            }
            }();cullMode=(VkCullModeFlags)temp_JocwJIC;}();}();

debug_printf("Ending vkCmdSetCullMode...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCullModeEXT( VkCommandBuffer commandBuffer, VkCullModeFlags cullMode ){
return vkCmdSetCullMode(commandBuffer, cullMode);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFace( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFrontFace\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETFRONTFACE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["frontFace"]=frontFace;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRONTFACE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_ZBubEzp;[&](){
            if (json["frontFace"].is_uint64()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_uint64());
            }else if (json["frontFace"].is_int64()){
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_int64());
            }else{
                temp_ZBubEzp=static_cast<int>(json["frontFace"].get_double());
            }
            }();frontFace=(VkFrontFace)temp_ZBubEzp;}();}();

debug_printf("Ending vkCmdSetFrontFace...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetFrontFaceEXT( VkCommandBuffer commandBuffer, VkFrontFace frontFace ){
return vkCmdSetFrontFace(commandBuffer, frontFace);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopology( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveTopology\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPRIMITIVETOPOLOGY;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["primitiveTopology"]=primitiveTopology;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVETOPOLOGY):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_jzAnfAA;[&](){
            if (json["primitiveTopology"].is_uint64()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_uint64());
            }else if (json["primitiveTopology"].is_int64()){
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_int64());
            }else{
                temp_jzAnfAA=static_cast<int>(json["primitiveTopology"].get_double());
            }
            }();primitiveTopology=(VkPrimitiveTopology)temp_jzAnfAA;}();}();

debug_printf("Ending vkCmdSetPrimitiveTopology...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveTopologyEXT( VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology ){
return vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCount( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWithCount\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORTWITHCOUNT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewports==NULL){
                json["pViewports"]=boost::json::array();
            return; }json["pViewports"]=boost::json::array(viewportCount);
        auto& arr_SyYryUE=json["pViewports"].get_array();
        for(int HAuJlzw=0; HAuJlzw < viewportCount; HAuJlzw++){
            [&](){
            auto& temp=arr_SyYryUE[HAuJlzw].emplace_object();
            return serialize_struct(temp, pViewports[HAuJlzw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWithCountEXT( VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports ){
return vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCount( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
//Will only be called by the client
debug_printf("Executing vkCmdSetScissorWithCount\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSCISSORWITHCOUNT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["scissorCount"]=scissorCount;}();
[&](){
            if (pScissors==NULL){
                json["pScissors"]=boost::json::array();
            return; }json["pScissors"]=boost::json::array(scissorCount);
        auto& arr_RpUaBcS=json["pScissors"].get_array();
        for(int XBYGvVT=0; XBYGvVT < scissorCount; XBYGvVT++){
            [&](){
            auto& temp=arr_RpUaBcS[XBYGvVT].emplace_object();
            return serialize_struct(temp, pScissors[XBYGvVT]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSCISSORWITHCOUNT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["scissorCount"].is_uint64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_uint64());
            }else if (json["scissorCount"].is_int64()){
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_int64());
            }else{
                scissorCount=static_cast<uint32_t>(json["scissorCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetScissorWithCount...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetScissorWithCountEXT( VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors ){
return vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
}
__attribute__((visibility ("hidden"))) void vkCmdBindIndexBuffer2KHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType ){
//Will only be called by the client
debug_printf("Executing vkCmdBindIndexBuffer2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDINDEXBUFFER2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkBuffer(json["buffer"],buffer);}();
[&](){[&](){json["offset"]=offset;}();}();
[&](){[&](){json["size"]=size;}();}();
[&](){[&](){[&](){json["indexType"]=indexType;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDINDEXBUFFER2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkBuffer(json["buffer"], buffer);}();
[&](){uint64_t temp_aceTSRc;[&](){
            if (json["offset"].is_uint64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_uint64());
            }else if (json["offset"].is_int64()){
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_int64());
            }else{
                temp_aceTSRc=static_cast<uint64_t>(json["offset"].get_double());
            }
            }();offset=(VkDeviceSize)temp_aceTSRc;}();
[&](){uint64_t temp_PlNcOBd;[&](){
            if (json["size"].is_uint64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_uint64());
            }else if (json["size"].is_int64()){
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_int64());
            }else{
                temp_PlNcOBd=static_cast<uint64_t>(json["size"].get_double());
            }
            }();size=(VkDeviceSize)temp_PlNcOBd;}();
[&](){[&](){int temp_GdrXdVh;[&](){
            if (json["indexType"].is_uint64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_uint64());
            }else if (json["indexType"].is_int64()){
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_int64());
            }else{
                temp_GdrXdVh=static_cast<int>(json["indexType"].get_double());
            }
            }();indexType=(VkIndexType)temp_GdrXdVh;}();}();

debug_printf("Ending vkCmdBindIndexBuffer2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
//Will only be called by the client
debug_printf("Executing vkCmdBindVertexBuffers2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDVERTEXBUFFERS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstBinding"]=firstBinding;}();
[&](){json["bindingCount"]=bindingCount;}();
[&](){
            if (pBuffers==NULL){
                json["pBuffers"]=boost::json::array();
            return; }json["pBuffers"]=boost::json::array(bindingCount);
        auto& arr_ENtnMTo=json["pBuffers"].get_array();
        for(int mMgieLc=0; mMgieLc < bindingCount; mMgieLc++){
            [&](){serialize_VkBuffer(arr_ENtnMTo[mMgieLc],pBuffers[mMgieLc]);}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(bindingCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < bindingCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
[&](){
            if (pSizes==NULL){
                json["pSizes"]=boost::json::array();
            return; }json["pSizes"]=boost::json::array(bindingCount);
        auto& arr_OwyEmcF=json["pSizes"].get_array();
        for(int YFhxzVl=0; YFhxzVl < bindingCount; YFhxzVl++){
            [&](){[&](){arr_OwyEmcF[YFhxzVl]=pSizes[YFhxzVl];}();}();
        }
        }();
[&](){
            if (pStrides==NULL){
                json["pStrides"]=boost::json::array();
            return; }json["pStrides"]=boost::json::array(bindingCount);
        auto& arr_YFLMtWg=json["pStrides"].get_array();
        for(int qlkJtZj=0; qlkJtZj < bindingCount; qlkJtZj++){
            [&](){[&](){arr_YFLMtWg[qlkJtZj]=pStrides[qlkJtZj];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDVERTEXBUFFERS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstBinding"].is_uint64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_uint64());
            }else if (json["firstBinding"].is_int64()){
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_int64());
            }else{
                firstBinding=static_cast<uint32_t>(json["firstBinding"].get_double());
            }
            }();
[&](){
            if (json["bindingCount"].is_uint64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_uint64());
            }else if (json["bindingCount"].is_int64()){
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_int64());
            }else{
                bindingCount=static_cast<uint32_t>(json["bindingCount"].get_double());
            }
            }();





debug_printf("Ending vkCmdBindVertexBuffers2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindVertexBuffers2EXT( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides ){
return vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthTestEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHTESTENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthTestEnable"]=depthTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_WLSKeYp;[&](){
            if (json["depthTestEnable"].is_uint64()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_uint64());
            }else if (json["depthTestEnable"].is_int64()){
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_int64());
            }else{
                temp_WLSKeYp=static_cast<uint32_t>(json["depthTestEnable"].get_double());
            }
            }();depthTestEnable=(VkBool32)temp_WLSKeYp;}();

debug_printf("Ending vkCmdSetDepthTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthTestEnable ){
return vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnable( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthWriteEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHWRITEENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthWriteEnable"]=depthWriteEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHWRITEENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qztdWhG;[&](){
            if (json["depthWriteEnable"].is_uint64()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_uint64());
            }else if (json["depthWriteEnable"].is_int64()){
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_int64());
            }else{
                temp_qztdWhG=static_cast<uint32_t>(json["depthWriteEnable"].get_double());
            }
            }();depthWriteEnable=(VkBool32)temp_qztdWhG;}();

debug_printf("Ending vkCmdSetDepthWriteEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthWriteEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable ){
return vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOp( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthCompareOp\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHCOMPAREOP;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["depthCompareOp"]=depthCompareOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCOMPAREOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_GommENv;[&](){
            if (json["depthCompareOp"].is_uint64()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_uint64());
            }else if (json["depthCompareOp"].is_int64()){
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_int64());
            }else{
                temp_GommENv=static_cast<int>(json["depthCompareOp"].get_double());
            }
            }();depthCompareOp=(VkCompareOp)temp_GommENv;}();}();

debug_printf("Ending vkCmdSetDepthCompareOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthCompareOpEXT( VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp ){
return vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnable( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBoundsTestEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHBOUNDSTESTENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBoundsTestEnable"]=depthBoundsTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBOUNDSTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qmudcyJ;[&](){
            if (json["depthBoundsTestEnable"].is_uint64()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_uint64());
            }else if (json["depthBoundsTestEnable"].is_int64()){
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_int64());
            }else{
                temp_qmudcyJ=static_cast<uint32_t>(json["depthBoundsTestEnable"].get_double());
            }
            }();depthBoundsTestEnable=(VkBool32)temp_qmudcyJ;}();

debug_printf("Ending vkCmdSetDepthBoundsTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBoundsTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable ){
return vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnable( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilTestEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSTENCILTESTENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stencilTestEnable"]=stencilTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILTESTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_qPvOEDS;[&](){
            if (json["stencilTestEnable"].is_uint64()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_uint64());
            }else if (json["stencilTestEnable"].is_int64()){
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_int64());
            }else{
                temp_qPvOEDS=static_cast<uint32_t>(json["stencilTestEnable"].get_double());
            }
            }();stencilTestEnable=(VkBool32)temp_qPvOEDS;}();

debug_printf("Ending vkCmdSetStencilTestEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilTestEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable ){
return vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOp( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetStencilOp\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSTENCILOP;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["faceMask"]=faceMask;}();}();}();
[&](){[&](){[&](){json["failOp"]=failOp;}();}();}();
[&](){[&](){[&](){json["passOp"]=passOp;}();}();}();
[&](){[&](){[&](){json["depthFailOp"]=depthFailOp;}();}();}();
[&](){[&](){[&](){json["compareOp"]=compareOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSTENCILOP):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_VFXTqgy;[&](){
            if (json["faceMask"].is_uint64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_uint64());
            }else if (json["faceMask"].is_int64()){
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_int64());
            }else{
                temp_VFXTqgy=static_cast<int>(json["faceMask"].get_double());
            }
            }();faceMask=(VkStencilFaceFlags)temp_VFXTqgy;}();}();
[&](){[&](){int temp_lKXncFy;[&](){
            if (json["failOp"].is_uint64()){
                temp_lKXncFy=static_cast<int>(json["failOp"].get_uint64());
            }else if (json["failOp"].is_int64()){
                temp_lKXncFy=static_cast<int>(json["failOp"].get_int64());
            }else{
                temp_lKXncFy=static_cast<int>(json["failOp"].get_double());
            }
            }();failOp=(VkStencilOp)temp_lKXncFy;}();}();
[&](){[&](){int temp_SPMLjKg;[&](){
            if (json["passOp"].is_uint64()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_uint64());
            }else if (json["passOp"].is_int64()){
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_int64());
            }else{
                temp_SPMLjKg=static_cast<int>(json["passOp"].get_double());
            }
            }();passOp=(VkStencilOp)temp_SPMLjKg;}();}();
[&](){[&](){int temp_TdIKNtG;[&](){
            if (json["depthFailOp"].is_uint64()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_uint64());
            }else if (json["depthFailOp"].is_int64()){
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_int64());
            }else{
                temp_TdIKNtG=static_cast<int>(json["depthFailOp"].get_double());
            }
            }();depthFailOp=(VkStencilOp)temp_TdIKNtG;}();}();
[&](){[&](){int temp_NLoCySV;[&](){
            if (json["compareOp"].is_uint64()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_uint64());
            }else if (json["compareOp"].is_int64()){
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_int64());
            }else{
                temp_NLoCySV=static_cast<int>(json["compareOp"].get_double());
            }
            }();compareOp=(VkCompareOp)temp_NLoCySV;}();}();

debug_printf("Ending vkCmdSetStencilOp...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetStencilOpEXT( VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp ){
return vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
__attribute__((visibility ("hidden"))) void vkCmdSetPatchControlPointsEXT( VkCommandBuffer commandBuffer, uint32_t patchControlPoints ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPatchControlPointsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPATCHCONTROLPOINTSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["patchControlPoints"]=patchControlPoints;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPATCHCONTROLPOINTSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["patchControlPoints"].is_uint64()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_uint64());
            }else if (json["patchControlPoints"].is_int64()){
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_int64());
            }else{
                patchControlPoints=static_cast<uint32_t>(json["patchControlPoints"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetPatchControlPointsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnable( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizerDiscardEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETRASTERIZERDISCARDENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["rasterizerDiscardEnable"]=rasterizerDiscardEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZERDISCARDENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_bdbWnok;[&](){
            if (json["rasterizerDiscardEnable"].is_uint64()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_uint64());
            }else if (json["rasterizerDiscardEnable"].is_int64()){
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_int64());
            }else{
                temp_bdbWnok=static_cast<uint32_t>(json["rasterizerDiscardEnable"].get_double());
            }
            }();rasterizerDiscardEnable=(VkBool32)temp_bdbWnok;}();

debug_printf("Ending vkCmdSetRasterizerDiscardEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizerDiscardEnableEXT( VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable ){
return vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnable( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBiasEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHBIASENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthBiasEnable"]=depthBiasEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIASENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_ewcVkBi;[&](){
            if (json["depthBiasEnable"].is_uint64()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_uint64());
            }else if (json["depthBiasEnable"].is_int64()){
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_int64());
            }else{
                temp_ewcVkBi=static_cast<uint32_t>(json["depthBiasEnable"].get_double());
            }
            }();depthBiasEnable=(VkBool32)temp_ewcVkBi;}();

debug_printf("Ending vkCmdSetDepthBiasEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBiasEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable ){
return vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEXT( VkCommandBuffer commandBuffer, VkLogicOp logicOp ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLOGICOPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["logicOp"]=logicOp;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_KRaggtp;[&](){
            if (json["logicOp"].is_uint64()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_uint64());
            }else if (json["logicOp"].is_int64()){
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_int64());
            }else{
                temp_KRaggtp=static_cast<int>(json["logicOp"].get_double());
            }
            }();logicOp=(VkLogicOp)temp_KRaggtp;}();}();

debug_printf("Ending vkCmdSetLogicOpEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnable( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPrimitiveRestartEnable\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPRIMITIVERESTARTENABLE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["primitiveRestartEnable"]=primitiveRestartEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPRIMITIVERESTARTENABLE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_mDszbuh;[&](){
            if (json["primitiveRestartEnable"].is_uint64()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_uint64());
            }else if (json["primitiveRestartEnable"].is_int64()){
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_int64());
            }else{
                temp_mDszbuh=static_cast<uint32_t>(json["primitiveRestartEnable"].get_double());
            }
            }();primitiveRestartEnable=(VkBool32)temp_mDszbuh;}();

debug_printf("Ending vkCmdSetPrimitiveRestartEnable...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPrimitiveRestartEnableEXT( VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable ){
return vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
__attribute__((visibility ("hidden"))) void vkCmdSetTessellationDomainOriginEXT( VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin ){
//Will only be called by the client
debug_printf("Executing vkCmdSetTessellationDomainOriginEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETTESSELLATIONDOMAINORIGINEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["domainOrigin"]=domainOrigin;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETTESSELLATIONDOMAINORIGINEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MhaRSZf;[&](){
            if (json["domainOrigin"].is_uint64()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_uint64());
            }else if (json["domainOrigin"].is_int64()){
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_int64());
            }else{
                temp_MhaRSZf=static_cast<int>(json["domainOrigin"].get_double());
            }
            }();domainOrigin=(VkTessellationDomainOrigin)temp_MhaRSZf;}();}();

debug_printf("Ending vkCmdSetTessellationDomainOriginEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClampEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClampEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClampEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHCLAMPENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClampEnable"]=depthClampEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLAMPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_DzsSqgr;[&](){
            if (json["depthClampEnable"].is_uint64()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_uint64());
            }else if (json["depthClampEnable"].is_int64()){
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_int64());
            }else{
                temp_DzsSqgr=static_cast<uint32_t>(json["depthClampEnable"].get_double());
            }
            }();depthClampEnable=(VkBool32)temp_DzsSqgr;}();

debug_printf("Ending vkCmdSetDepthClampEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetPolygonModeEXT( VkCommandBuffer commandBuffer, VkPolygonMode polygonMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetPolygonModeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPOLYGONMODEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["polygonMode"]=polygonMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPOLYGONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XzCpfxJ;[&](){
            if (json["polygonMode"].is_uint64()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_uint64());
            }else if (json["polygonMode"].is_int64()){
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_int64());
            }else{
                temp_XzCpfxJ=static_cast<int>(json["polygonMode"].get_double());
            }
            }();polygonMode=(VkPolygonMode)temp_XzCpfxJ;}();}();

debug_printf("Ending vkCmdSetPolygonModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationSamplesEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationSamplesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETRASTERIZATIONSAMPLESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["rasterizationSamples"]=rasterizationSamples;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSAMPLESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_YCyLybT;[&](){
            if (json["rasterizationSamples"].is_uint64()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_uint64());
            }else if (json["rasterizationSamples"].is_int64()){
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_int64());
            }else{
                temp_YCyLybT=static_cast<int>(json["rasterizationSamples"].get_double());
            }
            }();rasterizationSamples=(VkSampleCountFlagBits)temp_YCyLybT;}();}();

debug_printf("Ending vkCmdSetRasterizationSamplesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleMaskEXT( VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask* pSampleMask ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleMaskEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSAMPLEMASKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["samples"]=samples;}();}();}();
[&](){
            if (pSampleMask==NULL){
                json["pSampleMask"]=boost::json::array();
            return; }json["pSampleMask"]=boost::json::array((samples + 31) / 32);
        auto& arr_nepOVVF=json["pSampleMask"].get_array();
        for(int ASCUBEW=0; ASCUBEW < (samples + 31) / 32; ASCUBEW++){
            [&](){[&](){arr_nepOVVF[ASCUBEW]=pSampleMask[ASCUBEW];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_lbKgbKj;[&](){
            if (json["samples"].is_uint64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_uint64());
            }else if (json["samples"].is_int64()){
                temp_lbKgbKj=static_cast<int>(json["samples"].get_int64());
            }else{
                temp_lbKgbKj=static_cast<int>(json["samples"].get_double());
            }
            }();samples=(VkSampleCountFlagBits)temp_lbKgbKj;}();}();


debug_printf("Ending vkCmdSetSampleMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToCoverageEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToCoverageEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETALPHATOCOVERAGEENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToCoverageEnable"]=alphaToCoverageEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOCOVERAGEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_GXlPpxl;[&](){
            if (json["alphaToCoverageEnable"].is_uint64()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_uint64());
            }else if (json["alphaToCoverageEnable"].is_int64()){
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_int64());
            }else{
                temp_GXlPpxl=static_cast<uint32_t>(json["alphaToCoverageEnable"].get_double());
            }
            }();alphaToCoverageEnable=(VkBool32)temp_GXlPpxl;}();

debug_printf("Ending vkCmdSetAlphaToCoverageEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetAlphaToOneEnableEXT( VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetAlphaToOneEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETALPHATOONEENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["alphaToOneEnable"]=alphaToOneEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETALPHATOONEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_vIViDmy;[&](){
            if (json["alphaToOneEnable"].is_uint64()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_uint64());
            }else if (json["alphaToOneEnable"].is_int64()){
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_int64());
            }else{
                temp_vIViDmy=static_cast<uint32_t>(json["alphaToOneEnable"].get_double());
            }
            }();alphaToOneEnable=(VkBool32)temp_vIViDmy;}();

debug_printf("Ending vkCmdSetAlphaToOneEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLogicOpEnableEXT( VkCommandBuffer commandBuffer, VkBool32 logicOpEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLogicOpEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLOGICOPENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["logicOpEnable"]=logicOpEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLOGICOPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_efIIzNf;[&](){
            if (json["logicOpEnable"].is_uint64()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_uint64());
            }else if (json["logicOpEnable"].is_int64()){
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_int64());
            }else{
                temp_efIIzNf=static_cast<uint32_t>(json["logicOpEnable"].get_double());
            }
            }();logicOpEnable=(VkBool32)temp_efIIzNf;}();

debug_printf("Ending vkCmdSetLogicOpEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEnableEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOLORBLENDENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEnables==NULL){
                json["pColorBlendEnables"]=boost::json::array();
            return; }json["pColorBlendEnables"]=boost::json::array(attachmentCount);
        auto& arr_saqDhTV=json["pColorBlendEnables"].get_array();
        for(int VGuJXMd=0; VGuJXMd < attachmentCount; VGuJXMd++){
            [&](){[&](){arr_saqDhTV[VGuJXMd]=pColorBlendEnables[VGuJXMd];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendEquationEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendEquationEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOLORBLENDEQUATIONEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendEquations==NULL){
                json["pColorBlendEquations"]=boost::json::array();
            return; }json["pColorBlendEquations"]=boost::json::array(attachmentCount);
        auto& arr_hKUQljx=json["pColorBlendEquations"].get_array();
        for(int EHggOtN=0; EHggOtN < attachmentCount; EHggOtN++){
            [&](){
            auto& temp=arr_hKUQljx[EHggOtN].emplace_object();
            return serialize_struct(temp, pColorBlendEquations[EHggOtN]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDEQUATIONEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendEquationEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteMaskEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteMaskEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOLORWRITEMASKEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteMasks==NULL){
                json["pColorWriteMasks"]=boost::json::array();
            return; }json["pColorWriteMasks"]=boost::json::array(attachmentCount);
        auto& arr_VFhepws=json["pColorWriteMasks"].get_array();
        for(int PbQLtdZ=0; PbQLtdZ < attachmentCount; PbQLtdZ++){
            [&](){[&](){[&](){arr_VFhepws[PbQLtdZ]=pColorWriteMasks[PbQLtdZ];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEMASKEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetColorWriteMaskEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRasterizationStreamEXT( VkCommandBuffer commandBuffer, uint32_t rasterizationStream ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRasterizationStreamEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETRASTERIZATIONSTREAMEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["rasterizationStream"]=rasterizationStream;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETRASTERIZATIONSTREAMEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["rasterizationStream"].is_uint64()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_uint64());
            }else if (json["rasterizationStream"].is_int64()){
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_int64());
            }else{
                rasterizationStream=static_cast<uint32_t>(json["rasterizationStream"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetRasterizationStreamEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetConservativeRasterizationModeEXT( VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetConservativeRasterizationModeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["conservativeRasterizationMode"]=conservativeRasterizationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCONSERVATIVERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_foXltQC;[&](){
            if (json["conservativeRasterizationMode"].is_uint64()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_uint64());
            }else if (json["conservativeRasterizationMode"].is_int64()){
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_int64());
            }else{
                temp_foXltQC=static_cast<int>(json["conservativeRasterizationMode"].get_double());
            }
            }();conservativeRasterizationMode=(VkConservativeRasterizationModeEXT)temp_foXltQC;}();}();

debug_printf("Ending vkCmdSetConservativeRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetExtraPrimitiveOverestimationSizeEXT( VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize ){
//Will only be called by the client
debug_printf("Executing vkCmdSetExtraPrimitiveOverestimationSizeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["extraPrimitiveOverestimationSize"]=extraPrimitiveOverestimationSize;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["extraPrimitiveOverestimationSize"].is_uint64()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_uint64());
            }else if (json["extraPrimitiveOverestimationSize"].is_int64()){
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_int64());
            }else{
                extraPrimitiveOverestimationSize=static_cast<float>(json["extraPrimitiveOverestimationSize"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetExtraPrimitiveOverestimationSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipEnableEXT( VkCommandBuffer commandBuffer, VkBool32 depthClipEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHCLIPENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["depthClipEnable"]=depthClipEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_xexuvpr;[&](){
            if (json["depthClipEnable"].is_uint64()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_uint64());
            }else if (json["depthClipEnable"].is_int64()){
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_int64());
            }else{
                temp_xexuvpr=static_cast<uint32_t>(json["depthClipEnable"].get_double());
            }
            }();depthClipEnable=(VkBool32)temp_xexuvpr;}();

debug_printf("Ending vkCmdSetDepthClipEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetSampleLocationsEnableEXT( VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetSampleLocationsEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSAMPLELOCATIONSENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["sampleLocationsEnable"]=sampleLocationsEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSAMPLELOCATIONSENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_dFVPXvO;[&](){
            if (json["sampleLocationsEnable"].is_uint64()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_uint64());
            }else if (json["sampleLocationsEnable"].is_int64()){
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_int64());
            }else{
                temp_dFVPXvO=static_cast<uint32_t>(json["sampleLocationsEnable"].get_double());
            }
            }();sampleLocationsEnable=(VkBool32)temp_dFVPXvO;}();

debug_printf("Ending vkCmdSetSampleLocationsEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorBlendAdvancedEXT( VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorBlendAdvancedEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOLORBLENDADVANCEDEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstAttachment"]=firstAttachment;}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorBlendAdvanced==NULL){
                json["pColorBlendAdvanced"]=boost::json::array();
            return; }json["pColorBlendAdvanced"]=boost::json::array(attachmentCount);
        auto& arr_VhJvkCW=json["pColorBlendAdvanced"].get_array();
        for(int rBcMzuv=0; rBcMzuv < attachmentCount; rBcMzuv++){
            [&](){
            auto& temp=arr_VhJvkCW[rBcMzuv].emplace_object();
            return serialize_struct(temp, pColorBlendAdvanced[rBcMzuv]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORBLENDADVANCEDEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstAttachment"].is_uint64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_uint64());
            }else if (json["firstAttachment"].is_int64()){
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_int64());
            }else{
                firstAttachment=static_cast<uint32_t>(json["firstAttachment"].get_double());
            }
            }();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetColorBlendAdvancedEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetProvokingVertexModeEXT( VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetProvokingVertexModeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETPROVOKINGVERTEXMODEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["provokingVertexMode"]=provokingVertexMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETPROVOKINGVERTEXMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_unvGJcm;[&](){
            if (json["provokingVertexMode"].is_uint64()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_uint64());
            }else if (json["provokingVertexMode"].is_int64()){
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_int64());
            }else{
                temp_unvGJcm=static_cast<int>(json["provokingVertexMode"].get_double());
            }
            }();provokingVertexMode=(VkProvokingVertexModeEXT)temp_unvGJcm;}();}();

debug_printf("Ending vkCmdSetProvokingVertexModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineRasterizationModeEXT( VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineRasterizationModeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLINERASTERIZATIONMODEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["lineRasterizationMode"]=lineRasterizationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINERASTERIZATIONMODEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_TzHFAEB;[&](){
            if (json["lineRasterizationMode"].is_uint64()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_uint64());
            }else if (json["lineRasterizationMode"].is_int64()){
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_int64());
            }else{
                temp_TzHFAEB=static_cast<int>(json["lineRasterizationMode"].get_double());
            }
            }();lineRasterizationMode=(VkLineRasterizationModeEXT)temp_TzHFAEB;}();}();

debug_printf("Ending vkCmdSetLineRasterizationModeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetLineStippleEnableEXT( VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetLineStippleEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETLINESTIPPLEENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["stippledLineEnable"]=stippledLineEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETLINESTIPPLEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lOgURYj;[&](){
            if (json["stippledLineEnable"].is_uint64()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_uint64());
            }else if (json["stippledLineEnable"].is_int64()){
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_int64());
            }else{
                temp_lOgURYj=static_cast<uint32_t>(json["stippledLineEnable"].get_double());
            }
            }();stippledLineEnable=(VkBool32)temp_lOgURYj;}();

debug_printf("Ending vkCmdSetLineStippleEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthClipNegativeOneToOneEXT( VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthClipNegativeOneToOneEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["negativeOneToOne"]=negativeOneToOne;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHCLIPNEGATIVEONETOONEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_KbgfkEI;[&](){
            if (json["negativeOneToOne"].is_uint64()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_uint64());
            }else if (json["negativeOneToOne"].is_int64()){
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_int64());
            }else{
                temp_KbgfkEI=static_cast<uint32_t>(json["negativeOneToOne"].get_double());
            }
            }();negativeOneToOne=(VkBool32)temp_KbgfkEI;}();

debug_printf("Ending vkCmdSetDepthClipNegativeOneToOneEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportWScalingEnableNV( VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportWScalingEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORTWSCALINGENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["viewportWScalingEnable"]=viewportWScalingEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTWSCALINGENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_FBvKoOa;[&](){
            if (json["viewportWScalingEnable"].is_uint64()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_uint64());
            }else if (json["viewportWScalingEnable"].is_int64()){
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_int64());
            }else{
                temp_FBvKoOa=static_cast<uint32_t>(json["viewportWScalingEnable"].get_double());
            }
            }();viewportWScalingEnable=(VkBool32)temp_FBvKoOa;}();

debug_printf("Ending vkCmdSetViewportWScalingEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetViewportSwizzleNV( VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles ){
//Will only be called by the client
debug_printf("Executing vkCmdSetViewportSwizzleNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVIEWPORTSWIZZLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["firstViewport"]=firstViewport;}();
[&](){json["viewportCount"]=viewportCount;}();
[&](){
            if (pViewportSwizzles==NULL){
                json["pViewportSwizzles"]=boost::json::array();
            return; }json["pViewportSwizzles"]=boost::json::array(viewportCount);
        auto& arr_mlTjeMw=json["pViewportSwizzles"].get_array();
        for(int jvBpVNx=0; jvBpVNx < viewportCount; jvBpVNx++){
            [&](){
            auto& temp=arr_mlTjeMw[jvBpVNx].emplace_object();
            return serialize_struct(temp, pViewportSwizzles[jvBpVNx]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVIEWPORTSWIZZLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["firstViewport"].is_uint64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_uint64());
            }else if (json["firstViewport"].is_int64()){
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_int64());
            }else{
                firstViewport=static_cast<uint32_t>(json["firstViewport"].get_double());
            }
            }();
[&](){
            if (json["viewportCount"].is_uint64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_uint64());
            }else if (json["viewportCount"].is_int64()){
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_int64());
            }else{
                viewportCount=static_cast<uint32_t>(json["viewportCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetViewportSwizzleNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGETOCOLORENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageToColorEnable"]=coverageToColorEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_StrBHxz;[&](){
            if (json["coverageToColorEnable"].is_uint64()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_uint64());
            }else if (json["coverageToColorEnable"].is_int64()){
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_int64());
            }else{
                temp_StrBHxz=static_cast<uint32_t>(json["coverageToColorEnable"].get_double());
            }
            }();coverageToColorEnable=(VkBool32)temp_StrBHxz;}();

debug_printf("Ending vkCmdSetCoverageToColorEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageToColorLocationNV( VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageToColorLocationNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGETOCOLORLOCATIONNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageToColorLocation"]=coverageToColorLocation;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGETOCOLORLOCATIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["coverageToColorLocation"].is_uint64()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_uint64());
            }else if (json["coverageToColorLocation"].is_int64()){
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_int64());
            }else{
                coverageToColorLocation=static_cast<uint32_t>(json["coverageToColorLocation"].get_double());
            }
            }();

debug_printf("Ending vkCmdSetCoverageToColorLocationNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationModeNV( VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationModeNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGEMODULATIONMODENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageModulationMode"]=coverageModulationMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_BTSRuJL;[&](){
            if (json["coverageModulationMode"].is_uint64()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_uint64());
            }else if (json["coverageModulationMode"].is_int64()){
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_int64());
            }else{
                temp_BTSRuJL=static_cast<int>(json["coverageModulationMode"].get_double());
            }
            }();coverageModulationMode=(VkCoverageModulationModeNV)temp_BTSRuJL;}();}();

debug_printf("Ending vkCmdSetCoverageModulationModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableEnableNV( VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGEMODULATIONTABLEENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["coverageModulationTableEnable"]=coverageModulationTableEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_lmSvUmH;[&](){
            if (json["coverageModulationTableEnable"].is_uint64()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_uint64());
            }else if (json["coverageModulationTableEnable"].is_int64()){
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_int64());
            }else{
                temp_lmSvUmH=static_cast<uint32_t>(json["coverageModulationTableEnable"].get_double());
            }
            }();coverageModulationTableEnable=(VkBool32)temp_lmSvUmH;}();

debug_printf("Ending vkCmdSetCoverageModulationTableEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageModulationTableNV( VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageModulationTableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGEMODULATIONTABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["coverageModulationTableCount"]=coverageModulationTableCount;}();
[&](){
            if (pCoverageModulationTable==NULL){
                json["pCoverageModulationTable"]=boost::json::array();
            return; }json["pCoverageModulationTable"]=boost::json::array(coverageModulationTableCount);
        auto& arr_FKEHfYD=json["pCoverageModulationTable"].get_array();
        for(int pMqhQqL=0; pMqhQqL < coverageModulationTableCount; pMqhQqL++){
            [&](){arr_FKEHfYD[pMqhQqL]=pCoverageModulationTable[pMqhQqL];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEMODULATIONTABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["coverageModulationTableCount"].is_uint64()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_uint64());
            }else if (json["coverageModulationTableCount"].is_int64()){
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_int64());
            }else{
                coverageModulationTableCount=static_cast<uint32_t>(json["coverageModulationTableCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetCoverageModulationTableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetShadingRateImageEnableNV( VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetShadingRateImageEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETSHADINGRATEIMAGEENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["shadingRateImageEnable"]=shadingRateImageEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETSHADINGRATEIMAGEENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_BQfvSQF;[&](){
            if (json["shadingRateImageEnable"].is_uint64()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_uint64());
            }else if (json["shadingRateImageEnable"].is_int64()){
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_int64());
            }else{
                temp_BQfvSQF=static_cast<uint32_t>(json["shadingRateImageEnable"].get_double());
            }
            }();shadingRateImageEnable=(VkBool32)temp_BQfvSQF;}();

debug_printf("Ending vkCmdSetShadingRateImageEnableNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetCoverageReductionModeNV( VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode ){
//Will only be called by the client
debug_printf("Executing vkCmdSetCoverageReductionModeNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOVERAGEREDUCTIONMODENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["coverageReductionMode"]=coverageReductionMode;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOVERAGEREDUCTIONMODENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_MbjGgOv;[&](){
            if (json["coverageReductionMode"].is_uint64()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_uint64());
            }else if (json["coverageReductionMode"].is_int64()){
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_int64());
            }else{
                temp_MbjGgOv=static_cast<int>(json["coverageReductionMode"].get_double());
            }
            }();coverageReductionMode=(VkCoverageReductionModeNV)temp_MbjGgOv;}();}();

debug_printf("Ending vkCmdSetCoverageReductionModeNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetRepresentativeFragmentTestEnableNV( VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable ){
//Will only be called by the client
debug_printf("Executing vkCmdSetRepresentativeFragmentTestEnableNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["representativeFragmentTestEnable"]=representativeFragmentTestEnable;}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETREPRESENTATIVEFRAGMENTTESTENABLENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint32_t temp_VmtUEuY;[&](){
            if (json["representativeFragmentTestEnable"].is_uint64()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_uint64());
            }else if (json["representativeFragmentTestEnable"].is_int64()){
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_int64());
            }else{
                temp_VmtUEuY=static_cast<uint32_t>(json["representativeFragmentTestEnable"].get_double());
            }
            }();representativeFragmentTestEnable=(VkBool32)temp_VmtUEuY;}();

debug_printf("Ending vkCmdSetRepresentativeFragmentTestEnableNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlot( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
//Will only be called by the client
debug_printf("Executing vkCreatePrivateDataSlot\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEPRIVATEDATASLOT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_OhzuPlW=json["pCreateInfo"].get_array();
        for(int KUjUcQv=0; KUjUcQv < 1; KUjUcQv++){
            [&](){
            auto& temp=arr_OhzuPlW[KUjUcQv].emplace_object();
            return serialize_struct(temp, pCreateInfo[KUjUcQv]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pPrivateDataSlot==NULL){
                json["pPrivateDataSlot"]=boost::json::array();
            return; }json["pPrivateDataSlot"]=boost::json::array(1);
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].get_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){serialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt],pPrivateDataSlot[QtkHhpt]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pPrivateDataSlot"].get_array().size()==0){
                pPrivateDataSlot=NULL;
            return; }
        auto& arr_EOSkjPn=json["pPrivateDataSlot"].get_array();
        for(int QtkHhpt=0; QtkHhpt < 1; QtkHhpt++){
            [&](){deserialize_VkPrivateDataSlot(arr_EOSkjPn[QtkHhpt], pPrivateDataSlot[QtkHhpt]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_qQVSpod;[&](){
            if (json["result"].is_uint64()){
                temp_qQVSpod=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_qQVSpod=static_cast<int>(json["result"].get_int64());
            }else{
                temp_qQVSpod=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_qQVSpod;}();}();

                if (pPrivateDataSlot!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pPrivateDataSlot[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreatePrivateDataSlot...\n");
debug_printf("Return value of vkCreatePrivateDataSlot is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreatePrivateDataSlotEXT( VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot ){
return vkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlot( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyPrivateDataSlot\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYPRIVATEDATASLOT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYPRIVATEDATASLOT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();


debug_printf("Ending vkDestroyPrivateDataSlot...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyPrivateDataSlotEXT( VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator ){
return vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
//Will only be called by the client
debug_printf("Executing vkSetPrivateData\n");

    boost::json::object json;
    json["stream_type"]=VKSETPRIVATEDATA;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){json["data"]=data;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){
            if (json["objectHandle"].is_uint64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_uint64());
            }else if (json["objectHandle"].is_int64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_int64());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_double());
            }
            }();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){
            if (json["data"].is_uint64()){
                data=static_cast<uint64_t>(json["data"].get_uint64());
            }else if (json["data"].is_int64()){
                data=static_cast<uint64_t>(json["data"].get_int64());
            }else{
                data=static_cast<uint64_t>(json["data"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_HIenTTf;[&](){
            if (json["result"].is_uint64()){
                temp_HIenTTf=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HIenTTf=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HIenTTf=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HIenTTf;}();}();

debug_printf("Ending vkSetPrivateData...\n");
debug_printf("Return value of vkSetPrivateData is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkSetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data ){
return vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
}
__attribute__((visibility ("hidden"))) void vkGetPrivateData( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
//Will only be called by the client
debug_printf("Executing vkGetPrivateData\n");

    boost::json::object json;
    json["stream_type"]=VKGETPRIVATEDATA;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["objectType"]=objectType;}();}();}();
[&](){json["objectHandle"]=objectHandle;}();
[&](){serialize_VkPrivateDataSlot(json["privateDataSlot"],privateDataSlot);}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(1);
        auto& arr_niIcbqy=json["pData"].get_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){arr_niIcbqy[rXHtNoy]=pData[rXHtNoy];}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPRIVATEDATA):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_xzhtvEi;[&](){
            if (json["objectType"].is_uint64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_uint64());
            }else if (json["objectType"].is_int64()){
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_int64());
            }else{
                temp_xzhtvEi=static_cast<int>(json["objectType"].get_double());
            }
            }();objectType=(VkObjectType)temp_xzhtvEi;}();}();
[&](){
            if (json["objectHandle"].is_uint64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_uint64());
            }else if (json["objectHandle"].is_int64()){
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_int64());
            }else{
                objectHandle=static_cast<uint64_t>(json["objectHandle"].get_double());
            }
            }();
[&](){deserialize_VkPrivateDataSlot(json["privateDataSlot"], privateDataSlot);}();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }
        auto& arr_niIcbqy=json["pData"].get_array();
        for(int rXHtNoy=0; rXHtNoy < 1; rXHtNoy++){
            [&](){
            if (arr_niIcbqy[rXHtNoy].is_uint64()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_uint64());
            }else if (arr_niIcbqy[rXHtNoy].is_int64()){
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_int64());
            }else{
                pData[rXHtNoy]=static_cast<uint64_t>(arr_niIcbqy[rXHtNoy].get_double());
            }
            }();
        }
        }();

debug_printf("Ending vkGetPrivateData...\n");
}
__attribute__((visibility ("hidden"))) void vkGetPrivateDataEXT( VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData ){
return vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBuffer2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYBUFFER2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferInfo==NULL){
                json["pCopyBufferInfo"]=boost::json::array();
            return; }json["pCopyBufferInfo"]=boost::json::array(1);
        auto& arr_RrXlJAO=json["pCopyBufferInfo"].get_array();
        for(int tCibIjb=0; tCibIjb < 1; tCibIjb++){
            [&](){
            auto& temp=arr_RrXlJAO[tCibIjb].emplace_object();
            return serialize_struct(temp, pCopyBufferInfo[tCibIjb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo ){
return vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImage2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYIMAGE2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageInfo==NULL){
                json["pCopyImageInfo"]=boost::json::array();
            return; }json["pCopyImageInfo"]=boost::json::array(1);
        auto& arr_fhmwDMM=json["pCopyImageInfo"].get_array();
        for(int vtScDqF=0; vtScDqF < 1; vtScDqF++){
            [&](){
            auto& temp=arr_fhmwDMM[vtScDqF].emplace_object();
            return serialize_struct(temp, pCopyImageInfo[vtScDqF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImage2KHR( VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo ){
return vkCmdCopyImage2(commandBuffer, pCopyImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBlitImage2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBLITIMAGE2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBlitImageInfo==NULL){
                json["pBlitImageInfo"]=boost::json::array();
            return; }json["pBlitImageInfo"]=boost::json::array(1);
        auto& arr_uMZBSOh=json["pBlitImageInfo"].get_array();
        for(int mMDYqpe=0; mMDYqpe < 1; mMDYqpe++){
            [&](){
            auto& temp=arr_uMZBSOh[mMDYqpe].emplace_object();
            return serialize_struct(temp, pBlitImageInfo[mMDYqpe]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBLITIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBlitImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBlitImage2KHR( VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo ){
return vkCmdBlitImage2(commandBuffer, pBlitImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyBufferToImage2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYBUFFERTOIMAGE2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyBufferToImageInfo==NULL){
                json["pCopyBufferToImageInfo"]=boost::json::array();
            return; }json["pCopyBufferToImageInfo"]=boost::json::array(1);
        auto& arr_GgxIzVF=json["pCopyBufferToImageInfo"].get_array();
        for(int kZlUXOa=0; kZlUXOa < 1; kZlUXOa++){
            [&](){
            auto& temp=arr_GgxIzVF[kZlUXOa].emplace_object();
            return serialize_struct(temp, pCopyBufferToImageInfo[kZlUXOa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYBUFFERTOIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyBufferToImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyBufferToImage2KHR( VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo ){
return vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyImageToBuffer2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYIMAGETOBUFFER2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCopyImageToBufferInfo==NULL){
                json["pCopyImageToBufferInfo"]=boost::json::array();
            return; }json["pCopyImageToBufferInfo"]=boost::json::array(1);
        auto& arr_dKwPEQq=json["pCopyImageToBufferInfo"].get_array();
        for(int SXwhnUi=0; SXwhnUi < 1; SXwhnUi++){
            [&](){
            auto& temp=arr_dKwPEQq[SXwhnUi].emplace_object();
            return serialize_struct(temp, pCopyImageToBufferInfo[SXwhnUi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYIMAGETOBUFFER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyImageToBuffer2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyImageToBuffer2KHR( VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo ){
return vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdResolveImage2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDRESOLVEIMAGE2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pResolveImageInfo==NULL){
                json["pResolveImageInfo"]=boost::json::array();
            return; }json["pResolveImageInfo"]=boost::json::array(1);
        auto& arr_WXEMxut=json["pResolveImageInfo"].get_array();
        for(int oSccZaz=0; oSccZaz < 1; oSccZaz++){
            [&](){
            auto& temp=arr_WXEMxut[oSccZaz].emplace_object();
            return serialize_struct(temp, pResolveImageInfo[oSccZaz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESOLVEIMAGE2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdResolveImage2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResolveImage2KHR( VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo ){
return vkCmdResolveImage2(commandBuffer, pResolveImageInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateKHR( VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETFRAGMENTSHADINGRATEKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pFragmentSize==NULL){
                json["pFragmentSize"]=boost::json::array();
            return; }json["pFragmentSize"]=boost::json::array(1);
        auto& arr_RBQYqfx=json["pFragmentSize"].get_array();
        for(int rHAqvQQ=0; rHAqvQQ < 1; rHAqvQQ++){
            [&](){
            auto& temp=arr_RBQYqfx[rHAqvQQ].emplace_object();
            return serialize_struct(temp, pFragmentSize[rHAqvQQ]);
            }();
        }
        }();
[&](){json["combinerOps"]=boost::json::array(2);
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

[&](){
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceFragmentShadingRatesKHR( VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceFragmentShadingRatesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pFragmentShadingRateCount==NULL){
                json["pFragmentShadingRateCount"]=boost::json::array();
            return; }json["pFragmentShadingRateCount"]=boost::json::array(1);
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].get_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){arr_CjAZByp[vQwTqIV]=pFragmentShadingRateCount[vQwTqIV];}();
        }
        }();
[&](){
            if (pFragmentShadingRates==NULL){
                json["pFragmentShadingRates"]=boost::json::array();
            return; }json["pFragmentShadingRates"]=boost::json::array(*pFragmentShadingRateCount);
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].get_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].emplace_object();
            return serialize_struct(temp, pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pFragmentShadingRateCount"].get_array().size()==0){
                pFragmentShadingRateCount=NULL;
            return; }
        auto& arr_CjAZByp=json["pFragmentShadingRateCount"].get_array();
        for(int vQwTqIV=0; vQwTqIV < 1; vQwTqIV++){
            [&](){
            if (arr_CjAZByp[vQwTqIV].is_uint64()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_uint64());
            }else if (arr_CjAZByp[vQwTqIV].is_int64()){
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_int64());
            }else{
                pFragmentShadingRateCount[vQwTqIV]=static_cast<uint32_t>(arr_CjAZByp[vQwTqIV].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pFragmentShadingRates"].get_array().size()==0){
                pFragmentShadingRates=NULL;
            return; }
        auto& arr_UdwJpYv=json["pFragmentShadingRates"].get_array();
        for(int bVRSXYW=0; bVRSXYW < *pFragmentShadingRateCount; bVRSXYW++){
            [&](){
            auto& temp=arr_UdwJpYv[bVRSXYW].get_object();
            deserialize_struct(temp,pFragmentShadingRates[bVRSXYW]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_YWmAync;[&](){
            if (json["result"].is_uint64()){
                temp_YWmAync=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_YWmAync=static_cast<int>(json["result"].get_int64());
            }else{
                temp_YWmAync=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_YWmAync;}();}();

debug_printf("Ending vkGetPhysicalDeviceFragmentShadingRatesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceFragmentShadingRatesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetFragmentShadingRateEnumNV( VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2] ){
//Will only be called by the client
debug_printf("Executing vkCmdSetFragmentShadingRateEnumNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETFRAGMENTSHADINGRATEENUMNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["shadingRate"]=shadingRate;}();}();}();
[&](){json["combinerOps"]=boost::json::array(2);
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            [&](){[&](){[&](){arr_foscmwP[uBsarms]=combinerOps[uBsarms];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETFRAGMENTSHADINGRATEENUMNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_CqLMxeN;[&](){
            if (json["shadingRate"].is_uint64()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_uint64());
            }else if (json["shadingRate"].is_int64()){
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_int64());
            }else{
                temp_CqLMxeN=static_cast<int>(json["shadingRate"].get_double());
            }
            }();shadingRate=(VkFragmentShadingRateNV)temp_CqLMxeN;}();}();
[&](){
        auto& arr_foscmwP=json["combinerOps"].get_array();
        for(int uBsarms=0; uBsarms < 2; uBsarms++){
            
        }
        }();

debug_printf("Ending vkCmdSetFragmentShadingRateEnumNV...\n");
}
__attribute__((visibility ("hidden"))) void vkGetAccelerationStructureBuildSizesKHR( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureBuildSizesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }json["pBuildInfo"]=boost::json::array(1);
        auto& arr_rNWxDog=json["pBuildInfo"].get_array();
        for(int DpqeGQs=0; DpqeGQs < 1; DpqeGQs++){
            [&](){
            auto& temp=arr_rNWxDog[DpqeGQs].emplace_object();
            return serialize_struct(temp, pBuildInfo[DpqeGQs]);
            }();
        }
        }();
[&](){
            if (pMaxPrimitiveCounts==NULL){
                json["pMaxPrimitiveCounts"]=boost::json::array();
            return; }json["pMaxPrimitiveCounts"]=boost::json::array(pBuildInfo->geometryCount);
        auto& arr_vNFCnZs=json["pMaxPrimitiveCounts"].get_array();
        for(int KHWuVmo=0; KHWuVmo < pBuildInfo->geometryCount; KHWuVmo++){
            [&](){arr_vNFCnZs[KHWuVmo]=pMaxPrimitiveCounts[KHWuVmo];}();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }json["pSizeInfo"]=boost::json::array(1);
        auto& arr_aJATMZS=json["pSizeInfo"].get_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].emplace_object();
            return serialize_struct(temp, pSizeInfo[pwtSWhd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREBUILDSIZESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_uint64());
            }else if (json["buildType"].is_int64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_int64());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].get_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();


[&](){
            if (json["pSizeInfo"].get_array().size()==0){
                pSizeInfo=NULL;
            return; }
        auto& arr_aJATMZS=json["pSizeInfo"].get_array();
        for(int pwtSWhd=0; pwtSWhd < 1; pwtSWhd++){
            [&](){
            auto& temp=arr_aJATMZS[pwtSWhd].get_object();
            deserialize_struct(temp,pSizeInfo[pwtSWhd]);
            }();
        }
        }();

debug_printf("Ending vkGetAccelerationStructureBuildSizesKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetVertexInputEXT( VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions ){
//Will only be called by the client
debug_printf("Executing vkCmdSetVertexInputEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETVERTEXINPUTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["vertexBindingDescriptionCount"]=vertexBindingDescriptionCount;}();
[&](){
            if (pVertexBindingDescriptions==NULL){
                json["pVertexBindingDescriptions"]=boost::json::array();
            return; }json["pVertexBindingDescriptions"]=boost::json::array(vertexBindingDescriptionCount);
        auto& arr_CLcpEBv=json["pVertexBindingDescriptions"].get_array();
        for(int BlSYyCp=0; BlSYyCp < vertexBindingDescriptionCount; BlSYyCp++){
            [&](){
            auto& temp=arr_CLcpEBv[BlSYyCp].emplace_object();
            return serialize_struct(temp, pVertexBindingDescriptions[BlSYyCp]);
            }();
        }
        }();
[&](){json["vertexAttributeDescriptionCount"]=vertexAttributeDescriptionCount;}();
[&](){
            if (pVertexAttributeDescriptions==NULL){
                json["pVertexAttributeDescriptions"]=boost::json::array();
            return; }json["pVertexAttributeDescriptions"]=boost::json::array(vertexAttributeDescriptionCount);
        auto& arr_nigNRkL=json["pVertexAttributeDescriptions"].get_array();
        for(int UWEyBUU=0; UWEyBUU < vertexAttributeDescriptionCount; UWEyBUU++){
            [&](){
            auto& temp=arr_nigNRkL[UWEyBUU].emplace_object();
            return serialize_struct(temp, pVertexAttributeDescriptions[UWEyBUU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETVERTEXINPUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["vertexBindingDescriptionCount"].is_uint64()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_uint64());
            }else if (json["vertexBindingDescriptionCount"].is_int64()){
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_int64());
            }else{
                vertexBindingDescriptionCount=static_cast<uint32_t>(json["vertexBindingDescriptionCount"].get_double());
            }
            }();

[&](){
            if (json["vertexAttributeDescriptionCount"].is_uint64()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_uint64());
            }else if (json["vertexAttributeDescriptionCount"].is_int64()){
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_int64());
            }else{
                vertexAttributeDescriptionCount=static_cast<uint32_t>(json["vertexAttributeDescriptionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetVertexInputEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetColorWriteEnableEXT( VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables ){
//Will only be called by the client
debug_printf("Executing vkCmdSetColorWriteEnableEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETCOLORWRITEENABLEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["attachmentCount"]=attachmentCount;}();
[&](){
            if (pColorWriteEnables==NULL){
                json["pColorWriteEnables"]=boost::json::array();
            return; }json["pColorWriteEnables"]=boost::json::array(attachmentCount);
        auto& arr_jmtmyTP=json["pColorWriteEnables"].get_array();
        for(int yHXwpvy=0; yHXwpvy < attachmentCount; yHXwpvy++){
            [&](){[&](){arr_jmtmyTP[yHXwpvy]=pColorWriteEnables[yHXwpvy];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETCOLORWRITEENABLEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["attachmentCount"].is_uint64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_uint64());
            }else if (json["attachmentCount"].is_int64()){
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_int64());
            }else{
                attachmentCount=static_cast<uint32_t>(json["attachmentCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdSetColorWriteEnableEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetEvent2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETEVENT2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }json["pDependencyInfo"]=boost::json::array(1);
        auto& arr_RUiZhht=json["pDependencyInfo"].get_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();


debug_printf("Ending vkCmdSetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo ){
return vkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
//Will only be called by the client
debug_printf("Executing vkCmdResetEvent2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDRESETEVENT2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkEvent(json["event"],event);}();
[&](){[&](){[&](){json["stageMask"]=stageMask;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDRESETEVENT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkEvent(json["event"], event);}();
[&](){[&](){int temp_bRKcCBq;[&](){
            if (json["stageMask"].is_uint64()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_uint64());
            }else if (json["stageMask"].is_int64()){
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_int64());
            }else{
                temp_bRKcCBq=static_cast<int>(json["stageMask"].get_double());
            }
            }();stageMask=(VkPipelineStageFlags2)temp_bRKcCBq;}();}();

debug_printf("Ending vkCmdResetEvent2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdResetEvent2KHR( VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask ){
return vkCmdResetEvent2(commandBuffer, event, stageMask);
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdWaitEvents2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWAITEVENTS2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["eventCount"]=eventCount;}();
[&](){
            if (pEvents==NULL){
                json["pEvents"]=boost::json::array();
            return; }json["pEvents"]=boost::json::array(eventCount);
        auto& arr_tUuyOPJ=json["pEvents"].get_array();
        for(int aYMSaGl=0; aYMSaGl < eventCount; aYMSaGl++){
            [&](){serialize_VkEvent(arr_tUuyOPJ[aYMSaGl],pEvents[aYMSaGl]);}();
        }
        }();
[&](){
            if (pDependencyInfos==NULL){
                json["pDependencyInfos"]=boost::json::array();
            return; }json["pDependencyInfos"]=boost::json::array(eventCount);
        auto& arr_ZVkfhDe=json["pDependencyInfos"].get_array();
        for(int jvYalYw=0; jvYalYw < eventCount; jvYalYw++){
            [&](){
            auto& temp=arr_ZVkfhDe[jvYalYw].emplace_object();
            return serialize_struct(temp, pDependencyInfos[jvYalYw]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWAITEVENTS2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["eventCount"].is_uint64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_uint64());
            }else if (json["eventCount"].is_int64()){
                eventCount=static_cast<uint32_t>(json["eventCount"].get_int64());
            }else{
                eventCount=static_cast<uint32_t>(json["eventCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdWaitEvents2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWaitEvents2KHR( VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos ){
return vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdPipelineBarrier2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDPIPELINEBARRIER2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDependencyInfo==NULL){
                json["pDependencyInfo"]=boost::json::array();
            return; }json["pDependencyInfo"]=boost::json::array(1);
        auto& arr_RUiZhht=json["pDependencyInfo"].get_array();
        for(int rtSvYgr=0; rtSvYgr < 1; rtSvYgr++){
            [&](){
            auto& temp=arr_RUiZhht[rtSvYgr].emplace_object();
            return serialize_struct(temp, pDependencyInfo[rtSvYgr]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDPIPELINEBARRIER2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdPipelineBarrier2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdPipelineBarrier2KHR( VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo ){
return vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
//Will only be called by the client
debug_printf("Executing vkQueueSubmit2\n");

    boost::json::object json;
    json["stream_type"]=VKQUEUESUBMIT2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){json["submitCount"]=submitCount;}();
[&](){
            if (pSubmits==NULL){
                json["pSubmits"]=boost::json::array();
            return; }json["pSubmits"]=boost::json::array(submitCount);
        auto& arr_shQKWeV=json["pSubmits"].get_array();
        for(int uwYUklT=0; uwYUklT < submitCount; uwYUklT++){
            [&](){
            auto& temp=arr_shQKWeV[uwYUklT].emplace_object();
            return serialize_struct(temp, pSubmits[uwYUklT]);
            }();
        }
        }();
[&](){serialize_VkFence(json["fence"],fence);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKQUEUESUBMIT2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["submitCount"].is_uint64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_uint64());
            }else if (json["submitCount"].is_int64()){
                submitCount=static_cast<uint32_t>(json["submitCount"].get_int64());
            }else{
                submitCount=static_cast<uint32_t>(json["submitCount"].get_double());
            }
            }();

[&](){deserialize_VkFence(json["fence"], fence);}();
VkResult result;
[&](){[&](){int temp_kyODmSO;[&](){
            if (json["result"].is_uint64()){
                temp_kyODmSO=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_kyODmSO=static_cast<int>(json["result"].get_int64());
            }else{
                temp_kyODmSO=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_kyODmSO;}();}();

debug_printf("Ending vkQueueSubmit2...\n");
debug_printf("Return value of vkQueueSubmit2 is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkQueueSubmit2KHR( VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence ){
return vkQueueSubmit2(queue, submitCount, pSubmits, fence);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteTimestamp2\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITETIMESTAMP2;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["query"]=query;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITETIMESTAMP2):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_uint64());
            }else if (json["stage"].is_int64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_int64());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["query"].is_uint64()){
                query=static_cast<uint32_t>(json["query"].get_uint64());
            }else if (json["query"].is_int64()){
                query=static_cast<uint32_t>(json["query"].get_int64());
            }else{
                query=static_cast<uint32_t>(json["query"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteTimestamp2...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdWriteTimestamp2KHR( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query ){
return vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
__attribute__((visibility ("hidden"))) void vkCmdWriteBufferMarker2AMD( VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteBufferMarker2AMD\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITEBUFFERMARKER2AMD;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["stage"]=stage;}();}();}();
[&](){serialize_VkBuffer(json["dstBuffer"],dstBuffer);}();
[&](){[&](){json["dstOffset"]=dstOffset;}();}();
[&](){json["marker"]=marker;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEBUFFERMARKER2AMD):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_XkgNLEZ;[&](){
            if (json["stage"].is_uint64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_uint64());
            }else if (json["stage"].is_int64()){
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_int64());
            }else{
                temp_XkgNLEZ=static_cast<int>(json["stage"].get_double());
            }
            }();stage=(VkPipelineStageFlags2)temp_XkgNLEZ;}();}();
[&](){deserialize_VkBuffer(json["dstBuffer"], dstBuffer);}();
[&](){uint64_t temp_fIjfpOW;[&](){
            if (json["dstOffset"].is_uint64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_uint64());
            }else if (json["dstOffset"].is_int64()){
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_int64());
            }else{
                temp_fIjfpOW=static_cast<uint64_t>(json["dstOffset"].get_double());
            }
            }();dstOffset=(VkDeviceSize)temp_fIjfpOW;}();
[&](){
            if (json["marker"].is_uint64()){
                marker=static_cast<uint32_t>(json["marker"].get_uint64());
            }else if (json["marker"].is_int64()){
                marker=static_cast<uint32_t>(json["marker"].get_int64());
            }else{
                marker=static_cast<uint32_t>(json["marker"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteBufferMarker2AMD...\n");
}
__attribute__((visibility ("hidden"))) void vkGetQueueCheckpointData2NV( VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData ){
//Will only be called by the client
debug_printf("Executing vkGetQueueCheckpointData2NV\n");

    boost::json::object json;
    json["stream_type"]=VKGETQUEUECHECKPOINTDATA2NV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)queue];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkQueue(json["queue"],queue);}();
[&](){
            if (pCheckpointDataCount==NULL){
                json["pCheckpointDataCount"]=boost::json::array();
            return; }json["pCheckpointDataCount"]=boost::json::array(1);
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){arr_LsYqVIK[lgasnOP]=pCheckpointDataCount[lgasnOP];}();
        }
        }();
[&](){
            if (pCheckpointData==NULL){
                json["pCheckpointData"]=boost::json::array();
            return; }json["pCheckpointData"]=boost::json::array(*pCheckpointDataCount);
        auto& arr_jIvYyZg=json["pCheckpointData"].get_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].emplace_object();
            return serialize_struct(temp, pCheckpointData[yGwfptp]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETQUEUECHECKPOINTDATA2NV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkQueue(json["queue"], queue);}();
[&](){
            if (json["pCheckpointDataCount"].get_array().size()==0){
                pCheckpointDataCount=NULL;
            return; }
        auto& arr_LsYqVIK=json["pCheckpointDataCount"].get_array();
        for(int lgasnOP=0; lgasnOP < 1; lgasnOP++){
            [&](){
            if (arr_LsYqVIK[lgasnOP].is_uint64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_uint64());
            }else if (arr_LsYqVIK[lgasnOP].is_int64()){
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_int64());
            }else{
                pCheckpointDataCount[lgasnOP]=static_cast<uint32_t>(arr_LsYqVIK[lgasnOP].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pCheckpointData"].get_array().size()==0){
                pCheckpointData=NULL;
            return; }
        auto& arr_jIvYyZg=json["pCheckpointData"].get_array();
        for(int yGwfptp=0; yGwfptp < *pCheckpointDataCount; yGwfptp++){
            [&](){
            auto& temp=arr_jIvYyZg[yGwfptp].get_object();
            deserialize_struct(temp,pCheckpointData[yGwfptp]);
            }();
        }
        }();

debug_printf("Ending vkGetQueueCheckpointData2NV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToImageEXT( VkDevice device, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToImageEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYMEMORYTOIMAGEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyMemoryToImageInfo==NULL){
                json["pCopyMemoryToImageInfo"]=boost::json::array();
            return; }json["pCopyMemoryToImageInfo"]=boost::json::array(1);
        auto& arr_VVrQQGW=json["pCopyMemoryToImageInfo"].get_array();
        for(int pVINPWa=0; pVINPWa < 1; pVINPWa++){
            [&](){
            auto& temp=arr_VVrQQGW[pVINPWa].emplace_object();
            return serialize_struct(temp, pCopyMemoryToImageInfo[pVINPWa]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_LkGTyEt;[&](){
            if (json["result"].is_uint64()){
                temp_LkGTyEt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_LkGTyEt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_LkGTyEt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_LkGTyEt;}();}();

debug_printf("Ending vkCopyMemoryToImageEXT...\n");
debug_printf("Return value of vkCopyMemoryToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToMemoryEXT( VkDevice device, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToMemoryEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYIMAGETOMEMORYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToMemoryInfo==NULL){
                json["pCopyImageToMemoryInfo"]=boost::json::array();
            return; }json["pCopyImageToMemoryInfo"]=boost::json::array(1);
        auto& arr_uAVSOVI=json["pCopyImageToMemoryInfo"].get_array();
        for(int vveMAPG=0; vveMAPG < 1; vveMAPG++){
            [&](){
            auto& temp=arr_uAVSOVI[vveMAPG].emplace_object();
            return serialize_struct(temp, pCopyImageToMemoryInfo[vveMAPG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_reiMRMs;[&](){
            if (json["result"].is_uint64()){
                temp_reiMRMs=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_reiMRMs=static_cast<int>(json["result"].get_int64());
            }else{
                temp_reiMRMs=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_reiMRMs;}();}();

debug_printf("Ending vkCopyImageToMemoryEXT...\n");
debug_printf("Return value of vkCopyImageToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCopyImageToImageEXT( VkDevice device, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyImageToImageEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYIMAGETOIMAGEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCopyImageToImageInfo==NULL){
                json["pCopyImageToImageInfo"]=boost::json::array();
            return; }json["pCopyImageToImageInfo"]=boost::json::array(1);
        auto& arr_mMvIKFh=json["pCopyImageToImageInfo"].get_array();
        for(int vOMFrGb=0; vOMFrGb < 1; vOMFrGb++){
            [&](){
            auto& temp=arr_mMvIKFh[vOMFrGb].emplace_object();
            return serialize_struct(temp, pCopyImageToImageInfo[vOMFrGb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYIMAGETOIMAGEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_rdZDVxa;[&](){
            if (json["result"].is_uint64()){
                temp_rdZDVxa=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_rdZDVxa=static_cast<int>(json["result"].get_int64());
            }else{
                temp_rdZDVxa=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_rdZDVxa;}();}();

debug_printf("Ending vkCopyImageToImageEXT...\n");
debug_printf("Return value of vkCopyImageToImageEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkTransitionImageLayoutEXT( VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfoEXT* pTransitions ){
//Will only be called by the client
debug_printf("Executing vkTransitionImageLayoutEXT\n");

    boost::json::object json;
    json["stream_type"]=VKTRANSITIONIMAGELAYOUTEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["transitionCount"]=transitionCount;}();
[&](){
            if (pTransitions==NULL){
                json["pTransitions"]=boost::json::array();
            return; }json["pTransitions"]=boost::json::array(transitionCount);
        auto& arr_KQaENWu=json["pTransitions"].get_array();
        for(int EeppCgm=0; EeppCgm < transitionCount; EeppCgm++){
            [&](){
            auto& temp=arr_KQaENWu[EeppCgm].emplace_object();
            return serialize_struct(temp, pTransitions[EeppCgm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKTRANSITIONIMAGELAYOUTEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["transitionCount"].is_uint64()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_uint64());
            }else if (json["transitionCount"].is_int64()){
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_int64());
            }else{
                transitionCount=static_cast<uint32_t>(json["transitionCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_pjFnweb;[&](){
            if (json["result"].is_uint64()){
                temp_pjFnweb=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_pjFnweb=static_cast<int>(json["result"].get_int64());
            }else{
                temp_pjFnweb=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_pjFnweb;}();}();

debug_printf("Ending vkTransitionImageLayoutEXT...\n");
debug_printf("Return value of vkTransitionImageLayoutEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoCapabilitiesKHR( VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoCapabilitiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoProfile==NULL){
                json["pVideoProfile"]=boost::json::array();
            return; }json["pVideoProfile"]=boost::json::array(1);
        auto& arr_eFObkVe=json["pVideoProfile"].get_array();
        for(int YJbJtas=0; YJbJtas < 1; YJbJtas++){
            [&](){
            auto& temp=arr_eFObkVe[YJbJtas].emplace_object();
            return serialize_struct(temp, pVideoProfile[YJbJtas]);
            }();
        }
        }();
[&](){
            if (pCapabilities==NULL){
                json["pCapabilities"]=boost::json::array();
            return; }json["pCapabilities"]=boost::json::array(1);
        auto& arr_rprZzlH=json["pCapabilities"].get_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].emplace_object();
            return serialize_struct(temp, pCapabilities[NPLkdlm]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOCAPABILITIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pCapabilities"].get_array().size()==0){
                pCapabilities=NULL;
            return; }
        auto& arr_rprZzlH=json["pCapabilities"].get_array();
        for(int NPLkdlm=0; NPLkdlm < 1; NPLkdlm++){
            [&](){
            auto& temp=arr_rprZzlH[NPLkdlm].get_object();
            deserialize_struct(temp,pCapabilities[NPLkdlm]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_DRSBHXR;[&](){
            if (json["result"].is_uint64()){
                temp_DRSBHXR=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_DRSBHXR=static_cast<int>(json["result"].get_int64());
            }else{
                temp_DRSBHXR=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_DRSBHXR;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoCapabilitiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoCapabilitiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceVideoFormatPropertiesKHR( VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceVideoFormatPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pVideoFormatInfo==NULL){
                json["pVideoFormatInfo"]=boost::json::array();
            return; }json["pVideoFormatInfo"]=boost::json::array(1);
        auto& arr_JJWKnHz=json["pVideoFormatInfo"].get_array();
        for(int FIocPZR=0; FIocPZR < 1; FIocPZR++){
            [&](){
            auto& temp=arr_JJWKnHz[FIocPZR].emplace_object();
            return serialize_struct(temp, pVideoFormatInfo[FIocPZR]);
            }();
        }
        }();
[&](){
            if (pVideoFormatPropertyCount==NULL){
                json["pVideoFormatPropertyCount"]=boost::json::array();
            return; }json["pVideoFormatPropertyCount"]=boost::json::array(1);
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].get_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){arr_kJoqfTP[hCeCDXk]=pVideoFormatPropertyCount[hCeCDXk];}();
        }
        }();
[&](){
            if (pVideoFormatProperties==NULL){
                json["pVideoFormatProperties"]=boost::json::array();
            return; }json["pVideoFormatProperties"]=boost::json::array(*pVideoFormatPropertyCount);
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].get_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].emplace_object();
            return serialize_struct(temp, pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pVideoFormatPropertyCount"].get_array().size()==0){
                pVideoFormatPropertyCount=NULL;
            return; }
        auto& arr_kJoqfTP=json["pVideoFormatPropertyCount"].get_array();
        for(int hCeCDXk=0; hCeCDXk < 1; hCeCDXk++){
            [&](){
            if (arr_kJoqfTP[hCeCDXk].is_uint64()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_uint64());
            }else if (arr_kJoqfTP[hCeCDXk].is_int64()){
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_int64());
            }else{
                pVideoFormatPropertyCount[hCeCDXk]=static_cast<uint32_t>(arr_kJoqfTP[hCeCDXk].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pVideoFormatProperties"].get_array().size()==0){
                pVideoFormatProperties=NULL;
            return; }
        auto& arr_GhjQGHj=json["pVideoFormatProperties"].get_array();
        for(int mUXWOpX=0; mUXWOpX < *pVideoFormatPropertyCount; mUXWOpX++){
            [&](){
            auto& temp=arr_GhjQGHj[mUXWOpX].get_object();
            deserialize_struct(temp,pVideoFormatProperties[mUXWOpX]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_KDbEDAY;[&](){
            if (json["result"].is_uint64()){
                temp_KDbEDAY=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_KDbEDAY=static_cast<int>(json["result"].get_int64());
            }else{
                temp_KDbEDAY=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_KDbEDAY;}();}();

debug_printf("Ending vkGetPhysicalDeviceVideoFormatPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceVideoFormatPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionKHR( VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEVIDEOSESSIONKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_mCuZMrp=json["pCreateInfo"].get_array();
        for(int tsYbFnY=0; tsYbFnY < 1; tsYbFnY++){
            [&](){
            auto& temp=arr_mCuZMrp[tsYbFnY].emplace_object();
            return serialize_struct(temp, pCreateInfo[tsYbFnY]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSession==NULL){
                json["pVideoSession"]=boost::json::array();
            return; }json["pVideoSession"]=boost::json::array(1);
        auto& arr_YUuHYdT=json["pVideoSession"].get_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){serialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX],pVideoSession[SJFoYbX]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSession"].get_array().size()==0){
                pVideoSession=NULL;
            return; }
        auto& arr_YUuHYdT=json["pVideoSession"].get_array();
        for(int SJFoYbX=0; SJFoYbX < 1; SJFoYbX++){
            [&](){deserialize_VkVideoSessionKHR(arr_YUuHYdT[SJFoYbX], pVideoSession[SJFoYbX]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_dWIUHBt;[&](){
            if (json["result"].is_uint64()){
                temp_dWIUHBt=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_dWIUHBt=static_cast<int>(json["result"].get_int64());
            }else{
                temp_dWIUHBt=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_dWIUHBt;}();}();

                if (pVideoSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionKHR...\n");
debug_printf("Return value of vkCreateVideoSessionKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionKHR( VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYVIDEOSESSIONKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();


debug_printf("Ending vkDestroyVideoSessionKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateVideoSessionParametersKHR( VkDevice device, const VkVideoSessionParametersCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters ){
//Will only be called by the client
debug_printf("Executing vkCreateVideoSessionParametersKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEVIDEOSESSIONPARAMETERSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_PbbIaMM=json["pCreateInfo"].get_array();
        for(int uFIOrHK=0; uFIOrHK < 1; uFIOrHK++){
            [&](){
            auto& temp=arr_PbbIaMM[uFIOrHK].emplace_object();
            return serialize_struct(temp, pCreateInfo[uFIOrHK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pVideoSessionParameters==NULL){
                json["pVideoSessionParameters"]=boost::json::array();
            return; }json["pVideoSessionParameters"]=boost::json::array(1);
        auto& arr_drxJQhO=json["pVideoSessionParameters"].get_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){serialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP],pVideoSessionParameters[VQDtlbP]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pVideoSessionParameters"].get_array().size()==0){
                pVideoSessionParameters=NULL;
            return; }
        auto& arr_drxJQhO=json["pVideoSessionParameters"].get_array();
        for(int VQDtlbP=0; VQDtlbP < 1; VQDtlbP++){
            [&](){deserialize_VkVideoSessionParametersKHR(arr_drxJQhO[VQDtlbP], pVideoSessionParameters[VQDtlbP]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_sWaVcNh;[&](){
            if (json["result"].is_uint64()){
                temp_sWaVcNh=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_sWaVcNh=static_cast<int>(json["result"].get_int64());
            }else{
                temp_sWaVcNh=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_sWaVcNh;}();}();

                if (pVideoSessionParameters!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pVideoSessionParameters[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkCreateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUpdateVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo ){
//Will only be called by the client
debug_printf("Executing vkUpdateVideoSessionParametersKHR\n");

    boost::json::object json;
    json["stream_type"]=VKUPDATEVIDEOSESSIONPARAMETERSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pUpdateInfo==NULL){
                json["pUpdateInfo"]=boost::json::array();
            return; }json["pUpdateInfo"]=boost::json::array(1);
        auto& arr_miOYaCQ=json["pUpdateInfo"].get_array();
        for(int gnypMkA=0; gnypMkA < 1; gnypMkA++){
            [&](){
            auto& temp=arr_miOYaCQ[gnypMkA].emplace_object();
            return serialize_struct(temp, pUpdateInfo[gnypMkA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUPDATEVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();

VkResult result;
[&](){[&](){int temp_EZpQGsU;[&](){
            if (json["result"].is_uint64()){
                temp_EZpQGsU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_EZpQGsU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_EZpQGsU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_EZpQGsU;}();}();

debug_printf("Ending vkUpdateVideoSessionParametersKHR...\n");
debug_printf("Return value of vkUpdateVideoSessionParametersKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyVideoSessionParametersKHR( VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyVideoSessionParametersKHR\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYVIDEOSESSIONPARAMETERSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionParametersKHR(json["videoSessionParameters"],videoSessionParameters);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYVIDEOSESSIONPARAMETERSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionParametersKHR(json["videoSessionParameters"], videoSessionParameters);}();


debug_printf("Ending vkDestroyVideoSessionParametersKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetVideoSessionMemoryRequirementsKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements ){
//Will only be called by the client
debug_printf("Executing vkGetVideoSessionMemoryRequirementsKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){
            if (pMemoryRequirementsCount==NULL){
                json["pMemoryRequirementsCount"]=boost::json::array();
            return; }json["pMemoryRequirementsCount"]=boost::json::array(1);
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].get_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){arr_pJPineF[NMpDmPR]=pMemoryRequirementsCount[NMpDmPR];}();
        }
        }();
[&](){
            if (pMemoryRequirements==NULL){
                json["pMemoryRequirements"]=boost::json::array();
            return; }json["pMemoryRequirements"]=boost::json::array(*pMemoryRequirementsCount);
        auto& arr_UuJQZUu=json["pMemoryRequirements"].get_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].emplace_object();
            return serialize_struct(temp, pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETVIDEOSESSIONMEMORYREQUIREMENTSKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){
            if (json["pMemoryRequirementsCount"].get_array().size()==0){
                pMemoryRequirementsCount=NULL;
            return; }
        auto& arr_pJPineF=json["pMemoryRequirementsCount"].get_array();
        for(int NMpDmPR=0; NMpDmPR < 1; NMpDmPR++){
            [&](){
            if (arr_pJPineF[NMpDmPR].is_uint64()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_uint64());
            }else if (arr_pJPineF[NMpDmPR].is_int64()){
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_int64());
            }else{
                pMemoryRequirementsCount[NMpDmPR]=static_cast<uint32_t>(arr_pJPineF[NMpDmPR].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pMemoryRequirements"].get_array().size()==0){
                pMemoryRequirements=NULL;
            return; }
        auto& arr_UuJQZUu=json["pMemoryRequirements"].get_array();
        for(int FfNBlzG=0; FfNBlzG < *pMemoryRequirementsCount; FfNBlzG++){
            [&](){
            auto& temp=arr_UuJQZUu[FfNBlzG].get_object();
            deserialize_struct(temp,pMemoryRequirements[FfNBlzG]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_bfyMKzS;[&](){
            if (json["result"].is_uint64()){
                temp_bfyMKzS=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_bfyMKzS=static_cast<int>(json["result"].get_int64());
            }else{
                temp_bfyMKzS=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_bfyMKzS;}();}();

debug_printf("Ending vkGetVideoSessionMemoryRequirementsKHR...\n");
debug_printf("Return value of vkGetVideoSessionMemoryRequirementsKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkBindVideoSessionMemoryKHR( VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos ){
//Will only be called by the client
debug_printf("Executing vkBindVideoSessionMemoryKHR\n");

    boost::json::object json;
    json["stream_type"]=VKBINDVIDEOSESSIONMEMORYKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkVideoSessionKHR(json["videoSession"],videoSession);}();
[&](){json["bindSessionMemoryInfoCount"]=bindSessionMemoryInfoCount;}();
[&](){
            if (pBindSessionMemoryInfos==NULL){
                json["pBindSessionMemoryInfos"]=boost::json::array();
            return; }json["pBindSessionMemoryInfos"]=boost::json::array(bindSessionMemoryInfoCount);
        auto& arr_XamFtca=json["pBindSessionMemoryInfos"].get_array();
        for(int bWiRCGV=0; bWiRCGV < bindSessionMemoryInfoCount; bWiRCGV++){
            [&](){
            auto& temp=arr_XamFtca[bWiRCGV].emplace_object();
            return serialize_struct(temp, pBindSessionMemoryInfos[bWiRCGV]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDVIDEOSESSIONMEMORYKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkVideoSessionKHR(json["videoSession"], videoSession);}();
[&](){
            if (json["bindSessionMemoryInfoCount"].is_uint64()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_uint64());
            }else if (json["bindSessionMemoryInfoCount"].is_int64()){
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_int64());
            }else{
                bindSessionMemoryInfoCount=static_cast<uint32_t>(json["bindSessionMemoryInfoCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_VaKszLh;[&](){
            if (json["result"].is_uint64()){
                temp_VaKszLh=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VaKszLh=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VaKszLh=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VaKszLh;}();}();

debug_printf("Ending vkBindVideoSessionMemoryKHR...\n");
debug_printf("Return value of vkBindVideoSessionMemoryKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdDecodeVideoKHR( VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdDecodeVideoKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDECODEVIDEOKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDecodeInfo==NULL){
                json["pDecodeInfo"]=boost::json::array();
            return; }json["pDecodeInfo"]=boost::json::array(1);
        auto& arr_FUuNCSo=json["pDecodeInfo"].get_array();
        for(int jmrOltD=0; jmrOltD < 1; jmrOltD++){
            [&](){
            auto& temp=arr_FUuNCSo[jmrOltD].emplace_object();
            return serialize_struct(temp, pDecodeInfo[jmrOltD]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECODEVIDEOKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdDecodeVideoKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginVideoCodingKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINVIDEOCODINGKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pBeginInfo==NULL){
                json["pBeginInfo"]=boost::json::array();
            return; }json["pBeginInfo"]=boost::json::array(1);
        auto& arr_pSWbqZw=json["pBeginInfo"].get_array();
        for(int tVSxYNW=0; tVSxYNW < 1; tVSxYNW++){
            [&](){
            auto& temp=arr_pSWbqZw[tVSxYNW].emplace_object();
            return serialize_struct(temp, pBeginInfo[tVSxYNW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdControlVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdControlVideoCodingKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCONTROLVIDEOCODINGKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pCodingControlInfo==NULL){
                json["pCodingControlInfo"]=boost::json::array();
            return; }json["pCodingControlInfo"]=boost::json::array(1);
        auto& arr_vJmaWsp=json["pCodingControlInfo"].get_array();
        for(int MLwaMsn=0; MLwaMsn < 1; MLwaMsn++){
            [&](){
            auto& temp=arr_vJmaWsp[MLwaMsn].emplace_object();
            return serialize_struct(temp, pCodingControlInfo[MLwaMsn]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCONTROLVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdControlVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndVideoCodingKHR( VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdEndVideoCodingKHR\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDVIDEOCODINGKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pEndCodingInfo==NULL){
                json["pEndCodingInfo"]=boost::json::array();
            return; }json["pEndCodingInfo"]=boost::json::array(1);
        auto& arr_OpexQSo=json["pEndCodingInfo"].get_array();
        for(int KxwYkSG=0; KxwYkSG < 1; KxwYkSG++){
            [&](){
            auto& temp=arr_OpexQSo[KxwYkSG].emplace_object();
            return serialize_struct(temp, pEndCodingInfo[KxwYkSG]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDVIDEOCODINGKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdEndVideoCodingKHR...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryNV( VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDECOMPRESSMEMORYNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["decompressRegionCount"]=decompressRegionCount;}();
[&](){
            if (pDecompressMemoryRegions==NULL){
                json["pDecompressMemoryRegions"]=boost::json::array();
            return; }json["pDecompressMemoryRegions"]=boost::json::array(decompressRegionCount);
        auto& arr_oMszjDS=json["pDecompressMemoryRegions"].get_array();
        for(int PnFzdhd=0; PnFzdhd < decompressRegionCount; PnFzdhd++){
            [&](){
            auto& temp=arr_oMszjDS[PnFzdhd].emplace_object();
            return serialize_struct(temp, pDecompressMemoryRegions[PnFzdhd]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["decompressRegionCount"].is_uint64()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_uint64());
            }else if (json["decompressRegionCount"].is_int64()){
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_int64());
            }else{
                decompressRegionCount=static_cast<uint32_t>(json["decompressRegionCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdDecompressMemoryNV...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdDecompressMemoryIndirectCountNV( VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride ){
//Will only be called by the client
debug_printf("Executing vkCmdDecompressMemoryIndirectCountNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){json["indirectCommandsAddress"]=indirectCommandsAddress;}();}();
[&](){[&](){json["indirectCommandsCountAddress"]=indirectCommandsCountAddress;}();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDDECOMPRESSMEMORYINDIRECTCOUNTNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){uint64_t temp_nwmsRdL;[&](){
            if (json["indirectCommandsAddress"].is_uint64()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_uint64());
            }else if (json["indirectCommandsAddress"].is_int64()){
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_int64());
            }else{
                temp_nwmsRdL=static_cast<uint64_t>(json["indirectCommandsAddress"].get_double());
            }
            }();indirectCommandsAddress=(VkDeviceAddress)temp_nwmsRdL;}();
[&](){uint64_t temp_TcxQHrV;[&](){
            if (json["indirectCommandsCountAddress"].is_uint64()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_uint64());
            }else if (json["indirectCommandsCountAddress"].is_int64()){
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_int64());
            }else{
                temp_TcxQHrV=static_cast<uint64_t>(json["indirectCommandsCountAddress"].get_double());
            }
            }();indirectCommandsCountAddress=(VkDeviceAddress)temp_TcxQHrV;}();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<uint32_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<uint32_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<uint32_t>(json["stride"].get_double());
            }
            }();

debug_printf("Ending vkCmdDecompressMemoryIndirectCountNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuModuleNVX( VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule ){
//Will only be called by the client
debug_printf("Executing vkCreateCuModuleNVX\n");

    boost::json::object json;
    json["stream_type"]=VKCREATECUMODULENVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_FjdqPXh=json["pCreateInfo"].get_array();
        for(int TUVhIjf=0; TUVhIjf < 1; TUVhIjf++){
            [&](){
            auto& temp=arr_FjdqPXh[TUVhIjf].emplace_object();
            return serialize_struct(temp, pCreateInfo[TUVhIjf]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pModule==NULL){
                json["pModule"]=boost::json::array();
            return; }json["pModule"]=boost::json::array(1);
        auto& arr_FnQIexZ=json["pModule"].get_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){serialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko],pModule[ozltKko]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pModule"].get_array().size()==0){
                pModule=NULL;
            return; }
        auto& arr_FnQIexZ=json["pModule"].get_array();
        for(int ozltKko=0; ozltKko < 1; ozltKko++){
            [&](){deserialize_VkCuModuleNVX(arr_FnQIexZ[ozltKko], pModule[ozltKko]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_yCFJkOi;[&](){
            if (json["result"].is_uint64()){
                temp_yCFJkOi=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yCFJkOi=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yCFJkOi=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yCFJkOi;}();}();

                if (pModule!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pModule[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuModuleNVX...\n");
debug_printf("Return value of vkCreateCuModuleNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateCuFunctionNVX( VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction ){
//Will only be called by the client
debug_printf("Executing vkCreateCuFunctionNVX\n");

    boost::json::object json;
    json["stream_type"]=VKCREATECUFUNCTIONNVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_XkBojZi=json["pCreateInfo"].get_array();
        for(int twsSgji=0; twsSgji < 1; twsSgji++){
            [&](){
            auto& temp=arr_XkBojZi[twsSgji].emplace_object();
            return serialize_struct(temp, pCreateInfo[twsSgji]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pFunction==NULL){
                json["pFunction"]=boost::json::array();
            return; }json["pFunction"]=boost::json::array(1);
        auto& arr_TrIYEcP=json["pFunction"].get_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){serialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF],pFunction[zzRpTQF]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATECUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pFunction"].get_array().size()==0){
                pFunction=NULL;
            return; }
        auto& arr_TrIYEcP=json["pFunction"].get_array();
        for(int zzRpTQF=0; zzRpTQF < 1; zzRpTQF++){
            [&](){deserialize_VkCuFunctionNVX(arr_TrIYEcP[zzRpTQF], pFunction[zzRpTQF]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_rHMlbiM;[&](){
            if (json["result"].is_uint64()){
                temp_rHMlbiM=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_rHMlbiM=static_cast<int>(json["result"].get_int64());
            }else{
                temp_rHMlbiM=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_rHMlbiM;}();}();

                if (pFunction!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pFunction[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateCuFunctionNVX...\n");
debug_printf("Return value of vkCreateCuFunctionNVX is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyCuModuleNVX( VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuModuleNVX\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYCUMODULENVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuModuleNVX(json["module"],module);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUMODULENVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuModuleNVX(json["module"], module);}();


debug_printf("Ending vkDestroyCuModuleNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkDestroyCuFunctionNVX( VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyCuFunctionNVX\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYCUFUNCTIONNVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkCuFunctionNVX(json["function"],function);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYCUFUNCTIONNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkCuFunctionNVX(json["function"], function);}();


debug_printf("Ending vkDestroyCuFunctionNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCuLaunchKernelNVX( VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCuLaunchKernelNVX\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCULAUNCHKERNELNVX;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pLaunchInfo==NULL){
                json["pLaunchInfo"]=boost::json::array();
            return; }json["pLaunchInfo"]=boost::json::array(1);
        auto& arr_UKYVund=json["pLaunchInfo"].get_array();
        for(int eUSpbRB=0; eUSpbRB < 1; eUSpbRB++){
            [&](){
            auto& temp=arr_UKYVund[eUSpbRB].emplace_object();
            return serialize_struct(temp, pLaunchInfo[eUSpbRB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCULAUNCHKERNELNVX):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCuLaunchKernelNVX...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutSizeEXT( VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutSizeEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTORSETLAYOUTSIZEEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){
            if (pLayoutSizeInBytes==NULL){
                json["pLayoutSizeInBytes"]=boost::json::array();
            return; }json["pLayoutSizeInBytes"]=boost::json::array(1);
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].get_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){[&](){arr_xOYiCiO[QcQjmSi]=pLayoutSizeInBytes[QcQjmSi];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTSIZEEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){
            if (json["pLayoutSizeInBytes"].get_array().size()==0){
                pLayoutSizeInBytes=NULL;
            return; }
        auto& arr_xOYiCiO=json["pLayoutSizeInBytes"].get_array();
        for(int QcQjmSi=0; QcQjmSi < 1; QcQjmSi++){
            [&](){uint64_t temp_xOYiCiO;[&](){
            if (arr_xOYiCiO[QcQjmSi].is_uint64()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_uint64());
            }else if (arr_xOYiCiO[QcQjmSi].is_int64()){
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_int64());
            }else{
                temp_xOYiCiO=static_cast<uint64_t>(arr_xOYiCiO[QcQjmSi].get_double());
            }
            }();pLayoutSizeInBytes[QcQjmSi]=(VkDeviceSize)temp_xOYiCiO;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutSizeEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutBindingOffsetEXT( VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutBindingOffsetEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSetLayout(json["layout"],layout);}();
[&](){json["binding"]=binding;}();
[&](){
            if (pOffset==NULL){
                json["pOffset"]=boost::json::array();
            return; }json["pOffset"]=boost::json::array(1);
        auto& arr_dquZgZN=json["pOffset"].get_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){[&](){arr_dquZgZN[LNetLnu]=pOffset[LNetLnu];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSetLayout(json["layout"], layout);}();
[&](){
            if (json["binding"].is_uint64()){
                binding=static_cast<uint32_t>(json["binding"].get_uint64());
            }else if (json["binding"].is_int64()){
                binding=static_cast<uint32_t>(json["binding"].get_int64());
            }else{
                binding=static_cast<uint32_t>(json["binding"].get_double());
            }
            }();
[&](){
            if (json["pOffset"].get_array().size()==0){
                pOffset=NULL;
            return; }
        auto& arr_dquZgZN=json["pOffset"].get_array();
        for(int LNetLnu=0; LNetLnu < 1; LNetLnu++){
            [&](){uint64_t temp_dquZgZN;[&](){
            if (arr_dquZgZN[LNetLnu].is_uint64()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_uint64());
            }else if (arr_dquZgZN[LNetLnu].is_int64()){
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_int64());
            }else{
                temp_dquZgZN=static_cast<uint64_t>(arr_dquZgZN[LNetLnu].get_double());
            }
            }();pOffset[LNetLnu]=(VkDeviceSize)temp_dquZgZN;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutBindingOffsetEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorEXT( VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTOREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pDescriptorInfo==NULL){
                json["pDescriptorInfo"]=boost::json::array();
            return; }json["pDescriptorInfo"]=boost::json::array(1);
        auto& arr_RGgHhwd=json["pDescriptorInfo"].get_array();
        for(int cdcTeyn=0; cdcTeyn < 1; cdcTeyn++){
            [&](){
            auto& temp=arr_RGgHhwd[cdcTeyn].emplace_object();
            return serialize_struct(temp, pDescriptorInfo[cdcTeyn]);
            }();
        }
        }();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pDescriptor==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }[&](){
            if (((char*)(pDescriptor))==NULL){
                json["pDescriptor"]=boost::json::array();
            return; }json["pDescriptor"]=boost::json::array(dataSize);
        auto& arr_NUAdiYW=json["pDescriptor"].get_array();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){arr_NUAdiYW[skXTLXg]=((char*)(pDescriptor))[skXTLXg];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTOREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pDescriptor"].get_array().size()==0){
                pDescriptor=NULL;
            return; }char* temp_mEHYUhJ;[&](){
            if (json["pDescriptor"].get_array().size()==0){
                temp_mEHYUhJ=NULL;
            return; }temp_mEHYUhJ=(char*)malloc(dataSize*sizeof(char));
        auto& arr_NUAdiYW=json["pDescriptor"].get_array();
        for(int skXTLXg=0; skXTLXg < dataSize; skXTLXg++){
            [&](){
            if (arr_NUAdiYW[skXTLXg].is_uint64()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_uint64());
            }else if (arr_NUAdiYW[skXTLXg].is_int64()){
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_int64());
            }else{
                temp_mEHYUhJ[skXTLXg]=static_cast<char>(arr_NUAdiYW[skXTLXg].get_double());
            }
            }();
        }
        }();pDescriptor=temp_mEHYUhJ;}();

debug_printf("Ending vkGetDescriptorEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBuffersEXT( VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBuffersEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDDESCRIPTORBUFFERSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["bufferCount"]=bufferCount;}();
[&](){
            if (pBindingInfos==NULL){
                json["pBindingInfos"]=boost::json::array();
            return; }json["pBindingInfos"]=boost::json::array(bufferCount);
        auto& arr_guwgqGC=json["pBindingInfos"].get_array();
        for(int btgeqwi=0; btgeqwi < bufferCount; btgeqwi++){
            [&](){
            auto& temp=arr_guwgqGC[btgeqwi].emplace_object();
            return serialize_struct(temp, pBindingInfos[btgeqwi]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["bufferCount"].is_uint64()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_uint64());
            }else if (json["bufferCount"].is_int64()){
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_int64());
            }else{
                bufferCount=static_cast<uint32_t>(json["bufferCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdBindDescriptorBuffersEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdSetDescriptorBufferOffsetsEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDescriptorBufferOffsetsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDESCRIPTORBUFFEROFFSETSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["firstSet"]=firstSet;}();
[&](){json["setCount"]=setCount;}();
[&](){
            if (pBufferIndices==NULL){
                json["pBufferIndices"]=boost::json::array();
            return; }json["pBufferIndices"]=boost::json::array(setCount);
        auto& arr_zejaAgt=json["pBufferIndices"].get_array();
        for(int tuuKbsL=0; tuuKbsL < setCount; tuuKbsL++){
            [&](){arr_zejaAgt[tuuKbsL]=pBufferIndices[tuuKbsL];}();
        }
        }();
[&](){
            if (pOffsets==NULL){
                json["pOffsets"]=boost::json::array();
            return; }json["pOffsets"]=boost::json::array(setCount);
        auto& arr_YvpyTDd=json["pOffsets"].get_array();
        for(int ySwhvse=0; ySwhvse < setCount; ySwhvse++){
            [&](){[&](){arr_YvpyTDd[ySwhvse]=pOffsets[ySwhvse];}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDESCRIPTORBUFFEROFFSETSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["firstSet"].is_uint64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_uint64());
            }else if (json["firstSet"].is_int64()){
                firstSet=static_cast<uint32_t>(json["firstSet"].get_int64());
            }else{
                firstSet=static_cast<uint32_t>(json["firstSet"].get_double());
            }
            }();
[&](){
            if (json["setCount"].is_uint64()){
                setCount=static_cast<uint32_t>(json["setCount"].get_uint64());
            }else if (json["setCount"].is_int64()){
                setCount=static_cast<uint32_t>(json["setCount"].get_int64());
            }else{
                setCount=static_cast<uint32_t>(json["setCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdSetDescriptorBufferOffsetsEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBindDescriptorBufferEmbeddedSamplersEXT( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set ){
//Will only be called by the client
debug_printf("Executing vkCmdBindDescriptorBufferEmbeddedSamplersEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){[&](){[&](){json["pipelineBindPoint"]=pipelineBindPoint;}();}();}();
[&](){serialize_VkPipelineLayout(json["layout"],layout);}();
[&](){json["set"]=set;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){[&](){int temp_Hfcuzju;[&](){
            if (json["pipelineBindPoint"].is_uint64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_uint64());
            }else if (json["pipelineBindPoint"].is_int64()){
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_int64());
            }else{
                temp_Hfcuzju=static_cast<int>(json["pipelineBindPoint"].get_double());
            }
            }();pipelineBindPoint=(VkPipelineBindPoint)temp_Hfcuzju;}();}();
[&](){deserialize_VkPipelineLayout(json["layout"], layout);}();
[&](){
            if (json["set"].is_uint64()){
                set=static_cast<uint32_t>(json["set"].get_uint64());
            }else if (json["set"].is_int64()){
                set=static_cast<uint32_t>(json["set"].get_int64());
            }else{
                set=static_cast<uint32_t>(json["set"].get_double());
            }
            }();

debug_printf("Ending vkCmdBindDescriptorBufferEmbeddedSamplersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetBufferOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetBufferOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_Hxvezrr=json["pInfo"].get_array();
        for(int VgzeNwX=0; VgzeNwX < 1; VgzeNwX++){
            [&](){
            auto& temp=arr_Hxvezrr[VgzeNwX].emplace_object();
            return serialize_struct(temp, pInfo[VgzeNwX]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_BreRMSA;[&](){
            if (json["result"].is_uint64()){
                temp_BreRMSA=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_BreRMSA=static_cast<int>(json["result"].get_int64());
            }else{
                temp_BreRMSA=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_BreRMSA;}();}();

debug_printf("Ending vkGetBufferOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetBufferOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_vrxBIsi=json["pInfo"].get_array();
        for(int swRpuDc=0; swRpuDc < 1; swRpuDc++){
            [&](){
            auto& temp=arr_vrxBIsi[swRpuDc].emplace_object();
            return serialize_struct(temp, pInfo[swRpuDc]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_PrnsDXW;[&](){
            if (json["result"].is_uint64()){
                temp_PrnsDXW=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_PrnsDXW=static_cast<int>(json["result"].get_int64());
            }else{
                temp_PrnsDXW=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_PrnsDXW;}();}();

debug_printf("Ending vkGetImageOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetImageViewOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetImageViewOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_CYlSaQv=json["pInfo"].get_array();
        for(int pmdADqD=0; pmdADqD < 1; pmdADqD++){
            [&](){
            auto& temp=arr_CYlSaQv[pmdADqD].emplace_object();
            return serialize_struct(temp, pInfo[pmdADqD]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_UkGTadX;[&](){
            if (json["result"].is_uint64()){
                temp_UkGTadX=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_UkGTadX=static_cast<int>(json["result"].get_int64());
            }else{
                temp_UkGTadX=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_UkGTadX;}();}();

debug_printf("Ending vkGetImageViewOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetImageViewOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetSamplerOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetSamplerOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_RMPxsVS=json["pInfo"].get_array();
        for(int SScNLQN=0; SScNLQN < 1; SScNLQN++){
            [&](){
            auto& temp=arr_RMPxsVS[SScNLQN].emplace_object();
            return serialize_struct(temp, pInfo[SScNLQN]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_qhwUZoX;[&](){
            if (json["result"].is_uint64()){
                temp_qhwUZoX=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_qhwUZoX=static_cast<int>(json["result"].get_int64());
            }else{
                temp_qhwUZoX=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_qhwUZoX;}();}();

debug_printf("Ending vkGetSamplerOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetSamplerOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT( VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_iLnHGmk=json["pInfo"].get_array();
        for(int kbTuVMH=0; kbTuVMH < 1; kbTuVMH++){
            [&](){
            auto& temp=arr_iLnHGmk[kbTuVMH].emplace_object();
            return serialize_struct(temp, pInfo[kbTuVMH]);
            }();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(strlen(((char*)(pData)))+1);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < strlen(((char*)(pData)))+1; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_lBHICWs;[&](){
            if (json["pData"].get_array().size()==0){
                temp_lBHICWs=NULL;
            return; }temp_lBHICWs=(char*)malloc(json["pData"].get_array().size()*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < json["pData"].get_array().size(); tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_lBHICWs[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_lBHICWs;}();
VkResult result;
[&](){[&](){int temp_EdBxllU;[&](){
            if (json["result"].is_uint64()){
                temp_EdBxllU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_EdBxllU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_EdBxllU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_EdBxllU;}();}();

debug_printf("Ending vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT...\n");
debug_printf("Return value of vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkSetDeviceMemoryPriorityEXT( VkDevice device, VkDeviceMemory memory, float priority ){
//Will only be called by the client
debug_printf("Executing vkSetDeviceMemoryPriorityEXT\n");

    boost::json::object json;
    json["stream_type"]=VKSETDEVICEMEMORYPRIORITYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeviceMemory(json["memory"],memory);}();
[&](){json["priority"]=priority;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKSETDEVICEMEMORYPRIORITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeviceMemory(json["memory"], memory);}();
[&](){
            if (json["priority"].is_uint64()){
                priority=static_cast<float>(json["priority"].get_uint64());
            }else if (json["priority"].is_int64()){
                priority=static_cast<float>(json["priority"].get_int64());
            }else{
                priority=static_cast<float>(json["priority"].get_double());
            }
            }();

debug_printf("Ending vkSetDeviceMemoryPriorityEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkAcquireDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display ){
//Will only be called by the client
debug_printf("Executing vkAcquireDrmDisplayEXT\n");

    boost::json::object json;
    json["stream_type"]=VKACQUIREDRMDISPLAYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){serialize_VkDisplayKHR(json["display"],display);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKACQUIREDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["drmFd"].is_uint64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_uint64());
            }else if (json["drmFd"].is_int64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_int64());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].get_double());
            }
            }();
[&](){deserialize_VkDisplayKHR(json["display"], display);}();
VkResult result;
[&](){[&](){int temp_VLASVci;[&](){
            if (json["result"].is_uint64()){
                temp_VLASVci=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_VLASVci=static_cast<int>(json["result"].get_int64());
            }else{
                temp_VLASVci=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_VLASVci;}();}();

debug_printf("Ending vkAcquireDrmDisplayEXT...\n");
debug_printf("Return value of vkAcquireDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDrmDisplayEXT( VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display ){
//Will only be called by the client
debug_printf("Executing vkGetDrmDisplayEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDRMDISPLAYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){json["drmFd"]=drmFd;}();
[&](){json["connectorId"]=connectorId;}();
[&](){
            if (display==NULL){
                json["display"]=boost::json::array();
            return; }json["display"]=boost::json::array(1);
        auto& arr_DpFHFgI=json["display"].get_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){serialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA],display[AVVxOCA]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDRMDISPLAYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["drmFd"].is_uint64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_uint64());
            }else if (json["drmFd"].is_int64()){
                drmFd=static_cast<int32_t>(json["drmFd"].get_int64());
            }else{
                drmFd=static_cast<int32_t>(json["drmFd"].get_double());
            }
            }();
[&](){
            if (json["connectorId"].is_uint64()){
                connectorId=static_cast<uint32_t>(json["connectorId"].get_uint64());
            }else if (json["connectorId"].is_int64()){
                connectorId=static_cast<uint32_t>(json["connectorId"].get_int64());
            }else{
                connectorId=static_cast<uint32_t>(json["connectorId"].get_double());
            }
            }();
[&](){
            if (json["display"].get_array().size()==0){
                display=NULL;
            return; }
        auto& arr_DpFHFgI=json["display"].get_array();
        for(int AVVxOCA=0; AVVxOCA < 1; AVVxOCA++){
            [&](){deserialize_VkDisplayKHR(arr_DpFHFgI[AVVxOCA], display[AVVxOCA]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_pCKulNk;[&](){
            if (json["result"].is_uint64()){
                temp_pCKulNk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_pCKulNk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_pCKulNk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_pCKulNk;}();}();

debug_printf("Ending vkGetDrmDisplayEXT...\n");
debug_printf("Return value of vkGetDrmDisplayEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkWaitForPresentKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout ){
//Will only be called by the client
debug_printf("Executing vkWaitForPresentKHR\n");

    boost::json::object json;
    json["stream_type"]=VKWAITFORPRESENTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkSwapchainKHR(json["swapchain"],swapchain);}();
[&](){json["presentId"]=presentId;}();
[&](){json["timeout"]=timeout;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWAITFORPRESENTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkSwapchainKHR(json["swapchain"], swapchain);}();
[&](){
            if (json["presentId"].is_uint64()){
                presentId=static_cast<uint64_t>(json["presentId"].get_uint64());
            }else if (json["presentId"].is_int64()){
                presentId=static_cast<uint64_t>(json["presentId"].get_int64());
            }else{
                presentId=static_cast<uint64_t>(json["presentId"].get_double());
            }
            }();
[&](){
            if (json["timeout"].is_uint64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_uint64());
            }else if (json["timeout"].is_int64()){
                timeout=static_cast<uint64_t>(json["timeout"].get_int64());
            }else{
                timeout=static_cast<uint64_t>(json["timeout"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_GxvXpqW;[&](){
            if (json["result"].is_uint64()){
                temp_GxvXpqW=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_GxvXpqW=static_cast<int>(json["result"].get_int64());
            }else{
                temp_GxvXpqW=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_GxvXpqW;}();}();

debug_printf("Ending vkWaitForPresentKHR...\n");
debug_printf("Return value of vkWaitForPresentKHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRendering( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdBeginRendering\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBEGINRENDERING;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }json["pRenderingInfo"]=boost::json::array(1);
        auto& arr_DOEgrev=json["pRenderingInfo"].get_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBEGINRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdBeginRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdBeginRenderingKHR( VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo ){
return vkCmdBeginRendering(commandBuffer, pRenderingInfo);
}
__attribute__((visibility ("hidden"))) void vkCmdEndRendering( VkCommandBuffer commandBuffer ){
//Will only be called by the client
debug_printf("Executing vkCmdEndRendering\n");

    boost::json::object json;
    json["stream_type"]=VKCMDENDRENDERING;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDENDRENDERING):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();

debug_printf("Ending vkCmdEndRendering...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdEndRenderingKHR( VkCommandBuffer commandBuffer ){
return vkCmdEndRendering(commandBuffer);
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetLayoutHostMappingInfoVALVE( VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetLayoutHostMappingInfoVALVE\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pBindingReference==NULL){
                json["pBindingReference"]=boost::json::array();
            return; }json["pBindingReference"]=boost::json::array(1);
        auto& arr_JTmPGZt=json["pBindingReference"].get_array();
        for(int OEumPxJ=0; OEumPxJ < 1; OEumPxJ++){
            [&](){
            auto& temp=arr_JTmPGZt[OEumPxJ].emplace_object();
            return serialize_struct(temp, pBindingReference[OEumPxJ]);
            }();
        }
        }();
[&](){
            if (pHostMapping==NULL){
                json["pHostMapping"]=boost::json::array();
            return; }json["pHostMapping"]=boost::json::array(1);
        auto& arr_zODJzpL=json["pHostMapping"].get_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].emplace_object();
            return serialize_struct(temp, pHostMapping[jHGvhna]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pHostMapping"].get_array().size()==0){
                pHostMapping=NULL;
            return; }
        auto& arr_zODJzpL=json["pHostMapping"].get_array();
        for(int jHGvhna=0; jHGvhna < 1; jHGvhna++){
            [&](){
            auto& temp=arr_zODJzpL[jHGvhna].get_object();
            deserialize_struct(temp,pHostMapping[jHGvhna]);
            }();
        }
        }();

debug_printf("Ending vkGetDescriptorSetLayoutHostMappingInfoVALVE...\n");
}
__attribute__((visibility ("hidden"))) void vkGetDescriptorSetHostMappingVALVE( VkDevice device, VkDescriptorSet descriptorSet, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkGetDescriptorSetHostMappingVALVE\n");

    boost::json::object json;
    json["stream_type"]=VKGETDESCRIPTORSETHOSTMAPPINGVALVE;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDescriptorSet(json["descriptorSet"],descriptorSet);}();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }arr_JgRLJSK[NsRFkBj]=boost::json::array(strlen(((char*)(ppData[NsRFkBj])))+1);
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[NsRFkBj]))[jYdchEs];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDESCRIPTORSETHOSTMAPPINGVALVE):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDescriptorSet(json["descriptorSet"], descriptorSet);}();
[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].get_array().size()*sizeof(char));
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].get_array().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();

debug_printf("Ending vkGetDescriptorSetHostMappingVALVE...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCreateMicromapEXT( VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap ){
//Will only be called by the client
debug_printf("Executing vkCreateMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_vrQtrYo=json["pCreateInfo"].get_array();
        for(int cfhYIUK=0; cfhYIUK < 1; cfhYIUK++){
            [&](){
            auto& temp=arr_vrQtrYo[cfhYIUK].emplace_object();
            return serialize_struct(temp, pCreateInfo[cfhYIUK]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pMicromap==NULL){
                json["pMicromap"]=boost::json::array();
            return; }json["pMicromap"]=boost::json::array(1);
        auto& arr_mHmzwPX=json["pMicromap"].get_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){serialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm],pMicromap[vcxNgSm]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pMicromap"].get_array().size()==0){
                pMicromap=NULL;
            return; }
        auto& arr_mHmzwPX=json["pMicromap"].get_array();
        for(int vcxNgSm=0; vcxNgSm < 1; vcxNgSm++){
            [&](){deserialize_VkMicromapEXT(arr_mHmzwPX[vcxNgSm], pMicromap[vcxNgSm]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_kPZvlkz;[&](){
            if (json["result"].is_uint64()){
                temp_kPZvlkz=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_kPZvlkz=static_cast<int>(json["result"].get_int64());
            }else{
                temp_kPZvlkz=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_kPZvlkz;}();}();

                if (pMicromap!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pMicromap[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateMicromapEXT...\n");
debug_printf("Return value of vkCreateMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBuildMicromapsEXT( VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkCmdBuildMicromapsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBUILDMICROMAPSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_KdoluBZ=json["pInfos"].get_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();


debug_printf("Ending vkCmdBuildMicromapsEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBuildMicromapsEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos ){
//Will only be called by the client
debug_printf("Executing vkBuildMicromapsEXT\n");

    boost::json::object json;
    json["stream_type"]=VKBUILDMICROMAPSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){json["infoCount"]=infoCount;}();
[&](){
            if (pInfos==NULL){
                json["pInfos"]=boost::json::array();
            return; }json["pInfos"]=boost::json::array(infoCount);
        auto& arr_KdoluBZ=json["pInfos"].get_array();
        for(int bfMWBOA=0; bfMWBOA < infoCount; bfMWBOA++){
            [&](){
            auto& temp=arr_KdoluBZ[bfMWBOA].emplace_object();
            return serialize_struct(temp, pInfos[bfMWBOA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBUILDMICROMAPSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();
[&](){
            if (json["infoCount"].is_uint64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_uint64());
            }else if (json["infoCount"].is_int64()){
                infoCount=static_cast<uint32_t>(json["infoCount"].get_int64());
            }else{
                infoCount=static_cast<uint32_t>(json["infoCount"].get_double());
            }
            }();

VkResult result;
[&](){[&](){int temp_UtJGuJG;[&](){
            if (json["result"].is_uint64()){
                temp_UtJGuJG=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_UtJGuJG=static_cast<int>(json["result"].get_int64());
            }else{
                temp_UtJGuJG=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_UtJGuJG;}();}();

debug_printf("Ending vkBuildMicromapsEXT...\n");
debug_printf("Return value of vkBuildMicromapsEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyMicromapEXT( VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkMicromapEXT(json["micromap"],micromap);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkMicromapEXT(json["micromap"], micromap);}();


debug_printf("Ending vkDestroyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_UIlbXxp=json["pInfo"].get_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_UIlbXxp=json["pInfo"].get_array();
        for(int vDMleIo=0; vDMleIo < 1; vDMleIo++){
            [&](){
            auto& temp=arr_UIlbXxp[vDMleIo].emplace_object();
            return serialize_struct(temp, pInfo[vDMleIo]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_ONHPOzE;[&](){
            if (json["result"].is_uint64()){
                temp_ONHPOzE=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ONHPOzE=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ONHPOzE=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ONHPOzE;}();}();

debug_printf("Ending vkCopyMicromapEXT...\n");
debug_printf("Return value of vkCopyMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMicromapToMemoryEXT( VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMicromapToMemoryEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMICROMAPTOMEMORYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_EiLirbT=json["pInfo"].get_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMicromapToMemoryEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMicromapToMemoryEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMicromapToMemoryEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYMICROMAPTOMEMORYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_EiLirbT=json["pInfo"].get_array();
        for(int dzsAOWF=0; dzsAOWF < 1; dzsAOWF++){
            [&](){
            auto& temp=arr_EiLirbT[dzsAOWF].emplace_object();
            return serialize_struct(temp, pInfo[dzsAOWF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMICROMAPTOMEMORYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_FivEhpk;[&](){
            if (json["result"].is_uint64()){
                temp_FivEhpk=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_FivEhpk=static_cast<int>(json["result"].get_int64());
            }else{
                temp_FivEhpk=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_FivEhpk;}();}();

debug_printf("Ending vkCopyMicromapToMemoryEXT...\n");
debug_printf("Return value of vkCopyMicromapToMemoryEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdCopyMemoryToMicromapEXT( VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdCopyMemoryToMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDCOPYMEMORYTOMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QufOGLT=json["pInfo"].get_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdCopyMemoryToMicromapEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkCopyMemoryToMicromapEXT( VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT* pInfo ){
//Will only be called by the client
debug_printf("Executing vkCopyMemoryToMicromapEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCOPYMEMORYTOMICROMAPEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkDeferredOperationKHR(json["deferredOperation"],deferredOperation);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_QufOGLT=json["pInfo"].get_array();
        for(int semZpgt=0; semZpgt < 1; semZpgt++){
            [&](){
            auto& temp=arr_QufOGLT[semZpgt].emplace_object();
            return serialize_struct(temp, pInfo[semZpgt]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCOPYMEMORYTOMICROMAPEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkDeferredOperationKHR(json["deferredOperation"], deferredOperation);}();

VkResult result;
[&](){[&](){int temp_TKYMlWK;[&](){
            if (json["result"].is_uint64()){
                temp_TKYMlWK=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TKYMlWK=static_cast<int>(json["result"].get_int64());
            }else{
                temp_TKYMlWK=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_TKYMlWK;}();}();

debug_printf("Ending vkCopyMemoryToMicromapEXT...\n");
debug_printf("Return value of vkCopyMemoryToMicromapEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdWriteMicromapsPropertiesEXT( VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery ){
//Will only be called by the client
debug_printf("Executing vkCmdWriteMicromapsPropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDWRITEMICROMAPSPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }json["pMicromaps"]=boost::json::array(micromapCount);
        auto& arr_NriAFXg=json["pMicromaps"].get_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){serialize_VkQueryPool(json["queryPool"],queryPool);}();
[&](){json["firstQuery"]=firstQuery;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["micromapCount"].is_uint64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_uint64());
            }else if (json["micromapCount"].is_int64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_int64());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){deserialize_VkQueryPool(json["queryPool"], queryPool);}();
[&](){
            if (json["firstQuery"].is_uint64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_uint64());
            }else if (json["firstQuery"].is_int64()){
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_int64());
            }else{
                firstQuery=static_cast<uint32_t>(json["firstQuery"].get_double());
            }
            }();

debug_printf("Ending vkCmdWriteMicromapsPropertiesEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkWriteMicromapsPropertiesEXT( VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride ){
//Will only be called by the client
debug_printf("Executing vkWriteMicromapsPropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKWRITEMICROMAPSPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["micromapCount"]=micromapCount;}();
[&](){
            if (pMicromaps==NULL){
                json["pMicromaps"]=boost::json::array();
            return; }json["pMicromaps"]=boost::json::array(micromapCount);
        auto& arr_NriAFXg=json["pMicromaps"].get_array();
        for(int PNFyIBp=0; PNFyIBp < micromapCount; PNFyIBp++){
            [&](){serialize_VkMicromapEXT(arr_NriAFXg[PNFyIBp],pMicromaps[PNFyIBp]);}();
        }
        }();
[&](){[&](){[&](){json["queryType"]=queryType;}();}();}();
[&](){json["dataSize"]=dataSize;}();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(dataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
[&](){json["stride"]=stride;}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKWRITEMICROMAPSPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["micromapCount"].is_uint64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_uint64());
            }else if (json["micromapCount"].is_int64()){
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_int64());
            }else{
                micromapCount=static_cast<uint32_t>(json["micromapCount"].get_double());
            }
            }();

[&](){[&](){int temp_VdJSktT;[&](){
            if (json["queryType"].is_uint64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_uint64());
            }else if (json["queryType"].is_int64()){
                temp_VdJSktT=static_cast<int>(json["queryType"].get_int64());
            }else{
                temp_VdJSktT=static_cast<int>(json["queryType"].get_double());
            }
            }();queryType=(VkQueryType)temp_VdJSktT;}();}();
[&](){
            if (json["dataSize"].is_uint64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_uint64());
            }else if (json["dataSize"].is_int64()){
                dataSize=static_cast<size_t>(json["dataSize"].get_int64());
            }else{
                dataSize=static_cast<size_t>(json["dataSize"].get_double());
            }
            }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_hrhAtyM;[&](){
            if (json["pData"].get_array().size()==0){
                temp_hrhAtyM=NULL;
            return; }temp_hrhAtyM=(char*)malloc(dataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < dataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_hrhAtyM[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_hrhAtyM;}();
[&](){
            if (json["stride"].is_uint64()){
                stride=static_cast<size_t>(json["stride"].get_uint64());
            }else if (json["stride"].is_int64()){
                stride=static_cast<size_t>(json["stride"].get_int64());
            }else{
                stride=static_cast<size_t>(json["stride"].get_double());
            }
            }();
VkResult result;
[&](){[&](){int temp_zcmywrl;[&](){
            if (json["result"].is_uint64()){
                temp_zcmywrl=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_zcmywrl=static_cast<int>(json["result"].get_int64());
            }else{
                temp_zcmywrl=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_zcmywrl;}();}();

debug_printf("Ending vkWriteMicromapsPropertiesEXT...\n");
debug_printf("Return value of vkWriteMicromapsPropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceMicromapCompatibilityEXT( VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceMicromapCompatibilityEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEMICROMAPCOMPATIBILITYEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pVersionInfo==NULL){
                json["pVersionInfo"]=boost::json::array();
            return; }json["pVersionInfo"]=boost::json::array(1);
        auto& arr_PYqUGEM=json["pVersionInfo"].get_array();
        for(int odfXDEI=0; odfXDEI < 1; odfXDEI++){
            [&](){
            auto& temp=arr_PYqUGEM[odfXDEI].emplace_object();
            return serialize_struct(temp, pVersionInfo[odfXDEI]);
            }();
        }
        }();
[&](){
            if (pCompatibility==NULL){
                json["pCompatibility"]=boost::json::array();
            return; }json["pCompatibility"]=boost::json::array(1);
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){[&](){arr_dBMhFMX[nzOFTGF]=pCompatibility[nzOFTGF];}();}();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEMICROMAPCOMPATIBILITYEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pCompatibility"].get_array().size()==0){
                pCompatibility=NULL;
            return; }
        auto& arr_dBMhFMX=json["pCompatibility"].get_array();
        for(int nzOFTGF=0; nzOFTGF < 1; nzOFTGF++){
            [&](){[&](){int temp_guVSKHd;[&](){
            if (arr_dBMhFMX[nzOFTGF].is_uint64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_uint64());
            }else if (arr_dBMhFMX[nzOFTGF].is_int64()){
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_int64());
            }else{
                temp_guVSKHd=static_cast<int>(arr_dBMhFMX[nzOFTGF].get_double());
            }
            }();pCompatibility[nzOFTGF]=(VkAccelerationStructureCompatibilityKHR)temp_guVSKHd;}();}();
        }
        }();

debug_printf("Ending vkGetDeviceMicromapCompatibilityEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetMicromapBuildSizesEXT( VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo ){
//Will only be called by the client
debug_printf("Executing vkGetMicromapBuildSizesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETMICROMAPBUILDSIZESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){[&](){[&](){json["buildType"]=buildType;}();}();}();
[&](){
            if (pBuildInfo==NULL){
                json["pBuildInfo"]=boost::json::array();
            return; }json["pBuildInfo"]=boost::json::array(1);
        auto& arr_lREHNwp=json["pBuildInfo"].get_array();
        for(int nPItxru=0; nPItxru < 1; nPItxru++){
            [&](){
            auto& temp=arr_lREHNwp[nPItxru].emplace_object();
            return serialize_struct(temp, pBuildInfo[nPItxru]);
            }();
        }
        }();
[&](){
            if (pSizeInfo==NULL){
                json["pSizeInfo"]=boost::json::array();
            return; }json["pSizeInfo"]=boost::json::array(1);
        auto& arr_fJKSsZw=json["pSizeInfo"].get_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].emplace_object();
            return serialize_struct(temp, pSizeInfo[XgjgtXU]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETMICROMAPBUILDSIZESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){[&](){int temp_XouAsBI;[&](){
            if (json["buildType"].is_uint64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_uint64());
            }else if (json["buildType"].is_int64()){
                temp_XouAsBI=static_cast<int>(json["buildType"].get_int64());
            }else{
                temp_XouAsBI=static_cast<int>(json["buildType"].get_double());
            }
            }();buildType=(VkAccelerationStructureBuildTypeKHR)temp_XouAsBI;}();}();

[&](){
            if (json["pSizeInfo"].get_array().size()==0){
                pSizeInfo=NULL;
            return; }
        auto& arr_fJKSsZw=json["pSizeInfo"].get_array();
        for(int XgjgtXU=0; XgjgtXU < 1; XgjgtXU++){
            [&](){
            auto& temp=arr_fJKSsZw[XgjgtXU].get_object();
            deserialize_struct(temp,pSizeInfo[XgjgtXU]);
            }();
        }
        }();

debug_printf("Ending vkGetMicromapBuildSizesEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleIdentifierEXT( VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleIdentifierEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETSHADERMODULEIDENTIFIEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderModule(json["shaderModule"],shaderModule);}();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }json["pIdentifier"]=boost::json::array(1);
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULEIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderModule(json["shaderModule"], shaderModule);}();
[&](){
            if (json["pIdentifier"].get_array().size()==0){
                pIdentifier=NULL;
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].get_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetShaderModuleCreateInfoIdentifierEXT( VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier ){
//Will only be called by the client
debug_printf("Executing vkGetShaderModuleCreateInfoIdentifierEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETSHADERMODULECREATEINFOIDENTIFIEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_iSZUILM=json["pCreateInfo"].get_array();
        for(int dKxemXH=0; dKxemXH < 1; dKxemXH++){
            [&](){
            auto& temp=arr_iSZUILM[dKxemXH].emplace_object();
            return serialize_struct(temp, pCreateInfo[dKxemXH]);
            }();
        }
        }();
[&](){
            if (pIdentifier==NULL){
                json["pIdentifier"]=boost::json::array();
            return; }json["pIdentifier"]=boost::json::array(1);
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].emplace_object();
            return serialize_struct(temp, pIdentifier[DSBkSwY]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERMODULECREATEINFOIDENTIFIEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pIdentifier"].get_array().size()==0){
                pIdentifier=NULL;
            return; }
        auto& arr_ICaFqGG=json["pIdentifier"].get_array();
        for(int DSBkSwY=0; DSBkSwY < 1; DSBkSwY++){
            [&](){
            auto& temp=arr_ICaFqGG[DSBkSwY].get_object();
            deserialize_struct(temp,pIdentifier[DSBkSwY]);
            }();
        }
        }();

debug_printf("Ending vkGetShaderModuleCreateInfoIdentifierEXT...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2KHR( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetImageSubresourceLayout2KHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETIMAGESUBRESOURCELAYOUT2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkImage(json["image"],image);}();
[&](){
            if (pSubresource==NULL){
                json["pSubresource"]=boost::json::array();
            return; }json["pSubresource"]=boost::json::array(1);
        auto& arr_xtdYssI=json["pSubresource"].get_array();
        for(int HvvKvoL=0; HvvKvoL < 1; HvvKvoL++){
            [&](){
            auto& temp=arr_xtdYssI[HvvKvoL].emplace_object();
            return serialize_struct(temp, pSubresource[HvvKvoL]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETIMAGESUBRESOURCELAYOUT2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkImage(json["image"], image);}();

[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].get_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetImageSubresourceLayout2KHR...\n");
}
__attribute__((visibility ("hidden"))) void vkGetImageSubresourceLayout2EXT( VkDevice device, VkImage image, const VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout ){
return vkGetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
}
__attribute__((visibility ("hidden"))) VkResult vkGetPipelinePropertiesEXT( VkDevice device, const VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPipelinePropertiesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETPIPELINEPROPERTIESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pPipelineInfo==NULL){
                json["pPipelineInfo"]=boost::json::array();
            return; }json["pPipelineInfo"]=boost::json::array(1);
        auto& arr_eGbOPJq=json["pPipelineInfo"].get_array();
        for(int iUjmOrp=0; iUjmOrp < 1; iUjmOrp++){
            [&](){
            auto& temp=arr_eGbOPJq[iUjmOrp].emplace_object();
            return serialize_struct(temp, pPipelineInfo[iUjmOrp]);
            }();
        }
        }();
[&](){
            if (pPipelineProperties==NULL){
                json["pPipelineProperties"]=boost::json::array();
            return; }json["pPipelineProperties"]=boost::json::array(1);
        auto& arr_eMgMlNc=json["pPipelineProperties"].get_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].emplace_object();
            return serialize_struct(temp, pPipelineProperties[cJpCXwz]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPIPELINEPROPERTIESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pPipelineProperties"].get_array().size()==0){
                pPipelineProperties=NULL;
            return; }
        auto& arr_eMgMlNc=json["pPipelineProperties"].get_array();
        for(int cJpCXwz=0; cJpCXwz < 1; cJpCXwz++){
            [&](){
            auto& temp=arr_eMgMlNc[cJpCXwz].get_object();
            deserialize_struct(temp,pPipelineProperties[cJpCXwz]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_XOJEaHr;[&](){
            if (json["result"].is_uint64()){
                temp_XOJEaHr=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_XOJEaHr=static_cast<int>(json["result"].get_int64());
            }else{
                temp_XOJEaHr=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_XOJEaHr;}();}();

debug_printf("Ending vkGetPipelinePropertiesEXT...\n");
debug_printf("Return value of vkGetPipelinePropertiesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetFramebufferTilePropertiesQCOM( VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetFramebufferTilePropertiesQCOM\n");

    boost::json::object json;
    json["stream_type"]=VKGETFRAMEBUFFERTILEPROPERTIESQCOM;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkFramebuffer(json["framebuffer"],framebuffer);}();
[&](){
            if (pPropertiesCount==NULL){
                json["pPropertiesCount"]=boost::json::array();
            return; }json["pPropertiesCount"]=boost::json::array(1);
        auto& arr_vUkyKfO=json["pPropertiesCount"].get_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){arr_vUkyKfO[YhfeqPW]=pPropertiesCount[YhfeqPW];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertiesCount);
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETFRAMEBUFFERTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkFramebuffer(json["framebuffer"], framebuffer);}();
[&](){
            if (json["pPropertiesCount"].get_array().size()==0){
                pPropertiesCount=NULL;
            return; }
        auto& arr_vUkyKfO=json["pPropertiesCount"].get_array();
        for(int YhfeqPW=0; YhfeqPW < 1; YhfeqPW++){
            [&](){
            if (arr_vUkyKfO[YhfeqPW].is_uint64()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_uint64());
            }else if (arr_vUkyKfO[YhfeqPW].is_int64()){
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_int64());
            }else{
                pPropertiesCount[YhfeqPW]=static_cast<uint32_t>(arr_vUkyKfO[YhfeqPW].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < *pPropertiesCount; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].get_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_TLkSlaU;[&](){
            if (json["result"].is_uint64()){
                temp_TLkSlaU=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_TLkSlaU=static_cast<int>(json["result"].get_int64());
            }else{
                temp_TLkSlaU=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_TLkSlaU;}();}();

debug_printf("Ending vkGetFramebufferTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetFramebufferTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetDynamicRenderingTilePropertiesQCOM( VkDevice device, const VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetDynamicRenderingTilePropertiesQCOM\n");

    boost::json::object json;
    json["stream_type"]=VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pRenderingInfo==NULL){
                json["pRenderingInfo"]=boost::json::array();
            return; }json["pRenderingInfo"]=boost::json::array(1);
        auto& arr_DOEgrev=json["pRenderingInfo"].get_array();
        for(int dAqQfxy=0; dAqQfxy < 1; dAqQfxy++){
            [&](){
            auto& temp=arr_DOEgrev[dAqQfxy].emplace_object();
            return serialize_struct(temp, pRenderingInfo[dAqQfxy]);
            }();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(1);
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].emplace_object();
            return serialize_struct(temp, pProperties[oGElcJh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDYNAMICRENDERINGTILEPROPERTIESQCOM):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_hYNBodF=json["pProperties"].get_array();
        for(int oGElcJh=0; oGElcJh < 1; oGElcJh++){
            [&](){
            auto& temp=arr_hYNBodF[oGElcJh].get_object();
            deserialize_struct(temp,pProperties[oGElcJh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_inlNtLF;[&](){
            if (json["result"].is_uint64()){
                temp_inlNtLF=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_inlNtLF=static_cast<int>(json["result"].get_int64());
            }else{
                temp_inlNtLF=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_inlNtLF;}();}();

debug_printf("Ending vkGetDynamicRenderingTilePropertiesQCOM...\n");
debug_printf("Return value of vkGetDynamicRenderingTilePropertiesQCOM is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceOpticalFlowImageFormatsNV( VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceOpticalFlowImageFormatsNV\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pOpticalFlowImageFormatInfo==NULL){
                json["pOpticalFlowImageFormatInfo"]=boost::json::array();
            return; }json["pOpticalFlowImageFormatInfo"]=boost::json::array(1);
        auto& arr_oyPfnWV=json["pOpticalFlowImageFormatInfo"].get_array();
        for(int HqzITOl=0; HqzITOl < 1; HqzITOl++){
            [&](){
            auto& temp=arr_oyPfnWV[HqzITOl].emplace_object();
            return serialize_struct(temp, pOpticalFlowImageFormatInfo[HqzITOl]);
            }();
        }
        }();
[&](){
            if (pFormatCount==NULL){
                json["pFormatCount"]=boost::json::array();
            return; }json["pFormatCount"]=boost::json::array(1);
        auto& arr_OWVxAsX=json["pFormatCount"].get_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){arr_OWVxAsX[AvMKjKj]=pFormatCount[AvMKjKj];}();
        }
        }();
[&](){
            if (pImageFormatProperties==NULL){
                json["pImageFormatProperties"]=boost::json::array();
            return; }json["pImageFormatProperties"]=boost::json::array(*pFormatCount);
        auto& arr_oZncgpa=json["pImageFormatProperties"].get_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].emplace_object();
            return serialize_struct(temp, pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();

[&](){
            if (json["pFormatCount"].get_array().size()==0){
                pFormatCount=NULL;
            return; }
        auto& arr_OWVxAsX=json["pFormatCount"].get_array();
        for(int AvMKjKj=0; AvMKjKj < 1; AvMKjKj++){
            [&](){
            if (arr_OWVxAsX[AvMKjKj].is_uint64()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_uint64());
            }else if (arr_OWVxAsX[AvMKjKj].is_int64()){
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_int64());
            }else{
                pFormatCount[AvMKjKj]=static_cast<uint32_t>(arr_OWVxAsX[AvMKjKj].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pImageFormatProperties"].get_array().size()==0){
                pImageFormatProperties=NULL;
            return; }
        auto& arr_oZncgpa=json["pImageFormatProperties"].get_array();
        for(int gkJgIzP=0; gkJgIzP < *pFormatCount; gkJgIzP++){
            [&](){
            auto& temp=arr_oZncgpa[gkJgIzP].get_object();
            deserialize_struct(temp,pImageFormatProperties[gkJgIzP]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_tYfFThn;[&](){
            if (json["result"].is_uint64()){
                temp_tYfFThn=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_tYfFThn=static_cast<int>(json["result"].get_int64());
            }else{
                temp_tYfFThn=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_tYfFThn;}();}();

debug_printf("Ending vkGetPhysicalDeviceOpticalFlowImageFormatsNV...\n");
debug_printf("Return value of vkGetPhysicalDeviceOpticalFlowImageFormatsNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateOpticalFlowSessionNV( VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession ){
//Will only be called by the client
debug_printf("Executing vkCreateOpticalFlowSessionNV\n");

    boost::json::object json;
    json["stream_type"]=VKCREATEOPTICALFLOWSESSIONNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pCreateInfo==NULL){
                json["pCreateInfo"]=boost::json::array();
            return; }json["pCreateInfo"]=boost::json::array(1);
        auto& arr_dKVOiZE=json["pCreateInfo"].get_array();
        for(int LaeeodD=0; LaeeodD < 1; LaeeodD++){
            [&](){
            auto& temp=arr_dKVOiZE[LaeeodD].emplace_object();
            return serialize_struct(temp, pCreateInfo[LaeeodD]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pSession==NULL){
                json["pSession"]=boost::json::array();
            return; }json["pSession"]=boost::json::array(1);
        auto& arr_PyNQerY=json["pSession"].get_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){serialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ],pSession[FnADpyZ]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATEOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();


[&](){
            if (json["pSession"].get_array().size()==0){
                pSession=NULL;
            return; }
        auto& arr_PyNQerY=json["pSession"].get_array();
        for(int FnADpyZ=0; FnADpyZ < 1; FnADpyZ++){
            [&](){deserialize_VkOpticalFlowSessionNV(arr_PyNQerY[FnADpyZ], pSession[FnADpyZ]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_gzRTYMj;[&](){
            if (json["result"].is_uint64()){
                temp_gzRTYMj=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_gzRTYMj=static_cast<int>(json["result"].get_int64());
            }else{
                temp_gzRTYMj=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_gzRTYMj;}();}();

                if (pSession!=NULL){
                    for (int i=0; i<1; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pSession[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateOpticalFlowSessionNV...\n");
debug_printf("Return value of vkCreateOpticalFlowSessionNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyOpticalFlowSessionNV( VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyOpticalFlowSessionNV\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYOPTICALFLOWSESSIONNV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYOPTICALFLOWSESSIONNV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkDestroyOpticalFlowSessionNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkBindOpticalFlowSessionImageNV( VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout ){
//Will only be called by the client
debug_printf("Executing vkBindOpticalFlowSessionImageNV\n");

    boost::json::object json;
    json["stream_type"]=VKBINDOPTICALFLOWSESSIONIMAGENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){[&](){[&](){json["bindingPoint"]=bindingPoint;}();}();}();
[&](){serialize_VkImageView(json["view"],view);}();
[&](){[&](){[&](){json["layout"]=layout;}();}();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKBINDOPTICALFLOWSESSIONIMAGENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();
[&](){[&](){int temp_dqYOkbF;[&](){
            if (json["bindingPoint"].is_uint64()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_uint64());
            }else if (json["bindingPoint"].is_int64()){
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_int64());
            }else{
                temp_dqYOkbF=static_cast<int>(json["bindingPoint"].get_double());
            }
            }();bindingPoint=(VkOpticalFlowSessionBindingPointNV)temp_dqYOkbF;}();}();
[&](){deserialize_VkImageView(json["view"], view);}();
[&](){[&](){int temp_IaQZtFR;[&](){
            if (json["layout"].is_uint64()){
                temp_IaQZtFR=static_cast<int>(json["layout"].get_uint64());
            }else if (json["layout"].is_int64()){
                temp_IaQZtFR=static_cast<int>(json["layout"].get_int64());
            }else{
                temp_IaQZtFR=static_cast<int>(json["layout"].get_double());
            }
            }();layout=(VkImageLayout)temp_IaQZtFR;}();}();
VkResult result;
[&](){[&](){int temp_PXkQMYg;[&](){
            if (json["result"].is_uint64()){
                temp_PXkQMYg=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_PXkQMYg=static_cast<int>(json["result"].get_int64());
            }else{
                temp_PXkQMYg=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_PXkQMYg;}();}();

debug_printf("Ending vkBindOpticalFlowSessionImageNV...\n");
debug_printf("Return value of vkBindOpticalFlowSessionImageNV is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdOpticalFlowExecuteNV( VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdOpticalFlowExecuteNV\n");

    boost::json::object json;
    json["stream_type"]=VKCMDOPTICALFLOWEXECUTENV;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){serialize_VkOpticalFlowSessionNV(json["session"],session);}();
[&](){
            if (pExecuteInfo==NULL){
                json["pExecuteInfo"]=boost::json::array();
            return; }json["pExecuteInfo"]=boost::json::array(1);
        auto& arr_CyySpro=json["pExecuteInfo"].get_array();
        for(int XLHKKBA=0; XLHKKBA < 1; XLHKKBA++){
            [&](){
            auto& temp=arr_CyySpro[XLHKKBA].emplace_object();
            return serialize_struct(temp, pExecuteInfo[XLHKKBA]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDOPTICALFLOWEXECUTENV):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){deserialize_VkOpticalFlowSessionNV(json["session"], session);}();


debug_printf("Ending vkCmdOpticalFlowExecuteNV...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetDeviceFaultInfoEXT( VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceFaultInfoEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEFAULTINFOEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pFaultCounts==NULL){
                json["pFaultCounts"]=boost::json::array();
            return; }json["pFaultCounts"]=boost::json::array(1);
        auto& arr_LWLqmdd=json["pFaultCounts"].get_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].emplace_object();
            return serialize_struct(temp, pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (pFaultInfo==NULL){
                json["pFaultInfo"]=boost::json::array();
            return; }json["pFaultInfo"]=boost::json::array(1);
        auto& arr_CRNBZxs=json["pFaultInfo"].get_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].emplace_object();
            return serialize_struct(temp, pFaultInfo[AHHHhvb]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEFAULTINFOEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["pFaultCounts"].get_array().size()==0){
                pFaultCounts=NULL;
            return; }
        auto& arr_LWLqmdd=json["pFaultCounts"].get_array();
        for(int RexMRxZ=0; RexMRxZ < 1; RexMRxZ++){
            [&](){
            auto& temp=arr_LWLqmdd[RexMRxZ].get_object();
            deserialize_struct(temp,pFaultCounts[RexMRxZ]);
            }();
        }
        }();
[&](){
            if (json["pFaultInfo"].get_array().size()==0){
                pFaultInfo=NULL;
            return; }
        auto& arr_CRNBZxs=json["pFaultInfo"].get_array();
        for(int AHHHhvb=0; AHHHhvb < 1; AHHHhvb++){
            [&](){
            auto& temp=arr_CRNBZxs[AHHHhvb].get_object();
            deserialize_struct(temp,pFaultInfo[AHHHhvb]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_QCKCJeX;[&](){
            if (json["result"].is_uint64()){
                temp_QCKCJeX=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_QCKCJeX=static_cast<int>(json["result"].get_int64());
            }else{
                temp_QCKCJeX=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_QCKCJeX;}();}();

debug_printf("Ending vkGetDeviceFaultInfoEXT...\n");
debug_printf("Return value of vkGetDeviceFaultInfoEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdSetDepthBias2EXT( VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo ){
//Will only be called by the client
debug_printf("Executing vkCmdSetDepthBias2EXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDSETDEPTHBIAS2EXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){
            if (pDepthBiasInfo==NULL){
                json["pDepthBiasInfo"]=boost::json::array();
            return; }json["pDepthBiasInfo"]=boost::json::array(1);
        auto& arr_AKZgFGf=json["pDepthBiasInfo"].get_array();
        for(int kGsXYsB=0; kGsXYsB < 1; kGsXYsB++){
            [&](){
            auto& temp=arr_AKZgFGf[kGsXYsB].emplace_object();
            return serialize_struct(temp, pDepthBiasInfo[kGsXYsB]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDSETDEPTHBIAS2EXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();


debug_printf("Ending vkCmdSetDepthBias2EXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkReleaseSwapchainImagesEXT( VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo ){
//Will only be called by the client
debug_printf("Executing vkReleaseSwapchainImagesEXT\n");

    boost::json::object json;
    json["stream_type"]=VKRELEASESWAPCHAINIMAGESEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pReleaseInfo==NULL){
                json["pReleaseInfo"]=boost::json::array();
            return; }json["pReleaseInfo"]=boost::json::array(1);
        auto& arr_jcnZDBn=json["pReleaseInfo"].get_array();
        for(int dRtPqPF=0; dRtPqPF < 1; dRtPqPF++){
            [&](){
            auto& temp=arr_jcnZDBn[dRtPqPF].emplace_object();
            return serialize_struct(temp, pReleaseInfo[dRtPqPF]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKRELEASESWAPCHAINIMAGESEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_MnSoniu;[&](){
            if (json["result"].is_uint64()){
                temp_MnSoniu=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_MnSoniu=static_cast<int>(json["result"].get_int64());
            }else{
                temp_MnSoniu=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_MnSoniu;}();}();

debug_printf("Ending vkReleaseSwapchainImagesEXT...\n");
debug_printf("Return value of vkReleaseSwapchainImagesEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkGetDeviceImageSubresourceLayoutKHR( VkDevice device, const VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout ){
//Will only be called by the client
debug_printf("Executing vkGetDeviceImageSubresourceLayoutKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pInfo==NULL){
                json["pInfo"]=boost::json::array();
            return; }json["pInfo"]=boost::json::array(1);
        auto& arr_SwRDgPP=json["pInfo"].get_array();
        for(int wxoktPv=0; wxoktPv < 1; wxoktPv++){
            [&](){
            auto& temp=arr_SwRDgPP[wxoktPv].emplace_object();
            return serialize_struct(temp, pInfo[wxoktPv]);
            }();
        }
        }();
[&](){
            if (pLayout==NULL){
                json["pLayout"]=boost::json::array();
            return; }json["pLayout"]=boost::json::array(1);
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].emplace_object();
            return serialize_struct(temp, pLayout[jEkaLQP]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETDEVICEIMAGESUBRESOURCELAYOUTKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["pLayout"].get_array().size()==0){
                pLayout=NULL;
            return; }
        auto& arr_JxnVeqW=json["pLayout"].get_array();
        for(int jEkaLQP=0; jEkaLQP < 1; jEkaLQP++){
            [&](){
            auto& temp=arr_JxnVeqW[jEkaLQP].get_object();
            deserialize_struct(temp,pLayout[jEkaLQP]);
            }();
        }
        }();

debug_printf("Ending vkGetDeviceImageSubresourceLayoutKHR...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkMapMemory2KHR( VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData ){
//Will only be called by the client
debug_printf("Executing vkMapMemory2KHR\n");
MemoryMapLock.lock();

    boost::json::object json;
    json["stream_type"]=VKMAPMEMORY2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        

        if (pMemoryMapInfo->size==VK_WHOLE_SIZE){
            VkMemoryMapInfoKHR new_map_info=*pMemoryMapInfo;
            new_map_info.size=devicememory_to_size[(uintptr_t)new_map_info.memory]-new_map_info.offset;
            pMemoryMapInfo=&new_map_info;
        }
        
{
*ppData=NULL;
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryMapInfo==NULL){
                json["pMemoryMapInfo"]=boost::json::array();
            return; }json["pMemoryMapInfo"]=boost::json::array(1);
        auto& arr_udcndbe=json["pMemoryMapInfo"].get_array();
        for(int iwSaLAe=0; iwSaLAe < 1; iwSaLAe++){
            [&](){
            auto& temp=arr_udcndbe[iwSaLAe].emplace_object();
            return serialize_struct(temp, pMemoryMapInfo[iwSaLAe]);
            }();
        }
        }();
[&](){
            if (ppData==NULL){
                json["ppData"]=boost::json::array();
            return; }json["ppData"]=boost::json::array(1);
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (ppData[NsRFkBj]==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }[&](){
            if (((char*)(ppData[NsRFkBj]))==NULL){
                arr_JgRLJSK[NsRFkBj]=boost::json::array();
            return; }arr_JgRLJSK[NsRFkBj]=boost::json::array(strlen(((char*)(ppData[NsRFkBj])))+1);
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < strlen(((char*)(ppData[NsRFkBj])))+1; jYdchEs++){
            [&](){arr_vLfeDBZ[jYdchEs]=((char*)(ppData[NsRFkBj]))[jYdchEs];}();
        }
        }();}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

[&](){
            if (json["ppData"].get_array().size()==0){
                ppData=NULL;
            return; }
        auto& arr_JgRLJSK=json["ppData"].get_array();
        for(int NsRFkBj=0; NsRFkBj < 1; NsRFkBj++){
            [&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                ppData[NsRFkBj]=NULL;
            return; }char* temp_JgRLJSK;[&](){
            if (arr_JgRLJSK[NsRFkBj].get_array().size()==0){
                temp_JgRLJSK=NULL;
            return; }temp_JgRLJSK=(char*)malloc(arr_JgRLJSK[NsRFkBj].get_array().size()*sizeof(char));
        auto& arr_vLfeDBZ=arr_JgRLJSK[NsRFkBj].get_array();
        for(int jYdchEs=0; jYdchEs < arr_JgRLJSK[NsRFkBj].get_array().size(); jYdchEs++){
            [&](){
            if (arr_vLfeDBZ[jYdchEs].is_uint64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_uint64());
            }else if (arr_vLfeDBZ[jYdchEs].is_int64()){
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_int64());
            }else{
                temp_JgRLJSK[jYdchEs]=static_cast<char>(arr_vLfeDBZ[jYdchEs].get_double());
            }
            }();
        }
        }();ppData[NsRFkBj]=temp_JgRLJSK;}();
        }
        }();
VkResult result;
[&](){[&](){int temp_ISWBnyX;[&](){
            if (json["result"].is_uint64()){
                temp_ISWBnyX=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_ISWBnyX=static_cast<int>(json["result"].get_int64());
            }else{
                temp_ISWBnyX=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_ISWBnyX;}();}();

        boost::json::value server_memory_json;
        serialize_VkDeviceMemory(server_memory_json, pMemoryMapInfo->memory);
        
        auto server_memory=value_to<uintptr_t>(server_memory_json); 
        
        *ppData=registerDeviceMemoryMap(server_memory, pMemoryMapInfo->memory,pMemoryMapInfo->size,*ppData,value_to<uintptr_t>(json["mem"]));
        
        #ifndef CLIENT
            json["mem"]=value_to<uintptr_t>(json["mem"]);
        #endif
        
MemoryMapLock.unlock();
debug_printf("Ending vkMapMemory2KHR...\n");
debug_printf("Return value of vkMapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkUnmapMemory2KHR( VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo ){
//Will only be called by the client
debug_printf("Executing vkUnmapMemory2KHR\n");
MemoryMapLock.lock();

    boost::json::object json;
    json["stream_type"]=VKUNMAPMEMORY2KHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){
            if (pMemoryUnmapInfo==NULL){
                json["pMemoryUnmapInfo"]=boost::json::array();
            return; }json["pMemoryUnmapInfo"]=boost::json::array(1);
        auto& arr_hZlnXPf=json["pMemoryUnmapInfo"].get_array();
        for(int caczdhq=0; caczdhq < 1; caczdhq++){
            [&](){
            auto& temp=arr_hZlnXPf[caczdhq].emplace_object();
            return serialize_struct(temp, pMemoryUnmapInfo[caczdhq]);
            }();
        }
        }();
}
deregisterDeviceMemoryMap(pMemoryUnmapInfo->memory);

        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKUNMAPMEMORY2KHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();

VkResult result;
[&](){[&](){int temp_yHbgkCw;[&](){
            if (json["result"].is_uint64()){
                temp_yHbgkCw=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_yHbgkCw=static_cast<int>(json["result"].get_int64());
            }else{
                temp_yHbgkCw=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_yHbgkCw;}();}();

MemoryMapLock.unlock();
debug_printf("Ending vkUnmapMemory2KHR...\n");
debug_printf("Return value of vkUnmapMemory2KHR is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) VkResult vkCreateShadersEXT( VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCreateShadersEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCREATESHADERSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){json["createInfoCount"]=createInfoCount;}();
[&](){
            if (pCreateInfos==NULL){
                json["pCreateInfos"]=boost::json::array();
            return; }json["pCreateInfos"]=boost::json::array(createInfoCount);
        auto& arr_mOfZnnW=json["pCreateInfos"].get_array();
        for(int bOiKywR=0; bOiKywR < createInfoCount; bOiKywR++){
            [&](){
            auto& temp=arr_mOfZnnW[bOiKywR].emplace_object();
            return serialize_struct(temp, pCreateInfos[bOiKywR]);
            }();
        }
        }();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }json["pShaders"]=boost::json::array(createInfoCount);
        auto& arr_ndnxxFm=json["pShaders"].get_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){serialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN],pShaders[NwhTkPN]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCREATESHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){
            if (json["createInfoCount"].is_uint64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_uint64());
            }else if (json["createInfoCount"].is_int64()){
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_int64());
            }else{
                createInfoCount=static_cast<uint32_t>(json["createInfoCount"].get_double());
            }
            }();


[&](){
            if (json["pShaders"].get_array().size()==0){
                pShaders=NULL;
            return; }
        auto& arr_ndnxxFm=json["pShaders"].get_array();
        for(int NwhTkPN=0; NwhTkPN < createInfoCount; NwhTkPN++){
            [&](){deserialize_VkShaderEXT(arr_ndnxxFm[NwhTkPN], pShaders[NwhTkPN]);}();
        }
        }();
VkResult result;
[&](){[&](){int temp_DjHJocd;[&](){
            if (json["result"].is_uint64()){
                temp_DjHJocd=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_DjHJocd=static_cast<int>(json["result"].get_int64());
            }else{
                temp_DjHJocd=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_DjHJocd;}();}();

                if (pShaders!=NULL){
                    for (int i=0; i<createInfoCount; i++){
                        handle_to_parent_handle_struct[(uintptr_t)(pShaders[i])]=parent;
                    }
                }
                

debug_printf("Ending vkCreateShadersEXT...\n");
debug_printf("Return value of vkCreateShadersEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkDestroyShaderEXT( VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator ){
//Will only be called by the client
debug_printf("Executing vkDestroyShaderEXT\n");

    boost::json::object json;
    json["stream_type"]=VKDESTROYSHADEREXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pAllocator==NULL){
                json["pAllocator"]=boost::json::array();
            return; }json["pAllocator"]=boost::json::array(1);
        auto& arr_daGjOqj=json["pAllocator"].get_array();
        for(int fdxDfEW=0; fdxDfEW < 1; fdxDfEW++){
            [&](){
            auto& temp=arr_daGjOqj[fdxDfEW].emplace_object();
            return serialize_struct(temp, pAllocator[fdxDfEW]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKDESTROYSHADEREXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();


debug_printf("Ending vkDestroyShaderEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetShaderBinaryDataEXT( VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData ){
//Will only be called by the client
debug_printf("Executing vkGetShaderBinaryDataEXT\n");

    boost::json::object json;
    json["stream_type"]=VKGETSHADERBINARYDATAEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)device];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkDevice(json["device"],device);}();
[&](){serialize_VkShaderEXT(json["shader"],shader);}();
[&](){
            if (pDataSize==NULL){
                json["pDataSize"]=boost::json::array();
            return; }json["pDataSize"]=boost::json::array(1);
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){arr_Zcusyfw[HCzJfGC]=pDataSize[HCzJfGC];}();
        }
        }();
[&](){
            if (pData==NULL){
                json["pData"]=boost::json::array();
            return; }[&](){
            if (((char*)(pData))==NULL){
                json["pData"]=boost::json::array();
            return; }json["pData"]=boost::json::array(*pDataSize);
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){arr_KuWJuFa[tDEuamw]=((char*)(pData))[tDEuamw];}();
        }
        }();}();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETSHADERBINARYDATAEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkDevice(json["device"], device);}();
[&](){deserialize_VkShaderEXT(json["shader"], shader);}();
[&](){
            if (json["pDataSize"].get_array().size()==0){
                pDataSize=NULL;
            return; }
        auto& arr_Zcusyfw=json["pDataSize"].get_array();
        for(int HCzJfGC=0; HCzJfGC < 1; HCzJfGC++){
            [&](){
            if (arr_Zcusyfw[HCzJfGC].is_uint64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_uint64());
            }else if (arr_Zcusyfw[HCzJfGC].is_int64()){
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_int64());
            }else{
                pDataSize[HCzJfGC]=static_cast<size_t>(arr_Zcusyfw[HCzJfGC].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pData"].get_array().size()==0){
                pData=NULL;
            return; }char* temp_ZtBEjVJ;[&](){
            if (json["pData"].get_array().size()==0){
                temp_ZtBEjVJ=NULL;
            return; }temp_ZtBEjVJ=(char*)malloc(*pDataSize*sizeof(char));
        auto& arr_KuWJuFa=json["pData"].get_array();
        for(int tDEuamw=0; tDEuamw < *pDataSize; tDEuamw++){
            [&](){
            if (arr_KuWJuFa[tDEuamw].is_uint64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_uint64());
            }else if (arr_KuWJuFa[tDEuamw].is_int64()){
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_int64());
            }else{
                temp_ZtBEjVJ[tDEuamw]=static_cast<char>(arr_KuWJuFa[tDEuamw].get_double());
            }
            }();
        }
        }();pData=temp_ZtBEjVJ;}();
VkResult result;
[&](){[&](){int temp_zXjNUAM;[&](){
            if (json["result"].is_uint64()){
                temp_zXjNUAM=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_zXjNUAM=static_cast<int>(json["result"].get_int64());
            }else{
                temp_zXjNUAM=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_zXjNUAM;}();}();

debug_printf("Ending vkGetShaderBinaryDataEXT...\n");
debug_printf("Return value of vkGetShaderBinaryDataEXT is: %s...\n",string_VkResult(result));
return result;
}
__attribute__((visibility ("hidden"))) void vkCmdBindShadersEXT( VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders ){
//Will only be called by the client
debug_printf("Executing vkCmdBindShadersEXT\n");

    boost::json::object json;
    json["stream_type"]=VKCMDBINDSHADERSEXT;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)commandBuffer];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkCommandBuffer(json["commandBuffer"],commandBuffer);}();
[&](){json["stageCount"]=stageCount;}();
[&](){
            if (pStages==NULL){
                json["pStages"]=boost::json::array();
            return; }json["pStages"]=boost::json::array(stageCount);
        auto& arr_phXrzxO=json["pStages"].get_array();
        for(int uFucfxh=0; uFucfxh < stageCount; uFucfxh++){
            [&](){[&](){[&](){arr_phXrzxO[uFucfxh]=pStages[uFucfxh];}();}();}();
        }
        }();
[&](){
            if (pShaders==NULL){
                json["pShaders"]=boost::json::array();
            return; }json["pShaders"]=boost::json::array(stageCount);
        auto& arr_ZjERyql=json["pShaders"].get_array();
        for(int DxWTbGC=0; DxWTbGC < stageCount; DxWTbGC++){
            [&](){serialize_VkShaderEXT(arr_ZjERyql[DxWTbGC],pShaders[DxWTbGC]);}();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKCMDBINDSHADERSEXT):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkCommandBuffer(json["commandBuffer"], commandBuffer);}();
[&](){
            if (json["stageCount"].is_uint64()){
                stageCount=static_cast<uint32_t>(json["stageCount"].get_uint64());
            }else if (json["stageCount"].is_int64()){
                stageCount=static_cast<uint32_t>(json["stageCount"].get_int64());
            }else{
                stageCount=static_cast<uint32_t>(json["stageCount"].get_double());
            }
            }();



debug_printf("Ending vkCmdBindShadersEXT...\n");
}
__attribute__((visibility ("hidden"))) VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR( VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties ){
//Will only be called by the client
debug_printf("Executing vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR\n");

    boost::json::object json;
    json["stream_type"]=VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR;
    
    auto& parent_json=json["parent"].emplace_object();
    parent_json.clear();
    

        auto parent=handle_to_parent_handle_struct[(uintptr_t)physicalDevice];
        
        if (parent.device!=NULL){
            serialize_VkDevice(parent_json["device"], parent.device);
        }else{
            serialize_VkInstance(parent_json["instance"], parent.instance);
        }
        
{
[&](){serialize_VkPhysicalDevice(json["physicalDevice"],physicalDevice);}();
[&](){
            if (pPropertyCount==NULL){
                json["pPropertyCount"]=boost::json::array();
            return; }json["pPropertyCount"]=boost::json::array(1);
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){arr_ICoMmRG[srQaIwu]=pPropertyCount[srQaIwu];}();
        }
        }();
[&](){
            if (pProperties==NULL){
                json["pProperties"]=boost::json::array();
            return; }json["pProperties"]=boost::json::array(*pPropertyCount);
        auto& arr_PEzgESc=json["pProperties"].get_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].emplace_object();
            return serialize_struct(temp, pProperties[iTGjLCh]);
            }();
        }
        }();
}


        writeToConn(json);
        
        while(true){
            json=readFromConn();
            
            switch(static_cast<StreamType>(value_to<int>(json["stream_type"]))){
                case (SYNC):
                    handle_sync_init(json);
                    continue;
                case (VKGETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR):
                    break; 
    

         case (PFN_VKINTERNALALLOCATIONNOTIFICATION):
            handle_PFN_vkInternalAllocationNotification(json);
            continue;
        

         case (PFN_VKINTERNALFREENOTIFICATION):
            handle_PFN_vkInternalFreeNotification(json);
            continue;
        

         case (PFN_VKREALLOCATIONFUNCTION):
            handle_PFN_vkReallocationFunction(json);
            continue;
        

         case (PFN_VKALLOCATIONFUNCTION):
            handle_PFN_vkAllocationFunction(json);
            continue;
        

         case (PFN_VKFREEFUNCTION):
            handle_PFN_vkFreeFunction(json);
            continue;
        

         case (PFN_VKDEBUGREPORTCALLBACKEXT):
            handle_PFN_vkDebugReportCallbackEXT(json);
            continue;
        

         case (PFN_VKDEBUGUTILSMESSENGERCALLBACKEXT):
            handle_PFN_vkDebugUtilsMessengerCallbackEXT(json);
            continue;
        

         case (PFN_VKDEVICEMEMORYREPORTCALLBACKEXT):
            handle_PFN_vkDeviceMemoryReportCallbackEXT(json);
            continue;
        
}break;}
[&](){deserialize_VkPhysicalDevice(json["physicalDevice"], physicalDevice);}();
[&](){
            if (json["pPropertyCount"].get_array().size()==0){
                pPropertyCount=NULL;
            return; }
        auto& arr_ICoMmRG=json["pPropertyCount"].get_array();
        for(int srQaIwu=0; srQaIwu < 1; srQaIwu++){
            [&](){
            if (arr_ICoMmRG[srQaIwu].is_uint64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_uint64());
            }else if (arr_ICoMmRG[srQaIwu].is_int64()){
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_int64());
            }else{
                pPropertyCount[srQaIwu]=static_cast<uint32_t>(arr_ICoMmRG[srQaIwu].get_double());
            }
            }();
        }
        }();
[&](){
            if (json["pProperties"].get_array().size()==0){
                pProperties=NULL;
            return; }
        auto& arr_PEzgESc=json["pProperties"].get_array();
        for(int iTGjLCh=0; iTGjLCh < *pPropertyCount; iTGjLCh++){
            [&](){
            auto& temp=arr_PEzgESc[iTGjLCh].get_object();
            deserialize_struct(temp,pProperties[iTGjLCh]);
            }();
        }
        }();
VkResult result;
[&](){[&](){int temp_HxBNOnK;[&](){
            if (json["result"].is_uint64()){
                temp_HxBNOnK=static_cast<int>(json["result"].get_uint64());
            }else if (json["result"].is_int64()){
                temp_HxBNOnK=static_cast<int>(json["result"].get_int64());
            }else{
                temp_HxBNOnK=static_cast<int>(json["result"].get_double());
            }
            }();result=(VkResult)temp_HxBNOnK;}();}();

debug_printf("Ending vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR...\n");
debug_printf("Return value of vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR is: %s...\n",string_VkResult(result));
return result;
}
}
#endif

#ifndef CLIENT
int main(int argc, char** argv){
    startServer();
}
#endif

